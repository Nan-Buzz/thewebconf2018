<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">  <head>  <title>Evaluation of Query Transformations without Data Short paper</title>  <!-- Copyright (c) 2010-2015 The MathJax Consortium --><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>  <meta name="viewport" content="width=device-width; initial-scale=1.0;"></meta>  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>  <link media="screen, print" rel="stylesheet"    href="https://dl.acm.org/pubs/lib/css/bootstrap.min.css"/><link media="screen, print" rel="stylesheet"    href="https://dl.acm.org/pubs/lib/css/bootstrap-theme.min.css"/><link media="screen, print" rel="stylesheet"    href="https://dl.acm.org/pubs/lib/css/main.css"/><script src="https://dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script>  <script src="https://dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script>  <script src="https://dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script>  <script src="https://dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script>  <script type="text/javascript"    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>  <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>  </head>  <body id="main">  <section class="front-matter">   <section>    <header class="title-info">     <div class="journal-title">     <h1>      <span class="title">Evaluation of Query Transformations without Data Short paper</span>      <br/>      <span class="subTitle"/>     </h1>     </div>    </header>    <div class="authorGroup">     <div class="author">     <span class="givenName">J&#x00E9;r&#x00F4;me</span>      <span class="surName">David</span>     Univ. Grenoble Alpes, Inria, CNRS, Grenoble INP, LIG, F-38000Grenoble, France, <a href="mailto:Jerome.David@univ-grenoble-alpes.fr">Jerome.David@univ-grenoble-alpes.fr</a>     </div>     <div class="author">     <span class="givenName">J&#x00E9;r&#x00F4;me</span>      <span class="surName">Euzenat</span>     Univ. Grenoble Alpes, Inria, CNRS, Grenoble INP, LIG, F-38000Grenoble, France, <a href="mailto:Jerome.Euzenat@inria.fr">Jerome.Euzenat@inria.fr</a>     </div>     <div class="author">     <span class="givenName">Pierre</span>      <span class="surName">Genev&#x00E8;s</span>     Univ. Grenoble Alpes, Inria, CNRS, Grenoble INP, LIG, F-38000Grenoble, France, <a href="mailto:Pierre.Geneves@cnrs.fr">Pierre.Geneves@cnrs.fr</a>     </div>     <div class="author">     <span class="givenName">Nabil</span>      <span class="surName">Laya&#x00EF;da</span>     Univ. Grenoble Alpes, Inria, CNRS, Grenoble INP, LIG, F-38000Grenoble, France, <a href="mailto:Nabil.Layaida@inria.fr">Nabil.Layaida@inria.fr</a>     </div>                     </div>    <br/>    <div class="pubInfo">     <p>DOI: <a href="https://doi.org/10.1145/3184558.3191617" target="_blank">https://doi.org/10.1145/3184558.3191617</a>     <br/>WWW '18: <a href="https://doi.org/10.1145/3184558" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p>    </div>    <div class="abstract">     <p>     <small>Query transformations are ubiquitous in semantic web query processing. For any situation in which transformations are not proved correct by construction, the quality of these transformations has to be evaluated. Usual evaluation measures are either overly syntactic and not very informative &#x2014;the result being: correct or incorrect&#x2014; or dependent from the evaluation sources. Moreover, both approaches do not necessarily yield the same result. We suggest that grounding the evaluation on query containment allows for a data-independent evaluation that is more informative than the usual syntactic evaluation. In addition, such evaluation modalities may take into account ontologies, alignments or different query languages as soon as they are relevant to query evaluation.</small>     </p>    </div>    <div class="CCSconcepts">     <p> <small> <span style="font-weight:bold;">CCS Concepts:</span> &#x2022;<strong> Information systems </strong>&#x2192; <strong>Semantic web description languages;</strong> &#x2022;<strong> Theory of computation </strong>&#x2192; <strong>Logic and verification;</strong> <strong>Database query processing and optimization (theory);</strong></small> </p>    </div>    <div class="classifications">     <div class="AcmReferenceFormat">     <p>      <small>       <span style="font-weight:bold;">ACM Reference Format:</span>       <br/>       J&#x00E9;r&#x00F4;me David, J&#x00E9;r&#x00F4;me Euzenat, Pierre Genev&#x00E8;s, and Nabil Laya&#x00EF;da. 2018. Evaluation of Query Transformations without Data Short paper. In <em>WWW '18 Companion: The 2018 Web Conference Companion,</em>       <em>April 23&#x2013;27, 2018,</em>       <em> Lyon, France. ACM, New York, NY, USA</em> 5 Pages. <a href="https://doi.org/10.1145/3184558.3191617" class="link-inline force-break"        target="_blank">https://doi.org/10.1145/3184558.3191617</a></small>     </p>     </div>    </div>   </section>  </section>  <section class="body">   <p>SPARQL Query transformation; Query containment; Transformation evaluation</p>   <p>With the availability of standard web knowledge representation languages such as RDF and OWL, SPARQL querying is becoming ubiquitous to access data. As for SQL before it, the language allows for its manipulation before being evaluated. SPARQL queries may be transformed to optimise their evaluation, to deal with heterogeneous vocabularies or to use more restricted query languages.</p>   <p>In particular, query transformation is at the heart of ontology-based data access (OBDA) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0010">10</a>] and federated querying [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0012">12</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0014">14</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0015">15</a>]. Some transformations are theoretically proved correct by construction (this is the case for some OBDA) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0003">3</a>], however some others, especially when they connect data sources expressed in different ontologies, may be designed by hand [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0009">9</a>] or resorting to ad hoc rules [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0005">5</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0007">7</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0012">12</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0016">16</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0017">17</a>]. In such cases, the quality of these transformations has to be assessed. <figure id="fig1">     <img src="http://deliveryimages.acm.org/10.1145/3200000/3191617/images/www18companion-356-fig1.jpg" class="img-responsive" alt="Figure 1"      longdesc=""/>     <div class="figure-caption">     <span class="figure-number">Figure 1:</span>     <span class="figure-title">Sample queries resulting from transformations (the <SmallCap>from</SmallCap> clause is omitted; <SmallCap>distinct</SmallCap> could be added for the evaluation since we use the set semantics).</span>     </div>    </figure>   </p>   <section id="sec-5">    <header>     <div class="title-info">     <h2>      <span class="section-number">1</span> Evaluating transformed queries</h2>     </div>    </header>    <p>Query transformation methods transform a query <em>q</em> into a replacement query <em>t</em>(<em>q</em>). They may be used to evaluate the query against the same data source, i.e., database or RDF graph, or against a different data source using a different data model.</p>    <p>The evaluation of the quality of such transformations is measured by computing a value that we will consider in the [0~1] interval. It is usually performed along two different modalities.</p>    <p>In the first modality [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0007">7</a>], an initial query <em>q</em> and the query it is expected to be transformed in <em>q<sub>R</sub>     </em> (reference query) are given and <em>m</em>(<em>t</em>) is computed as: <div class="table-responsive">     <div class="display-equation">      <span class="tex mytex">\[ m(t) = {\left\lbrace \begin{array}{@{}l@{\quad }l@{}}1 &#x0026; \text{if } t(q) \cong q_{R} \\ 0 &#x0026; \text{otherwise} \end{array}\right.} \] </span>      <br/>     </div>     </div> The equality predicate (&#x2245;) is usually not strict syntactic equality but may be equality modulo commutativity and variable renaming &#x2014;this is the case when comparing <em>t</em>     <sub>2</sub>(<em>q</em>) and <em>q<sub>R</sub>     </em> in Figure&#x00A0;<a class="fig" href="#fig1">1</a>&#x2014; or equality with respect to queries in a normal form.</p>    <p>In the second modality [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0009">9</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0016">16</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0017">17</a>], an initial query <em>q</em> and the expected evaluation results <em>R<sub>D</sub>     </em> against a data source <em>D</em> are given, very often such that <em>R<sub>D</sub>     </em> = <em>eval</em>(<em>q<sub>R</sub>     </em>, <em>D</em>) for some reference query <em>q<sub>R</sub>     </em>. <em>R<sub>D</sub>     </em> is then compared to the result of <em>eval</em>(<em>t</em>(<em>q</em>), <em>D</em>). It is then possible to define classical measures such as precision (<em>p</em>(<em>t</em>)) and recall (<em>r</em>(<em>t</em>)) on this set of answers as: <div class="table-responsive">     <div class="display-equation">      <span class="tex mytex">\begin{align*} p(t)=\frac{|eval(t(q),D)\cap R_{D}|}{|eval(t(q),D)|} ~~&#x0026;~~ r(t)=\frac{|eval(t(q),D)\cap R_{D}|}{|R_{D}|}\end{align*} </span>      <br/>     </div>     </div> the F-measure is computed in the usual way as the harmonic mean between precision and recall.</p>    <div class="table-responsive" id="tab1">     <div class="table-caption">     <span class="table-number">Table 1:</span>     <span class="table-title">Results of query evaluation against data sets <em>G</em>      <sub>1</sub> and <em>G</em>      <sub>2</sub> of Figure&#x00A0;<a class="fig" href="#fig2">2</a> and <a class="fig" href="#fig3">3</a> (queries are evaluated with the set semantics instead of the standard bag semantics).</span>     </div>     <table class="table">     <tbody>      <tr>       <td style="text-align:left;">        <img src="http://deliveryimages.acm.org/10.1145/3200000/3191617/images/www18companion-356-graphic2.jpg" class="img-responsive" alt=""         longdesc=""/>       </td>      </tr>     </tbody>     </table>    </div>    <p>Usually evaluation is performed against a benchmark involving various such tests whose results are aggregated or averaged. Table&#x00A0;<a class="tbl" href="#tab1">1</a> shows the results of evaluating queries <em>q<sub>R</sub>     </em>, <em>t</em>     <sub>1</sub>, <em>t</em>     <sub>2</sub>, <em>t</em>     <sub>3</sub> and <em>t</em>     <sub>4</sub> of Figure&#x00A0;<a class="fig" href="#fig1">1</a> against the data sets <em>G</em>     <sub>1</sub> and <em>G</em>     <sub>2</sub> of Figure&#x00A0;<a class="fig" href="#fig2">2</a> and <a class="fig" href="#fig3">3</a>. From this, the measures <em>m</em>, <em>p</em>, <em>f</em> and <em>r</em> reported on Table&#x00A0;<a class="tbl" href="#tab2">2</a> are computed.</p>    <div class="table-responsive" id="tab2">     <div class="table-caption">     <span class="table-number">Table 2:</span>     <span class="table-title">Transformation evaluation measures (gray cells illustrate the implications of Section&#x00A0;<a class="sec" href="#sec-7">3</a>).</span>     </div>     <table class="table">     <tbody>      <tr>       <td style="text-align:left;">        <img src="http://deliveryimages.acm.org/10.1145/3200000/3191617/images/www18companion-356-graphic3.jpg" class="img-responsive" alt=""         longdesc=""/>       </td>      </tr>     </tbody>     </table>    </div>    <p>When the measure <em>m</em>(<em>t</em>) is at 1, both precision and recall are at 100%. However, they can be at 100% with <em>m</em>(<em>t</em>) = 0. <figure id="fig2">     <img src="http://deliveryimages.acm.org/10.1145/3200000/3191617/images/www18companion-356-fig2.jpg" class="img-responsive" alt="Figure 2"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 2:</span>      <span class="figure-title">Data set <em>G</em>       <sub>1</sub>.</span>     </div>     </figure>    </p>   </section>   <section id="sec-6">    <header>     <div class="title-info">     <h2>      <span class="section-number">2</span> Problems</h2>     </div>    </header>    <p>Three problems may be identified with such evaluation measures.</p>    <p>(1) There is a gap between the two measures. In particular, it is possible to have a 100% correct result for precision and recall with a query which is not the expected one. Table&#x00A0;<a class="tbl" href="#tab2">2</a> shows that, though the syntactic comparison determines that <em>t</em>     <sub>1</sub> and <em>t</em>     <sub>3</sub> do not yield the reference query, the use of the data set <em>G</em>     <sub>1</sub> does not allow to discriminate them. Conversely, though the use of precision and recall with respect to <em>G</em>     <sub>2</sub> correctly determines that <em>t</em>     <sub>1</sub> returns incomplete results and <em>t</em>     <sub>3</sub> returns incorrect results, this information is not available by using the syntactic measure which grants them the same value, 0, as <em>t</em>     <sub>4</sub>.</p>    <p>(2) Precision and recall are highly dependent on the selected data set. This is obvious from Table&#x00A0;<a class="tbl" href="#tab2">2</a> as <em>G</em>     <sub>1</sub> finds the result of transformation <em>t</em>     <sub>1</sub>, <em>t</em>     <sub>2</sub> and <em>t</em>     <sub>3</sub> equally perfect, though <em>G</em>     <sub>2</sub> identifies true negatives in <em>t</em>     <sub>1</sub> and false positives in <em>t</em>     <sub>3</sub>. In addition, obtaining <em>R<sub>D</sub>     </em>, on large data sources may be a resource-consuming task, so benchmarks are not easy to build.</p>    <p>(3) The syntactic measure is very rough as it only tells if the query is the expected one or not. This does not allow to discriminate queries, though precision, recall and F-measure may permit to rank them on a more precise scale. The information that <em>t</em>     <sub>1</sub> only provides correct answers and that <em>t</em>     <sub>3</sub> always provides all answers, is not available by using the syntactic measure which grants them 0.</p>    <p>The apparent added-value of precision and recall is, in fact, very dependent on the data set. Indeed, as soon as its value is not <em>necessarily</em> 1. it is always possible to tune the data set to obtain a different value &#x2014;through adding and suppressing triples that will generate more true positive or more false positive. Hence, one may argue that the finer grain provided by these measures is misleading and that there is actually only three values, for either precision and recall: it is necessarily 1. or not (necessarily 0. is only obtained by the empty query).</p>    <p>Checking what is necessary does not depend on the data set and is prone to static analysis. Hence, we suggest here that by using query containment instead of syntactic equality, it is possible to improve such methods without resorting to data sets. <figure id="fig3">     <img src="http://deliveryimages.acm.org/10.1145/3200000/3191617/images/www18companion-356-fig3.jpg" class="img-responsive" alt="Figure 3"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 3:</span>      <span class="figure-title">Data set <em>G</em>       <sub>2</sub>.</span>     </div>     </figure>    </p>   </section>   <section id="sec-7">    <header>     <div class="title-info">     <h2>      <span class="section-number">3</span> Containment-based tests</h2>     </div>    </header>    <p>In order to better qualify the quality of transformations, a containment test can replace the equality test. A query <em>q</em> is contained in another <em>q</em>&#x2032;, noted <em>q</em>&#x2291;<em>q</em>&#x2032; if, for any RDF graph <em>G</em>, <em>eval</em>(<em>q</em>, <em>D</em>)&#x2286;<em>eval</em>(<em>q</em>&#x2032;, <em>D</em>) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0002">2</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0011">11</a>]. The evaluation measures can then be defined as:</p>    <div class="table-responsive" id="inltbl1">     <table class="table">     <tbody>      <tr>       <td style="text-align:center;">        <span class="inline-equation"><span class="tex">$\tilde{p}(t) = {\left\lbrace \begin{array}{@{}l@{\quad }l@{}}1 &#x0026; \text{if } t(q) \sqsubseteq q_{R} \\ 0 &#x0026; \text{otherwise} \end{array}\right.}$</span>        </span>       </td>       <td style="text-align:center;">&#x00A0;and&#x00A0;</td>       <td style="text-align:center;">        <span class="inline-equation"><span class="tex">$\tilde{r}(t) = {\left\lbrace \begin{array}{@{}l@{\quad }l@{}}1 &#x0026; \text{if } t(q) \sqsupseteq q_{R} \\ 0 &#x0026; \text{otherwise} \end{array}\right.}$</span>        </span>       </td>      </tr>     </tbody>     </table>    </div>    <p>this has the advantage of benefiting from well-understood definitions that go beyond the implementation of the equality predicate. It also splits the measure in two different meaningful ways in the sense that it may be used to determine if one can expect fully correct or fully complete results. Hence, this is strictly more informative than the measure <em>m</em>.</p>    <p>In particular, if <em>R<sub>D</sub>     </em> = <em>eval</em>(<em>q<sub>R</sub>     </em>, <em>D</em>), we know that: <div class="table-responsive">     <div class="display-equation">      <span class="tex mytex">\[ t(q) \sqsubseteq q_{R} \Rightarrow eval(t(q),D) \subseteq eval(q_{R},D) \] </span>      <br/>     </div>     </div> or <span class="inline-equation"><span class="tex">$\tilde{p}(t)=1 \Rightarrow p(t)=1.$</span>     </span>, and <div class="table-responsive">     <div class="display-equation">      <span class="tex mytex">\[ t(q) \sqsupseteq q_{R} \Rightarrow eval(t(q),D) \supseteq eval(q_{R},D) \] </span>      <br/>     </div>     </div> or <span class="inline-equation"><span class="tex">$\tilde{r}(t)=1 \Rightarrow r(t)=1.$</span>     </span>, and this for any <em>D</em>. Hence, this is true for all data sets.</p>    <p>It is still possible to compute a F-measure <span class="inline-equation"><span class="tex">$\tilde{f}$</span>     </span> in the usual way following the intuition that precision denotes correction and recall denotes completeness [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0006">6</a>]. However, this measure loses information as it will only have two values, 0 and 1 (actually, <span class="inline-equation"><span class="tex">$\tilde{f}$</span>     </span> would be <span class="inline-equation"><span class="tex">$\tilde{m}$</span>     </span> if <span class="inline-equation"><span class="tex">$\tilde{m}$</span>     </span> were <em>m</em> computed with semantic equivalence).</p>    <p>This may also be combined as: <div class="table-responsive">     <div class="display-equation">      <span class="tex mytex">\[ t(q) \equiv q_{R} \Rightarrow eval(t(q),D) = eval(q_{R},D) \] </span>      <br/>     </div>     </div> or <span class="inline-equation"><span class="tex">$\tilde{m}(t)=1 \Rightarrow f(t)=1.$</span>     </span>.</p>    <p>Such containment-based tests do not provide a fine-grained measure of the proportion of results that are missed or wrong. However, they can tell if none is missed and none is wrong and are valid for all data sources. This could be an important information if someone is interested in a transformation that does not miss answers (choose <em>t</em>     <sub>3</sub>) or does not return irrelevant answers (take <em>t</em>     <sub>1</sub>).</p>    <p>Hence, containment-based measures address Problem (1) by providing two boolean values instead of only one which are intermediate between the two types of measures. The approach retrieves <span class="inline-equation"><span class="tex">$\tilde{m}$</span>     </span> (arguably better than <em>m</em>) by simply taking the conjunction of the two values. It also approximates precision and recall by being able to guarantee that precision or recall must be 100%.</p>    <p>The approach deals with Problem (2) by being independent from data sources, and Problem (3) by providing the more precise information about the query behaviour, preserving the link with precision and recall indicating that some answers may be incorrect or missing respectively.</p>    <p>It may also be used on a whole test bench instead of on a single test. In such a case the results can be averaged (which proportion of the containment tests are successful).</p>   </section>   <section id="sec-8">    <header>     <div class="title-info">     <h2>      <span class="section-number">4</span> Transformation comparison</h2>     </div>    </header>    <p>Although, the results may still seem rough by returning a pair of boolean, they may be used to compare the merits of different transformations together. Indeed, containment is a partial order relation that may be assessed to compare several transformations. Hence it is possible to position all the queries obtained by the transformations with respect to each others and to observe that a query is closer to the reference query than another (although this is not the case in the example given in Figure&#x00A0;<a class="fig" href="#fig4">4</a>). <figure id="fig4">     <img src="http://deliveryimages.acm.org/10.1145/3200000/3191617/images/www18companion-356-fig4.jpg" class="img-responsive" alt="Figure 4"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 4:</span>      <span class="figure-title">Transformation order induced by query containment on the queries of Figure&#x00A0;<a class="fig" href="#fig1">1</a>.</span>     </div>     </figure>    </p>    <p>This applies for one query. It is possible to account for a set of queries by replacing queries by transformations in each graph, preserving a single <em>q<sub>R</sub>     </em> node, replacing &#x2261; by two &#x2291; and &#x2292; edges, and finally intersecting these graphs, i.e., their set of edges. If a transformation is always returning less answers than another or the reference query, they should be related by a &#x2291; edge. It is also possible to take the union of these graphs and weight the edges depending of the number of graphs in which they appear.</p>   </section>   <section id="sec-9">    <header>     <div class="title-info">     <h2>      <span class="section-number">5</span> Ontologies and query languages</h2>     </div>    </header>    <p>If the data sources are expressed in a particular schema or ontology <em>O</em>, it is possible to use containment modulo schema &#x2291;<sub>     <em>O</em>     </sub> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0003">3</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0004">4</a>] in order to perform the test. This can still be achieved independently from any data set. <figure id="fig5">     <img src="http://deliveryimages.acm.org/10.1145/3200000/3191617/images/www18companion-356-fig5.jpg" class="img-responsive" alt="Figure 5"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 5:</span>      <span class="figure-title">Queries expressed with respect to ontological expressions (<tt>sPO</tt> stands for <tt>rdfs:subPropertyOf</tt>).</span>     </div>     </figure>    </p>    <p>In addition, if the query evaluation mechanism can take such ontologies into account under a particular entailment regime <em>reg</em>, then the previous inequalities may be rendered as: <div class="table-responsive">     <div class="display-equation">      <span class="tex mytex">\[ t(q) \sqsubseteq ^{reg}_{O} q_{R} \Rightarrow eval^{reg}(t(q),D\cup O) \subseteq eval^{reg}(q_{R},D\cup O) \] </span>      <br/>     </div>     </div>    </p>    <p>Figure&#x00A0;<a class="fig" href="#fig5">5</a> shows a genuine SPARQL query <em>t</em>     <sub>5</sub>(<em>q</em>) using the OWL property <tt>rdfs:subPropertyOf</tt>. If considered as simple SPARQL queries, there is no containment relation between <em>t</em>     <sub>5</sub>(<em>q</em>) and <em>q<sub>R</sub>     </em>. However, if the OWL-entailment regime is used, <em>t</em>     <sub>5</sub>(<em>q</em>) &#x2261; <em>q<sub>R</sub>     </em> because the triple pattern <tt>?z q ?y</tt> in <em>q<sub>R</sub>     </em> will match all triples which entail it, including those involving a subproperty of <tt>q</tt>.</p>    <p>This also applies for queries in SPARQL variants: the containment test must be defined with respect to the specific variant to match the corresponding evaluation operation. This has already been done for PSPARQL [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0002">2</a>], a variant of SPARQL 1.0 extended with property path expressions, now included in SPARQL 1.1.</p>    <p>Figure&#x00A0;<a class="fig" href="#fig5">5</a> shows a PSPARQL query <em>t</em>     <sub>6</sub>(<em>q</em>) using a property path of an undefined number of <tt>rdfs:subPropertyOf</tt> properties (aiming at implementing the transitivity of this relation). If <em>q<sub>R</sub>     </em> is evaluated as a PSPARQL query, then <em>q<sub>R</sub>     </em>&#x2291;<em>t</em>     <sub>6</sub>(<em>q</em>) because <tt>?z q ?y</tt> in <em>q<sub>R</sub>     </em> only matches those triples with the <tt>q</tt> property, but <em>t</em>     <sub>6</sub>(<em>q</em>) will match these and in addition all those properties related to it by a chain of <tt>rdfs:subPropertyOf</tt> in the data.</p>   </section>   <section id="sec-10">    <header>     <div class="title-info">     <h2>      <span class="section-number">6</span> Alignments</h2>     </div>    </header>    <p>When a query expressed in a vocabulary <em>O</em> is transformed in a query expressed in a vocabulary <em>O</em>&#x2032;, this way of performing evaluation is very convenient because it does not rely on any alignment: the transformation <em>t</em> may involve an alignment or not, but the queries <em>t</em>(<em>q</em>) and <em>q<sub>R</sub>     </em> are both expressed in the vocabulary <em>O</em>&#x2032; and thus can be tested for containment, modulo <em>O</em>&#x2032; or not.</p>    <p>We had already defined measures for evaluating ontology alignments taking into account the idea that users may want precise answers to queries or on the contrary complete answers to queries [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0006">6</a>]. This led to precision-oriented and recall-oriented evaluation measures depending on the direction of the transformation and the property (correctness or completeness) expected by the user. The measures were relaxing syntactic precision and recall by tolerating that they return more precise or more general classes than the corresponding ones. This does not directly translate to better precision and recall with respect to specific SPARQL queries due to the use of operations, such as <SmallCap>minus</SmallCap>, which would require inverting the orientation.</p>    <p>Containment-based transformation evaluation actually provides a new way to compare ontology alignments in the context of query evaluation. Indeed, if one considers that the transformation <em>t</em> is parameterised by an alignment <em>A</em> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0005">5</a>], then the evaluation of <em>t<sub>A</sub>     </em> is an evaluation of <em>A</em>. This procedure has been used in the ontology alignment evaluation campaigns using specific data sets on which the reference results were available [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0008">8</a>]. Using containment-based evaluation, the same can be obtained from a set of reference queries without relying on data sets: several alignments, provided by different matchers, may be compared on this benchmark in their capability to transform queries. This also provides an alternative way to evaluate alignments in an oriented way with respect to their use in query processing since the result will be related to the necessary precision and recall.</p>   </section>   <section id="sec-11">    <header>     <div class="title-info">     <h2>      <span class="section-number">7</span> Conclusion</h2>     </div>    </header>    <p>Query transformation quality is usually evaluated through two types of measures with their qualities (easy to define/fine grained) and pitfalls (rough/data set dependent+difficult to define). We proposed an intermediate type of measures, grounded on query containment, that is as easy to define as the first, but more precise in its outcome and whose result is valid for any data set.</p>    <p>Such measures have the advantage that they allow to order different transformations on a solid basis instead of on a scale tightly depending on the chosen data set. They can also be defined using query subsumption [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0011">11</a>] instead of containment. This would result in valid measures but the relations with the initial measures may not directly hold.</p>    <p>The approach can be defined for any type of containment relation relying on different query languages, ontologies or inference regimes. It can also be thought of as an alignment evaluation measure.</p>    <p>Query containment may be computationally expensive (well-defined patterns with <SmallCap>optional</SmallCap> are <span class="inline-equation"><span class="tex">$\Pi _2^p$</span>     </span>-complete [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0011">11</a>], many known procedures are in <SmallCap>ExpTime</SmallCap> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0004">4</a>]) and in some cases undecidable (bag semantics or full SPARQL including <SmallCap>select</SmallCap> and <SmallCap>optional</SmallCap> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0013">13</a>]). However, when it is practicable it does only depend on the size of queries and not that of usually larger data sets. Hence we expect this to be acceptable for an evaluation task.</p>   </section>  </section>  <section class="back-matter">   <section id="ref-001">    <header>     <div class="title-info">     <h2 class="page-brake-head">REFERENCES</h2>     </div>    </header>    <ul class="bibUl">     <li id="BibPLXBIB0001" label="[1]">Meghyn Bienvenu, Stanislav Kikot, Roman Kontchakov, Vladimir Podolskii, Vladislav Ryzhikov, and Michael Zakharyaschev. 2017. The complexity of ontology-based data access with OWL2 QL and bounded treewidth queries. In <em>Proc. 36th Symposium on Principles of Database Systems (PODS), Chicago (US)</em>, 201&#x2013;216.</li>     <li id="BibPLXBIB0002" label="[2]">Melisachew Wudage Chekol, J&#x00E9;r&#x00F4;me Euzenat, Pierre Genev&#x00E8;s, and Nabil Laya&#x00EF;da. 2011. PSPARQL query containment. In <em>Proc. 13th International Symposium on Database Programming Languages (DBPL), Seattle (US)</em>.</li>     <li id="BibPLXBIB0003" label="[3]">Melisachew Wudage Chekol, J&#x00E9;r&#x00F4;me Euzenat, Pierre Genev&#x00E8;s, and Nabil Laya&#x00EF;da. 2012. SPARQL query containment under RDFS entailment regime. In <em>Proc. 6th International Joint Conference on Automated Reasoning (IJCAR), Manchester (UK)</em>, 134&#x2013;148.</li>     <li id="BibPLXBIB0004" label="[4]">Melisachew Wudage Chekol, J&#x00E9;r&#x00F4;me Euzenat, Pierre Genev&#x00E8;s, and Nabil Laya&#x00EF;da. 2012. SPARQL query containment under SHI axioms. In <em>Proc. 26th AAAI Conference on Artificial Intelligence, Toronto (CA)</em>, 10&#x2013;16.</li>     <li id="BibPLXBIB0005" label="[5]">Gianluca Correndo, Manuel Salvadores, Ian Millard, Hugh Glaser, and Nigel Shadbolt. 2010. SPARQL query rewriting for implementing data integration over linked data. In <em>Proc. EDBT/ICDT Workshops, Lausanne (CH)</em>.</li>     <li id="BibPLXBIB0006" label="[6]">Marc Ehrig and J&#x00E9;r&#x00F4;me Euzenat. 2005. Relaxed precision and recall for ontology matching. In <em>Proc. K-CAP Workshop on Integrating Ontologies, Banff (CA)</em>, 25&#x2013;32.</li>     <li id="BibPLXBIB0007" label="[7]">Pascal Gillet, C&#x00E1;ssia Trojahn dos Santos, Ollivier Haemmerl&#x00E9;, and Camille Pradel. 2013. Complex correspondences for query patterns rewriting. In <em>Proc. 8th International Workshop on Ontology Matching (OM), Sydney (AU)</em>, 49&#x2013;60.</li>     <li id="BibPLXBIB0008" label="[8]">Antoine Isaac, Shenghui Wang, Claus Zinn, Henk Matthezing, Lourens van der Meij, and Stefan Schlobach. 2009. Evaluating thesaurus alignments for semantic interoperability in the library domain. <em>IEEE Intelligent Systems</em>, 24, 2, 76&#x2013;86.</li>     <li id="BibPLXBIB0009" label="[9]">Prateek Jain, Peter Yeh, Kunal Verma, Cory Henson, and Amit Sheth. 2009. SPARQL query re-writing using partonomy based transformation rules. In <em>Proc. 3rd International Conference on Geospatial semantics (GeoS), Mexico (MX)</em>, 140&#x2013;158.</li>     <li id="BibPLXBIB0010" label="[10]">Roman Kontchakov, Mariano Rodriguez-Muro, and Michael Zakharyaschev. 2013. Ontology-based data access with databases: A short course. In <em>Proc. 9th International Reasoning Web Summer School, Mannheim (DE)</em>, 194&#x2013;229.</li>     <li id="BibPLXBIB0011" label="[11]">Andr&#x00E9;s Letelier, Jorge P&#x00E9;rez, Reinhard Pichler, and Sebastian Skritek. 2013. Static analysis and optimization of semantic web queries. <em>ACM Transactions on Database Systems</em>, 38, 4, 25:1&#x2013;25:45.</li>     <li id="BibPLXBIB0012" label="[12]">Konstantinos Makris, Nektarios Gioldasis, Nikos Bikakis, and Stavros Christodoulakis. 2010. Ontology mapping and SPARQL rewriting for querying federated RDF data sources. In <em>Proc. On the Move to Meaningful Internet Systems (OTM), Hersonissos (GR)</em>, 1108&#x2013;1117.</li>     <li id="BibPLXBIB0013" label="[13]">Reinhard Pichler and Sebastian Skritek. 2014. Containment and equivalence of well-designed SPARQL. In <em>Proc. 33rd Symposium on Principles of Database Systems (PODS), Snowbird (UT US)</em>, 39&#x2013;50.</li>     <li id="BibPLXBIB0014" label="[14]">Eric Prud&#x0027;hommeaux and Carlos Buil-Aranda. 2013. SPARQL 1.1 Federated Query. Recommendation. W3C.</li>     <li id="BibPLXBIB0015" label="[15]">Bastian Quilitz and Ulf Leser. 2008. Querying distributed RDF data sources with SPARQL. In <em>Proc. 5th European Semantic Web Conference (ESWC), Tenerife (ES)</em>, 524&#x2013;538.</li>     <li id="BibPLXBIB0016" label="[16]">&#x00C9;lodie Thi&#x00E9;blin, Fabien Amarger, Ollivier Haemmerl&#x00E9;, Nathalie Hernandez, and C&#x00E1;ssia Trojahn dos Santos. 2016. Rewriting SELECT SPARQL queries from 1: n complex correspondences. In <em>Proc. 11th International Workshop on Ontology Matching (OM), Kobe (JP)</em>, 49&#x2013;60.</li>     <li id="BibPLXBIB0017" label="[17]">Ana Isabel Torre Bastida, Jes&#x00FA;s Berm&#x00FA;dez, and Arantza Illarramendi. 2015. Query approximation in the case of incompletely aligned datasets. In <em>Actas XX Jornadas de Ingenier&#x00ED;a del Software y Bases de Datos (JISBD), Santander (ES)</em>.</li>    </ul>   </section>  </section>  <section id="foot-001" class="footnote">   <header>    <div class="title-info">     <h2>FOOTNOTE</h2>    </div>   </header>   <div class="bibStrip">    <p>This paper is published under the Creative Commons Attribution 4.0 International (CC-BY&#x00A0;4.0) license. Authors reserve their rights to disseminate the work on their personal and corporate Web sites with the appropriate attribution.</p>    <p>     <em>WWW '18, April 23-27, 2018, Lyon, France</em>    </p>    <p>&#x00A9; 2018; IW3C2 (International World Wide Web Conference Committee), published under Creative Commons CC-BY&#x00A0;4.0 License. ACM ISBN 978-1-4503-5640-4/18/04.<br/>DOI: <a class="link-inline force-break" target="_blank"     href="https://doi.org/10.1145/3184558.3191617">https://doi.org/10.1145/3184558.3191617</a>    </p>   </div>  </section>  <div class="pubHistory">   <p/>  </div>  </body> </html> 
