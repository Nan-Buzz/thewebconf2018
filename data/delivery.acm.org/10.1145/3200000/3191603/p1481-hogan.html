<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> <head>  <title>Profiling Graphs: Order from Chaos</title>  <!-- Copyright (c) 2010-2015 The MathJax Consortium --><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>  <meta name="viewport" content="width=device-width; initial-scale=1.0;"></meta>  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>  <link media="screen, print" rel="stylesheet"    href="../../../../dl.acm.org/pubs/lib/css/bootstrap.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../../dl.acm.org/pubs/lib/css/bootstrap-theme.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../../dl.acm.org/pubs/lib/css/main.css"/><script src="../../../../dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script>  <script src="../../../../dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script>  <script src="../../../../dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script>  <script src="../../../../dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script>  <script type="text/javascript"    src="../../../../dl.acm.org/pubs/lib/js/MathJax.js?config=TeX-AMS_CHTML"></script>  <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script> </head> <body id="main">  <section class="front-matter">   <section>    <header class="title-info">    <div class="journal-title">     <h1>      <span class="title">Profiling Graphs: Order from Chaos</span>      <br/>      <span class="subTitle"/>     </h1>    </div>    </header>    <div class="authorGroup">    <div class="author">     <span class="givenName">Aidan</span>     <span class="surName">Hogan</span>     Institute for the Foundations of Data DCC, Universidad de Chile, <a href="mailto:ahogan@dcc.uchile.cl">ahogan@dcc.uchile.cl</a>    </div>        </div>    <br/>    <div class="pubInfo">    <p>DOI: <a href="https://doi.org/10.1145/3184558.3191647" target="_blank">https://doi.org/10.1145/3184558.3191647</a>     <br/>WWW '18: <a href="https://doi.org/10.1145/3184558" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p>    </div>    <div class="abstract">    <p>     <small>Graphs are being increasingly adopted as a flexible data model in scenarios (e.g., Google&#x0027;s Knowledge Graph, Facebook&#x0027;s Graph API, Wikidata, etc.) where multiple editors are involved in content creation, where the schema is ever changing, where data are incomplete, where the connectivity of resources plays a key role&#x2014;scenarios where relational models traditionally struggle. But with this flexibility comes a conceptual cost: it can be difficult to summarise and understand, at a high level, the content that a given graph contains. Hence profiling graphs becomes of increasing importance to extract order, a posteriori, from the chaotic processes by which such graphs are generated. This talk will motivate the use of graphs as a data model, abstract recent trends in graph data management, and then turn to the issue of profiling and summarising graphs: what are the goals of such profiling, the principles by which graphs can be summarised, the main techniques by which this can/could be achieved? The talk will emphasise the importance of profiling graphs while highlighting a variety of open research questions yet to be tackled.</small>    </p>    </div>    <div class="CCSconcepts">    <p> <small> <span style="font-weight:bold;">CCS Concepts:</span> &#x2022;<strong> Information systems </strong>&#x2192; <strong>Graph-based database models;</strong></small> </p>    </div>    <div class="classifications">    <div class="AcmReferenceFormat">     <p>      <small>       <span style="font-weight:bold;">ACM Reference Format:</span>       <br/>       Aidan Hogan. 2018. Profiling Graphs: Order from Chaos. In <em>WWW '18 Companion: The 2018 Web Conference Companion,</em>       <em>April 23&#x2013;27, 2018,</em>       <em> Lyon, France. ACM, New York, NY, USA</em> 2 Pages. <a href="https://doi.org/10.1145/3184558.3191647" class="link-inline force-break"       target="_blank">https://doi.org/10.1145/3184558.3191647</a></small>     </p>    </div>    </div>   </section>  </section>  <section class="body">   <p>graphs, profiling, schema</p>   <section id="sec-2">    <header>    <div class="title-info">     <h2>      <span class="section-number">1</span> Why Graphs?</h2>    </div>    </header>    <p>The relational model has proven rather useful for managing data in digital form. Order is imposed in this model by the presence of the relational schema. With the resulting order, one can avail of a number of benefits, including integrity constraints, access control primitives, indexing schemes, query optimisation techniques, transactions, ..., not to mention a detailed blueprint of what data may or may not be contained in the model. To avail of this order &#x2013; and all of its benefits &#x2013; one simply has to answer, up front, some basic questions about the data domain: What types of entities will be described? What are the relations and their multiplicities? What are the attributes and what are the functional dependencies?</p>    <p>Achieving agreement on such questions is straightforward &#x2013; if not at least worthwhile &#x2013; in the context of, for example, a bank or a hospital. However, in situations where the domain is more open &#x2013; where potentially reality itself could be modelled&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0008">8</a>] &#x2013; arriving at dependable <em>a priori</em> answers to such questions becomes a lot more difficult. While it may seem safe, for example, to assert in a schema that <SmallCap>mayor</SmallCap> is a relation between a <SmallCap>person</SmallCap> and a <SmallCap>place</SmallCap>, the people of Sunol, California could, at some unspecified point in the future, take exception to that definition having had a <SmallCap>dog</SmallCap> (&#x201C;Bosco&#x201D;) as <SmallCap>mayor</SmallCap> for over a decade. To any sufficiently-specific <em>a priori</em> schema, reality is sure to hold difficult exceptions.</p>    <p>In settings where the domain is more open, the growing trend is thus moving away from relational models and towards more flexible alternatives; one such alternative is that of the graph model. The idea of structuring data as directed labelled graphs has been around for at least as long as the present author&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0006">6</a>]. While more exotic flavours of graph data models have been proposed since then &#x2013; including graphs where nodes can themselves be graphs (<em>hypernodes</em>), or where edges can connect any number of nodes (<em>hyperedges</em>), or where edges can be labelled with attribute&#x2013;value pairs (<em>property graphs</em>)&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0002">2</a>] &#x2013; the core ideas remain the same: graphs offer a natural way to represent (and query) the connections between elements of the data, and offer a more flexible alternative to, e.g., the rigid relational model governed by a relational schema.</p>    <p>Such characteristics of graph models have become increasingly valued for environments where data are incomplete and/or where the schema remains fluid&#x2014;a natural example being scenarios involving management of Web data. While the Semantic Web community has long championed graph data models through the foundational RDF standard, the recent hype around industry-driven initiatives &#x2013; such as Google&#x0027;s Knowledge <em>Graph</em>, Facebook&#x0027;s <em>Graph</em> API or the Open <em>Graph</em> Protocol &#x2013; indicate that graph data models are becoming more and more mainstream: viewing (and querying) your data through the lens of a graph is no longer necessarily seen as an act of relational heresy, but rather something that could be considered natural when dealing with diverse &#x201C;semi-structured&#x201D; data.</p>   </section>   <section id="sec-3">    <header>    <div class="title-info">     <h2>      <span class="section-number">2</span> Why Profile Graphs?</h2>    </div>    </header>    <p>While graphs offer a natural way to model and query incomplete data with a fluid schema, their use comes at a cost. The relational schema plays a key role in traditional data management scenarios but it has no direct analogue in the world of graphs. When a user first wishes to query a relational database, to understand what content it contains, they might first ask for the list of tables or some other description of the schema; what should they ask for if they wish to query a graph? The lack of such a schema also complicates various data management operations, such as indexing, query optimisation, transactions, validation, and so forth.</p>    <p>The question then is: can we have the best of both worlds? Can we maintain the flexibility that graph models provide <em>and</em> the benefits of having a relational schema to impose order on the data? The simple answer is probably &#x201C;no&#x201D;, at least in the general case: if we lose some measure of order and regularity in our data model, then we lose the benefits that would have come with it for data management. We cannot have our schema and break it too.</p>    <p>Perhaps for this reason, a lot of focus in terms of structuring graphs has been on defining &#x201C;upfront schemas&#x201D;. For example, in the Semantic Web community, the RDF Schema&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0003">3</a>] standard allows to define the semantics of terms that can be used in the graph, such as to state that <SmallCap>mayorOf</SmallCap> has the domain <SmallCap>human</SmallCap>; however, such a schema does not help to understand the legacy data of a graph, which may or may not use the terms defined in RDFS. Another standard more recently proposed along these lines is the SHACL language&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0005">5</a>], which allows for specifying some constraints that an RDF graph should follow; however, this standard aims to enforce order upfront and again does not help to understand legacy data.</p>    <p>But even without an explicit upfront schema, most real-world graphs do have an inherent order. Most mayors are still, after all, human. But to exploit this order, we need methods to analyse and distil that order from graph-structured datasets. That order can then be used to help users formulate queries, to help summarise the content of a graph for the purposes of data retrieval or federation, to understand the processes by which the graphs evolve and change, as well as to enable or otherwise optimise low level data-management operations, such as query optimisation, compression, indexing, quality and completeness assessment, and so forth. Distilling such order from graphs is (often) known as &#x201C;<em>profiling</em>&#x201D;&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0004">4</a>], and may involve analysing and describing a graph along a variety of dimensions for a variety of applications.</p>   </section>   <section id="sec-4">    <header>    <div class="title-info">     <h2>      <span class="section-number">3</span> How should we profile graphs?</h2>    </div>    </header>    <p>While there has been quite a lot of work proposed to profile graphs, much of this work has been as heterogeneous as the graphs that the works aim to profile&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0004">4</a>]: different techniques have been proposed to study the dynamics of graphs, or the quality of graphs, or the completeness of graphs, or to index graphs, or summarise them, or integrate them. This talk will argue that all of these aspects of profiling graphs are inherently related and can all benefit from better ways to analyse and summarise the structure of graphs from a more theoretical perspective and with a more general approach.</p>    <p>Along these lines, we argue that the area of graph profiling could greatly benefit from &#x2013; and should actively seek &#x2013; an appropriate notion of data-driven schema for graphs: something that plays the role of the relational schema but is extracted from the data rather than being imposed upfront. Thereafter, many profiling tasks could be done not over the &#x201C;raw&#x201D; graphs, but rather at the schema level.</p>   </section>   <section id="sec-5">    <header>    <div class="title-info">     <h2>      <span class="section-number">4</span> A general schema for graphs?</h2>    </div>    </header>    <p>While this idea sounds good in principle, in practice, there is no unique natural notion of schema for graphs&#x2014;natural in the sense, for example, of the relational schema for tabular data. Rather there are a wide variety of proposed methods to summarise and extract high-level structures from graphs&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0007">7</a>]. Many such proposals, however, are based on common principles: for example, if one assumes that a schema for graphs should be connected (as a graph), then creating such a schema must involve grouping sets of nodes into a single node and/or grouping sets of edges into a single edge, be it through a direct equivalence relation, or some clustering or community detection method. A problem we face in this line of research is not a lack of possibilities for graph schemas, but rather the opposite: how can we decide between them for the purposes of profiling?</p>    <p>To present some ideas along these lines, we give some example desiderata for a data-driven graph schema:</p>    <ul class="list-no-style">    <li id="uid1" label="Scalability:">Given that some knowledge graphs are in the order of millions of nodes and edges, a suitable notion of schema should be computable from graphs of that size.<br/></li>    <li id="uid2" label="Stability:">A minor change in the underlying graph should not be able to effect a major change in the corresponding schema.<br/></li>    <li id="uid3" label="Conciseness:">The schema should be significantly smaller than the graph that it describes.<br/></li>    <li id="uid4" label="Connectivity:">The schema should not simply describe the nodes of the graph, but should capture information on how the graph is connected.<br/></li>    <li id="uid5" label="Readability:">The schema should be human-interpretable, meaning that its structure can be directly understood rather than representing abstract objects without direct significance.<br/></li>    </ul>    <p>In this talk, we will then use this list of desiderata to guide a discussion of possible research directions towards defining what a general notion of graph schema could look like (if such a holy grail exists) and how we could define benchmarks for such.<a class="fn" href="#fn1" id="foot-fn1"><sup>1</sup></a>    </p>    <p>    <strong>Acknowledgements</strong>. <em>This work was supported by Fondecyt Grant No. 1181896.</em>    </p>   </section>  </section>  <section class="back-matter">   <section id="ref-001">    <header>    <div class="title-info">     <h2 class="page-brake-head">REFERENCES</h2>    </div>    </header>    <ul class="bibUl">    <li id="BibPLXBIB0001" label="[1]">Renzo Angles, Marcelo Arenas, Pablo Barcel&#x00F3;, Aidan Hogan, Juan&#x00A0;L. Reutter, and Domagoj Vrgoc. 2017. Foundations of Modern Query Languages for Graph Databases. <em>      <em>ACM Comput. Surv.</em>     </em>50, 5 (2017), 68:1&#x2013;68:40. <a class="link-inline force-break" href="https://doi.org/10.1145/3104031"      target="_blank">https://doi.org/10.1145/3104031</a></li>    <li id="BibPLXBIB0002" label="[2]">Renzo Angles and Claudio Guti&#x00E9;rrez. 2008. Survey of graph database models. <em>      <em>ACM Comput. Surv.</em>     </em>40, 1 (2008), 1:1&#x2013;1:39. <a class="link-inline force-break" href="https://doi.org/10.1145/1322432.1322433"      target="_blank">https://doi.org/10.1145/1322432.1322433</a></li>    <li id="BibPLXBIB0003" label="[3]">Dan Brickley, R.V. Guha, and Brian McBride. 2014. RDF Schema 1.1. W3C Recommendation. (25 Feb. 2014). <a class="link-inline force-break" href="http://www.w3.org/TR/rdf-schema/">http://www.w3.org/TR/rdf-schema/</a>.</li>    <li id="BibPLXBIB0004" label="[4]">Mohamed&#x00A0;Ben Ellefi, Zohra Bellahsene, John&#x00A0;G. Breslin, Elena Demidova, Stefan Dietze, Julian Szymanski, and Konstantin Todorov. RDF Dataset Profiling - a Survey of Features, Methods, Vocabularies and Applications. <em>      <em>Semantic Web Journal</em>     </em>(????). To appear.</li>    <li id="BibPLXBIB0005" label="[5]">Holger Knublauch and Dimitris Kontokostas. 2014. Shapes Constraint Language (SHACL). W3C Working Group Note. (24 June 2014). <a class="link-inline force-break" href="http://www.w3.org/TR/rdf11-primer/">http://www.w3.org/TR/rdf11-primer/</a>.</li>    <li id="BibPLXBIB0006" label="[6]">Gabriel&#x00A0;M. Kuper and Moshe&#x00A0;Y. Vardi. 1984. A New Approach to Database Logic. In <em>      <em>ACM SIGACT-SIGMOD Symposium on Principles of Database Systems (PODS)</em>     </em>. 86&#x2013;96. <a class="link-inline force-break" href="https://doi.org/10.1145/588011.588026"      target="_blank">https://doi.org/10.1145/588011.588026</a></li>    <li id="BibPLXBIB0007" label="[7]">Yike Liu, Tara Safavi, Abhilash Dighe, and Danai Koutra. 2018. Graph Summarization Methods and Applications: A Survey. <em>      <em>CoRR</em>     </em>abs/1612.04883(2018). arxiv:1612.04883<a class="link-inline force-break" href="http://arxiv.org/abs/1612.04883"      target="_blank">http://arxiv.org/abs/1612.04883</a></li>    <li id="BibPLXBIB0008" label="[8]">Denny Vrande&#x010D;i&#x0107; and Markus Kr&#x00F6;tzsch. 2014. Wikidata: a free collaborative knowledgebase. <em>      <em>Commun. ACM</em>     </em>57, 10 (2014), 78&#x2013;85.</li>    </ul>   </section>  </section>  <section id="foot-001" class="footnote">   <header>    <div class="title-info">    <h2>FOOTNOTE</h2>    </div>   </header>   <p id="fn1"><a href="#foot-fn1"><sup>1</sup></a>Of course, this list of desiderata is far from complete. We may also consider more application-oriented requirements; e.g., it may be useful for schemas to be composable, such that given the schemas of two independent graphs, it should be feasible to compute the schema of the union of the two graphs.</p>   <div class="bibStrip">    <p>This paper is published under the Creative Commons Attribution 4.0 International (CC-BY&#x00A0;4.0) license. Authors reserve their rights to disseminate the work on their personal and corporate Web sites with the appropriate attribution.</p>    <p>    <em>WWW '18, April 23-27, 2018, Lyon, France</em>    </p>    <p>&#x00A9; 2018; IW3C2 (International World Wide Web Conference Committee), published under Creative Commons CC-BY&#x00A0;4.0 License. ACM ISBN 978-1-4503-5640-4/18/04.<br/>DOI: <a class="link-inline force-break" target="_blank"     href="https://doi.org/10.1145/3184558.3191647">https://doi.org/10.1145/3184558.3191647</a>    </p>   </div>  </section>  <div class="pubHistory">   <p/>  </div> </body> </html> 
