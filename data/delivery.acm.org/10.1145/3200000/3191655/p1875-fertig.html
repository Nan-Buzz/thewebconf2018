<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">  <head>  <title>Towards Offline Support for RESTful Systems</title>  <!-- Copyright (c) 2010-2015 The MathJax Consortium --><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>  <meta name="viewport" content="width=device-width; initial-scale=1.0;"></meta>  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>  <link media="screen, print" rel="stylesheet"    href="https://dl.acm.org/pubs/lib/css/bootstrap.min.css"/><link media="screen, print" rel="stylesheet"    href="https://dl.acm.org/pubs/lib/css/bootstrap-theme.min.css"/><link media="screen, print" rel="stylesheet"    href="https://dl.acm.org/pubs/lib/css/main.css"/><script src="https://dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script>  <script src="https://dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script>  <script src="https://dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script>  <script src="https://dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script>  <script type="text/javascript"    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>  <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>  </head>  <body id="main">  <section class="front-matter">   <section>    <header class="title-info">     <div class="journal-title">     <h1>      <span class="title">Towards Offline Support for RESTful Systems</span>      <br/>      <span class="subTitle"/>     </h1>     </div>    </header>    <div class="authorGroup">     <div class="author">     <span class="givenName">Tobias</span>      <span class="surName">Fertig</span>,     University of Applied Science W&#x00FC;rzburg-Schweinfurt, Sanderheinrichsleitenweg 20W&#x00FC;rzburg 97074, <a href="mailto:tobias.fertig@fhws.de">tobias.fertig@fhws.de</a>     </div>     <div class="author">     <span class="givenName">Peter</span>      <span class="surName">Braun</span>,     University of Applied Science W&#x00FC;rzburg-Schweinfurt, Sanderheinrichsleitenweg 20W&#x00FC;rzburg 97074, <a href="mailto:peter.braun@fhws.de">peter.braun@fhws.de</a>     </div>            </div>    <br/>    <div class="pubInfo">     <p>DOI: <a href="https://doi.org/10.1145/3184558.3191655" target="_blank">https://doi.org/10.1145/3184558.3191655</a>     <br/>WWW '18: <a href="https://doi.org/10.1145/3184558" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p>    </div>    <div class="abstract">     <p>     <small>Representational State Transfer (REST) is an efficient and by now established architectural style for distributed hypermedia systems. However, REST has not been designed for offline operations, yet many applications must also keep functioning when going offline for more than a few seconds. Burdening the programmer with knowledge about offline status is undesirable. RESTful applications can be described by a formal model. Therefore, we define a function to derive a formal model of the proxy for handling offline support on the client-side. We then extend existing caching approaches so that a client-side proxy can transparently hide the offline status from the application. We validate our solution with a proxy layer that covers all test cases derived from the model. Using our model and proxy, clients do not have to know and worry about whether they are online or offline.</small>     </p>    </div>    <div class="CCSconcepts">     <p> <small> <span style="font-weight:bold;">CCS Concepts:</span> &#x2022;<strong> Software and its engineering </strong>&#x2192; <strong>Model-driven software engineering;</strong> <strong>Client-server architectures;</strong> <em>Layered systems;</em></small> </p>    </div>    <div class="classifications">     <div class="author">     <span style="font-weight:bold;">      <small>Keywords:</small>     </span>     <span class="keyword">      <small>REST</small>, </span>     <span class="keyword">      <small> RESTful Applications</small>, </span>     <span class="keyword">      <small> RESTful Systems</small>, </span>     <span class="keyword">      <small> Offline Support</small>, </span>     <span class="keyword">      <small> Hypermedia</small>, </span>     <span class="keyword">      <small> Offline First</small>, </span>     <span class="keyword">      <small> MDSD</small>     </span>     </div>     <br/>     <div class="AcmReferenceFormat">     <p>      <small>       <span style="font-weight:bold;">ACM Reference Format:</span>       <br/>       Tobias Fertig and Peter Braun. 2018. Towards Offline Support for RESTful Systems. In <em>WWW '18 Companion: The 2018 Web Conference Companion,</em>       <em>April23&#x2013;27, 2018 (WWW &#x2019;18 Companion),</em>       <em> Lyon, France. ACM, New York, NY, USA</em> 6 Pages. <a href="https://doi.org/10.1145/3184558.3191655" class="link-inline force-break"        target="_blank">https://doi.org/10.1145/3184558.3191655</a></small>     </p>     </div>    </div>   </section>  </section>  <section class="body">   <section id="sec-3">    <header>     <div class="title-info">     <h2>      <span class="section-number">1</span> Introduction</h2>     </div>    </header>    <p>Representational State Transfer (REST) was introduced by Fielding within his dissertation [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0002">2</a>]. Despite of the popularity of REST many developers ignored several constraints of REST. That is why Fielding&#x0027;s blog post explains that REST APIs must be hyper-text driven in order to fulfill the hypermedia constraint [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0003">3</a>]. This constraint requires a stable internet connection to allow the client to communicate with the server uninterruptedly. However, stable internet connections are not possible in any place at any time. Could it be possible to improve the user experience by providing offline support on the client side? We encountered several scenarios that would benefit from offline support:</p>    <p>Sitting in an airplane forces people to work in offline mode. Therefore, any application that does not provide offline support, cannot be used by passengers on airplanes. Cloud Computing also benefits from offline support. Current browsers use offline storage to enable Web or cloud applications working offline. Google suggests the <em>offline first</em> approach in their developer documentation (<a class="link-inline force-break"     href="https://developer.chrome.com/apps/offline_apps">https://developer.chrome.com/apps/offline_apps</a>). Offline first recommends to write an app as if it needs no internet connection. Network features can be added once the app works offline. Nowadays, developers have to implement offline support manually and they are also forced to distinguish between offline and online mode.</p>    <p>Is offline support in RESTful systems an oxymoron? Is there any way to reduce the developer&#x0027;s effort for implementing offline clients? To answer these questions we did some research on related work that will be discussed in the following section. The third section proposes the research questions for this paper, which will then be answered in the following three sections <a class="sec" href="#sec-6">4</a>, <a class="sec" href="#sec-7">5</a> and <a class="sec" href="#sec-8">6</a>. Afterwards, we show the results by using our model and its implementation. Finally, we will give a short outlook on future work.</p>   </section>   <section id="sec-4">    <header>     <div class="title-info">     <h2>      <span class="section-number">2</span> Related Work</h2>     </div>    </header>    <p>Satyanarayanan proposed Coda, a distributed file system that runs using a client-server model [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0010">10</a>]. It distinguishes a small number of trusted servers and a large number of untrusted clients. Coda uses a callback-based cache coherence: the server remembers which objects have been cached by a client. However, Fielding defined the stateless constraint for REST: the server has to be stateless to improve scalability of the overall system. Therefore, Satyanarayanan&#x0027;s approach is not applicable for RESTful systems [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0002">2</a>].</p>    <p>Gon&#x00E7;alves and Leit&#x00E3;o contributed a lot to enable offline execution in Web applications [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0005">5</a>]. They described an offline model that contains a subset of the server logic. The interaction model describes that a local server has to work as a proxy which has to forward all requests if online. In offline mode the proxy has to save the offline request and return an offline response. If the client later goes online, all offline work has to be synchronized back to the server [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0006">6</a>]. However, Gon&#x00E7;alves and Leit&#x00E3;o focused on prefetching mechanisms to fill the offline cache which we consider to be part of our future work.</p>    <p>Disconnected operations are not exclusive to Web applications. In fact, distributed systems already consider them. Nevertheless, those considerations are not suitable for Web architecture. However, some distributed systems defined similar goals. For example, Demers et al. defined for their Bayou architecture the following goals: Firstly, an offline approach has to support devices with limited resources. Secondly, high availability for read and write operations should be ensured. Thirdly, there has to be a mechanism to support the detection of update conflicts. Finally, an application specific resolution of update conflicts has to be established [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>].</p>    <p>Hoodie (<a class="link-inline force-break" href="http://hood.ie">http://hood.ie</a>) is designed for frontend Web applications and follows the offline first approach (<a class="link-inline force-break" href="http://offlinefirst.org">http://offlinefirst.org</a>). Hoodie offers a local, user-specific database that is automatically synchronized back to the server. Loopback (<a class="link-inline force-break" href="https://loopback.io">https://loopback.io</a>) is a Node.js API framework that enables offline synchronization via isomorphic JavaScript. The data replication is implemented as model-based data persistence. The framework was mainly developed to synchronize multiple backends. Therefore, its focus is not on offline support. Furthermore, those frameworks do not concentrate on RESTful systems and they need specific backends to run properly. This is why we tried to define a generic model to add offline support not only to RESTful systems under development but also to existing systems.</p>   </section>   <section id="sec-5">    <header>     <div class="title-info">     <h2>      <span class="section-number">3</span> Research Questions</h2>     </div>    </header>    <p>This section lists three research questions that have to be answered within this work and we also describe our research methodology:</p>    <ol class="list-no-style">     <li id="list1" label="Q1">Are RESTful systems and offline support combinable?<br/></li>     <li id="list2" label="Q2">How is it possible to organize offline supported functionality hierarchically?<br/></li>     <li id="list3" label="Q3">Is there a generic solution for offline support in RESTful systems?<br/></li>    </ol>    <p>Questions Q1 will be answered by literature research in the following section. Afterwards, we will propose a six-level hierarchy to answer Question Q2 in Section <a class="sec" href="#sec-7">5</a>. Question Q3 will then be answered by using a formal model to describe RESTful systems.</p>   </section>   <section id="sec-6">    <header>     <div class="title-info">     <h2>      <span class="section-number">4</span> Offline Support and REST</h2>     </div>    </header>    <p>To answer Q1 we review latest literature on REST for existing approaches to combine the REST architectural style with offline operations. Richardson [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0007">7</a>] as well as Webber [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0012">12</a>] do not talk about offline support at all, since they only focus on how to design and implement the server-side of such a RESTful system. However, Richardson wrote at least one chapter about caching but focused on HTTP [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0008">8</a>].</p>    <p>In contrast to literature, searching the World Wide Web leads to different approaches to implement offline support for RESTful systems. REST inherently fits many offline scenarios, mainly because of statelessness and the use of caches. For example, safe requests, like GET can easily be supported in offline mode due to caching. Moreover, idempotent requests, like PUT, and DELETE can be queued on the client side quite easily for later delivery [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0004">4</a>]. Of course, the necessary synchronization of modified data back to the server might cause severe situations where it is difficult or even impossible to solve. However, there is no significant difference whether these problems occur at the time the request was issued or later during synchronization.</p>    <p>Riva and Laitkorpi summarized challenges and constraints of a mobile environment that are beyond the typical REST design [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0009">9</a>]. One of these constraints is the offline/online behavior. They state that flaky network connections are typical for mobile devices. Therefore, mobile services have to define a strategy for supporting offline operations. Since they are designing mobile services using REST, their opinion is that offline support is fit for RESTful systems. However, they do not have any explicit support to process requests offline within their solution.</p>   </section>   <section id="sec-7">    <header>     <div class="title-info">     <h2>      <span class="section-number">5</span> Hierarchies of Offline Support</h2>     </div>    </header>    <figure id="fig1">     <img src="http://deliveryimages.acm.org/10.1145/3200000/3191655/images/www18companion-394-fig1.svg" class="img-responsive" alt="Figure 1"      longdesc=""/>     <div class="figure-caption">     <span class="figure-number">Figure 1:</span>     <span class="figure-title">A six-level hierarchy for offline support.</span>     </div>    </figure>    <p>In research question Q2, we ask for a proper software design to implement offline support for RESTful clients. In other words, we ask for a hierarchy of different levels in which offline support can be provided depending on specific requirements. We propose a level oriented architecture shown in Figure <a class="fig" href="#fig1">1</a>.</p>    <p>The lowest level represents caching and enables the client to process read operations. In addition to Fielding, who defined the caching constraint to reduce network traffic, caching can also be seen as strategy for processing requests while being offline [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0002">2</a>].</p>    <p>To achieve the second level of offline support, idempotent operations have to be supported. The HTTP specification defines that the methods GET, PUT and DELETE have to be idempotent [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0004">4</a>]. Therefore, those requests should be processible on this level. The client will need a queue to store all requests that were issued offline. Since caching is transient by default it has to be persistent on this level in order to allow the restart of clients. Query operations are also idempotent but are not considered within this level.</p>    <p>Handling Create, Retrieve, Update and Delete (CRUD) operations is defined on the third level. Create operations are not always idempotent. Therefore, client and server have to ensure that those requests will not be executed multiple times. The client needs additional knowledge in order to create temporary resources containing all relevant information like identifiers. During synchronization the temporary resources must be removed from the cache. Requests that are sent after the create operation have to be redirected to correct URIs.</p>    <p>The fourth level now also includes query operations. On the client side it cannot be guaranteed that all data is available in the local cache. Queries can only return a limited collection of resources if executed offline. The client does not know whether a request would return the same collection in online mode. In addition to the previous levels, the client also needs to support paging, i.&#x00A0;e.&#x00A0; only a limited number of results is returned instead of all results.</p>    <p>The fifth level is dedicated to the decision whether complex business logic is only available on the origin server or also on the client side.</p>    <p>A perfect clone of the origin server would achieve the sixth level. The most specific implementations have to be made on this level. Moreover, all functionality has to be implemented on client side. This is why the highest level is an utopia that can never be reached.</p>   </section>   <section id="sec-8">    <header>     <div class="title-info">     <h2>      <span class="section-number">6</span> Deriving Offline Support</h2>     </div>    </header>    <section id="sec-9">     <header>     <div class="title-info">      <h3>       <span class="section-number">6.1</span> Overview of the Underlying Model</h3>     </div>     </header>     <p>Every &#x025B;-NFA can be described as a tuple <span class="inline-equation"><span class="tex">$(S, \Sigma , s_{0}, \delta , F)$</span>     </span>, where <em>S</em> is a finite, non-empty set of states. <em>&#x03A3;</em> is a finite, non-empty set of symbols representing the input alphabet. <span class="inline-equation"><span class="tex">$s_{0} \in S$</span>     </span> is the initial state of the &#x025B;-NFA. <em>&#x03B4;</em> is the state transition function <em>&#x03B4;</em>: <em>S</em> &#x00D7; (<em>&#x03A3;</em>&#x2009;&#x222A;&#x025B;) &#x2192; <em>P</em>(<em>S</em>), where <em>P</em>(<em>S</em>) is the power set of <em>S</em> and <em>F</em>&#x2286;<em>S</em> is the set of accepting states. Zuzak, Budiselic and Delac described three main parts of &#x025B;-NFA operations: the <em>Input Symbol Generator</em>, the <em>Transition Function</em> and finally the <em>Current State</em> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0013">13</a>].</p>     <p>They mapped a RESTful system to the &#x025B;-NFA formal model as follows: Let <em>Reqs</em> be a finite set of valid requests, let <em>Metas</em> be a finite set of metadata key-value pairs, let <em>LTypes</em> be a finite set of link types and let <em>MTypes</em> be a finite set of media types. Finally, let <em>Reprs</em> be a finite set of resource representations: <em>Reprs</em>&#x2286;<em>data</em> &#x00D7; <em>P</em>(<em>Metas</em>) where one metadata element defines the media type of the representation.</p>     <p>Next, let <em>Ops</em> be a finite set of resource manipulation methods. The set of states <em>S</em> of the &#x025B;-NFA are the application states, where an application state is defined as a non-empty and ordered set of representations <em>S</em>&#x2286;<em>P</em>(<em>Reprs</em>) &#x2212; {}. In addition to Zuzak et al. we also include the <em>Ops</em> in the definition of states <em>S</em>&#x2286;(<em>P</em>(<em>Reprs</em>) &#x2212; {}) &#x00D7; <em>Ops</em>. Therefore, an application has different states for manipulating and retrieving representations. Moreover, the initial state <span class="inline-equation"><span class="tex">$s_{0}$</span>     </span> represents the initial application state, which is called dispatcher state. Zuzak et al. also defined the set of accepting states. In our opinion a RESTful system does not contain such accepting states, since it runs until it is undeployed. Therefore, let <em>F</em> be empty. The set of input symbols <em>&#x03A3;</em> of the &#x025B;-NFA represents requests <em>Reqs</em> and their corresponding link types <em>LTypes</em>, <em>&#x03A3;</em>&#x2286;<em>Reqs</em> &#x00D7; <em>LTypes</em>. The transistion function <em>&#x03B4;</em> represents the translation of input symbols into requests, processing of requests into responses and integration of response representations into the next application state, <em>&#x03B4;</em>: <em>S</em> &#x00D7; (<em>Reqs</em> &#x00D7; <em>LTypes</em>) &#x2192; <em>P</em>(<em>S</em>).</p>    </section>    <section id="sec-10">     <header>     <div class="title-info">      <h3>       <span class="section-number">6.2</span> Deriving the Proxy Model</h3>     </div>     </header>     <figure id="fig2">     <img src="http://deliveryimages.acm.org/10.1145/3200000/3191655/images/www18companion-394-fig2.svg" class="img-responsive" alt="Figure 2"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 2:</span>      <span class="figure-title">a) The method we used for verifying our work. We used the defined function <em>&#x03A6;</em> on an existing REST API manually. Afterwards we implemented the proxy layer for the first time based on the finite-state machine returned by <em>&#x03A6;</em>. Finally, we evaluated the proxy layer. b) Describes the method in future work, where the proxy is generated automatically.</span>     </div>     </figure>     <p>We distinguish between the origin server and the proxy on client-side. If the RESTful system has to work offline, all requests will be handled by the proxy. The origin is responsible for the conversion of requests into responses and the proxy has to convert the requests into responses while working offline, too. We defined two different limitations for offline mode: functional limitations and data limitations. The &#x025B;-NFA of the proxy is a subset of the &#x025B;-NFA of the origin. However, if the origin only serves Create, Retrieve, Update and Delete (CRUD) operations the proxy &#x025B;-NFA may contain all states of the origin.</p>     <p>Processing images and creating PDF files are two examples for functional limitations. Every state handling those functional limitations has to be removed from the proxy &#x025B;-NFA. Data limitations due to missing availability have to be considered, too. This could be the case with statistical evaluations but also simply with query endpoints. Therefore, every state has to be evaluated as to whether it returns a collection of resources. If working on a cached subset of data is sufficient, the state can be part of the proxy &#x025B;-NFA. If all data is needed for the processing of requests, the state has to be removed from the proxy.</p>     <p>By using the model of Zuzak, Budiselic and Delac we define a function <em>&#x03A6;</em>. This function uses the &#x025B;-NFA of the origin as input and converts it to the &#x025B;-NFA of the proxy, <span class="inline-equation"><span class="tex">$\Phi (M_{Origin}) \rightarrow M_{Proxy}$</span>     </span>. Since both machines are described as tuples <span class="inline-equation"><span class="tex">$(S, \Sigma , s_{0}, \delta , F)$</span>     </span>, function <em>&#x03A6;</em> defines rules for every element of the tuple.</p>     <p>Every state without functional and data limitation is part of the finite set of states of the proxy. Functional limitations can be filtered by media type. A state is a non-empty, ordered set of representations, while a representation contains at least the media type as metadata key-value pair. Therefore, the function <em>mtype</em>(<em>s</em>) returns the media type of the representations. <em>MTypes<sub>Online</sub>     </em> is the finite set of media types that can only be provided in online mode. The function <em>count</em>(<em>s</em>) verifies that enough data is available offline so that a non-empty, ordered set of representations can be returned in the response. The rules for filtering the origin states is defined as follows: <div class="table-responsive" id="eq1">      <div class="display-equation">       <span class="tex mytex">\begin{multline} S_{Proxy} = \lbrace s| s \in S_{Origin} \setminus \lbrace {mtype(s) \not\in MTypes_{Online} \wedge count(s) {\gt} 0\rbrace \rbrace }\end{multline} </span>       <br/>       <span class="equation-number">(1)</span>      </div>     </div> Due to additional limitations it may be necessary to remove some of the input elements from the proxy. Since an input element is defined as the combination of <em>Reqs</em> and <em>LTypes</em>, the <em>LType</em> can be used to decide whether the input element should be part of the proxy. Therefore, we define a function <em>ltype</em>(<em>&#x03C3;</em>) that returns the <em>LType</em> of the input element. <em>LTypes<sub>Online</sub>     </em> is the finite set of link types that can only be provided in online mode. Function <em>&#x03A6;</em> uses the following rule for filtering the input elements: <div class="table-responsive" id="eq2">      <div class="display-equation">       <span class="tex mytex">\begin{multline} \Sigma _{Proxy} = \lbrace \sigma | \sigma \in \Sigma _{Origin} \setminus \lbrace {ltype(\sigma) \not\in LTypes_{Online}\rbrace \rbrace }\end{multline} </span>       <br/>       <span class="equation-number">(2)</span>      </div>     </div> The initial state or dispatcher of the state machine is the same for both, the origin and the proxy. The dispatcher contains information about the next available states. Therefore, no data is needed and there are no functional limitations. It can be ensured that the dispatcher state will not be removed from the proxy by the defined rules of <em>&#x03A6;</em>: <div class="table-responsive" id="eq3">      <div class="display-equation">       <span class="tex mytex">\begin{align} s_{0_{Proxy}} = s_{0_{Origin}} \end{align} </span>       <br/>       <span class="equation-number">(3)</span>      </div>     </div> The transition function <em>&#x03B4;</em> is also transformed by <em>&#x03A6;</em>. The translation of input symbols in requests, the processing of requests to responses and the integration of response representations into the next application state is defined as <em>S</em> &#x00D7; <em>&#x03A3;</em> &#x2192; <em>P</em>(<em>S</em>). The proxy may have a smaller power set due to some missing states and input elements, thus the transition function itself has to be filtered: <div class="table-responsive" id="eq4">      <div class="display-equation">       <span class="tex mytex">\begin{multline} \delta _{Proxy} = \lbrace (s,\sigma)| s \in S_{Proxy} \wedge \sigma \in \Sigma _{Proxy} \wedge (s, \sigma) \in \delta _{Origin}\rbrace\end{multline} </span>       <br/>       <span class="equation-number">(4)</span>      </div>     </div> The accepting states should only contain states <em>s</em> &#x2208; <em>S<sub>Proxy</sub>     </em> if one follows the definition of accepting states by Zuzak et al. Since we have a different opinion, our set of accepting states remains empty in the proxy as well as in the origin. Therefore, we defined the rule: <div class="table-responsive" id="eq5">      <div class="display-equation">       <span class="tex mytex">\begin{align} F_{Proxy} = F_{Origin} \end{align} </span>       <br/>       <span class="equation-number">(5)</span>      </div>     </div> The function <em>&#x03A6;</em> transforms any &#x025B;-NFA of an origin server into an &#x025B;-NFA for a proxy on client-side. This allows a developer to implement an offline mode in their RESTful system.</p>    </section>    <section id="sec-11">     <header>     <div class="title-info">      <h3>       <span class="section-number">6.3</span> Using the Transformation Function</h3>     </div>     </header>     <p>Figure <a class="fig" href="#fig2">2</a> shows the next steps of our method under <em>a)</em>: at first, we have to define an application sample. Afterwards, the origin &#x025B;-NFA will be transformed into the proxy &#x025B;-NFA by manual application of function <em>&#x03A6;</em>. The resulting proxy will then be implemented and evaluated. If the proxy can support the application during offline mode, we consider <em>&#x03A6;</em> as correct. <figure id="fig3">      <img src="http://deliveryimages.acm.org/10.1145/3200000/3191655/images/www18companion-394-fig3.svg" class="img-responsive" alt="Figure 3"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 3:</span>       <span class="figure-title">The finite-state machine for the sample to-do-list application. The asterisk represents the default CRUD states for the to-do sub-resource similar to the user states.</span>      </div>     </figure>     </p>    </section>   </section>   <section id="sec-12">    <header>     <div class="title-info">     <h2>      <span class="section-number">7</span> An Offline Framework</h2>     </div>    </header>    <p>The RESTful system we used as an example implementation will be described in this section. Afterwards, we derive the proxy &#x025B;-NFA by the manual application of our function <em>&#x03A6;</em>. Therefore, the set of rules described in Section <a class="sec" href="#sec-11">6.3</a> is used. All relevant concepts for the implementation are also discussed in this section.</p>    <p>Figure <a class="fig" href="#fig3">3</a> shows the &#x025B;-NFA of the sample application which does not contain transitions for error cases for sake of clarity. The sample application has users as primary resource and to-dos as sub-resource. The states for the to-do sub-resource are summarized as asterisk since they are similar to the CRUD states for the users&#x2019; resource.</p>    <p>Creating a new user requires information such as username, email address, and password. However, the returned representations should not contain password information on retrieval. Therefore, we define two media types for the user resource. The to-do resource requires only one representation, and therefore, only one media type.</p>    <p>Input elements were defined as requests and their corresponding link types. Input elements can affect different resources. However, they can be grouped by their <em>LType</em> since the same <em>LType</em> has an equivalent effect on different resources.</p>    <p>The next step is to apply the function <em>&#x03A6;</em> manually. Therefore, the finite set of states as well as the finite set of input elements have to be filtered. Based on the defined rules we dropped the states for profile images and passwords. Furthermore, the input elements with the corresponding link types were removed. Figure <a class="fig" href="#fig3">3</a> shows the resulting &#x025B;-NFA of the proxy on the left side of the dashed line.</p>    <p>The derived proxy will be implemented as prototype for evaluation. The proxy should then enable offline support on the fourth level of our hierarchy. The essential component of the first level is the cache. Since the media types of the example application are based on JSON the cache component should be able to handle finite sets of key value pairs. The second level requires the cache to be persistent in order to allow the client application to restart without losing the current state of data. However, for this prototype we will only implement an in-memory cache for simplicity.</p>    <p>An additional component has to enqueue all requests that were issued offline. The enqueued requests can later be replayed to the server. The fourth level can also serve non-idempotent requests which may lead to conflicts. Furthermore, lost update problems may occur if multiple users are updating same resources. Therefore, the proxy implementation has to detect those conflicts. If conflicts were detected the proxy has to solve them either by itself or by using a callback function asking the application for help. The component for request execution itself has to interpret incoming requests and manipulate the cached data as well as handling queries. Therefore, a component for filtering cached resources and enabling pagination is required.</p>   </section>   <section id="sec-13">    <header>     <div class="title-info">     <h2>      <span class="section-number">8</span> Discussion</h2>     </div>    </header>    <section id="sec-14">     <header>     <div class="title-info">      <h3>       <span class="section-number">8.1</span> Implementing the Prototype</h3>     </div>     </header>     <p>To achieve transparency for the developers of RESTful clients, we decided to decorate an existing HTTP client. The processing of requests can be seen in Figure <a class="fig" href="#fig4">4</a>. The request handler determines whether the client is online. In online mode the requests will be directly sent to the origin server. In offline mode all requests will be redirected to the proxy. The proxy will respond to the requests based on cached resources, if possible. Afterwards, the requests are enqueued for later synchronization. GET requests will not be stored in the queue since they were already answered by the proxy and do not modify representations of resources. As soon as the client goes online again, the queue gets synchronized to the origin server.</p>     <p>Offline support was implemented with states. There is one client state for every HTTP method. Each state has the capabilities to operate on the persistent cache. After the required CRUD operation was executed a response is built. The response contains all hypermedia links that the origin server would have returned except for those removed by function <em>&#x03A6;</em>. However, it is possible that an application sends requests to cached hyperlinks that are not part of the proxy &#x025B;-NFA. The proxy implementation will detect those requests and replies with status code <em>503 - Service Unavailable</em>.</p>    </section>    <section id="sec-15">     <header>     <div class="title-info">      <h3>       <span class="section-number">8.2</span> Testing the Prototype</h3>     </div>     </header>     <p>For testing, we implemented a random request generator that can easily generate hundreds of valid requests. Moreover, we manually prepared an in-memory cache so that we would not have to bother with requests for filling the cache. Since our prototype cannot dynamically load the required information via <em>OPTIONS</em> request we also implemented the application specific classes.</p>     <p>The test cases are using two clients: one that works offline and one that works online. Since the offline client is the test subject, the online client is only necessary to produce some conflicts during synchronization. The request generator uses different probabilities for each HTTP method. Since the sample application is focused on resource manipulation requests, we increased the probability for those.</p>     <p>The tests were successful and proved that our proxy prototype works correctly. Since the proxy is a subset of the origin &#x025B;-NFA, it is clear that the proxy itself is also a RESTful system. <figure id="fig4">      <img src="http://deliveryimages.acm.org/10.1145/3200000/3191655/images/www18companion-394-fig4.svg" class="img-responsive" alt="Figure 4"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 4:</span>       <span class="figure-title">The client sends requests to the proxy when working offline. The proxy enqueues every POST, PUT and DELETE request for synchronization. GET requests can be dropped since they do not modify representations. The client sends requests to the origin server directly when working online. For the sake of clarity we do not include responses.</span>      </div>     </figure>     </p>    </section>    <section id="sec-16">     <header>     <div class="title-info">      <h3>       <span class="section-number">8.3</span> Suitability of the Proxy Layer</h3>     </div>     </header>     <p>Fielding defined five mandatory constraints for REST and the principle of layered systems is one of them [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0002">2</a>]. An additional layer for offline support, fits this requirement. The hypermedia constraint is also fulfilled due to the proxy returning all offline supported hypermedia links within responses.</p>     <p>The proxy layer has to manipulate some of the requests while replaying the queue. According to Fielding &#x201C;intermediary components can actively transform the content of messages because the messages are self-descriptive and their semantics are visible to intermediaries.&#x201D; [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0002">2</a>, 5.1.6] The manipulation of requests is thus allowed and possible.</p>     <p>The server side does not have to care about offline support since the proxy is not dependent on the server. The server does not have to provide additional information for the proxy layer within resource representations. The developers do not have to change the server implementation if they want to add offline support to their RESTful systems.</p>     <p>Using a proxy layer has some disadvantages. The proxy layer provides its own cache of resources. If the application using the proxy layer also implemented a cache, the mobile client could reach its memory capacity. This issue has to be considered while planning the offline support for an existing application. If the application is built from scratch the developer could consider not implementing an own cache on top of the proxy layer.</p>     <p>Another disadvantage is that the proxy layer can only process the requests that are part of the input elements of the proxy &#x025B;-NFA. If the layer above requests a cached hyperlink that cannot be processed, the proxy will return a <em>503 - Service Unavailable</em> response. Therefore, the layers above the proxy layer have to handle those responses. If the application itself implement offline support those conflicts could be avoided.</p>    </section>   </section>   <section id="sec-17">    <header>     <div class="title-info">     <h2>      <span class="section-number">9</span> Conclusion and Future Work</h2>     </div>    </header>    <p>We implemented offline support for RESTful systems to achieve a better user experience in several scenarios. Therefore, we answered the question whether REST and offline support are combinable and defined a hierarchy of six levels for offline support. With the help of Zuzak&#x0027;s formal model we derived the function <em>&#x03A6;</em> to retrieve the &#x025B;-NFA for the proxy layer. We implemented the proxy that resulted from the manual use of <em>&#x03A6;</em>. Since our tests were successful we proved that our model is correct.</p>    <p>We reached the goals of Demers et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>]. Some functionality was removed from the proxy due to limited resources on the clients. We achieved a high availability of reads and writes and conflicts can be detected via Etags. The prototype also follows the model of Gon&#x00E7;alves and Leit&#x00E3;o for working offline [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0005">5</a>]. A local server works as proxy, saves the offline requests, and returns offline responses. When going online all saved requests are synchronized with the origin server. If the client is back online it sends all saved requests directly to the origin server.</p>    <p>The implemented proxy layer only served as a prototype. In the future the prototype has to be refactored and extended. The cache as well as the queue have to be stored persistently to enable restarting of the client application. Moreover, the information given in the application specific classes can be loaded dynamically from the origin server. The proxy has to understand the message of the server and parse the information correctly.</p>    <p>In the future we also plan to implement the fully automatically application of function <em>&#x03A6;</em> to a model of the RESTful application. With regards to the work of Schreibmann and Braun it may be possible to implement <em>&#x03A6;</em> within their model-driven approach to enable automated generation of proxy layers for modeled RESTful APIs [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0011">11</a>]. Figure <a class="fig" href="#fig2">2</a> shows the future process by using the model-driven approach in <em>b)</em>: the required RESTful application will be described in the model, afterwards the proxy will be generated by the automatic use of function <em>&#x03A6;</em> and can finally be deployed. This would also allow us to generate application specific classes and functionality. Therefore, it could be possible to generate a proxy layer above the fourth level of our hierarchy for offline support. The generated proxy layer could then enable even more functionality while being offline.</p>   </section>  </section>  <section class="back-matter">   <section id="ref-001">    <header>     <div class="title-info">     <h2 class="page-brake-head">REFERENCES</h2>     </div>    </header>    <ul class="bibUl">     <li id="BibPLXBIB0001" label="[1]">A. Demers, K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and B. Welch. 1994. The Bayou Architecture: Support for Data Sharing Among Mobile Users. In <em>      <em>Mobile Computing Systems and Applications, 1994. WMCSA 1994. First Workshop on</em>     </em>. 2&#x2013;7.</li>     <li id="BibPLXBIB0002" label="[2]">R.T. Fielding. 2000. <em>REST: Architectural Styles and the Design of Network-based Software Architectures</em>. Doctoral dissertation. University of California, Irvine.</li>     <li id="BibPLXBIB0003" label="[3]">R.T. Fielding. 2008. REST APIs must be hyper-text driven. (10 2008). <a class="link-inline force-break"      href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven</a>.</li>     <li id="BibPLXBIB0004" label="[4]">R.T. Fielding and J. Reschke. 2014. RFC 7231, Hypertext Transfer Protocol &#x2013; HTTP/1.1: Semantics and Content. (2014). <a class="link-inline force-break" href="http://tools.ietf.org/html/rfc7231">http://tools.ietf.org/html/rfc7231</a>.</li>     <li id="BibPLXBIB0005" label="[5]">Edgar E.&#x00A0;M. Gon&#x00E7;alves and Ant&#x00F3;nio&#x00A0;Menezes Leit&#x00E3;o. 2007. Offline execution in workflow-enabled Web applications. In <em>      <em>6th International Conference on the Quality of Information and Communications Technology (QUATIC 2007)</em>     </em>. 204&#x2013;207.</li>     <li id="BibPLXBIB0006" label="[6]">Edgar E.&#x00A0;M. Gon&#x00E7;alves and Ant&#x00F3;nio&#x00A0;Menezes Leit&#x00E3;o. 2009. Using Common Lisp to Prototype Offline Work in Web Applications for Rich Domains. In <em>      <em>Proceedings of the 6th European Lisp Workshop</em>     </em>(<em>ELW &#x2019;09</em>). ACM, New York, NY, USA, 18&#x2013;27.</li>     <li id="BibPLXBIB0007" label="[7]">L. Richardson, M. Amundsen, and S. Ruby. 2013. <em>      <em>RESTful Web APIs</em>     </em>. O&#x0027;Reilly Media.</li>     <li id="BibPLXBIB0008" label="[8]">L. Richardson and S. Ruby. 2008. <em>      <em>RESTful Web Services</em>     </em>. O&#x0027;Reilly Media.</li>     <li id="BibPLXBIB0009" label="[9]">Claudio Riva and Markku Laitkorpi. 2009. <em>      <em>Service-Oriented Computing - ICSOC 2007 Workshops: ICSOC 2007, International Workshops, Vienna, Austria, September 17, 2007, Revised Selected Papers</em>     </em>. Springer Berlin Heidelberg, Chapter Designing Web-Based Mobile Services with REST, 439&#x2013;450. <a class="link-inline force-break"      href="https://doi.org/10.1007/978-3-540-93851-4_42"      target="_blank">https://doi.org/10.1007/978-3-540-93851-4_42</a></li>     <li id="BibPLXBIB0010" label="[10]">M. Satyanarayanan. 2002. The Evolution of Coda. <em>      <em>ACM Trans. Comput. Syst.</em>     </em>20, 2 (May 2002), 85&#x2013;124.</li>     <li id="BibPLXBIB0011" label="[11]">Vitaliy Schreibmann and Peter Braun. 2015. Model-Driven Development of RESTful APIs. In <em>      <em>Proceedings of the 11th International Conference of Web Information Systems and Technologies</em>     </em>. INSTICC, SciTePress, 5&#x2013;14.</li>     <li id="BibPLXBIB0012" label="[12]">J. Webber, S. Parastatidis, and I. Robinson. 2010. <em>      <em>REST in Practice: Hypermedia and Systems Architecture</em>     </em>. O&#x0027;Reilly Media.</li>     <li id="BibPLXBIB0013" label="[13]">Ivan Zuzak, Ivan Budiselic, and Goran Delac. 2011. <em>      <em>Web Engineering: 11th International Conference, ICWE 2011, Paphos, Cyprus, June 20-24, 2011</em>     </em>. Springer Berlin Heidelberg, Chapter Formal Modeling of RESTful Systems Using Finite-State Machines, 346&#x2013;360.</li>    </ul>   </section>  </section>  <section id="foot-001" class="footnote">   <header>    <div class="title-info">     <h2>FOOTNOTE</h2>    </div>   </header>   <div class="bibStrip">    <p>This paper is published under the Creative Commons Attribution 4.0 International (CC-BY&#x00A0;4.0) license. Authors reserve their rights to disseminate the work on their personal and corporate Web sites with the appropriate attribution.</p>    <p>     <em>WWW '18, April 23-27, 2018, Lyon, France</em>    </p>    <p>&#x00A9; 2018; IW3C2 (International World Wide Web Conference Committee), published under Creative Commons CC-BY&#x00A0;4.0 License. ACM ISBN 978-1-4503-5640-4/18/04.<br/>DOI: <a class="link-inline force-break" target="_blank"     href="https://doi.org/10.1145/3184558.3191655">https://doi.org/10.1145/3184558.3191655</a>    </p>   </div>  </section>  <div class="pubHistory">   <p/>  </div>  </body> </html> 
