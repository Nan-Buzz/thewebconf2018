<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> <head>  <title>A High-Performance Graph Enginefor Efficient Social Network Analysis</title>  <!-- Copyright (c) 2010-2015 The MathJax Consortium --><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>  <meta name="viewport" content="width=device-width; initial-scale=1.0;"></meta>  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>  <link media="screen, print" rel="stylesheet"    href="../../../../dl.acm.org/pubs/lib/css/bootstrap.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../../dl.acm.org/pubs/lib/css/bootstrap-theme.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../../dl.acm.org/pubs/lib/css/main.css"/><script src="../../../../dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script>  <script src="../../../../dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script>  <script src="../../../../dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script>  <script src="../../../../dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script>  <script type="text/javascript"    src="../../../../dl.acm.org/pubs/lib/js/MathJax.js?config=TeX-AMS_CHTML"></script>  <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script> </head> <body id="main">  <section class="front-matter">   <section>    <header class="title-info">    <div class="journal-title">     <h1>      <span class="title">A High-Performance Graph Enginefor Efficient Social Network Analysis</span>      <br/>      <span class="subTitle"/>     </h1>    </div>    </header>    <div class="authorGroup">    <div class="author">     <span class="givenName">Yong-Yeon</span>     <span class="surName">Jo</span>     Hanyang University, Seoul, Korea    </div>    <div class="author">     <span class="givenName">Myung-Hwan</span>     <span class="surName">Jang</span>     Hanyang University, Seoul, Korea    </div>    <div class="author">     <span class="givenName">Hyungsoo</span>     <span class="surName">Jung</span>     Hanyang University, Seoul, Korea    </div>    <div class="author">     <span class="givenName">Sang-Wook</span>     <span class="surName">Kim</span>     Hanyang University, Seoul, Korea<a class="fn" href="#fn1" id="foot-fn1"><sup>&#x204E;</sup></a>, <a href="mailto:jyy0430, sugichiin, hyungsoo.jung, wook@hanyang.ac.kr">jyy0430, sugichiin, hyungsoo.jung, wook@hanyang.ac.kr</a>    </div>        </div>    <br/>    <div class="pubInfo">    <p>DOI: <a href="https://doi.org/10.1145/3184558.3186929" target="_blank">https://doi.org/10.1145/3184558.3186929</a>     <br/>WWW '18: <a href="https://doi.org/10.1145/3184558" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p>    </div>    <div class="abstract">    <p>     <small>Existing single-machine based graph engines do not leverage the characteristic of social networks following the power-law degree distribution. We propose a new graph engine tailored for processing and analyzing large-scale social networks efficiently by exploiting the power-law degree property.</small>    </p>    </div>    <div class="CCSconcepts">    <p> <small> <span style="font-weight:bold;">CCS Concepts:</span> &#x2022;<strong> Information systems </strong>&#x2192; <em>Graph-based database models;</em> <em>Database management system engines;</em></small> </p>    </div>    <div class="classifications">    <div class="AcmReferenceFormat">     <p>      <small>       <span style="font-weight:bold;">ACM Reference Format:</span>       <br/>       Yong-Yeon Jo, Myung-Hwan Jang, Hyungsoo Jung, and Sang-Wook Kim. 2018. A High-Performance Graph Enginefor Efficient Social Network Analysis. In <em>WWW '18 Companion: The 2018 Web Conference Companion,</em>       <em>April 23&#x2013;27, 2018,</em>       <em> Lyon, France. ACM, New York, NY, USA</em> 3 Pages. <a href="https://doi.org/10.1145/3184558.3186929" class="link-inline force-break"       target="_blank">https://doi.org/10.1145/3184558.3186929</a></small>     </p>    </div>    </div>   </section>  </section>  <section class="body">   <p>Social network, graph processing, big data</p>   <section id="sec-2">    <header>    <div class="title-info">     <h2>      <span class="section-number">1</span> Motivation</h2>    </div>    </header>    <p>In order to respond the growing demand to handle big graphs such as social networks, recent years have seen many proposals&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0004">4</a>] that offered the state-of-the-art graph engines aiming at efficient graph processing. Among many graph engines, we focus on the engines to process and analyze large-scale social networks efficiently on a single machine&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0003">3</a>].</p>    <p>A social network is a typical example of real-world graphs following <em>the power-law degree distribution</em> which specifies that a few nodes have a lot of edges while a lot of nodes have a few edges. To the best of our knowledge, none of graph engines available now have been designed with this important characteristic of social networks in mind. Two technical issues need to be addressed for a graph engine to attain better performance with real-world graphs.</p>    <p>    <strong>Load balancing:</strong> a graph algorithm is performed <em>iteratively</em> on a graph engine where nodes in each iteration could be processed only <em>after</em> all nodes in previous iteration is processed&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0003">3</a>]. To achieve higher performance, all nodes to be processed for each iteration need to be evenly distributed over a group of threads. Existing graph engines adopt a <em>node-based workload distribution</em> that each thread is assigned with each node and its edges (i.e., adjacent nodes). This makes a thread processing a node with high-degree a straggler due to the power-law degree distribution, which incurs <em>a skewed distribution of the workload</em> for threads. This indeed slows down the progress of graph processing. So, a uniform distribution of workloads across threads is important.</p>    <p>    <strong>Indicator scanning:</strong> When performing any type of graph algorithms, graph engines generally use an <em>indicator</em> consisting of a <em>big</em> bit vector with bits corresponding to all nodes, to identify a group of nodes to be processed in each iteration (e.g., in the case of BFS, it is necessary to identify nodes to be visited in each iteration). These nodes are identified by linearly scanning the big indicator. When processing real-world graphs, a large majority of nodes with low degree are accessed in most iterations, while a few hub nodes with high degree are accessed in only a few iterations. This skewed degree distribution surely makes an indicator <em>extremely sparse</em> in most iterations, which causes linear scan for the sparse indicator to be extremely inefficient. Therefore, designing an efficient way of scanning the indicator is crucial.</p>   </section>   <section id="sec-3">    <header>    <div class="title-info">     <h2>      <span class="section-number">2</span> Proposed Graph Engine</h2>    </div>    </header>    <p>We propose a graph engine that runs on a single machine and is intended to address two important issues in processing large-scale social networks. Our graph engine consists of four layers as fig:archi: a storage management layer, a buffer management layer, an object management layer, and a thread management layer. On top of them, we also provide a web-based user interface<a class="fn" href="#fn2" id="foot-fn2"><sup>1</sup></a>. <figure id="fig1">     <img src="../../../../deliveryimages.acm.org/10.1145/3190000/3186929/images/www18companion-169-fig1.jpg" class="img-responsive" alt="Figure 1"      longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 1:</span>      <span class="figure-title">Architecture of our graph engine.</span>     </div>    </figure>    <figure id="fig2">     <img src="../../../../deliveryimages.acm.org/10.1145/3190000/3186929/images/www18companion-169-fig2.jpg" class="img-responsive" alt="Figure 2"      longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 2:</span>      <span class="figure-title">Performance comparison of graph engines.</span>     </div>    </figure>    </p>    <p>In our graph engine, three layers except for the thread management layer use the design concepts adopted in existing storage systems such as WiSS&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0002">2</a>] for managing memory and storage space. The storage space is partitioned to blocks (e.g., pages) which are aligned with the I/O unit. <em>A block</em> contains a number of objects (e.g., records), each of which represents an adjacency list of a node (i.e., a node with its adjacent nodes). If an object cannot fit a given block, it could be stored across multiple blocks. We also store graphs by considering data locality for efficient access to the secondary storage following our method in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0005">5</a>]. The thread management layer manages a pool of threads and accesses/processes graph data using thread pooling. In addition, we propose two techniques leveraging the power-law degree distribution to achieve high the performance as follows.</p>    <p>    <strong>Block-based workload distribution:</strong> for a uniform distribution of workloads, we determine to use the block-based approach for the workload distribution where each thread processes <em>a fixed-size block</em> instead of a variable-size object. The block has multiple objects or a part of an object. However, the total size of objects in each block is almost <em>identical</em> regardless of each object size. This distribution policy could achieve the uniform distribution of workloads, which helps achieve great performance improvement.</p>    <p>    <strong>Hierarchical indicator:</strong> To alleviate this overhead of indicator scanning, we use a <em>hierarchical</em> indicator. Its lowest-level indicator has the same bit vector as existing one. A higher-level indicator consists of a bit vector where each bit compresses a range of a lower-level indicator which is divided into fixed ranges. Here, a bit set in the higher-level indicator implies that a range of the lower-level indicator corresponding to the bit is necessary to be scanned. Otherwise, the range does not need to be scanned. A scan operation with this hierarchical indicator starts from the highest-level indicator (i.e., root) and moves down to a lower-level indicator only if a bit in the higher-level indicator is set. As a result, most of ranges in the sparse lowest-level indicator are skipped, which reduces unnecessary scanning of the indicator.</p>   </section>   <section id="sec-4">    <header>    <div class="title-info">     <h2>      <span class="section-number">3</span> Evaluation</h2>    </div>    </header>    <p>We compared the performance and scalability of our graph engine (i.e., <em>OurGE</em>) with those of five state-of-the-art graph engines&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0003">3</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0004">4</a>]. TuboGraph, GridGraph, and GraphChi follow a vertex-centric programming model and an external memory model. Since FlashGraph adopts a semi-external-memory model, it is infeasible if a dataset cannot reside in memory. X-Stream adopts an edge-centric model and thus reads all graph data at every iteration. For evaluation, we used a PC equipped with i7-7700K, 64GiB memory, and 1TB SSD. We used six real-world datasets <a class="fn" href="#fn3" id="foot-fn3"><sup>2</sup></a> in tab:ge-data. We conducted the experiments with three graph algorithms commonly provided by all graph engines such as BFS, PageRank, and WCC.</p>    <div class="table-responsive" id="tab1">    <div class="table-caption">     <span class="table-number">Table 1:</span>     <span class="table-title">Real-world social networks</span>    </div>    <table class="table">     <tbody>      <tr>       <td style="text-align:center;">Datasets</td>       <td style="text-align:right;">Wiki</td>       <td style="text-align:right;">UK</td>       <td style="text-align:right;">Twit</td>       <td style="text-align:right;">SK</td>       <td style="text-align:right;">Friend</td>       <td>Yahoo</td>      </tr>      <tr>       <td style="text-align:center;"># of nodes (M)</td>       <td style="text-align:right;">12</td>       <td style="text-align:right;">39</td>       <td style="text-align:right;">61</td>       <td style="text-align:right;">50</td>       <td style="text-align:right;">68</td>       <td>1,413</td>      </tr>      <tr>       <td style="text-align:center;"># of edges (B)</td>       <td style="text-align:right;">0.37</td>       <td style="text-align:right;">0.93</td>       <td style="text-align:right;">1.4</td>       <td style="text-align:right;">1.9</td>       <td style="text-align:right;">2.5</td>       <td>6.6</td>      </tr>      <tr>       <td style="text-align:center;">Graph size (GiB)</td>       <td style="text-align:right;">5.7</td>       <td style="text-align:right;">16</td>       <td style="text-align:right;">24</td>       <td style="text-align:right;">32</td>       <td style="text-align:right;">44</td>       <td>114</td>      </tr>     </tbody>    </table>    </div>    <p>fig:performance shows the performance of graph engines for each algorithm. We measured the execution times in log-scale, changing the datasets. We observed that OurGE outperforms all other graph engines significantly. As the size of datasets gets larger, the execution times of all graph engines increase, and the performance gaps between OurGE and others are widening. In the case of GraphChi and X-Stream, BFS and WCC on the largest dataset (i.e., Yahoo dataset), are not completed within 24 hours (i.e., O.O.T). FlashGraph could not perform PageRank and WCC on the Yahoo dataset in limited memory (i.e., O.O.M). TurboGraph does not work on WCC of the Wikipedia dataset.</p>    <p>fig:performance-(a) shows the execution times of BFS. The performance of OurGE is much better than those of the fastest one with different models, FlashGraph, and the fastest one with same models, TurboGraph, by 6 and 43 times, respectively. fig:performance-(b) shows the execution times of PageRank. Since PageRank accesses <em>all nodes at every iteration</em>, graph engines do not use the indicator. Our graph engine, however, outperforms in all cases due to the nice load balancing by the block-based workload distribution. We see that OurGE is better than TurboGraph by 7 times, and its scalability is superior to that of FlashGraph. fig:performance-(c) shows the execution times of WCC. OurGE is also the best one in all cases except for the Twit dataset in terms of both performance and scalability. Through these experiments, we verified that our techniques are effective and help improve the performance and scalability of OurGE.</p>   </section>  </section>  <section class="back-matter">   <section id="sec-5">    <header>    <div class="title-info">     <h2>ACKNOWLEDGMENTS</h2>    </div>    </header>    <p>This work was supported by (1) Semiconductor Industry Collaborative Project between Hanyang University and Samsung Electronics Co. Ltd., (2) the National Research Foundation of Korea (NRF) grant funded by the Ministry of Science and ICT (MSIT) (No. NRF-2017R1A2B3004581), (3) Next-Generation Information Computing Development Program through NRF funded by MSIT (NRF-2017M3C4A7069440), and (4) the Information Technology Research Center (ITRC) support program (IITP-2017-2013-0-00881).</p>   </section>   <section id="ref-001">    <header>    <div class="title-info">     <h2 class="page-brake-head">REFERENCES</h2>    </div>    </header>    <ul class="bibUl">    <li id="BibPLXBIB0001" label="[1]">D.&#x00A0;Zheng et al.2015. FlashGraph: processing billion-node graphs on an array of commodity SSDs. In <em>      <em>Proceedings of USENIX FAST</em>     </em>. 45&#x2013;58.</li>    <li id="BibPLXBIB0002" label="[2]">H.&#x00A0;Chou et al.1985. Design and implementation of the Wisconsin storage system. <em>      <em>Software: Practice and Experience</em>     </em>15, 10 (1985), 943&#x2013;962.</li>    <li id="BibPLXBIB0003" label="[3]">W.&#x00A0;Han et al.2013. TurboGraph: a fast parallel graph engine handling billion-scale graphs in a single PC. In <em>      <em>Proceedings of ACM SIGKDD</em>     </em>. 77&#x2013;85.</li>    <li id="BibPLXBIB0004" label="[4]">X.&#x00A0;Zhu et al.2015. GridGraph: large-scale graph processing on a single machine using 2-Level hierarchical partitioning. In <em>      <em>Proceedings of USENIX ATC</em>     </em>. 375&#x2013;386.</li>    <li id="BibPLXBIB0005" label="[5]">Y.&#x00A0;Jo et al.2016. Data locality in graph engines: implications and preliminary experimental results. In <em>      <em>Proceedings of ACM CIKM</em>     </em>. 1885&#x2013;1888.</li>    </ul>   </section>  </section>  <section id="foot-001" class="footnote">   <header>    <div class="title-info">    <h2>FOOTNOTE</h2>    </div>   </header>   <p id="fn1"><a href="#foot-fn1"><sup>&#x204E;</sup></a>Corresponding author.</p>   <p id="fn2"><a href="#foot-fn2"><sup>1</sup></a>http://realgraph.hanyang.ac.kr:20080</p>   <p id="fn3"><a href="#foot-fn3"><sup>2</sup></a>Wiki: http://konect.uni-koblenz.de/networks/wikipedia_link_en/, UK: http://law.di.unimi.it/webdata/uk-2005/,</p>   <p>Twit: an.kaist.ac.kr/traces/WWW2010, SK: http://law.di.unimi.it/webdata/sk-2005/,</p>   <p>Friend: https://archive.org/details/friendster-dataset-201107, Yahoo: <a class="link-inline force-break" href="http://webscope.sandbox.yahoo.com">http://webscope.sandbox.yahoo.com</a>   </p>   <div class="bibStrip">    <p>This paper is published under the Creative Commons Attribution 4.0 International (CC-BY&#x00A0;4.0) license. Authors reserve their rights to disseminate the work on their personal and corporate Web sites with the appropriate attribution.</p>    <p>    <em>WWW '18, April 23-27, 2018, Lyon, France</em>    </p>    <p>&#x00A9; 2018; IW3C2 (International World Wide Web Conference Committee), published under Creative Commons CC-BY&#x00A0;4.0 License. ACM ISBN 978-1-4503-5640-4/18/04.<br/>DOI: <a class="link-inline force-break" target="_blank"     href="https://doi.org/10.1145/3184558.3186929">https://doi.org/10.1145/3184558.3186929</a>    </p>   </div>  </section>  <div class="pubHistory">   <p/>  </div> </body> </html> 
