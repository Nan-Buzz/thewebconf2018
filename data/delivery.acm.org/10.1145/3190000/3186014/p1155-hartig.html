<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> <head>  <title>Semantics and Complexity of GraphQL</title>  <!-- Copyright (c) 2010-2015 The MathJax Consortium --><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>  <meta name="viewport" content="width=device-width; initial-scale=1.0;"></meta>  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>  <link media="screen, print" rel="stylesheet"    href="https://dl.acm.org/pubs/lib/css/bootstrap.min.css"/><link media="screen, print" rel="stylesheet"    href="https://dl.acm.org/pubs/lib/css/bootstrap-theme.min.css"/><link media="screen, print" rel="stylesheet"    href="https://dl.acm.org/pubs/lib/css/main.css"/><script src="https://dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script>  <script src="https://dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script>  <script src="https://dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script>  <script src="https://dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script>  <script type="text/javascript"    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>  <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script> </head> <body id="main">  <section class="front-matter">   <section>    <header class="title-info">    <div class="journal-title">     <h1>      <span class="title">Semantics and Complexity of GraphQL</span>      <br/>      <span class="subTitle"/>     </h1>    </div>    </header>    <div class="authorGroup">    <div class="author">     <span class="givenName">Olaf</span>     <span class="surName">Hartig</span>,     Dept.&#x00A0;of Computer and Information Science (IDA), Link&#x00F6;ping University, <a href="mailto:olaf.hartig@liu.se">olaf.hartig@liu.se</a>    </div>    <div class="author">     <span class="givenName">Jorge</span>     <span class="surName">P&#x00E9;rez</span>,     Department of Computer Science, Universidad de Chile Millenium Institute for Foundational Research on Data, <a href="mailto:jperez@dcc.uchile.cl">jperez@dcc.uchile.cl</a>    </div>            </div>    <br/>    <div class="pubInfo">    <p>DOI: <a href="https://doi.org/10.1145/3178876.3186014" target="_blank">https://doi.org/10.1145/3178876.3186014</a>     <br/>WWW '18: <a href="https://doi.org/10.1145/3178876" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p>    </div>    <div class="abstract">    <p>     <small>GraphQL is a recently proposed, and increasingly adopted, conceptual framework for providing a new type of data access interface on the Web. The framework includes a new graph query language whose semantics has been specified informally only. This has prevented the formal study of the main properties of the language.</small>    </p>    <p>     <small>We embark on the formalization and study of GraphQL. To this end, we first formalize the semantics of GraphQL queries based on a labeled-graph data model. Thereafter, we analyze the language and show that it admits really efficient evaluation methods. In particular, we prove that the complexity of the GraphQL evaluation problem is NL-complete. Moreover, we show that the enumeration problem can be solved with constant delay. This implies that a server can answer a GraphQL query and send the response byte-by-byte while spending just a constant amount of time between every byte sent.</small>    </p>    <p>     <small>Despite these positive results, we prove that the size of a GraphQL response might be prohibitively large for an internet scenario. We present experiments showing that current practical implementations suffer from this issue. We provide a solution to cope with this problem by showing that the total size of a GraphQL response can be computed in polynomial time. Our results on polynomial-time size computation plus the constant-delay enumeration can help developers to provide more robust GraphQL interfaces on the Web.</small>    </p>    </div>    <div class="classifications">    <div class="AcmReferenceFormat">     <p>      <small>       <span style="font-weight:bold;">ACM Reference Format:</span>       <br/>       Olaf Hartig and Jorge P&#x00E9;rez. 2018. Semantics and Complexity of GraphQL. In <em>WWW 2018: The 2018 Web Conference,</em>       <em>April 23&#x2013;27, 2018,</em>       <em> Lyon, France. ACM, New York, NY, USA</em> 10 Pages. <a href="https://doi.org/10.1145/3178876.3186014" class="link-inline force-break"       target="_blank">https://doi.org/10.1145/3178876.3186014</a></small>     </p>    </div>    </div>   </section>  </section>  <section class="body">   <section id="sec-3">    <header>    <div class="title-info">     <h2>      <span class="section-number">1</span> Introduction</h2>    </div>    </header>    <p>After developing and using it internally for three years, in 2016, Facebook released a specification&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0005">5</a>] and a reference implementation of its GraphQL framework. This framework introduces a new type of Web-based data access interfaces that presents an alternative to the notion of REST-based interfaces&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0016">16</a>]. One of its main advantages is its ability to define precisely the data you want, replacing multiple REST requests with a single call&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0005">5</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0006">6</a>]. Since its release, GraphQL has gained significant momentum and has been adopted by an increasing number of users &#x00A0;including Coursera, Github, Neo4J, and Pinterest &#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0009">9</a>] . A core component of the GraphQL framework is a query 	  language for expressing the data retrieval requests issued to GraphQL-aware Web servers. While there already exist a number of implementations of this language, a more fundamental understanding of the properties of the language is missing. The goal of this paper is to close this gap, which is a fundamental step to clarify intrinsic limitations and, more importantly, to identify optimization opportunities of possible implementations.</p>    <p>To illustrate some of these limitations and optimization opportunities, consider the public GraphQL interface provided by Github&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0006">6</a>]. Figure&#x00A0;<a class="fig" href="#fig1">1</a>(a) shows a query over this interface and Figure&#x00A0;<a class="fig" href="#fig1">1</a>(b) illustrates the corresponding query result. <a class="fn" href="#fn1" id="foot-fn1"><sup>1</sup></a> This query retrieves the login names of the owners of the first two Github repositories that are listed for the user with login &#x201C;danbri&#x201D; (which happens to be &#x201C;danbri&#x201D; himself in both cases <a class="fn" href="#fn2" id="foot-fn2"><sup>2</sup></a>). As our experiments with this public GraphQL interface show, there is an intriguing issue with the size of a query result when we begin nesting queries. Assume that we extend our example into some kind of <em>path expressions</em> that discover repository owners by traversing the relationships between Github repositories and their owners in increasing levels of distance. Figure&#x00A0;<a class="fig" href="#fig1">1</a>(a) represents the level-1 version of such a traversal. The level-2 version, illustrated in Figure&#x00A0;<a class="fig" href="#fig1">1</a>(c), retrieves the owners of the&#x00A0;(first two) repositories that are listed for each repository owner in the result of the level-1 version, and so on. Figure&#x00A0;<a class="fig" href="#fig1">1</a>(d) shows that there is an exponential increase of the result sizes for levels 1&#x2013;7. We note that this issue is somehow acknowledged by the Github GraphQL interface and, as a safety measure to avoid queries that might turn out to be too resource-intensive, it introduces a few syntactic restrictions&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0007">7</a>]. As one such restriction, Github imposes a maximum level of nesting for queries that it accepts for execution.</p>    <p>However, even with this restriction (and other syntactic restrictions imposed by the Github GraphQL interface&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0007">7</a>]), Github fails to 	  avoid all queries that hit some resource limits when executed. For instance, when we replace <tt>first:2</tt> by <tt>first:5</tt> in the queries of our experiment, we observe not only exponential behavior of result size growth and query execution times&#x00A0;(cf. Figure&#x00A0;<a class="fig" href="#fig1">1</a>(e)), but we also receive timeout errors for the level-6 and level-7 versions of the queries. The response messages with these timeout errors arrive from the server a bit more than 10 seconds after issuing the requests. Hence, Github&#x0027;s GraphQL processor clearly tries to execute these queries before their execution times exceed a threshold. Developers have already embarked trying to cope with this and similar issues&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0020">20</a>] defining ad hoc notions of &#x201C;complexity&#x201D; or &#x201C;cost&#x201D; of GraphQL queries. As we explain in this paper these approaches fall short on providing a robust solution for the problem as they can fail in both directions: discarding requests in which an efficient evaluation is possible, and allowing requests in which a complete evaluation is too resource intensive. <figure id="fig1">     <img src="http://deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-fig1.jpg" class="img-responsive" alt="Figure 1"      longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 1:</span>      <span class="figure-title">GraphQL queries and responses over the Github GraphQL interface&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"       href="#BibPLXBIB0006">6</a>].</span>     </div>    </figure>    </p>    <p>Instead of trying to tackle these and other issues by 	  ad hoc solutions, we propose to study them from a formal point of view borrowing the long tradition and tools used by the database community to study the semantics and complexity of query languages. This paper is a first step in this direction. Our formalization and technical results allow us, among other things, to provide a robust solution for the above mentioned problems.</p>    <p>The semantics of GraphQL queries&#x2014;i.e., the 	  definition of what the expected result of any given 	  query is&#x2014;is given in the GraphQL specification 	  by means of a recursive program specified by pseudo 	  code. This recursion is based on an operation to 	  resolve any so-called &#x201C;field&#x201D; in a 	  query&#x00A0;(such as <tt>user</tt>, <tt>repositories</tt>, and <tt>owner</tt> in our example query). Surprisingly, this operation is not fully specified and, instead, simply assumes access to an <em>&#x201C;internal function [...] for determining the [...] value of [the] field&#x201D;</em>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0005">5</a>]. While the lack of a more precise definition of this internal function may be intentional&#x00A0;(to allow for implementations of GraphQL on top of arbitrary database back-ends), it makes a systematic analysis of the GraphQL language unworkable. That is, without a complete formal definition it is impossible to determine properties such as the expressive power or the computational complexity of the language. Thus, our main conceptual contribution is a formalization of the semantics of GraphQL. We begin by defining a logical data model that formally captures the notion of a GraphQL graph, as well as the corresponding notion of a GraphQL schema (cf.&#x00A0;Section&#x00A0;<a class="sec" href="#sec-4">2</a>). Thereafter, based on our data model, we formalize the semantics of GraphQL queries by using a compositional approach (cf.&#x00A0;Section&#x00A0;<a class="sec" href="#sec-7">3</a>) providing a normal form that we heavily use when study the properties of the language.</p>    <p>As our first technical contribution we use our formalization to study the computational complexity of GraphQL (cf.&#x00A0;Section&#x00A0;<a class="sec" href="#sec-11">4</a>). We study the classical decision evaluation problem and the enumeration problem, showing that both can be efficiently solved. In particular, we show that the evaluation problem is complete for the class of problems decided in Nondeterministic Logarithmic Space. Moreover, we prove that for queries that satisfy the above mentioned normal form, the enumeration problem can be solved with constant delay. This implies that a server can answer a GraphQL query and send the response byte-by-byte while spending just a constant amount of time between every byte sent.</p>    <p>We also study the problem of computing the size of a GraphQL response (cf.&#x00A0;Section&#x00A0;<a class="sec" href="#sec-12">5</a>), showing that it can be solved in polynomial time. That is, even though the size of a query result can be prohibitively large, one can efficiently compute the exact size without executing the query. Our results on polynomial-time size computation plus the constant-delay enumeration provide a robust way of tackling the issues presented by current GraphQL implementations.</p>    <p>In Section&#x00A0;<a class="sec" href="#sec-15">6</a> 	  we review the related work, briefly comparing GraphQL with other more classical query languages. The conclusions of our work are presented in Section&#x00A0;<a class="sec" href="#sec-16">7</a>. We emphasize that this paper is a substantially extended version of a workshop paper&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0010">10</a>] in which we initially presented a fragment of the formalization of the language but no result about normal forms, the complexity of the enumeration or the size computation problems.</p>   </section>   <section id="sec-4">    <header>    <div class="title-info">     <h2>      <span class="section-number">2</span> Data Model</h2>    </div>    </header>    <p>A dataset that is made available via a GraphQL 	  interface can be queried in terms of a so-called 	  <em>schema</em> based on which the dataset is 	  represented implicitly as a directed, edge-labeled 	  multigraph with typed nodes and node properties. The 	  nodes in this graph correspond to JSON-style objects that may occur in the query results. The schema associated with a GraphQL interface introduces a notion of types for these objects. Such a type characterizes what fields an object of the given type may have and what values are allowed for each of these fields. The possible values can be restricted to a specific type of scalars or objects. To define the GraphQL query semantics formally we first need to make explicit this logical data model assumed by GraphQL. To this end, this section formalizes the notions of a GraphQL schema and a GraphQL graph. For each concept of the GraphQL specification that our definitions capture, we refer to section of the specification that introduces the concept.</p>    <section id="sec-5">    <header>     <div class="title-info">      <h3>       <span class="section-number">2.1</span> GraphQL Schema</h3>     </div>    </header>    <p>We consider three infinite countable sets: <span class="inline-equation"><span class="tex">${\tt Fields}$</span>     </span>&#x00A0;(field names, <font style="normal">&#x0024;</font>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0005">5</a>]), <span class="inline-equation"><span class="tex">${\tt Arguments}$</span>     </span>&#x00A0;(argument names, <font style="normal">&#x0024;</font>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0005">5</a>]), and <span class="inline-equation"><span class="tex">${\tt Types}$</span>     </span>&#x00A0;(type names, <font style="normal">&#x0024;</font>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0005">5</a>]). We assume that <span class="inline-equation"><span class="tex">${\tt Fields}$</span>     </span>, <span class="inline-equation"><span class="tex">${\tt Arguments}$</span>     </span> and <span class="inline-equation"><span class="tex">${\tt Types}$</span>     </span> are disjoint and that there exists a finite set <span class="inline-equation"><span class="tex">${\tt Scalars}$</span>     </span>&#x00A0;(scalar type names, <font style="normal">&#x0024;</font>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0005">5</a>]) which is a subset of <span class="inline-equation"><span class="tex">${\tt Types}$</span></span>. We also consider a set <span class="inline-equation"><span class="tex">${\tt Vals}$</span>     </span> of scalar values, and a function <span class="inline-equation"><span class="tex">${\it values}:{\tt Scalars}\rightarrow 2^{{\tt Vals}}$</span>     </span> that assigns a set of values to every scalar type.</p>    <p>GraphQL schemas and graphs are defined over finite 		 subsets of the above sets. We assume three finite sets <span class="inline-equation"><span class="tex">${\tt F}\subset {\tt Fields}$</span>     </span>, <span class="inline-equation"><span class="tex">${\tt A}\subset {\tt Arguments}$</span>     </span>, and <span class="inline-equation"><span class="tex">${\tt T}\subset {\tt Types}$</span>     </span>, where <span class="inline-equation"><span class="tex">${\tt T}$</span>     </span> is the disjoint union of <span class="inline-equation"><span class="tex">${\tt O}_{\tt T}$</span>     </span>&#x00A0;(object types, <font style="normal">&#x0024;</font>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0005">5</a>]), <span class="inline-equation"><span class="tex">${\tt I}_{\tt T}$</span>     </span>&#x00A0;(interface types, <font style="normal">&#x0024;</font>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0005">5</a>]), <span class="inline-equation"><span class="tex">${\tt U}_{\tt T}$</span>     </span>&#x00A0;(union types, <font style="normal">&#x0024;</font>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0005">5</a>]) and <span class="inline-equation"><span class="tex">${\tt Scalars}$</span>     </span>, and we denote by&#x00A0;<span class="inline-equation"><span class="tex">${\tt L}_{\tt T}$</span>     </span> the set <span class="inline-equation"><span class="tex">$\lbrace [\ {\tt t}\ ]\mid {\tt t}\in {\tt T}\rbrace$</span>     </span> of list types constructed from <span class="inline-equation"><span class="tex">${\tt T}$</span>     </span>&#x00A0;(cf. <font style="normal">&#x0024;</font>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0005">5</a>]). We now have 		 everything necessary to define a GraphQL schema over <span class="inline-equation"><span class="tex">$({\tt F},{\tt A},{\tt T})$</span></span>.</p>    <div class="definition" id="enc1">     <Label>Definition 2.1.</Label>     <p> A GraphQL schema <span class="inline-equation"><span class="tex">${\mathcal {S}}$</span>      </span> over <span class="inline-equation"><span class="tex">$({\tt F},{\tt A},{\tt T})$</span>      </span> is composed of the following five assignments:</p>     <p>      <ul class="list-no-style">       <li id="list1" label="&#x2022;"><span class="inline-equation"><span class="tex">${\it fields}_{\mathcal {S}}:({\tt O}_{\tt T}\cup {\tt I}_{\tt T})\rightarrow 2^{{\tt F}}$</span>       </span> that assigns a set of fields to every object type and every interface type,<br/></li>       <li id="list2" label="&#x2022;"><span class="inline-equation"><span class="tex">${\it args}_{\mathcal {S}}:{\tt F}\rightarrow 2^{{\tt A}}$</span>       </span> that assigns a set of arguments to every field,<br/></li>       <li id="list3" label="&#x2022;"><span class="inline-equation"><span class="tex">${\it type}_{\mathcal {S}}:{\tt F}\cup {\tt A}\rightarrow {\tt T}\cup {\tt L}_{\tt T}$</span>       </span> that assigns a type or a list type to every field and argument, where<br/>arguments are assigned scalar types; i.e., <span class="inline-equation"><span class="tex">${\it type}_{\mathcal {S}}({\tt a})\in {\tt Scalars}$</span>       </span> for all <span class="inline-equation"><span class="tex">${\tt a}\in {\tt A}$</span>       </span>,<br/></li>       <li id="list4" label="&#x2022;"><span class="inline-equation"><span class="tex">${\it union}_{\mathcal {S}}:{\tt U}_{\tt T}\rightarrow 2^{{\tt O}_{\tt T}}$</span>       </span> that assigns a nonempty set of object types to every union type,<br/></li>       <li id="list5" label="&#x2022;"><span class="inline-equation"><span class="tex">${\it implementation}_{\mathcal {S}}:{\tt I}_{\tt T}\rightarrow 2^{{\tt O}_{\tt T}}$</span>       </span> that assigns a set of object types to every interface.<br/></li>      </ul>     </p>     <p>Additionally, <span class="inline-equation"><span class="tex">${\mathcal {S}}$</span>      </span> contains a distinguished type <span class="inline-equation"><span class="tex">${\it root}_{\mathcal {S}}\in {\tt O}_{\tt T}$</span>      </span> called the (query) <em>root type</em>.</p>    </div>    <p>To avoid an overly complex formalization, our definition of a GraphQL schema does not capture the additional notions of <em>input types</em>&#x00A0;(cf. <font style="normal">&#x0024;</font>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0005">5</a>]) and <em>non-null types</em>&#x00A0;(cf. <font style="normal">&#x0024;</font>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0005">5</a>]). Moreover, since we are mostly interested in queries, we do not consider <em>mutation types</em>&#x00A0;(<font style="normal">&#x0024;</font>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0005">5</a>]). A GraphQL schema is <em>consistent</em> if every object type that implements an interface type&#x00A0;<span class="inline-equation"><span class="tex">${\tt i}$</span>     </span> defines at least all the fields that <span class="inline-equation"><span class="tex">${\tt i}$</span>     </span> defines. Formally, <span class="inline-equation"><span class="tex">${\mathcal {S}}$</span>     </span> is consistent if <span class="inline-equation"><span class="tex">${\it fields}_{\mathcal {S}}({\tt i})\subseteq {\it fields}_{\mathcal {S}}({\tt t})$</span>     </span> for every <span class="inline-equation"><span class="tex">${\tt t}\in {\it implementation}_{\mathcal {S}}({\tt i})$</span></span>. We assume that all GraphQL schemas in this paper are consistent. <figure id="fig2">      <img src="http://deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-fig2.jpg" class="img-responsive" alt="Figure 2"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 2:</span>       <span class="figure-title">Example GraphQL 			 schema in its original syntax.</span>      </div>     </figure>    </p>    <div class="example" id="enc2">     <Label>Example 2.2.</Label>     <p> Figure&#x00A0;<a class="fig" href="#fig2">2</a> illustrates a GraphQL schema for data about Star Wars movies in the original syntax&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"       href="#BibPLXBIB0005">5</a>]. This a simplified version of the schema used in one of the official learning resources for GraphQL (see <a class="link-inline force-break" href="http://graphql.org/learn/schema/">http://graphql.org/learn/schema/</a>). In terms of our formalization, we have a schema <span class="inline-equation"><span class="tex">${\mathcal {S}}$</span>      </span> over <span class="inline-equation"><span class="tex">$({\tt F},{\tt A},{\tt T})$</span>      </span>&#x00A0;with <div class="table-responsive">       <div class="display-equation">       <span class="tex mytex">\begin{align*} {\tt F}&#x0026;= \lbrace {\tt id}, {\tt name}, {\tt length}, {\tt friends}, {\tt primaryFunction},{\tt starships}, \\[-1mm] &#x0026;\phantom{= \lbrace \ } {\tt hero}, {\tt search} \rbrace , \\[0mm] {\tt A}&#x0026;= \lbrace {\tt episode}, {\tt text}\rbrace , \text{ \; and \; } \; {\tt T}= {\tt O}_{\tt T}\cup {\tt I}_{\tt T}\cup {\tt U}_{\tt T}\cup {\tt Scalars}\text{ \, such that}\end{align*} </span>       <br/>       </div>      </div>      <div class="table-responsive">       <div class="display-equation">       <span class="tex mytex">\begin{align*} {\tt I}_{\tt T}&#x0026; = \lbrace {\tt Character}\rbrace , \; \; \; \; \; {\tt U}_{\tt T}= \lbrace {\tt SearchResult}\rbrace , \\ {\tt O}_{\tt T}&#x0026; = \lbrace {\tt Starship}, {\tt Droid}, {\tt Human}, {\tt Query}\rbrace , \\ {\tt Scalars}&#x0026; = \lbrace {\tt ID},{\tt String},{\tt Float}, {\tt Episode}\rbrace .\end{align*} </span>       <br/>       </div>      </div> As we can see in Figure&#x00A0;<a class="fig" href="#fig2">2</a>, in the original syntax, object types are defined using the keyword <span class="inline-equation"><span class="tex">${\tt type}$</span>      </span>, and interface and union types with keywords <span class="inline-equation"><span class="tex">${\tt interface}$</span>      </span> and <span class="inline-equation"><span class="tex">${\tt union}$</span>      </span>, respectively. The values for the scalar types are implicit in their names&#x00A0;(<span class="inline-equation"><span class="tex">${\tt String}, {\tt Float}$</span>      </span>) except for <span class="inline-equation"><span class="tex">${\tt ID}$</span>      </span> which is a special type used for unique identifiers&#x00A0; (cf. <font style="normal">&#x0024;</font>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"       href="#BibPLXBIB0005">5</a>]), and <span class="inline-equation"><span class="tex">${\tt Episodes}$</span>      </span> which is an <em>enum type</em> such that <span class="inline-equation"><span class="tex">${\it values}({\tt Episodes})=\lbrace {\tt NEWHOPE}, {\tt EMPIRE}, {\tt JEDI}\rbrace$</span></span>. Regarding the functions that compose <span class="inline-equation"><span class="tex">${\mathcal {S}}$</span>      </span> we have that <span class="inline-equation"><span class="tex">${\it fields}_{\mathcal {S}}$</span>      </span> defines the assignments: <div class="table-responsive">       <div class="display-equation">       <span class="tex mytex">\begin{align*} {\tt Starship} &#x0026;\rightarrow \lbrace {\tt id}, {\tt name}, {\tt length}\rbrace ,\\ {\tt Character} &#x0026;\rightarrow \lbrace {\tt id}, {\tt name}, {\tt friends}\rbrace , \\ {\tt Droid} &#x0026;\rightarrow \lbrace {\tt id}, {\tt name}, {\tt friends}, {\tt primaryFunction}\rbrace ,\\ {\tt Human} &#x0026;\rightarrow \lbrace {\tt id}, {\tt name}, {\tt friends}, {\tt starships}\rbrace ,\\ {\tt Query} &#x0026;\rightarrow \lbrace {\tt hero}, {\tt search}\rbrace ,\end{align*} </span>       <br/>       </div>      </div> function <span class="inline-equation"><span class="tex">${\it args}_{\mathcal {S}}$</span>      </span> defines the assignments: <div class="table-responsive">       <div class="display-equation">       <span class="tex mytex">\[ \begin{array}{rclcrcl}\tt hero &#x0026; \rightarrow &#x0026; \lbrace {\tt episode}\rbrace , &#x0026;&#x0026; {\tt search} &#x0026; \rightarrow &#x0026; \lbrace {\tt text}\rbrace ,\\ \end{array} \] </span>       <br/>       </div>      </div> and <span class="inline-equation"><span class="tex">${\it type}_{\mathcal {S}}$</span>      </span> defines the assignments: <div class="table-responsive">       <div class="display-equation">       <span class="tex mytex">\[ \begin{array}{rclrcl}\tt id &#x0026; \rightarrow &#x0026; {\tt ID}, &#x0026; {\tt friends} &#x0026; \rightarrow &#x0026; [{\tt Character}],\\ {\tt name} &#x0026; \rightarrow &#x0026; {\tt String},&#x0026; {\tt starships}&#x0026; \rightarrow &#x0026; {\tt [Starship]}, \\ {\tt length}&#x0026; \rightarrow &#x0026; {\tt Float},&#x0026; {\tt primaryFunction}&#x0026; \rightarrow &#x0026; {\tt String}\\ {\tt episode}&#x0026; \rightarrow &#x0026; {\tt Episode},&#x0026; {\tt hero}&#x0026; \rightarrow &#x0026; {\tt Character},\\ {\tt text}&#x0026; \rightarrow &#x0026; {\tt String},&#x0026; {\tt search}&#x0026; \rightarrow &#x0026; {\tt [SearchResult]}.\\ \end{array} \] </span>       <br/>       </div>      </div>     </p>     <p>The interface and union types are given as follows: <div class="table-responsive">       <div class="display-equation">       <span class="tex mytex">\begin{align*} {\it implementation}_{\mathcal {S}}({\tt Character})&#x0026;=\lbrace {\tt Human}, {\tt Droid}\rbrace ,\\ {} [-1mm] {\it union}_{\mathcal {S}}({\tt SearchResult})&#x0026;=\lbrace {\tt Human}, {\tt Droid}, {\tt Starship}\rbrace .\end{align*} </span>       <br/>       </div>      </div> Finally the root type is defined as <span class="inline-equation"><span class="tex">${\it root}_{\mathcal {S}}={\tt Query}$</span></span>. In Figure&#x00A0;<a class="fig" href="#fig2">2</a> this is defined as the type of the <span class="inline-equation"><span class="tex">${\tt query}$</span>      </span> field under a special <span class="inline-equation"><span class="tex">${\tt schema}$</span>      </span> type.</p>    </div>    </section>    <section id="sec-6">    <header>     <div class="title-info">      <h3>       <span class="section-number">2.2</span> GraphQL Graphs</h3>     </div>    </header>    <p>We now define the notion of a GraphQL graph by using the aforementioned domain&#x00A0;<span class="inline-equation"><span class="tex">$({\tt F},{\tt A},{\tt T})$</span></span>. Informally, a GraphQL graph is a directed, 		 edge-labeled multigraph. Each node in the graph is associated with an object type from&#x00A0;<span class="inline-equation"><span class="tex">${\tt O}_{\tt T}$</span>     </span> and a set of properties&#x00A0;(key-value pairs). The key names of these properties, as well as the edge labels, consist of a field name from&#x00A0;<span class="inline-equation"><span class="tex">${\tt F}$</span>     </span> and a (possibly empty) set of arguments, 		 where such an argument is a pair consisting of an argument name from <span class="inline-equation"><span class="tex">${\tt A}$</span>     </span> and a corresponding value. The value of 		 each node property is either a single scalar value or a sequence of scalars. Formally, we define the notion of a GraphQL graph as&#x00A0;follows.</p>    <div class="definition" id="enc3">     <Label>Definition 2.3.</Label>     <p> A <em>GraphQL graph</em>, or simply <em>graph</em>, over <span class="inline-equation"><span class="tex">$({\tt F},{\tt A},{\tt T})$</span>      </span> is a tuple <em>G</em> = (<em>N</em>, <em>E</em>, <em>&#x03C4;</em>, <em>&#x03BB;</em>, <em>r</em>) with the following elements:</p>     <p>      <ul class="list-no-style">       <li id="list6" label="&#x2022;"><em>N</em> is a set of nodes,<br/></li>       <li id="list7" label="&#x2022;"><em>E</em> is a set of edges of the form <span class="inline-equation"><span class="tex">$(u, {\tt f}[\alpha ], v)$</span>       </span> where <em>u</em>, <em>v</em> &#x2208; <em>N</em>, <span class="inline-equation"><span class="tex">${\tt f}\in {\tt F}$</span>       </span>, and <em>&#x03B1;</em> is a partial mapping from <span class="inline-equation"><span class="tex">${\tt A}$</span>       </span> to <span class="inline-equation"><span class="tex">${\tt Vals}$</span>       </span>,<br/></li>       <li id="list8" label="&#x2022;"><span class="inline-equation"><span class="tex">$\tau :N\rightarrow {\tt O}_{\tt T}$</span>       </span> is a function that assigns a type to every node,<br/></li>       <li id="list9" label="&#x2022;"><em>&#x03BB;</em> is a partial function that assigns a scalar value <span class="inline-equation"><span class="tex">${\tt v} \in {\tt Vals}$</span>       </span> or a sequence <span class="inline-equation"><span class="tex">${\tt [v}_1 \cdots {\tt v}_n{\tt ]}$</span>       </span> of scalar values&#x00A0;(<span class="inline-equation"><span class="tex">${\tt v}_i \in {\tt Vals}$</span>       </span>) to some pairs of the form <span class="inline-equation"><span class="tex">$(u, {\tt f}[\alpha ])$</span>       </span> where <em>u</em> &#x2208; <em>N</em>, <span class="inline-equation"><span class="tex">${\tt f}\in {\tt F}$</span>       </span>, and <em>&#x03B1;</em> is a partial mapping from <span class="inline-equation"><span class="tex">${\tt A}$</span>       </span> to <span class="inline-equation"><span class="tex">${\tt Vals}$</span>       </span>,<br/></li>       <li id="list10" label="&#x2022;"><em>r</em> &#x2208; <em>N</em> is a distinguished node called the <em>root</em> node.<br/></li>      </ul>     </p>    </div>    <figure id="fig3">     <img src="http://deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-fig3.jpg" class="img-responsive" alt="Figure 3"      longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 3:</span>      <span class="figure-title">Example GraphQL graph.</span>     </div>    </figure>    <div class="example" id="enc4">     <Label>Example 2.4.</Label>     <p> Figure&#x00A0;<a class="fig" href="#fig3">3</a> illustrates a graph <em>G</em> = (<em>N</em>, <em>E</em>, <em>&#x03C4;</em>, <em>&#x03BB;</em>, <em>r</em>) over the domain <span class="inline-equation"><span class="tex">$({\tt F}, {\tt A}, {\tt T})$</span>      </span> as given in Example&#x00A0;<a class="enc" href="#enc2">2.2</a>. <em>G</em> is a simplified version of the graph used in one of the official learning resources for GraphQL (see <a class="link-inline force-break" href="http://graphql.org/learn/schema/">http://graphql.org/learn/schema/</a>). In this case we have <em>N</em> = {<em>r</em>, <em>u</em>, <em>v</em>, <em>w</em>, <em>x</em>} and <em>E</em> contains several edges, including edges <span class="inline-equation"><span class="tex">$(r, {\tt hero[epsiode:EMPIRE]}, u)$</span>      </span> and <span class="inline-equation"><span class="tex">$(u, {\tt friends}, w)$</span></span>. The type assignment <em>&#x03C4;</em> is depicted inside every node. For instance <span class="inline-equation"><span class="tex">$\tau (v)={\tt Droid}$</span></span>. Function <em>&#x03BB;</em> is shown as a box beside every node. For instance <span class="inline-equation"><span class="tex">$\lambda (w,{\tt name})={\tt Han}$</span>      </span>, and <span class="inline-equation"><span class="tex">$\lambda (x,{\tt length})={\tt 34.37}$</span></span>.</p>    </div>    <p>Observe that Definition&#x00A0;<a class="enc" 	  href="#enc3">2.3</a> introduces the notion of a GraphQL graph independent of any particular GraphQL schema. However, for the purpose of defining queries over such a graph, the graph is assumed to conform to a given schema. Informally, the conditions of conformance to a schema <span class="inline-equation"><span class="tex">${\mathcal {S}}$</span>     </span> imposes on a graph <em>G</em> are summarized as follows: For every edge <span class="inline-equation"><span class="tex">$(u, {\tt f}[\alpha ], v)$</span>     </span>, field <span class="inline-equation"><span class="tex">${\tt f}$</span>     </span> is among the field names for the type of <em>u</em> (<span class="inline-equation"><span class="tex">${\tt f}\in {\it fields}_{\mathcal {S}}(\tau (u))$</span>     </span>). The type that <span class="inline-equation"><span class="tex">${\mathcal {S}}$</span>     </span> associates with <span class="inline-equation"><span class="tex">${\tt f}$</span>     </span> must match the type of <em>v</em> (<span class="inline-equation"><span class="tex">${\it type}_{\mathcal {S}}({\tt f})=\tau (v)$</span>     </span>, or <span class="inline-equation"><span class="tex">$\tau (v)\in {\it implementation}_{\mathcal {S}}({\it type}_{\mathcal {S}}({\tt f}))$</span>     </span>, or <span class="inline-equation"><span class="tex">$\tau (v)\in {\it union}_{\mathcal {S}}({\it type}_{\mathcal {S}}({\tt f}))$</span>     </span>), and if this type is not a list type, then <em>v</em> is the only node connected to <em>u</em> by an edge with label <span class="inline-equation"><span class="tex">${\tt f}[\alpha ]$</span></span>. Moreover, for every argument map <span class="inline-equation"><span class="tex">${\tt a:v}$</span>     </span> in <em>&#x03B1;</em>, argument name <span class="inline-equation"><span class="tex">${\tt a}$</span>     </span> must be among the arguments that <span class="inline-equation"><span class="tex">${\mathcal {S}}$</span>     </span> associates with <span class="inline-equation"><span class="tex">${\tt f}$</span>     </span> (<span class="inline-equation"><span class="tex">${\tt a}\in {\it args}_{\mathcal {S}}({\tt f})$</span>     </span>), and value <span class="inline-equation"><span class="tex">${\tt v}$</span>     </span> must be of the type associated with <span class="inline-equation"><span class="tex">${\tt a}$</span>     </span> (<span class="inline-equation"><span class="tex">${\tt v}\in {\it values}({\it type}_{\mathcal {S}}({\tt a}))$</span></span>. In addition to these conditions for the edges in <em>E</em>, there exist similar conditions for the node properties defined by function <em>&#x03BB;</em>. Finally, the type of the root node should be the root type of <span class="inline-equation"><span class="tex">${\mathcal {S}}$</span>     </span> (<span class="inline-equation"><span class="tex">$\tau (r)={\it root}_{\mathcal {S}}$</span>     </span>). With these intuitions, one can see that the graph in Example&#x00A0;<a class="enc" href="#enc4">2.4</a> conforms to the schema described in Example&#x00A0;<a class="enc" href="#enc2">2.2</a>. Providing a detailed definition of these conditions is straightforward. Due to space limitations, we omit the definition in this paper. Finally, the size of graph <em>G</em>, denoted by |<em>G</em>|, is the total number of edges and node properties in <em>G</em>.</p>    <p>We emphasize that our notion of a GraphQL graph is mostly a logical construct needed to base our work on a well-defined foundation. In practice, GraphQL interfaces typically provide access to an underlying database which may be stored using relational technology or in a NoSQL system. The actual data exposed via such an interface can be conceived of as graph-based view of the underlying database. GraphQL graphs are an abstraction of such views that allows us to formalize and study the GraphQL language independent of the technologies used to implement GraphQL interfaces.</p>    </section>   </section>   <section id="sec-7">    <header>    <div class="title-info">     <h2>      <span class="section-number">3</span> GraphQL Language</h2>    </div>    </header>    <p>In this section we provide a formal definition of the GraphQL query language, defining its syntax and semantics over the data model that we introduced in the previous section. Before going into the formal definitions, we give some intuition of the expressions based on which GraphQL queries may be constructed and how these expressions are evaluated. The most basic construction are expressions of the form <span class="inline-equation"><span class="tex">${\tt f} {\tt [} \alpha {\tt ]}$</span>    </span>&#x00A0;(cf. <font style="normal">&#x0024;</font>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0005">5</a>]). Informally, when evaluated over a graph, such an expression can be used to match node properties whose name has the same form. Then, assuming the value of the property is a scalar value <span class="inline-equation"><span class="tex">${\tt v}$</span>    </span>, the result of the evaluation is a string of the form <span class="inline-equation"><span class="tex">${\tt f} {\tt :} {\tt v}$</span></span>. An alternative to the construction <span class="inline-equation"><span class="tex">${\tt f} {\tt [} \alpha {\tt ]}$</span>    </span> is <span class="inline-equation"><span class="tex">$\ell {\tt :} {\tt f} {\tt [} \alpha {\tt ]}$</span>    </span> which captures the notion of <em>&#x201C;field aliases&#x201D;</em>&#x00A0;(cf. <font style="normal">&#x0024;</font>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0005">5</a>]). Such aliases can be 	  used to rename the field names that appear in the query result. To match edges, expressions of the form <span class="inline-equation"><span class="tex">${\tt f} {\tt [} \alpha {\tt ]{} \varphi {\tt }}$</span>    </span> can be used, where &#x03D5; is a subquery to be evaluated in the context of the target nodes. Then, for the case of a single matching edge, the result is a string of the form <span class="inline-equation"><span class="tex">${\tt f} {\tt :{} \rho {\tt }}$</span>    </span> with&#x00A0;<em>&#x03C1;</em> being the string resulting from the evaluation of the subquery &#x03D5;. On the other hand, if the number of matching edges may be greater than one&#x00A0;(which may be the case if the type associated with field&#x00A0;<span class="inline-equation"><span class="tex">${\tt f}$</span>    </span> is a list type), then the result string is of the form <span class="inline-equation"><span class="tex">${\tt f} {\tt :[{} \rho _1 {\tt }} \cdots {\tt {} \rho _n {\tt }]}$</span></span>. Expressions of the form <span class="inline-equation"><span class="tex">${\tt f} {\tt [} \alpha {\tt ]{} \varphi {\tt }}$</span>    </span> can also be prefixed with a field alias: <span class="inline-equation"><span class="tex">$\ell {\tt :} {\tt f} {\tt [} \alpha {\tt ]{} \varphi {\tt }}$</span></span>.</p>    <p>Our query syntax introduces two more constructions: <span class="inline-equation"><span class="tex">${\tt on}\; {\tt t} {\tt {} \varphi {\tt }}$</span>    </span> and &#x03D5;<sub>1</sub>&#x22C5;&#x22C5;&#x22C5;&#x03D5;<sub>     <em>n</em>    </sub>. While the latter is simply an enumeration of multiple subexpressions whose results are meant to be concatenated, the former captures the notion of a <em>&#x201C;type condition&#x201D;</em> that is given by what the GraphQL specification refers to as an <em>&#x201C;inline fragment&#x201D;</em>&#x00A0;(cf. <font style="normal">&#x0024;</font>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0005">5</a>]). Hence, <span class="inline-equation"><span class="tex">${\tt t}$</span>    </span> is either an object type, an interface type, or a union type, and &#x03D5; is a subquery to be evaluated only for nodes whose associated type is compatible with <span class="inline-equation"><span class="tex">${\tt t}$</span></span>.</p>    <p>Readers who are familiar with the query syntax 	  introduced in the GraphQL specification may notice 	  that we do not capture a number of additional language features, namely, (non-inline) <em>&#x201C;fragments&#x201D;</em>&#x00A0;(<font style="normal">&#x0024;</font>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0005">5</a>]), <em>&#x201C;variables&#x201D;</em>&#x00A0;(<font style="normal">&#x0024;</font>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0005">5</a>]), and <em>&#x201C;directives&#x201D;</em>&#x00A0;(<font style="normal">&#x0024;</font>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0005">5</a>]). We emphasize that 	  these features are merely syntactic sugar that a query parser may resolve by using the features captured in the presented&#x00A0;syntax. The following definition formalizes our syntax of GraphQL queries.</p>    <p>    <div class="definition" id="enc5">     <Label>Definition 3.1.</Label>     <p> A <em>GraphQL query</em>, or simply <em>query</em>, over <span class="inline-equation"><span class="tex">$({\tt F},{\tt A},{\tt T})$</span>      </span> is an expression&#x00A0;&#x03D5; 		  constructed from the following grammar where <span class="inline-equation"><span class="tex">${\tt [, ]}$</span>, 		  <span class="inline-equation"><span class="tex">${\tt 			\{, \}}$</span>      </span>, <span class="inline-equation"><span class="tex">${\tt :}$</span></span>, and <span class="inline-equation"><span class="tex">${\tt on}$</span>      </span> are terminal symbols, <span class="inline-equation"><span class="tex">${\tt t}\in {\tt O}_{\tt T}\cup {\tt I}_{\tt T}\cup {\tt U}_{\tt T}$</span>      </span>, <span class="inline-equation"><span class="tex">${\tt f}\in {\tt F}$</span>      </span>, <span class="inline-equation"><span class="tex">$\ell \in {\tt Fields}$</span>      </span>, and <em>&#x03B1;</em> represents a partial mapping from <span class="inline-equation"><span class="tex">${\tt A}$</span>      </span> to <span class="inline-equation"><span class="tex">${\tt Vals}$</span></span>. <div class="table-responsive">       <div class="display-equation">       <span class="tex mytex">\[ \begin{array}{rccccccccccccc}\varphi &#x0026; ::= \;\; &#x0026; {\tt f} {\tt [} \alpha {\tt ]} &#x0026;\;\; \mid \;\; &#x0026; \ell {\tt :} {\tt f} {\tt [} \alpha {\tt ]} &#x0026;\;\; \mid \;\; &#x0026; {\tt on}\; {\tt t} {\tt {} \varphi {\tt }} &#x0026; \;\; \mid \;\; &#x0026; \\ &#x0026; &#x0026; {\tt f} {\tt [} \alpha {\tt ]{} \varphi {\tt }} &#x0026; \;\; \mid \;\; &#x0026; \ell {\tt :} {\tt f} {\tt [} \alpha {\tt ]{} \varphi {\tt }} &#x0026; \;\; \mid \;\; &#x0026; \varphi \cdots \varphi &#x0026; \end{array} \] </span>       <br/>       </div>      </div>     </p>    </div>    </p>    <p>For the sake of conciseness&#x00A0;(and in correspondence with the original GraphQL syntax), for sub-expressions of the form <span class="inline-equation"><span class="tex">${\tt f} {\tt [} \alpha {\tt ]}$</span>    </span> with <em>&#x03B1;</em> the empty mapping, we just write&#x00A0;<span class="inline-equation"><span class="tex">${\tt f}$</span></span>. Figure&#x00A0;<a class="fig" href="#fig4">4</a>&#x00A0;(left) shows an example GraphQL query over the domain <span class="inline-equation"><span class="tex">$({\tt F},{\tt A},{\tt T})$</span>    </span> in Example&#x00A0;<a class="enc" href="#enc2">2.2</a>. <figure id="fig4">     <img src="http://deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-fig4.jpg" class="img-responsive" alt="Figure 4"      longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 4:</span>      <span class="figure-title">GraphQL query (left) 			and response object (right).</span>     </div>    </figure>    </p>    <p>In the GraphQL specification&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0005">5</a>], queries begin with the optional keyword <span class="inline-equation"><span class="tex">$\mathtt {query}$</span>    </span> followed by an expression as the one introduced in Definition&#x00A0;<a class="enc" href="#enc5">3.1</a>. That is, the query in Figure&#x00A0;<a class="fig" href="#fig4">4</a>&#x00A0;(left) is written as <span class="inline-equation"><span class="tex">$\mathtt {query}\mathtt {\lbrace } \mathtt {hero}\mathtt {[} \mathtt {episode}\texttt {:}\mathtt {EMPIRE}\mathtt {]}\mathtt {\lbrace }\cdots \mathtt { \rbrace }\mathtt { \rbrace }$</span>    </span> (see also Fig.&#x00A0;<a class="fig" href="#fig1">1</a>). We dropped the <span class="inline-equation"><span class="tex">$\mathtt {query}$</span>    </span> keyword to have a simpler recursive syntax.</p>    <p>A notion that we shall use heavily is the size of a query &#x03D5;, denoted by |&#x03D5;|, that we define as the number of field selections and types occurring in &#x03D5;. This can be formally defined by recursion as follows:</p>    <ul class="list-no-style">    <li id="list11" label="&#x2022;"><span class="inline-equation"><span class="tex">$|{\tt f} {\tt [} \alpha {\tt ]}|=|\ell {\tt :} {\tt f} {\tt [} \alpha {\tt ]}|=1$</span>     </span>     <br/></li>    <li id="list12" label="&#x2022;"><span class="inline-equation"><span class="tex">$|{\tt on}\; {\tt t} {\tt {} \varphi {\tt }}|=|{\tt f} {\tt [} \alpha {\tt ]{} \varphi {\tt }}| = |\ell {\tt :} {\tt f} {\tt [} \alpha {\tt ]{} \varphi {\tt }}| = 1 + |\varphi |$</span>     </span>     <br/></li>    <li id="list13" label="&#x2022;">|&#x03D5;<sub>1</sub>&#x03D5;<sub>2</sub>&#x22C5;&#x22C5;&#x22C5;&#x03D5;<sub>      <em>k</em>     </sub>| = |&#x03D5;<sub>1</sub>| + |&#x03D5;<sub>2</sub>| + &#x22C5;&#x22C5;&#x22C5; + |&#x03D5;<sub>      <em>k</em>     </sub>|<br/></li>    </ul>    <p>For instance, the query in Figure&#x00A0;<a class="fig" href="#fig4">4</a>&#x00A0;(left) has size 11.</p>    <p>As for the case of GraphQL graphs, there is a notion of whether a query conforms to a schema <span class="inline-equation"><span class="tex">${\mathcal {S}}$</span></span>. For instance, if a query begins with an expression of the form <span class="inline-equation"><span class="tex">${\tt f}{\tt {}{\tt g}{\tt {} \varphi {\tt }}}$</span>    </span>, then <span class="inline-equation"><span class="tex">${\tt f}$</span>    </span> must be a field of the root type in <span class="inline-equation"><span class="tex">${\mathcal {S}}$</span>    </span> (<span class="inline-equation"><span class="tex">${\tt f}\in {\it fields}_{\mathcal {S}}({\it root}_{\mathcal {S}})$</span>    </span>), <span class="inline-equation"><span class="tex">${\tt g}$</span>    </span> must be a field of the type assigned to <span class="inline-equation"><span class="tex">${\tt f}$</span>    </span> (<span class="inline-equation"><span class="tex">${\tt g}\in {\it fields}_{\mathcal {S}}({\it type}_{\mathcal {S}}({\tt f}))$</span>    </span>), and so on. Due to space limitations we do not include all the formal requirements here, but they are as straightforward to define as for the case of queries.</p>    <p>As a last preliminary for formalizing the semantics of GraphQL queries we require a definition of the notion of a result that a GraphQL query may return.</p>    <p>    <div class="definition" id="enc6">     <Label>Definition 3.2.</Label>     <p> A <em>GraphQL response object</em> is an 		  expression&#x00A0;<em>&#x03C1;</em> constructed 		  from the following grammar where 		  <span class="inline-equation"><span class="tex">${\tt \{, \}}$</span>, <span class="inline-equation"><span class="tex">${\tt [, ]}$</span>, <span class="inline-equation"><span class="tex">${\tt :}$</span></span>, and <span class="inline-equation"><span class="tex">$\mathtt {null}$</span>      </span> are terminal symbols, &#x025B; denotes the empty word, <span class="inline-equation"><span class="tex">$\ell \in {\tt Fields}$</span>      </span>, and <span class="inline-equation"><span class="tex">${\tt v}, {\tt v}_1, \,...\,, {\tt v}_n \in {\tt Vals}$</span>      </span>: <div class="table-responsive">       <div class="display-equation">       <span class="tex mytex">\[ \begin{array}{rcccccccccccccccccccc}\rho &#x0026; ::= \; &#x0026; \ell {\tt :} {\tt v} &#x0026; \; \mid \; &#x0026; \ell {\tt :[} {\tt v}_1 \cdots {\tt v}_n {\tt ]} &#x0026; \; \mid \; &#x0026; \ell {\tt :} {\tt null} &#x0026; \; \mid \; \\ &#x0026;&#x0026; \ell {\tt :{} \rho {\tt }} &#x0026; \; \mid \; &#x0026; \ell {\tt :[{} \rho {\tt }} \cdots {\tt {} \rho {\tt }]} &#x0026; \; \mid \; &#x0026; \rho \cdots \rho &#x0026; \; \mid \; &#x0026; \varepsilon \\ \end{array} \] </span>       <br/>       </div>      </div>     </p>    </div>    </p>    <p>Figure&#x00A0;<a class="fig" 	 href="#fig4">4</a>&#x00A0;(right) shows an example response object. Such objects are strings over alphabet <span class="inline-equation"><span class="tex">$\Sigma ={\tt Fields}\cup {\tt Vals}\cup \lbrace {\tt {}, {\tt }}, {\tt [}, {\tt ]}, {\tt :}, \mathtt {null}\rbrace$</span>    </span>, and thus we can define the size of a response object <em>&#x03C1;</em>, denoted by |<em>&#x03C1;</em>|, simply as the number of symbols of <em>&#x03A3;</em> occurring in <em>&#x03C1;</em>. For instance, the size of the response object in Figure&#x00A0;<a class="fig" href="#fig4">4</a> is 36. Similarly as for the case of queries, response objects in the official specification begin with the keyword <span class="inline-equation"><span class="tex">$\mathtt {data}$</span>    </span> (see Fig.&#x00A0;<a class="fig" href="#fig1">1</a>(b)). We have also dropped that keyword to have a simpler syntax.</p>    <p>As a final note on the syntax of queries and response objects, notice that both have a <em>tree structure</em>. Thus, one can intuitively talk, for example, about <em>root</em> or <em>leaf</em> fields of a query or a response object, or even about <em>children</em> of a field in a query.</p>    <section id="sec-8">        <section id="sec-9">     <p><em>Field collection.</em> Before going into the semantics we need the additional notion of <em>collecting fields</em> (cf. <font style="normal">&#x0024;</font>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"       href="#BibPLXBIB0005">5</a>]). The main idea is that repeated fields in a query/response should not be considered twice. For instance, a GraphQL query will never result in a response object of the following form: <div class="table-responsive">       <div class="display-equation">       <span class="tex mytex">\[ \mathtt {droid}\mathtt {:}\mathtt {\lbrace }\ \mathtt {name}\mathtt {:}{\tt C3PO}\ \mathtt { \rbrace }\;\; \mathtt {ship}\mathtt {:}\mathtt {\lbrace }\ \mathtt {length}\mathtt {:}\mathtt {30.0}\ \mathtt { \rbrace }\;\; \mathtt {droid}\mathtt {:}\mathtt {\lbrace }\ \mathtt {pF}\mathtt {:}\mathtt {Protocol}\ \mathtt { \rbrace }. \] </span>       <br/>       </div>      </div> Instead, if this is the data to be returned, the response object will&#x00A0;be: <div class="table-responsive">       <div class="display-equation">       <span class="tex mytex">\[ \mathtt {droid}\mathtt {:}\mathtt {\lbrace }\ \mathtt {name}\mathtt {:}{\tt C3PO}\;\; \mathtt {pF}\mathtt {:}\mathtt {Protocol} \mathtt { \rbrace }\;\; \mathtt {ship}\mathtt {:}\mathtt {\lbrace }\ \mathtt {length}\mathtt {:}\mathtt {30.0}\ \mathtt { \rbrace }. \] </span>       <br/>       </div>      </div> Notice how the two occurrences of the field <span class="inline-equation"><span class="tex">$\mathtt {droid}$</span>      </span> are merged collecting the subfields <span class="inline-equation"><span class="tex">$\mathtt {name}$</span>      </span> and <span class="inline-equation"><span class="tex">$\mathtt {pF}$</span>      </span> into a single group while maintaining their relative order. The example should clarify why this process is called field collection in the GraphQL specification. To formalize this we use a recursive function <span class="inline-equation"><span class="tex">$\operatorname{collect}(\cdot)$</span>      </span> over response objects. For the sake of space we do not include the details of this function, but it can be easily implemented as a recursive procedure over a response object following the intuition in the example above.</p>     <p>We are now ready to introduce the semantics of GraphQL queries. In what follows we always assume a fixed given schema <span class="inline-equation"><span class="tex">${\mathcal {S}}$</span>      </span>.</p>     <div class="definition" id="enc7">      <Label>Definition 3.3.</Label>      <p> Let <em>G</em> = (<em>N</em>, <em>E</em>, <em>&#x03C4;</em>, <em>&#x03BB;</em>, <em>r</em>) be a graph and &#x03D5; a query, both conforming to a schema <span class="inline-equation"><span class="tex">${\mathcal {S}}$</span>       </span> over <span class="inline-equation"><span class="tex">$({\tt F},{\tt A},{\tt T})$</span>       </span>. The <em>evaluation of&#x00A0;&#x03D5; over&#x00A0;<em>G</em> from node&#x00A0;<em>u</em> &#x2208; <em>N</em>       </em>, denoted by <span class="inline-equation"><span class="tex">$[[ \varphi ]] _G^u$</span>       </span>, is a GraphQL response object that is 			defined recursively as shown in Figure&#x00A0;<a class="fig" href="#fig5">5</a>. The <em>evaluation of &#x03D5; over <em>G</em>       </em>, denoted by <span class="inline-equation"><span class="tex">$[[ \varphi ]] _G$</span>       </span>, is simply <span class="inline-equation"><span class="tex">$[[ \varphi ]] _G^r.$</span>       </span> <figure id="fig5">       <img src="http://deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-fig5.jpg" class="img-responsive" alt="Figure 5"         longdesc=""/>       <div class="figure-caption">        <span class="figure-number">Figure 5:</span>        <span class="figure-title">Semantics of a GraphQL query.</span>       </div>       </figure>      </p>     </div>     <div class="example" id="enc8">      <Label>Example 3.4.</Label>      <p>For the GraphQL graph <em>G</em> in Example&#x00A0;<a class="enc" href="#enc4">2.4</a>, and the query &#x03D5; and response object <em>&#x03C1;</em> in Figure&#x00A0;<a class="fig" href="#fig4">4</a>, we have that <span class="inline-equation"><span class="tex">$\rho =[[ \varphi ]] _G$</span>       </span>.</p>     </div>    </section>    </section>    <section id="sec-10">    <header>     <div class="title-info">      <h3>Equivalences and normal forms</h3>     </div>    </header>    <p>Let &#x03D5;<sub>1</sub> and &#x03D5;<sub>2</sub> be queries that conform to a schema <span class="inline-equation"><span class="tex">${\mathcal {S}}$</span>     </span>. We say that &#x03D5;<sub>1</sub> and &#x03D5;<sub>2</sub> are equivalent, denoted by &#x03D5;<sub>1</sub> &#x2261; &#x03D5;<sub>2</sub>, if for every graph <em>G</em> that conforms to <span class="inline-equation"><span class="tex">${\mathcal {S}}$</span>     </span> it holds that <span class="inline-equation"><span class="tex">$[[ \varphi _1]] _G=[[ \varphi _2]] _G$</span>     </span>. We need two additional notions that shall be useful for algorithms and complexity analysis.</p>    <div class="definition" id="enc9">     <Label>Definition 3.5.</Label>     <p> A GraphQL query &#x03D5; is in <em>ground-typed normal form</em> if it satisfies the following grammar, where <span class="inline-equation"><span class="tex">$\mathtt {t}\in \mathtt {O_T}$</span>      </span>. <div class="table-responsive">       <div class="display-equation">       <span class="tex mytex">\[ \begin{array}{rcl}\varphi &#x0026; ::= \;\; &#x0026; \psi \cdots \psi \;\; \mid \;\; \chi \cdots \chi \\ \psi &#x0026; ::= \;\; &#x0026; {\tt on}\; {\tt t}\ {\tt {}\ \chi \cdots \chi \ {\tt }} \\ \chi &#x0026; ::= \;\; &#x0026; {\tt f} {\tt [} \alpha {\tt ]} \;\; \mid \;\; \ell \mathtt {:} {\tt f} {\tt [} \alpha {\tt ]} \;\; \mid \;\; {\tt f} {\tt [} \alpha {\tt ]{}\ \varphi \ {\tt }} \;\; \mid \;\; \ell \mathtt {:} {\tt f} {\tt [} \alpha {\tt ]{}\ \varphi \ {\tt }} \end{array} \] </span>       <br/>       </div>      </div>     </p>    </div>    <p>That is, intuitively, &#x03D5; is in <em>ground-typed normal form</em> if the following three conditions are satisfied: (1)&#x00A0;for every expression of the form <span class="inline-equation"><span class="tex">${\tt on}\, {\tt t}\ {\tt {}\ \,...\,\ {\tt }}$</span>     </span> that occurs in &#x03D5;, it holds that <span class="inline-equation"><span class="tex">$\mathtt {t}\in \mathtt {O_T}$</span>     </span>, (2)&#x00A0;expressions of the form <span class="inline-equation"><span class="tex">${\tt on}\, {\tt t}\ {\tt {}\ \,...\,\ {\tt }}$</span>     </span> do not occur mixed with regular field selections, and (3)&#x00A0;an expression <span class="inline-equation"><span class="tex">$\mathtt {on\, t^{\prime }}\ {\tt {}\ \,...\,\ {\tt }}$</span>     </span> does not occur immediately inside another <span class="inline-equation"><span class="tex">$\mathtt {on\, t}\ {\tt {}\ \,...\,\ {\tt }}$</span>     </span> expression. Finally, we introduce a notion that focuses on possible redundancy in GraphQL queries.</p>    <div class="definition" id="enc10">     <Label>Definition 3.6.</Label>     <p> A GraphQL query &#x03D5; is <em>non-redundant</em> if it satisfies the following condition. For every subexpression of &#x03D5; of the form &#x03D5;<sub>1</sub>&#x22C5;&#x22C5;&#x22C5;&#x03D5;<sub>       <em>k</em>      </sub> there are no indexes <em>i</em>, <em>j</em> &#x2208; {1,&#x2009;...&#x2009;, <em>k</em>} such that <em>i</em> &#x2260; <em>j</em> and</p>     <p>      <ul class="list-no-style">       <li id="list14" label="&#x2022;"><span class="inline-equation"><span class="tex">$\varphi _i=\varphi _j=\mathtt {f\mathtt {[}}\alpha \mathtt {]}$</span>       </span>, or<br/></li>       <li id="list15" label="&#x2022;"><span class="inline-equation"><span class="tex">$\varphi _i=\varphi _j=\ell \texttt {:}\mathtt {f\mathtt {[}}\alpha \mathtt {]}$</span>       </span>, or<br/></li>       <li id="list16" label="&#x2022;"><span class="inline-equation"><span class="tex">$\varphi _i=\mathtt {f\mathtt {[}}\alpha \mathtt {]}\mathtt {\lbrace } \beta \mathtt { \rbrace }$</span>       </span> and <span class="inline-equation"><span class="tex">$\varphi _j=\mathtt {f\mathtt {[}}\alpha \mathtt {]}\mathtt {\lbrace } \gamma \mathtt { \rbrace }$</span>       </span>, or<br/></li>       <li id="list17" label="&#x2022;"><span class="inline-equation"><span class="tex">$\varphi _i=\ell \texttt {:}\mathtt {f\mathtt {[}}\alpha \mathtt {]}\mathtt {\lbrace } \beta \mathtt { \rbrace }$</span>       </span> and <span class="inline-equation"><span class="tex">$\varphi _j=\ell \texttt {:}\mathtt {f\mathtt {[}}\alpha \mathtt {]}\mathtt {\lbrace } \gamma \mathtt { \rbrace }$</span>       </span>, or<br/></li>       <li id="list18" label="&#x2022;"><span class="inline-equation"><span class="tex">$\varphi _i=\mathtt {on\; t}\ \mathtt {\lbrace }\beta \mathtt { \rbrace }$</span>       </span> and <span class="inline-equation"><span class="tex">$\varphi _j=\mathtt {on\; t}\ \mathtt {\lbrace }\gamma \mathtt { \rbrace }$</span>       </span>.<br/></li>      </ul>     </p>    </div>    <div class="example" id="enc11">     <Label>Example 3.7.</Label>     <p> The query in Figure&#x00A0;<a class="fig" href="#fig4">4</a> is a non-redundant query in ground-typed normal form.</p>    </div>    <div class="theorem" id="enc12">     <Label>Theorem 3.8.</Label>     <p> For every query &#x03D5; that conforms to a schema <span class="inline-equation"><span class="tex">${\mathcal {S}}$</span>      </span> there exists a non-redundant query &#x03D5;&#x2032; in ground-typed normal form such that &#x03D5; &#x2261; &#x03D5;&#x2032;.</p>    </div>    <p>Theorem&#x00A0;<a class="enc" href="#enc12">3.8</a> 		 can be obtained by rewriting queries using equivalence rules. Due to space constraints, we cannot include these rules in this paper; we will provide them in the full version of the paper.</p>    <p>In the rest of the paper we assume that every GraphQL query is a non-redundant query in ground-typed normal form. One of the main properties of such queries is that they produce a unique response object without the need of the <span class="inline-equation"><span class="tex">$\operatorname{collect}(\cdot)$</span>     </span> operator. More formally, let &#x27E8;&#x27E8;&#x03D5;&#x27E9;&#x27E9;<sub>      <em>G</em>     </sub> be an evaluation function for queries defined in exactly the same way as <span class="inline-equation"><span class="tex">$[[ \varphi ]] _G$</span>     </span> in Definition&#x00A0;<a class="enc" href="#enc7">3.3</a> but replacing the last rule in Figure&#x00A0;<a class="fig" href="#fig5">5</a> by <span class="inline-equation"><span class="tex">$\langle \langle {\varphi _1\cdots \varphi _k}\rangle \rangle _G^u = \langle \langle {\varphi _1}\rangle \rangle _G^u\cdots \langle \langle {\varphi _k}\rangle \rangle _G^u$</span>     </span>, that is, without using <span class="inline-equation"><span class="tex">$\operatorname{collect}(\cdot)$</span>     </span>. It is not difficult to prove that if &#x03D5; is a non-redundant query in ground-typed normal form, then <span class="inline-equation"><span class="tex">$[[ \varphi ]] _G=\langle \langle \varphi \rangle \rangle _G$</span>     </span> for every graph <em>G</em>. We shall exploit this property in the next sections.</p>    </section>   </section>   <section id="sec-11">    <header>    <div class="title-info">     <h2>      <span class="section-number">4</span> The Complexity of GraphQL</h2>    </div>    </header>    <p>In this section we study the complexity of two 	  classical decision problems in the context of GraphQL, 	  namely, the evaluation problem and the enumeration problem, showing that both can be solved efficiently. For this analysis we make the following assumption: Let <em>G</em> be a GraphQL graph, <em>u</em> be a node, and <span class="inline-equation"><span class="tex">${\tt f[}\alpha {\tt ]}$</span>    </span> be an edge label. We assume that one can access the list of <span class="inline-equation"><span class="tex">${\tt f[}\alpha {\tt ]}$</span>    </span>-neighbors of <em>u</em> in time&#x00A0;<em>O</em>(1), and one can access the <span class="inline-equation"><span class="tex">${\tt f[}\alpha {\tt ]}$</span>    </span>-property of a node in 	  time&#x00A0;<em>O</em>(1). Although this is a standard assumption for graph databases in a RAM computational model, we stress that a GraphQL graph is usually implemented as a <em>view</em> over another data source and, thus, the time required to access neighbors and data may depend on the&#x00A0;underlying data storage. Our assumption allows us to study the two decision problems independent of implementation-specific peculiarities.</p>    <p>Classical query languages, such as SQL or Relational Algebra, take as inputs a query and a database and produce a set of tuples as output. For these languages the standard way of defining a decision problem is the following: given a query <em>Q</em>, a database <em>D</em>, and a candidate tuple <em>t</em>, check if <em>t</em> is part of the evaluation of <em>Q</em> over <em>D</em>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0021">21</a>]. In contrast to classical languages, the result of a GraphQL query is not a set of tuples but a single response object. To define a similar decision problem for GraphQL, we consider the data values occurring in response objects. For example, in the object <div class="table-responsive">     <div class="display-equation">      <span class="tex mytex">\[ \mathtt {droid}\mathtt {:}\mathtt {\lbrace }\ \mathtt {name}\mathtt {:}{\tt C3PO}\;\; \mathtt {pF}\mathtt {:}\mathtt {Protocol} \mathtt { \rbrace }\;\; \mathtt {ship}\mathtt {:}\mathtt {\lbrace }\ \mathtt {length}\mathtt {:}\mathtt {30.0}\ \mathtt { \rbrace } \] </span>      <br/>     </div>    </div> the values that occur are <span class="inline-equation"><span class="tex">$\texttt {C3PO}$</span>    </span>, <span class="inline-equation"><span class="tex">$\texttt {Protocol}$</span>    </span> and <span class="inline-equation"><span class="tex">$\texttt {30.0}$</span></span>. Formally, we define the following decision problem.</p>    <div class="table-responsive" id="inltbl1">    <table class="table">     <thead>      <tr>       <th style="text-align:right;">Problem:</th>       <th style="text-align:left;">       <font style="font-variant: small-caps">GraphQL-Eval</font>       </th>      </tr>     </thead>     <tbody>      <tr>       <td style="text-align:right;">Input:</td>       <td style="text-align:left;">GraphQL query &#x03D5;, graph <em>G</em>, and value <span class="inline-equation"><span class="tex">$\texttt {v}\in {\tt Vals}$</span>       </span>       </td>      </tr>      <tr>       <td style="text-align:right;">Ouput:</td>       <td style="text-align:left;">Does <span class="inline-equation"><span class="tex">$\texttt {v}$</span>       </span> occur in <span class="inline-equation"><span class="tex">$[[ \varphi ]] _G$</span>       </span>?</td>      </tr>     </tbody>    </table>    </div>    <p>We next show that <font style="font-variant: small-caps">GraphQL-Eval</font> is complete for the class of problems that can be decided in nondeterministic logarithmic space.</p>    <p>    <div class="theorem" id="enc13">     <Label>Theorem 4.1.</Label>     <p>      <font style="font-variant: small-caps">GraphQL-Eval</font> is NL-complete.</p>    </div>    </p>    <div class="proof" id="proof1">    <Label>Proof.</Label>    <p> (Sketch) The proof of the membership in NL is based on characterizing the evaluation process as several reachability tests. Recall first that a GraphQL query can be seen as a tree. Moreover, one can traverse a query by following its tree structure, that is, going from one label up to its parent, down to one of its children, or left/right to its siblings, with a logspace machine by using standard techniques (see e.g.&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0008">8</a>] Section 2.5). Thus, to show membership in NL we first guess a position, say <em>p</em>, in &#x03D5; corresponding to an expression of the form <span class="inline-equation"><span class="tex">${\tt f} {\tt [} \alpha {\tt ]}$</span>     </span> or <span class="inline-equation"><span class="tex">$\ell {\tt :} {\tt f} {\tt [} \alpha {\tt ]}$</span>     </span>. We also guess a node, say <em>u</em>, in <em>G</em>. Notice that to store <em>p</em> and <em>u</em> we only need logarithmic space. The intuition is that <em>p</em> represents the field in &#x03D5; that when evaluated from <em>u</em> produces the value <span class="inline-equation"><span class="tex">$\texttt {v}$</span>     </span>. This last property holds if and only if either <span class="inline-equation"><span class="tex">$\lambda (u,{\tt f}[\alpha ])=\texttt {v}$</span>     </span> or <span class="inline-equation"><span class="tex">$\lambda (u,{\tt f}[\alpha ])$</span>     </span> is a list containing <span class="inline-equation"><span class="tex">$\texttt {v}$</span>     </span>. Both options can be checked by simply inspecting <em>G</em>. To complete the proof we consider the path <em>P</em> (sequence of field names and type restrictions) in the tree representation of &#x03D5; that leads to position <em>p</em>. The last step in the proof is to check that node <em>u</em> can be reached from the root node in <em>G</em> by following path <em>P</em> which can be done in NL by a standard reachability test.</p>    <p>NL-hardness follows from the reachability problem in directed graphs. Given a directed graph <em>G</em> with <em>k</em> nodes and two nodes <em>u</em> and <em>v</em>, we create a GraphQL graph <em>G</em>&#x2032; from <em>G</em> by setting <em>u</em> as the root node, and adding a field label <span class="inline-equation"><span class="tex">${\tt e}$</span>     </span> to every edge. Moreover, for every node in <em>G</em>&#x2032; we add a property <span class="inline-equation"><span class="tex">${\tt a}$</span>     </span> with value <span class="inline-equation"><span class="tex">${\tt 1}$</span>     </span> except for node <em>v</em> in which <span class="inline-equation"><span class="tex">${\tt a}$</span>     </span> is associated with value <span class="inline-equation"><span class="tex">${\tt 2}$</span>     </span>. Then, we consider the sequence of queries constructed recursively as <span class="inline-equation"><span class="tex">$\alpha _1 = {\tt a}$</span>     </span> and <span class="inline-equation"><span class="tex">$\alpha_i = \verb|a e{|\alpha_{i-1}\verb|}|$</span>     </span>, and the query &#x03D5; = <em>&#x03B1;<sub>k</sub>     </em>. That is, &#x03D5; is the query <span class="inline-equation"><span class="tex">$\verb|a e{a e{a e{ |\cdots \verb| }}}|$</span>     </span>, where <span class="inline-equation"><span class="tex">${\tt a}$</span>     </span> is repeated <em>k</em> times and <span class="inline-equation"><span class="tex">${\tt e}$</span>     </span> repeated <em>k</em> &#x2212; 1 times. It is not difficult to argue that <em>G</em>&#x2032; and &#x03D5; can be constructed from <em>G</em> by using only logarithmic space. Moreover, value <span class="inline-equation"><span class="tex">${\tt 2}$</span>     </span> occurs in <span class="inline-equation"><span class="tex">$[[ \varphi ]] _{G^{\prime }}$</span>     </span> if and only if <em>v</em> is reachable from <em>u</em> in <em>G</em>.</p>    </div>    <p>Although it is theoretically interesting to pinpoint the exact complexity of the GraphQL evaluation problem, the previous result does not give a specific hint on how the whole evaluation of a query can be actually computed in practice. We next prove that for non-redundant queries in ground-typed normal form, the complete evaluation can be done in time linear with respect to the size of the output. Actually, in proving this result we show something even stronger: the complete evaluation of a GraphQL query can be constructed symbol-by-symbol with only constant-time delay between each symbol.</p>    <p>    <div class="theorem" id="enc14">     <Label>Theorem 4.2.</Label>     <p> Let <em>G</em> be a GraphQL graph and &#x03D5; a non-redundant query in ground-typed normal form. Then, <span class="inline-equation"><span class="tex">$\rho =[[ \varphi ]] _G$</span>      </span> can be computed such that <em>&#x03C1;</em> is produced symbol-by-symbol with constant-time delay between each symbol.</p>    </div>    </p>    <div class="proof" id="proof2">    <Label>Proof.</Label>    <p> (Sketch) We consider a fixed GraphQL schema <span class="inline-equation"><span class="tex">${\mathcal {S}}$</span>     </span>. Let &#x03D5; be a non-redundant query in ground-typed normal form, and <em>G</em> be a graph, both conforming to <span class="inline-equation"><span class="tex">${\mathcal {S}}$</span>     </span>. We describe a recursive algorithm <font style="font-variant: small-caps">Enumerate</font> that receives a subquery of &#x03D5; and a node <em>u</em>. The initial call is <font style="font-variant: small-caps">Enumerate</font>(&#x03D5;, <em>r</em>) where <em>r</em> is the root node. For the recursive case we assume that &#x03D5; follows the grammar in Definition&#x00A0;<a class="enc" href="#enc9">3.5</a>. Thus, consider a call <font style="font-variant: small-caps">Enumerate</font>(<em>&#x03C7;</em>, <em>u</em>) with <em>&#x03C7;</em> a subquery of &#x03D5; given by the third rule in Definition&#x00A0;<a class="enc" href="#enc9">3.5</a>. Assume first that <em>&#x03C7;</em> is of the form <span class="inline-equation"><span class="tex">$\mathtt {f[}\alpha \mathtt {]}$</span>     </span>. If there is a value <span class="inline-equation"><span class="tex">$\texttt {V}=\lambda (u,{\tt f}[\alpha ])$</span>     </span> in <em>G</em>, then <font style="font-variant: small-caps">Enumerate</font> outputs <span class="inline-equation"><span class="tex">$\mathtt {f}\mathtt {:}\texttt {V}$</span>     </span>, otherwise it outputs <span class="inline-equation"><span class="tex">$\mathtt {f}\mathtt {:}\texttt {null}$</span>     </span>, and returns. Assume now that <em>&#x03C7;</em> is of the form <span class="inline-equation"><span class="tex">$\mathtt {f[}\alpha \mathtt {]}\mathtt {\lbrace }\varphi ^{\prime }\mathtt { \rbrace }$</span>     </span>. <font style="font-variant: small-caps">Enumerate</font> first outputs expression <span class="inline-equation"><span class="tex">$\mathtt {f}\mathtt {:}$</span>     </span> and then it proceeds depending on the following cases:</p>    <p>     <ol class="list-no-style">      <li id="list19" label="(1)">If <span class="inline-equation"><span class="tex">${\it type}_{\mathcal {S}}({\tt f})\in {\tt L}_{\tt T}$</span>       </span>, then <font style="font-variant: small-caps">Enumerate</font> outputs the symbol <span class="inline-equation"><span class="tex">$\mathtt {[}$</span>       </span>. Next, for every <em>v</em> such that <span class="inline-equation"><span class="tex">$(u,\mathtt {f[}\alpha \mathtt {]},v)\in E$</span>       </span>, it first outputs the symbol <span class="inline-equation"><span class="tex">$\mathtt {\lbrace }$</span>       </span>, then calls <font style="font-variant: small-caps">Enumerate</font>(&#x03D5;&#x2032;, <em>v</em>), and then outputs the symbol <span class="inline-equation"><span class="tex">$\mathtt { \rbrace }$</span>       </span>. Finally, it outputs the symbol <span class="inline-equation"><span class="tex">$\mathtt {]}$</span>       </span> and returns.<br/></li>      <li id="list20" label="(2)">If <span class="inline-equation"><span class="tex">${\it type}_{\mathcal {S}}({\tt f})\notin {\tt L}_{\tt T}$</span>       </span>, then we have two cases depending on whether there is a <em>v</em> such that <span class="inline-equation"><span class="tex">$(u,\mathtt {f[}\alpha \mathtt {]},v)\in E$</span>       </span> or not. If there is no such <em>v</em>, then <font style="font-variant: small-caps">Enumerate</font> simply outputs <tt>null</tt> and returns. Otherwise it first outputs the symbol <span class="inline-equation"><span class="tex">$\mathtt {\lbrace }$</span>       </span>, then calls <font style="font-variant: small-caps">Enumerate</font>(&#x03D5;&#x2032;, <em>v</em>), and then outputs the symbol <span class="inline-equation"><span class="tex">$\mathtt { \rbrace }$</span>       </span>.<br/></li>     </ol>    </p>    <p>The cases in which <em>&#x03C7;</em> is of the form <span class="inline-equation"><span class="tex">$\ell \mathtt {:}\mathtt {f[}\alpha \mathtt {]}$</span>     </span> or <span class="inline-equation"><span class="tex">$\ell \mathtt {:}\mathtt {f[}\alpha \mathtt {]}\mathtt {\lbrace }\varphi ^{\prime }\mathtt { \rbrace }$</span>     </span> are similar but <font style="font-variant: small-caps">Enumerate</font> outputs first <span class="inline-equation"><span class="tex">$\ell \mathtt {:}$</span>     </span> instead of <span class="inline-equation"><span class="tex">$\mathtt {f}\mathtt {:}$</span></span>. Notice that in all these cases, <font style="font-variant: small-caps">Enumerate</font> is just following the semantics of GraphQL as defined in Definition&#x00A0;<a class="enc" href="#enc7">3.3</a>. The really important cases are when we have expressions constructed from the first or second rule in Definition&#x00A0;<a class="enc" href="#enc9">3.5</a>. Hence, consider a subquery of the form <em>&#x03C7;</em>     <sub>1</sub>     <em>&#x03C7;</em>     <sub>2</sub>&#x22C5;&#x22C5;&#x22C5;<em>&#x03C7;<sub>k</sub>     </em> where every <em>&#x03C7;<sub>i</sub>     </em> is constructed from the third rule in Definition&#x00A0;<a class="enc" href="#enc9">3.5</a>. Given that &#x03D5; is non-redundant and in ground-typed normal form, we do not need the <span class="inline-equation"><span class="tex">$\operatorname{collect}(\cdot)$</span>     </span> operator and, thus, <font style="font-variant: small-caps">Enumerate</font>(<em>&#x03C7;</em>     <sub>1</sub>     <em>&#x03C7;</em>     <sub>2</sub>&#x22C5;&#x22C5;&#x22C5;<em>&#x03C7;<sub>k</sub>     </em>, <em>u</em>) can simply call <font style="font-variant: small-caps">Enumerate</font>(<em>&#x03C7;<sub>i</sub>     </em>, <em>u</em>) one by one for every <em>i</em> = 1, 2,&#x2009;...&#x2009;, <em>k</em> and produce the desired output. Finally, consider a subquery <em>&#x03C8;</em>     <sub>1</sub>     <em>&#x03C8;</em>     <sub>2</sub>&#x22C5;&#x22C5;&#x22C5;<em>&#x03C8;<sub>k</sub>     </em> where every <em>&#x03C8;<sub>i</sub>     </em> is of the form <span class="inline-equation"><span class="tex">${\tt on}\; {\tt t}_i\ {\tt {} \varphi _i {\tt }}$</span>     </span>. Given that &#x03D5; is non-redundant we know that <span class="inline-equation"><span class="tex">${\tt t}_i\ne {\tt t}_j$</span>     </span> for <em>i</em> &#x2260; <em>j</em>. This implies that <em>k</em> is a constant value bounded by the number of types mentioned in <span class="inline-equation"><span class="tex">${\mathcal {S}}$</span>     </span>. Moreover, since &#x03D5; is ground typed, we have <span class="inline-equation"><span class="tex">${\tt t}_i\in {\tt O}_{\tt T}$</span>     </span> for every <em>i</em>. With these observations the call <font style="font-variant: small-caps">Enumerate</font>(<em>&#x03C8;</em>     <sub>1</sub>     <em>&#x03C8;</em>     <sub>2</sub>&#x22C5;&#x22C5;&#x22C5;<em>&#x03C8;<sub>k</sub>     </em>, <em>u</em>) can proceed as follows. Search for an index <em>i</em> such that <span class="inline-equation"><span class="tex">$\tau (u)={\tt t}_i$</span>     </span>. If such an index <em>i</em> exists, then call <font style="font-variant: small-caps">Enumerate</font>(&#x03D5;<sub>      <em>i</em>     </sub>, <em>u</em>). If the index does not exist, just return.</p>    <p>To see that there is a constant-time delay between any two symbols produced by <font style="font-variant: small-caps">Enumerate</font>, first notice that every call, except for the last case considered above, outputs at least one symbol as soon as it is called and at least one symbol just before it returns. Moreover, every recursive call to <font style="font-variant: small-caps">Enumerate</font> is performed after a constant time upon its parent call. Finally, to consider the last case in the previous paragraph, given that &#x03D5; is non-redundant and in ground-typed normal form we have that an expression of the form <span class="inline-equation"><span class="tex">$\mathtt {on\, t^{\prime }}\ {\tt {}\ \,...\,\ {\tt }}$</span>     </span> does not occur immediately inside another <span class="inline-equation"><span class="tex">$\mathtt {on\, t}\ {\tt {}\ \,...\,\ {\tt }}$</span>     </span> expression. This ensures that there are no two consecutive calls to <font style="font-variant: small-caps">Enumerate</font> that do not produce any output.</p>    </div>    <p>Computing all the components of the evaluation is usually called the <em>enumeration problem</em>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0003">3</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0013">13</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0017">17</a>]. Thus, Theorem&#x00A0;<a class="enc" href="#enc14">4.2</a> shows that the enumeration problem for GraphQL can be solved with constant delay. As an immediate corollary we obtain the following.</p>    <p>    <div class="corollary" id="enc15">     <Label>Corollary 4.3.</Label>     <p> Let <em>G</em> be a GraphQL graph and &#x03D5; a non-redundant query in ground-typed normal form. Then, <span class="inline-equation"><span class="tex">$\rho =[[ \varphi ]] _G$</span>      </span> can be computed in time linear with respect to |<em>&#x03C1;</em>|.</p>    </div>    </p>   </section>   <section id="sec-12">    <header>    <div class="title-info">     <h2>      <span class="section-number">5</span> The Size of a GraphQL Response</h2>    </div>    </header>    <p>Based on our results in the previous section, we may conclude that one of the main sources of complexity in evaluating GraphQL queries is the size of a query response object. In this section we prove that even for very simple cases this object might be prohibitively large. We begin by stating an exponential upper bound.</p>    <p>    <div class="proposition" id="enc16">     <Label>Proposition 5.1.</Label>     <p> For every GraphQL query &#x03D5; and GraphQL graph <em>G</em> it holds that <span class="inline-equation"><span class="tex">$[[ \varphi ]] _G$</span>      </span> is of size <em>O</em>(|<em>G</em>|<sup>|&#x03D5;|</sup>).</p>    </div>    </p>    <p>The upper bound can be proven by a simple induction argument.</p>    <p>    <div class="proposition" id="enc17">     <Label>Proposition 5.2.</Label>     <p> For every <em>n</em> &#x2265; 0, there exists a graph <em>G</em> and a query &#x03D5; such that <em>G</em> is of size 6 and &#x03D5; is of size 2(<em>n</em> + 1), but the size of <span class="inline-equation"><span class="tex">$[[ \varphi ]] _G$</span>      </span> is greater than 2<sup>       <em>n</em>      </sup>.</p>    </div>    </p>    <div class="proof" id="proof3">    <Label>Proof.</Label>    <p> Let <em>G</em> be the following graph with root node <em>r</em>. <figure id="fig6">      <img src="http://deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-fig6.jpg" class="img-responsive" alt="" longdesc=""/>     </figure>    </p>    <p>Consider now the queries given by the recurrence <span class="inline-equation"><span class="tex">$\alpha _0 = \mathtt {name}$</span>     </span>, and <span class="inline-equation"><span class="tex">$\alpha _i = \mathtt {knows}\ \mathtt {\lbrace }\ \mathtt {knows}\ \mathtt {\lbrace }\ \alpha _{i-1}\ \mathtt { \rbrace }\ \mathtt { \rbrace }$</span>     </span> for every <em>i</em> > 0. Define &#x03D5; as <span class="inline-equation"><span class="tex">$\mathtt {start}\, \mathtt {\lbrace }\, \alpha _n\, \mathtt { \rbrace }$</span>     </span>. Then, the size of &#x03D5; is 2<em>n</em> 		 + 2 but the evaluation of &#x03D5; over <em>G</em> is of size exponential in <em>n</em>; more precisely, the name <span class="inline-equation"><span class="tex">${\tt Alice}$</span>     </span> occurs 2<sup>      <em>n</em>     </sup> times in&#x00A0;<span class="inline-equation"><span class="tex">$[[ \varphi ]] _G$</span>     </span>.</p>    </div>    <p>One may think that the previous result is produced solely by the presence of directed cycles in the graph. As the next result shows, one can also obtain an exponential blow up even for acyclic graphs.</p>    <p>    <div class="proposition" id="enc18">     <Label>Proposition 5.3.</Label>     <p> For every <em>n</em> &#x2265; 0, there exists an acyclic graph <em>G</em> and a query &#x03D5; such that <em>G</em> is of size 4<em>n</em> + 2 and &#x03D5; is of size 2<em>n</em> + 2, but the size of <span class="inline-equation"><span class="tex">$[[ \varphi ]] _G$</span>      </span> is greater than 2<sup>       <em>n</em>      </sup>.</p>    </div>    </p>    <div class="proof" id="proof4">    <Label>Proof.</Label>    <p> Let <em>G</em> be the following graph with root node <em>r</em>. <figure id="fig7">      <img src="http://deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-fig7.jpg" class="img-responsive" alt="" longdesc=""/>     </figure>    </p>    <p>Furthermore, let &#x03D5; be as defined in the proof of Proposition&#x00A0;<a class="enc" href="#enc17">5.2</a>. Then <em>G</em> is of size 4<em>n</em> + 2, &#x03D5; is of size 2<em>n</em> + 2, but <span class="inline-equation"><span class="tex">$[[ \varphi ]] _{G}$</span>     </span> is of size exponential in <em>n</em>; the name <span class="inline-equation"><span class="tex">${\tt Alice}$</span>     </span> occurs 2<sup>      <em>n</em>     </sup> times in&#x00A0;<span class="inline-equation"><span class="tex">$[[ \varphi ]] _{G}$</span>     </span>.</p>    </div>    <p>A natural question at this point is how can we avoid obtaining a response object of exponential size. We prove next that we have at least two options: bound the number of different <em>walks</em> in the graph, or bound the <em>nesting depth</em> of queries. A walk in a graph is similar to a path but it is allowed to repeat edges. Notice that this implies that a graph with a cycle has an unbounded number of walks. The nesting depth of a query can be defined intuitively as the maximum number of nested curly braces in the query expression. For instance, the query in Figure&#x00A0;<a class="fig" href="#fig4">4</a> has nesting depth 4.</p>    <p>    <div class="theorem" id="enc19">     <Label>Theorem 5.4.</Label>     <p> Let <em>G</em> be a graph with root node <em>r</em>, and &#x03D5; a GraphQL query. Let <em>K</em> be a constant value not depending on the size of <em>G</em> or &#x03D5;. Consider the following two properties.</p>     <p>      <ol class="list-no-style">       <li id="list21" label="(1)">For every node <em>v</em> in <em>G</em> the number of different walks from <em>r</em> to <em>v</em> is bounded by <em>K</em>.<br/></li>       <li id="list22" label="(2)">The nesting depth of &#x03D5; is bounded by <em>K</em>.<br/></li>      </ol>     </p>     <p>For <em>G</em> and &#x03D5; satisfying either (1) or (2) we have that the evaluation <span class="inline-equation"><span class="tex">$[[ \varphi ]] _{G}$</span>      </span> is of size <em>O</em>(|<em>G</em>|<sup>       <em>K</em>      </sup> &#x00B7; |&#x03D5;|).</p>    </div>    </p>    <div class="proof" id="proof5">    <Label>Proof.</Label>    <p> (Sketch) For case (1), let <span class="inline-equation"><span class="tex">$\rho =[[ \varphi ]] _{G}$</span>     </span>. We know that every data value in <em>&#x03C1;</em> corresponds to a property of some node in <em>G</em> and, moreover, every path in <em>&#x03C1;</em> corresponds to a walk in <em>G</em> from the root node. Thus, the maximum number of data values appearing in <em>&#x03C1;</em> is bounded by |<em>G</em>|<sup>      <em>K</em>     </sup>. Furthermore, for every such value, the length of its path in <em>&#x03C1;</em> is bounded by |&#x03D5;|, which gives us the <em>O</em>(|<em>G</em>|<sup>      <em>K</em>     </sup> &#x00B7; |&#x03D5;|) bound. For case (2) the result follows from a simple induction argument.</p>    </div>    <p>Property&#x00A0;(2) is exactly one of the restrictions that the GraphQL interface of Github imposes to ensure a reasonable output size&#x00A0;(see Sec.&#x00A0;<a class="sec" href="#sec-3">1</a>)&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0007">7</a>]; there also exists a software library&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0020">20</a>] that can be used to integrate the same type of restriction into any other GraphQL&#x00A0;server.</p>    <p>While property&#x00A0;(1) or property&#x00A0;(2) may 	  be applied as a restriction to avoid exponential blow up of query results, we emphasize that both properties are more restrictive than necessary. That is, there are cases in which the properties are not satisfied but query results can still be of polynomial size only. For instance, we recall our initial Github experiment&#x00A0;(cf. Sec.&#x00A0;<a class="sec" href="#sec-3">1</a>) where the owner of some of the Github repositories listed for a Github user with login &#x201C;danbri&#x201D; was &#x201C;danbri&#x201D; himself. Hence, the data exposed via Github&#x0027;s GraphQL interface contains cycles and, thus, does not satisfy property&#x00A0;(1). Now, for the sequence of queries in our experiment&#x00A0;(with the level-1 and the level-2 versions illustrated in Figures&#x00A0;<a class="fig" href="#fig1">1</a>(a) and <a class="fig" href="#fig1">1</a>(c), respectively), consider a variation of the queries that uses <tt>first:1</tt>&#x00A0;(instead of <tt>first:2</tt> or <tt>first:5</tt>). It is easy to see that the result size of the so-changed queries grows linearly with the level of the queries. Hence, for these queries we may permit an arbitrarily deep nesting without having to expect an exponential result size blow up. In this case, enforcing property&#x00A0;(2) is too restrictive.</p>    <p>In addition to restricting the nesting depth of queries, other approaches are used in practice to identify queries whose computation could be too resource intensive. For instance, Github combines the nesting-depth restriction&#x00A0;(using a <em>K</em> of 25) with the following restriction. For every subquery of the form <span class="inline-equation"><span class="tex">${\tt f} {\tt [} \alpha {\tt ]{} \varphi {\tt }}$</span>    </span> or <span class="inline-equation"><span class="tex">$\ell {\tt :} {\tt f} {\tt [} \alpha {\tt ]{} \varphi {\tt }}$</span>    </span> for which the type of field&#x00A0;<span class="inline-equation"><span class="tex">${\tt f}$</span>    </span> is a list type&#x00A0;(i.e., <span class="inline-equation"><span class="tex">${\it type}_{\mathcal {S}}({\tt f})\in {\tt L}_{\tt T}$</span>    </span>), the arguments&#x00A0;<em>&#x03B1;</em> must contain either the argument named <tt>first</tt> or the argument named <tt>last</tt>, with a value that is an integer from 1 to 100. Moreover, based on these argument values, the Github GraphQL interface computes the maximum number of possible result nodes at each level of nesting depth of a given query. Queries for which this number is greater than 500,000 at some level are rejected&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0007">7</a>].</p>    <p>Note that this restriction has not been sufficient to 	  prevent the overly resource intensive attempt to execute the level-6 and the level-7 version of the test queries in our experiment in which we used <tt>first:5</tt>&#x00A0;(i.e., Figure&#x00A0;<a class="fig" href="#fig1">1</a>(e)). On the other hand, the restriction may also be too restrictive in various cases. For instance, there may be a query for which the maximum number of <em>possible</em> result nodes at some level of nesting depth is greater than 500,000, but if the query would be executed, the actual number of result nodes may turn out to be significantly smaller and not cause any trouble at all.</p>    <p>We found two more software libraries&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0014">14</a>] that aim to estimate some notion of &#x201C;complexity&#x201D; or &#x201C;cost&#x201D; of GraphQL queries. These estimation approaches take into account different cost factors that a user may associate with the various elements of the schema used. However, these approaches suffer from the same problem as the restrictions imposed by Github&#x0027;s GraphQL interface: They may easily overestimate the cost of a query by a large degree.</p>    <section id="sec-13">        <section id="sec-14">     <p><em>Computing the exact size of a GraphQL 		  response.</em> As shown in Theorem&#x00A0;<a class="enc" href="#enc19">5.4</a>, in order to avoid returning response objects of exponential size, GraphQL service providers must impose severe restrictions on the structure of the queries or the data. Moreover, these restrictions can fail in both directions: discarding settings in which an efficient evaluation is possible and allowing settings in which a complete evaluation is too resource intensive. Fortunately, we can give a more elegant solution by showing that the exact size of the complete evaluation of a GraphQL query can be computed efficiently without the need of evaluating the whole query. We formalize this result in the following theorem.</p>     <div class="theorem" id="enc20">      <Label>Theorem 5.5.</Label>      <p> Let <em>G</em> be a GraphQL graph and &#x03D5; a non-redundant query in ground-typed normal form. The size of <span class="inline-equation"><span class="tex">$[[ \varphi ]] _G$</span>       </span> can be computed in time <em>O</em>(|<em>G</em>| &#x00B7; |&#x03D5;|).</p>     </div>     <p>To prove the theorem we present a dynamic programming strategy in Algorithms&#x00A0;1 and&#x00A0;2 . Let &#x03D5; be a query and <em>G</em> a graph. The idea of procedure <span class="inline-equation"><span class="tex">$\mathtt {Label}$</span>      </span> in Algorithm&#x00A0;2 is to label every node <em>u</em> with all subqueries <em>&#x03C8;</em> of &#x03D5; for which we already know the size of <span class="inline-equation"><span class="tex">$[[ \psi ]] _G^u$</span>      </span>. In that way we never visit a node twice for the same subquery. We maintain two structures: <span class="inline-equation"><span class="tex">$\mathtt {labels}[u]$</span>      </span> to store (pointers to) the subqueries, and <span class="inline-equation"><span class="tex">$\mathtt {size}[u,\psi ]$</span>      </span> to store the size of <span class="inline-equation"><span class="tex">$[[ \psi ]] _G^u$</span>      </span>. To briefly illustrate how the algorithm works, consider the following graph <figure id="fig8">       <img src="http://deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-fig8.jpg" class="img-responsive" alt="" longdesc=""/>      </figure>     </p>     <p>and query &#x03D5; given by <tt>e&#x00A0;{&#x00A0;g&#x00A0;{&#x00A0;a&#x00A0;}&#x00A0;}&#x00A0;f&#x00A0;{&#x00A0;g&#x00A0;{&#x00A0;a&#x00A0;}&#x00A0;}</tt>. Assume that at some point during the execution of <span class="inline-equation"><span class="tex">$\mathtt {Label}$</span>      </span> we visit <em>w</em> with subquery <span class="inline-equation"><span class="tex">$\texttt {a}$</span>      </span> for the first time. Then, we store <span class="inline-equation"><span class="tex">$\texttt {a}$</span>      </span> in <span class="inline-equation"><span class="tex">$\mathtt {labels}[w]$</span>      </span> (line&#x00A0;2 in Algorithm&#x00A0;2) and set <span class="inline-equation"><span class="tex">$\mathtt {size}[w,\texttt {a}]$</span>      </span> to 3&#x00A0;(line&#x00A0;4) because the evaluation is <span class="inline-equation"><span class="tex">$\texttt {a}\mathtt {:}\texttt {1}$</span>      </span>, which has three symbols. Assume now that we visit <em>v</em> with subquery <tt>g{a}</tt>. We first store this expression in <span class="inline-equation"><span class="tex">$\mathtt {labels}[v]$</span>      </span> and we recursively call <span class="inline-equation"><span class="tex">$\mathtt {Label}(G,w,\texttt {a})$</span>      </span> (line&#x00A0;9) because <span class="inline-equation"><span class="tex">$(v, {\tt g}, w)\in E$</span>      </span>. Given that <span class="inline-equation"><span class="tex">$\texttt {a}\in \mathtt {labels}[w]$</span>      </span>, the process immediately returns without any additional computation (line&#x00A0;1). Next, we increment <span class="inline-equation"><span class="tex">$\mathtt {size}[v,{\tt g{a}}]$</span>      </span> with <span class="inline-equation"><span class="tex">$\mathtt {size}[w,{\tt a}]+2=5$</span>      </span> (line&#x00A0;10), and finally add 2 (line&#x00A0;12) to obtain <span class="inline-equation"><span class="tex">$\mathtt {size}[v,{\tt g{a}}]=7$</span>      </span>, which is exactly the size of the evaluation <tt>g:{a:1}</tt>      <span class="inline-equation"><span class="tex">$=[[ {\tt g{a}}]] _G^v$</span>      </span>. With a similar analysis we obtain that the algorithm produces the value <span class="inline-equation"><span class="tex">$\mathtt {size}[u,{\tt e{g{a}}}]=11$</span>      </span>, which is the number of symbols in <tt>e:{g:{a:1}}</tt>. What is more interesting is the call to <span class="inline-equation"><span class="tex">$\mathtt {Label}$</span>      </span> with arguments <em>u</em> and <tt>f{g{a}}</tt>. Notice that this call produces a recursive call to <span class="inline-equation"><span class="tex">$\mathtt {Label}(G,v,{\tt g{a}})$</span>      </span>, but since <tt>g{a}</tt>      <span class="inline-equation"><span class="tex">$\ \in \mathtt {labels}[v]$</span>      </span>, we already have the correct size in <span class="inline-equation"><span class="tex">$\mathtt {size}[v,{\tt g{a}}]$</span>      </span> and we do not need to do any additional computation. Finally, the value <span class="inline-equation"><span class="tex">$\mathtt {size}[v,{\tt g{a}}]=7$</span>      </span> is used to set <span class="inline-equation"><span class="tex">$\mathtt {size}[u,{\tt f{g{a}}}]$</span>      </span> to value 11. All this computation can be used to obtain the size of <span class="inline-equation"><span class="tex">$[[ \varphi ]] _G^u$</span>      </span> which is <span class="inline-equation"><span class="tex">$\mathtt {size}[u,{\tt e{g{a}}}]+\mathtt {size}[u,{\tt f{g{a}}}]=22$</span>      </span> (line&#x00A0;21) which is the number of symbols of <tt>e:{g:{a:1}}</tt>      <tt>f:{g:{a:1}}</tt>. Algorithm&#x00A0;1 initializes all the needed structures and makes the initial call with the whole query and the root node. To see that Algorithm&#x00A0;1 works in time <em>O</em>(|<em>G</em>| &#x00B7; |&#x03D5;|) just notice that the number of subqueries is linear with respect to the query, and every node is visited at most once per subquery. Moreover, when visiting a node <em>u</em>, the number of steps is at most the number of outgoing edges from <em>u</em>.</p>     <p>      <img src="http://deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-img1.svg" class="img-responsive" alt="" longdesc=""/>     </p>     <p>      <img src="http://deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-img2.svg" class="img-responsive" alt="" longdesc=""/>     </p>    </section>    </section>   </section>   <section id="sec-15">    <header>    <div class="title-info">     <h2>      <span class="section-number">6</span> Related Work</h2>    </div>    </header>    <p>A natural question is how our results compare with results for classical query languages. Given the tree-like structure of GraphQL queries, an immediate candidate to compare with is the language of acyclic conjunctive queries&#x00A0;(ACQs)&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0008">8</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0022">22</a>]. Conjunctive queries (CQs) corresponds to the SELECT-FROM-WHERE fragment of SQL. The further acyclic restriction in ACQs ensures the existence of a <em>join tree</em> that allows one to efficiently evaluate the query&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0022">22</a>].</p>    <p>In terms of expressiveness, it is not difficult to encode a GraphQL query into an ACQ, although some special care has to be put in the final construction of the GraphQL response object from the tuples of values produced by an ACQ. There is no formal work on proving properties of such an encoding, but practitioners have already started using these types of methods when evaluating GraphQL&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0019">19</a>]. Despite the existence of an encoding, the classical ACQs complexity results do not directly entail the results in this paper. In terms of the evaluation problem, Gottlob et al.&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0008">8</a>] have shown that for ACQs the problem is complete for LOGCFL, which is the class of problems that can be reduced in logarithmic space to a context-free language&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0011">11</a>]. <img src="http://deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-img3.svg" 	  class="img-responsive" alt="" longdesc=""/> the membership of <font style="font-variant: small-caps">GraphQL-Eval</font> in NL shows an important difference in terms of complexity theory. In terms of the enumeration problem, there is a substantial amount of work on restrictions that allow a constant-delay evaluation for ACQs and related languages&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0002">2</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0004">4</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0012">12</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0017">17</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0018">18</a>]. As mentioned in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0017">17</a>], &#x201C;it is very 	  unlikely that constant-delay enumeration can be achieved for all queries in ACQ&#x201D; and, thus, constant-delay results impose restrictions over the structure of the queries&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0002">2</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0017">17</a>] or of the queried data&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0004">4</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0012">12</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0018">18</a>]. In contrast, Theorem&#x00A0;<a class="enc" href="#enc14">4.2</a> proves the constant-delay result for GraphQL in general, requiring only a specific normal form for queries.</p>    <p>Pichler and Skritek&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0015">15</a>] presented a fairly complete picture of the complexity of counting the number of tuples in the evaluation of an ACQ. This problem is closely related to the problem of computing the size of the evaluation of a GraphQL query. In&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0015">15</a>] the authors proved that for general ACQs the problem is intractable, and they presented a polynomial-time algorithm for the case of ACQs without existential variables. It is not clear that a GraphQL query can be encoded as a single ACQ without existential variables, but even if possible, applied to our scenario, the algorithm in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0015">15</a>] would work in time <em>O</em>(|<em>G</em>|<sup>2</sup> &#x00B7; |&#x03D5;|) (see Theorem 1 in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0015">15</a>]), while our algorithm works in time linear with respect to |<em>G</em>|.</p>   </section>   <section id="sec-16">    <header>    <div class="title-info">     <h2>      <span class="section-number">7</span> Conclusions</h2>    </div>    </header>    <p>GraphQL is becoming increasingly popular as an alternative to REST-based interfaces which have dominated the Web-API scenario for more than 10 years. In the spirit of classical query languages, GraphQL uses a schema to describe the organization of the data and a declarative query language to allow clients to access this data.</p>    <p>We have embarked on a systematic study of GraphQL providing a full formalization of the semantics of its query language based on a logical data model. Given this formalization, we have also studied the complexity of the language, in particular the evaluation, enumeration, and size-computation problems, showing that all of them can be efficiently solved. While our conceptual contributions can be used to further study the language form a theoretical point of view, our technical contributions can also help developers to implement more robust GraphQL interfaces on the Web.</p>   </section>  </section>  <section class="back-matter">   <section id="sec-17">    <header>    <div class="title-info">     <h2>ACKNOWLEDGMENTS</h2>    </div>    </header>    <p>Olaf Hartig&#x0027;s work has been funded by the CENIIT program at Link&#x00F6;ping University&#x00A0;(project number 17.05). Jorge P&#x00E9;rez is supported by the Millenium Institute for Foundational Research on Data, and ENLACE-Fondecyt VID-UChile.</p>   </section>   <section id="ref-001">    <header>    <div class="title-info">     <h2 class="page-brake-head">REFERENCES</h2>    </div>    </header>    <ul class="bibUl">    <li id="BibPLXBIB0001" label="[1]">4Catalyzer Corporation. 2017. GraphQL Validation Complexity. <a href="https://github.com/4Catalyzer/graphql-validation-complexity/" target="_blank">https://github.com/4Catalyzer/graphql-validation-complexity/</a>. (2017).</li>    <li id="BibPLXBIB0002" label="[2]">Guillaume Bagan, Arnaud Durand, and Etienne Grandjean. 2007. On Acyclic Conjunctive Queries and Constant Delay Enumeration. In <em>      <em>Computer Science Logic, 21st International Workshop, CSL 2007, 16th Annual Conference of the EACSL, Lausanne, Switzerland, September 11-15, 2007, Proceedings</em>     </em>. 208&#x2013;222.</li>    <li id="BibPLXBIB0003" label="[3]">Nadia Creignou, Markus Kr&#x00F6;ll, Reinhard Pichler, Sebastian Skritek, and Heribert Vollmer. 2017. On the Complexity of Hard Enumeration Problems. In <em>      <em>Language and Automata Theory and Applications - 11th International Conference, LATA 2017, Ume&#x00E5;, Sweden, March 6-9, 2017, Proceedings</em>     </em>. 183&#x2013;195.</li>    <li id="BibPLXBIB0004" label="[4]">Arnaud Durand, Nicole Schweikardt, and Luc Segoufin. 2014. Enumerating answers to first-order queries over databases of low degree. In <em>      <em>Proceedings of the 33rd ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems, PODS&#x2019;14, Snowbird, UT, USA, June 22-27, 2014</em>     </em>. 121&#x2013;131.</li>    <li id="BibPLXBIB0005" label="[5]">Facebook, Inc.2016. GraphQL. Working Draft, Oct.&#x00A0;2016. Online at <a href="http://facebook.github.io/graphql" target="_blank">http://facebook.github.io/graphql</a>, retrieved on Dec.&#x00A0;12, 2016. (Oct. 2016).</li>    <li id="BibPLXBIB0006" label="[6]">Github GraphQL API 		 v4 2017. <a href="https://developer.github.com/v4/" target="_blank">https://developer.github.com/v4/</a>. (2017).</li>    <li id="BibPLXBIB0007" label="[7]">Github GraphQL API 		 v4, GraphQL resource limitations 2017. <a href="https://developer.github.com/v4/guides/resource-limitations/" target="_blank">https://developer.github.com/v4/guides/resource-limitations/</a>. (2017).</li>    <li id="BibPLXBIB0008" label="[8]">Georg Gottlob, Nicola Leone, and Francesco Scarcello. 2001. The complexity of acyclic conjunctive queries. <em>      <em>J. ACM</em>     </em>48, 3 (2001), 431&#x2013;498.</li>    <li id="BibPLXBIB0009" label="[9]">GraphQL Users2017. <a href="http://graphql.org/users/" target="_blank">http://graphql.org/users/</a>. (2017).</li>    <li id="BibPLXBIB0010" label="[10]">Olaf Hartig and Jorge P&#x00E9;rez. 2017. An Initial Analysis of Facebook&#x0027;s GraphQL Language. In <em>      <em>Proceedings of the 11th Alberto Mendelzon International Workshop on Foundations of Data Management (AMW)</em>     </em>.</li>    <li id="BibPLXBIB0011" label="[11]">D.&#x00A0;S. Johnson. 1990. A catalog of complexity classes. In <em>      <em>Handbook of Theoretical Computer Science</em>     </em>, J.&#x00A0;van Leeuwen (Ed.). Vol.&#x00A0;A. Elsevier, Chapter 2.</li>    <li id="BibPLXBIB0012" label="[12]">Wojciech Kazana and Luc Segoufin. 2013. Enumeration of first-order queries on classes of structures with bounded expansion. In <em>      <em>Proceedings of the 32nd ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems, PODS 2013, New York, NY, USA - June 22 - 27, 2013</em>     </em>. 297&#x2013;308.</li>    <li id="BibPLXBIB0013" label="[13]">Markus Kr&#x00F6;ll, Reinhard Pichler, and Sebastian Skritek. 2016. On the Complexity of Enumerating the Answers to Well-designed Pattern Trees. In <em>      <em>19th International Conference on Database Theory, ICDT 2016, Bordeaux, France, March 15-18, 2016</em>     </em>. 22:1&#x2013;22:18.</li>    <li id="BibPLXBIB0014" label="[14]">Ivo Mei&#x00DF;ner. 2017. GraphQL Query Complexity Analysis for graphql-js. <a href="https://github.com/ivome/graphql-query-complexity/" target="_blank">https://github.com/ivome/graphql-query-complexity/</a>. (2017).</li>    <li id="BibPLXBIB0015" label="[15]">Reinhard Pichler and Sebastian Skritek. 2013. Tractable counting of the answers to conjunctive queries. <em>      <em>J. Comput. Syst. Sci.</em>     </em>79, 6 (2013), 984&#x2013;1001.</li>    <li id="BibPLXBIB0016" label="[16]">Leonard Richardson, Mike Amundsen, and Sam Ruby. 2013. <em>      <em>RESTful Web APIs</em>     </em>. O&#x0027;Reilly Media, Inc.</li>    <li id="BibPLXBIB0017" label="[17]">Luc Segoufin. 2013. Enumerating with constant delay the answers to a query. In <em>      <em>Joint 2013 EDBT/ICDT Conferences, ICDT &#x2019;13 Proceedings, Genoa, Italy, March 18-22, 2013</em>     </em>. 10&#x2013;20.</li>    <li id="BibPLXBIB0018" label="[18]">Luc Segoufin and Alexandre Vigny. 2017. Constant Delay Enumeration for FO Queries over Databases with Local Bounded Expansion. In <em>      <em>20th International Conference on Database Theory, ICDT 2017, March 21-24, 2017, Venice, Italy</em>     </em>. 20:1&#x2013;20:16.</li>    <li id="BibPLXBIB0019" label="[19]">Stem Disintermedia, Inc.2016. Join Monster. <a href="https://github.com/stems/join-monster" target="_blank">https://github.com/stems/join-monster</a>. (2016).</li>    <li id="BibPLXBIB0020" label="[20]">Stem Disintermedia, Inc.2017. GraphQL Depth Limit. <a href="https://github.com/stems/graphql-depth-limit/" target="_blank">https://github.com/stems/graphql-depth-limit/</a>. (2017).</li>    <li id="BibPLXBIB0021" label="[21]">Moshe&#x00A0;Y. Vardi. 1982. The Complexity of Relational Query Languages (Extended Abstract). In <em>      <em>Proceedings of the 14th Annual ACM Symposium on Theory of Computing, May 5-7, 1982, San Francisco, California, USA</em>     </em>. 137&#x2013;146.</li>    <li id="BibPLXBIB0022" label="[22]">Mihalis Yannakakis. 1981. Algorithms for Acyclic Database Schemes. In <em>      <em>Very Large Data Bases, 7th International Conference, September 9-11, 1981, Cannes, France, Proceedings</em>     </em>. 82&#x2013;94.</li>    </ul>   </section>  </section>  <section id="foot-001" class="footnote">   <header>    <div class="title-info">    <h2>FOOTNOTE</h2>    </div>   </header>   <p id="fn1"><a href="#foot-fn1"><sup>1</sup></a>All the query executions on which we report have been performed on Oct. 3, 2017.</p>   <p id="fn2"><a href="#foot-fn2"><sup>2</sup></a>When increasing the number of repositories to be considered, by changing <tt>first:2</tt> to, say, <tt>first:10</tt>, we also find repositories with other owners.</p>   <div class="bibStrip">    <p>This paper is published under the Creative Commons Attribution 4.0 International (CC-BY&#x00A0;4.0) license. Authors reserve their rights to disseminate the work on their personal and corporate Web sites with the appropriate attribution.</p>    <p>    <em>WWW '18, April 23-27, 2018, Lyon, France</em>    </p>    <p>&#x00A9; 2018; IW3C2 (International World Wide Web Conference Committee), published under Creative Commons CC-BY&#x00A0;4.0 License. ACM ISBN 978-1-4503-5639-8/18/04.<br/>DOI: <a class="link-inline force-break" target="_blank"     href="https://doi.org/10.1145/3178876.3186014">https://doi.org/10.1145/3178876.3186014</a>    </p>   </div>  </section>  <div class="pubHistory">   <p/>  </div> </body> </html> 
