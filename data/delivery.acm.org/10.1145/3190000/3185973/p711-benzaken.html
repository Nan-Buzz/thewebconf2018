<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">  <head>  <title>Language-Integrated Queries: a BOLDR Approach</title>  <!-- Copyright (c) 2010-2015 The MathJax Consortium --><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>  <meta name="viewport" content="width=device-width; initial-scale=1.0;"></meta>  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>  <link media="screen, print" rel="stylesheet"    href="https://dl.acm.org/pubs/lib/css/bootstrap.min.css"/><link media="screen, print" rel="stylesheet"    href="https://dl.acm.org/pubs/lib/css/bootstrap-theme.min.css"/><link media="screen, print" rel="stylesheet"    href="https://dl.acm.org/pubs/lib/css/main.css"/><script src="https://dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script>  <script src="https://dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script>  <script src="https://dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script>  <script src="https://dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script>  <script type="text/javascript"    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>  <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>  </head>  <body id="main">  <section class="front-matter">   <section>    <header class="title-info">     <div class="journal-title">     <h1>      <span class="title">Language-Integrated Queries: a BOLDR Approach</span>      <br/>      <span class="subTitle"/>     </h1>     </div>    </header>    <div class="authorGroup">     <div class="author">     <span class="givenName">V&#x00E9;ronique</span>      <span class="surName">Benzaken</span>,     Universit&#x00E9; Paris-Sud, France     </div>     <div class="author">     <span class="givenName">Giuseppe</span>      <span class="surName">Castagna</span>,     CNRS, Univ Paris Diderot, France     </div>     <div class="author">     <span class="givenName">Laurent</span>      <span class="surName">Daynes</span>,     Oracle France, France     </div>     <div class="author">     <span class="givenName">Julien</span>      <span class="surName">Lopez</span>,     Universit&#x00E9; Paris-Sud, France     </div>     <div class="author">     <span class="givenName">Kim</span>      <span class="surName">Nguy&#x1EC5;n</span>,     Universit&#x00E9; Paris-Sud, France     </div>     <div class="author">     <span class="givenName">Romain</span>      <span class="surName">Vernoux</span>,     ENS Paris-Saclay, France     </div>                             </div>    <br/>    <div class="pubInfo">     <p>DOI: <a href="https://doi.org/10.1145/3184558.3185973" target="_blank">https://doi.org/10.1145/3184558.3185973</a>     <br/>WWW '18: <a href="https://doi.org/10.1145/3184558" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p>    </div>    <div class="abstract">     <p>     <small>We present BOLDR, a modular framework that enables the evaluation in databases of queries containing application logic and, in particular, user-defined functions. BOLDR also allows the nesting of queries for different databases of possibly different data models. The framework detects the boundaries of queries present in an application, translates them into an intermediate representation together with the relevant language environment, rewrites them in order to avoid query avalanches and to make the most out of database optimizations, and converts the results back to the application. Our experiments show that the techniques we implemented are applicable to real-world database applications, successfully handling a variety of language-integrated queries with good performances.</small>     </p>    </div>    <div class="classifications">     <div class="author">     <span style="font-weight:bold;">      <small>Keywords:</small>     </span>     <span class="keyword">      <small>Language-integrated queries</small>, </span>     <span class="keyword">      <small> databases</small>, </span>     <span class="keyword">      <small> data-centric languages</small>, </span>     <span class="keyword">      <small> R</small>     </span>     </div>     <br/>     <div class="AcmReferenceFormat">     <p>      <small>       <span style="font-weight:bold;">ACM Reference Format:</span>       <br/>       V&#x00E9;ronique Benzaken, Giuseppe Castagna, Laurent Daynes, Julien Lopez, Kim Nguy&#x1EC5;n, and Romain Vernoux. 2018. Language-Integrated Queries: a BOLDR Approach. In <em>WWW '18 Companion: The 2018 Web Conference Companion,</em>       <em>April 23&#x2013;27, 2018,</em>       <em> Lyon, France. ACM, New York, NY, USA</em> 10 Pages. <a href="https://doi.org/10.1145/3184558.3185973" class="link-inline force-break"        target="_blank">https://doi.org/10.1145/3184558.3185973</a></small>     </p>     </div>    </div>   </section>  </section>  <section class="body">   <section id="sec-7">    <header>     <div class="title-info">     <h2>      <span class="section-number">1</span> Introduction</h2>     </div>    </header>    <p>The increasing need for sophisticated data analysis encourages the use of programming languages that either better fit a specific task (e.g., R or Python for statistical analysis and data mining) or manipulate specific data formats (e.g., JavaScript for JSON). Support for data analysis in data processing platforms cannot follow the pace of innovation sustained by these languages. Therefore, databases are working on supporting these languages: Oracle R Enterprise&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0018">18</a>], and PL/R for R; PL/Python&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0019">19</a>], Amazon Redshift&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0002">2</a>], Hive&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0003">3</a>], and SPARK&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0004">4</a>] for Python; or MongoDB&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0014">14</a>] and Cassandra&#x0027;s CQL&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0005">5</a>] for JavaScript. APIs for these embedded languages are low-level, and data is accessed by custom operations, yielding non-portable code. In opposite to this ad hoc approach, language-integrated querying, popularized with Microsoft&#x0027;s LINQ framework&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0013">13</a>], proposes to extend programming languages with a querying syntax and to represent external data in the model of the language, thus shielding programmers from having to learn the syntax or data model of databases. To that end, LINQ exposes the language to a set of <em>standard query operators</em> that external data providers must implement. However, LINQ suffers from a key limitation: queries can only execute if they can be translated into this set of operators. For instance, the LINQ query</p>    <p>     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic1.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>which is intended to return the set of all employees which salary converted in USD is greater than 2000, will throw an error at runtime since LINQ fails to translate the function <tt>getRate</tt>to an equivalent database expression. One solution is to define <tt>getRate</tt> in the database, but this hinders portability and may not be possible at all if the function references runtime values of the language. A more common workaround is to rewrite the code as follows:</p>    <p>     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic2.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>But this hides huge performance issues: all the data is imported in the runtime of the language, potentially causing important network delays and out-of-memory errors, and the filter is evaluated in main memory thus neglecting all possible database optimizations.</p>    <p>In this work, we introduce BOLDR (<strong>B</strong>reaking boundaries <strong>O</strong>f <strong>L</strong>anguage and <strong>D</strong>ata <strong>R</strong>epresentations), a language-integrated query framework that allows arbitrary expressions from the <em>host language</em> (language from which the query comes from) to occur in queries and be evaluated in a database, thus lifting a key limitation of the existing solutions. Additionally, BOLDR is tied neither to a particular combination of database and programming language, nor to querying only one database at a time: for instance, BOLDR allows a NoSQL query targeting a HBase server to be nested in a SQL query targeting a relational database. BOLDR first translates queries into a <strong>Q</strong>uery <strong>I</strong>ntermediate <strong>R</strong>epresentation (or QIR for short), an untyped <em>&#x03BB;</em>-calculus with data-manipulation builtin operators, then applies a normalization process that may perform a partial evaluation of the QIR expression. This partial evaluation composes distinct queries that may occur separated in the code of the host language into larger queries, thus reducing the communication overhead between the client runtime and the database and allowing databases to perform whole query optimizations. Finally, BOLDR translates and sends the queries to the targeted databases.</p>    <p>Consider again our LINQ query containing the call to <tt>getRate</tt>. In BOLDR, its translation produces a QIR expression according to three different scenarios: (<em>i</em>)&#x00A0;if <tt>getRate</tt> can be translated into the query language of the targeted database, then the whole expression is translated into a single query expressed in the query language of the targeted database; (<em>ii</em>)&#x00A0;if <tt>getRate</tt> cannot be entirely translated but contains one or several queries that can be translated, then BOLDR produces the corresponding translated subqueries and sends them to their respective databases, and combines the results at QIR level; (<em>iii</em>)&#x00A0;if <tt>getRate</tt> cannot be translated at all, then BOLDR creates a query containing the serialized host language abstract syntax tree of <tt>getRate</tt> to be potentially executed on the database side. <figure id="fig1">     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-fig1.jpg" class="img-responsive" alt="Figure 1"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 1:</span>      <span class="figure-title">Evaluation of a BOLDR host language program</span>     </div>     </figure>    </p>    <p>Our implementation of BOLDR uses Truffle&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0023">23</a>], a framework developed by Oracle Labs to implement programming languages. Several features make Truffle appealing to BOLDR: first, Truffle implementations of languages must compile to an executable abstract syntax tree that BOLDR can directly manipulate; second, languages implemented with Truffle can be executed on any JVM, making their addition as an external language effortless in databases written in Java (e.g., Cassandra, HBase, ...), and relatively simple in others such as PostgreSQL. Third, work on one Truffle language can easily be transposed to other Truffle languages.</p>    <p>Our implementation currently supports the <em>PostgreSQL</em>, <em>HBase</em> and <em>Hive</em> databases, as well as <em>FastR</em>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0017">17</a>] (Truffle implementation of the R language) and Oracle&#x0027;s <em>SimpleLanguage</em> (a dynamic language with syntax and features inspired by JavaScript). The following R program illustrates the key aspects of BOLDR:</p>    <p>     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic4.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>This example is a standard R program with two exceptions: the function <tt>tableRef</tt> (Line&#x00A0;4 and 11) referencing an external source in lieu of creating a data frame (R implementation of tables) from a text file; and the function <tt>executeQuery</tt> (Line&#x00A0;16 and 17) that evaluates a query. We recall that in R, the <tt>c</tt> function creates a vector, the <tt>subset</tt> function filters a table using a predicate, and optionally keeps only the specified columns. The first function <tt>getRate</tt> takes the code of two currencies and queries a table using <tt>subset</tt>to get their exchange rate. The second function <tt>atLeast</tt>takes a minimum salary and a currency code and retrieves the names of the employees earning at least the minimal salary. Since the salary is stored in dollars in the database, the <tt>getRate</tt> function is used to perform the conversion.</p>    <p>In BOLDR, <tt>subset</tt> is overloaded to build an intermediate query representation if applied on an external source reference. The first call to <tt>atLeast(2000, &#x201D;USD&#x201D;)</tt> builds a query and captures the variables in the local scope. When <tt>executeQuery</tt> is called, then (<em>i</em>) the intermediate query is <em>normalized</em>, inlining all bound variables with their values; (<em>ii</em>) the normalized query is translated into the target database language (here SQL); and (<em>iii</em>) the resulting query is evaluated in the database and the results are sent back. After normalization and translation, the query generated for the first call on Line&#x00A0;14 is:</p>    <p>     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic5.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>which is optimal, in the sense that a single SQL query is generated. The code generated for the second call is also optimal thanks to the interplay between lazy building of the query and normalization:</p>    <p>     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic6.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>Therefore, BOLDR not only supports user-defined functions (UDFs) in queries, it also merges subqueries together to create fewer and larger queries, thus benefiting from database optimizations and avoiding the &#x201C;query avalanche&#x201D; phenomenon&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0012">12</a>].</p>    <p>While similar approaches exist (see Section&#x00A0;<a class="sec" href="#sec-18">8</a> on related work), BOLDR outperforms them on UDFs that cannot be completely translated. For instance, consider:</p>    <p>     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic7.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>This function builds an in-memory data frame using the builtin function <tt>data.frame</tt>. BOLDR cannot translate it to QIR since it calls the underlying runtime, so instead it generates the following query:</p>    <p>     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic8.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>where the string <tt>&#x201D;@...&#x201D;</tt> is a reference to a closure for <tt>getRate</tt>.</p>    <p>Mixing different data sources is supported, although less efficiently. For instance, we could refer to an HBase table in the function <tt>getRate</tt>. BOLDR would still be able to evaluate the query by sending a subquery to both the HBase and PostgreSQL databases, and by executing in main memory what could not be translated.</p>    <p>The general flow of query evaluation in BOLDR is described in Figure <a class="fig" href="#fig1">1</a>. During the evaluation&#x00A0;1 of a host program, QIR terms are lazily accumulated. Their evaluation, when triggered, is delegated to the QIR runtime&#x00A0;2 that normalizes&#x00A0;3 the QIR terms to defragment them, then translates&#x00A0;4 them to new QIR terms that contain database language queries (e.g., in SQL). Next, the pieces of these terms are evaluated where they belong, either in main-memory&#x00A0;5 or in a database&#x00A0;7. &#x201C;Frozen&#x201D; host language expressions occurring in these terms are evaluated either by the runtime of the host language that called the QIR evaluation&#x00A0;6, or in the runtime embedded in a target database&#x00A0;8. Results are then translated from the database to QIR&#x00A0;9, then from QIR to the host language&#x00A0;10. <strong>Overview and Contributions</strong>. In this work, we introduce BOLDR, a multi-language framework for integrated queries with a unique combination of features such as the possibility of executing user-defined functions in databases, of partially evaluating and merging distinct query fragments, and of defining single queries that operate on data from different data sources. Our technical developments are organized as follows. We first give a formal definition of QIR (Section&#x00A0;<a class="sec" href="#sec-9">3</a>). We then present the translation from QIR to query languages and focus on a translation from QIR to SQL, as well as a type system ensuring that well-typed queries translate into SQL and are avalanche-free (Section&#x00A0;<a class="sec" href="#sec-12">4</a>). We continue by presenting a normalization procedure on the QIR to optimize the translation of a query (Section&#x00A0;<a class="sec" href="#sec-15">5</a>). We next describe the translation from the host language R to QIR (Section&#x00A0;<a class="sec" href="#sec-16">6</a>). Finally, we discuss experimental results (Section&#x00A0;<a class="sec" href="#sec-17">7</a>) of our implementation that supports the languages R and SimpleLanguage and the databases PostgreSQL, HBase and Hive. We show that queries generated by BOLDR perform on a par with hand-written ones, and that UDFs can be efficiently executed in a corresponding runtime embedded in a target database.</p>   </section>   <section id="sec-8">    <header>     <div class="title-info">     <h2>      <span class="section-number">2</span> Definitions</h2>     </div>    </header>    <p>We give some basic definitions used throughout the presentation.</p>    <p>     <div class="definition" id="enc1">     <Label>Definition 2.1 (Host language).</Label>     <p> A <em>host language</em>      <span class="inline-equation"><span class="tex">$\mathcal {H}$</span>      </span> is a 4-tuple <span class="inline-equation"><span class="tex">$(\mathsf {E}_{\mathcal {H}}, \mathsf {I}_{\mathcal {H}}, \mathsf {V}_{\mathcal {H}}, {\stackrel{{\scriptscriptstyle \mathcal {H}}}{\rightarrow }})$</span>      </span> where:</p>     <p>      <ul class="list-no-style">       <li id="list1" label="&#x2022;"><span class="inline-equation"><span class="tex">$\mathsf {E}_{\mathcal {H}}$</span>        </span> is a set of <em>syntactic expressions</em>        <br/></li>       <li id="list2" label="&#x2022;"><span class="inline-equation"><span class="tex">$\mathsf {I}_{\mathcal {H}}$</span>        </span> is a set of <em>variables</em>, <span class="inline-equation"><span class="tex">$\mathsf {I}_{\mathcal {H}}\subset \mathsf {E}_{\mathcal {H}}$</span>        </span>        <br/></li>       <li id="list3" label="&#x2022;"><span class="inline-equation"><span class="tex">$\mathsf {V}_{\mathcal {H}}$</span>        </span> is a set of <em>values</em>        <br/></li>       <li id="list4" label="&#x2022;"><span class="inline-equation"><span class="tex">$\,{\stackrel{{\scriptscriptstyle \mathcal {H}}}{\rightarrow }}\,: 2^{\mathsf {I}_{\mathcal {H}}\times \mathsf {V}_{\mathcal {H}}} \times \mathsf {E}_{\mathcal {H}} \rightarrow 2^{\mathsf {I}_{\mathcal {H}}\times \mathsf {V}_{\mathcal {H}}} \times \mathsf {V}_{\mathcal {H}}$</span>        </span>, is the <em>evaluation function</em>        <br/></li>      </ul>     </p>     </div>    </p>    <p>We abstract a host language <span class="inline-equation"><span class="tex">$\mathcal {H}$</span>     </span> by reducing it to its bare components: a syntax given by a set of expressions <span class="inline-equation"><span class="tex">$\mathsf {E}_{\mathcal {H}}$</span>     </span>, a set of variables <span class="inline-equation"><span class="tex">$\mathsf {I}_{\mathcal {H}}$</span>     </span>, and a set of values <span class="inline-equation"><span class="tex">$\mathsf {V}_{\mathcal {H}}$</span>     </span>. Lastly we assume that the semantics of <span class="inline-equation"><span class="tex">$\mathcal {H}$</span>     </span> is given by a partial evaluation function <span class="inline-equation"><span class="tex">${\stackrel{{\scriptscriptstyle \mathcal {H}}}{\rightarrow }}$</span>     </span>. This function takes an evaluation <em>environment</em> (a set of pairs of variables and values, ranged over by <em>&#x03C3;</em>) and an expression and returns a new environment and a value resulting from the evaluation of the input expression. To integrate a host language we need to be able to manipulate syntactic expressions of the language, inspect and build <em>environments</em>, and have access to an <em>interpreter</em> for the language.</p>    <p>     <div class="definition" id="enc2">     <Label>Definition 2.2 (Database language).</Label>     <p> A <em>database language</em>      <span class="inline-equation"><span class="tex">$\mathcal {D}$</span>      </span> with support for a host language <span class="inline-equation"><span class="tex">$\mathcal {H}$</span>      </span> is a 4-tuple <span class="inline-equation"><span class="tex">$(\mathsf {E}_{\mathcal {D}},\mathsf {V}_{\mathcal {D}},\mathsf {O}_{\mathcal {D}},{\stackrel{{\scriptscriptstyle \mathcal {D}}}{\rightarrow }})$</span>      </span> where:</p>     <p>      <ul class="list-no-style">       <li id="list5" label="&#x2022;"><span class="inline-equation"><span class="tex">$\mathsf {E}_{\mathcal {D}}$</span>        </span> is a set of <em>syntactic expressions</em>        <br/></li>       <li id="list6" label="&#x2022;"><span class="inline-equation"><span class="tex">$\mathsf {V}_{\mathcal {D}}$</span>        </span> is a set of <em>values</em>        <br/></li>       <li id="list7" label="&#x2022;"><span class="inline-equation"><span class="tex">$\mathsf {O}_{\mathcal {D}}$</span>        </span> is a set of <em>supported data operators</em>        <br/></li>       <li id="list8" label="&#x2022;"><span class="inline-equation"><span class="tex">$\,{\stackrel{{\scriptscriptstyle \mathcal {D}}}{\rightarrow }}: 2^{\mathsf {I}_{\mathcal {H}}\times \mathsf {V}_{\mathcal {H}}}\times \mathsf {E}_{\mathcal {D}} \rightarrow 2^{\mathsf {I}_{\mathcal {H}}\times \mathsf {V}_{\mathcal {H}}}\times \mathsf {V}_{\mathcal {D}}$</span>        </span> is the <em>evaluation function</em>        <br/></li>      </ul>     </p>     </div>    </p>    <p>Similarly to host languages, we abstract a database language <span class="inline-equation"><span class="tex">$\mathcal {D}$</span>     </span> as a syntax <span class="inline-equation"><span class="tex">$\mathsf {E}_{\mathcal {D}}$</span>     </span>, a set of values <span class="inline-equation"><span class="tex">$\mathsf {V}_{\mathcal {D}}$</span>     </span>, and an evaluation function <span class="inline-equation"><span class="tex">${\stackrel{{\scriptscriptstyle \mathcal {D}}}{\rightarrow }}$</span>     </span> which takes an <span class="inline-equation"><span class="tex">$\mathcal {H}$</span>     </span> environment and a database expression and returns a new <span class="inline-equation"><span class="tex">$\mathcal {H}$</span>     </span> environment and a database value. Such an evaluation function allows us to abstract the behavior of modern databases that support queries containing foreign function calls. Last, but not least, a database language exposes the set <span class="inline-equation"><span class="tex">$\mathsf {O}_{\mathcal {D}}$</span>     </span> of data operators it supports, which will play a crucial role in building queries that can be efficiently executed by a database back-end.</p>   </section>   <section id="sec-9">    <header>     <div class="title-info">     <h2>      <span class="section-number">3</span> Query Intermediate Representation</h2>     </div>    </header>    <section id="sec-10">     <header>     <div class="title-info">      <h3>       <span class="section-number">3.1</span> Core calculus</h3>     </div>     </header>     <p>In this section, we define our Query Intermediate Representation, a <em>&#x03BB;</em>-calculus with recursive functions, constants, basic operations, data structures, data operators, and foreign language expressions.</p>     <div class="definition" id="enc3">     <Label>Definition 3.1.</Label>     <p> Given a countable set of variables <span class="inline-equation"><span class="tex">$\mathsf {I}_{\mathcal {\texttt {QIR}}}$</span>      </span>, we define the set of QIR <em>expressions</em>, denoted by <span class="inline-equation"><span class="tex">$\mathsf {E}_{\mathcal {\texttt {QIR}}}$</span>      </span> and ranged over by <em>q</em>, as the set of finite productions of the following grammar:</p>     <p>      <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic9.jpg" class="img-responsive" alt=""       longdesc=""/>     </p>     <p>where <span class="inline-equation"><span class="tex">$\mathcal {H}$</span>      </span> is a host language.</p>     </div>     <p>Besides lambda-terms, QIR expressions include constants (integers, strings, ...), and some builtin operations (arithmetic operations, ...). The data model consists of records and sequences. Records are deconstructed through field projections. Sequences are deconstructed by the <em>list matching</em>destructor whose four arguments are: the list to destruct, a pattern that binds the head and the tail of the list to variables, the term to evaluate (with the bound variables in scope) when the list is not empty, and the term to return when the list is empty. The new additions to these mundane constructs are <em>database operators</em> and <em>host language expressions</em>. A database operator <span class="inline-equation"><span class="tex">$o {\langle } q_1\ldots ,q_n {\mid } q_1^{\prime },\ldots ,q_m^{\prime } {\rangle }$</span>     </span> is similar to the notion of operator in the relational algebra. Its arguments are divided in two groups: the <em>q<sub>i</sub>     </em> expressions are called <em>configurations</em>and influence the behavior of the operator; the <span class="inline-equation"><span class="tex">$q_i^{\prime }$</span>     </span> expressions are the sub-collections that are operated on. Finally, a host expression <span class="inline-equation"><span class="tex">$\blacksquare _{\mathcal {H}}(\sigma {}, e)$</span>     </span> is an opaque construct that contains an evaluation environment <em>&#x03C3;</em> and an expression <em>e</em> of the host language <span class="inline-equation"><span class="tex">$\mathcal {H}$</span>     </span>. We use the following syntactic shortcuts:</p>     <ul class="list-no-style">     <li id="list9" label="&#x2022;">[&#x2009;<em>q</em>      <sub>1</sub>, &#x2026;, <em>q<sub>n</sub>      </em>&#x2009;] stands for <span class="inline-equation"><span class="tex">$q_1\bf \,::\,{} \ldots \bf \,::\,{} q_n \bf \,::\,{} {[}\,\,{ {]}}$</span>      </span>      <br/></li>     <li id="list10" label="&#x2022;"><span class="inline-equation"><span class="tex">$\bf fun^{f}{\bf (}x_1,\ldots ,x_n{\bf)}{ {\rightarrow }}q$</span>      </span> stands for <span class="inline-equation"><span class="tex">$\bf fun^{f}{\bf (}x_1{\bf)}{ {\rightarrow }}(\ldots (\bf fun^{f}{\bf (}x_n{\bf)}{ {\rightarrow }}q))$</span>      </span>      <br/></li>     <li id="list11" label="&#x2022;"><em>q</em>&#x2009;(<em>q</em>      <sub>1</sub>, &#x2026;, <em>q<sub>n</sub>      </em>) stands for (&#x2026;(<em>q</em>&#x2009;      <em>q</em>      <sub>1</sub>)&#x2026;)&#x2009;<em>q<sub>n</sub>      </em>      <br/></li>     </ul>     <p>Functions can be defined recursively by using the recursion variable that indexes the <strong>fun</strong> keyword, that we omit when useless.</p>     <div class="definition" id="enc4">     <Label>Definition 3.2 (Reduction rules).</Label>     <p> Let <span class="inline-equation"><span class="tex">$\rightarrow ^\delta \subset \mathsf {E}_{\mathcal {\textsf {QIR}}}\times \mathsf {E}_{\mathcal {\textsf {QIR}}}$</span>      </span> be a reduction relation for basic operators and <span class="inline-equation"><span class="tex">$\rightarrow \subset \mathsf {E}_{\mathcal {\textsf {QIR}}}\times \mathsf {E}_{\mathcal {\textsf {QIR}}}$</span>      </span> be the reduction relation defined by:</p>     <p>      <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic10.jpg" class="img-responsive" alt=""       longdesc=""/>     </p>     <p>where <em>q</em>{<em>x</em>      <sub>1</sub>/<em>q</em>      <sub>1</sub>, &#x2026;, <em>x<sub>n</sub>      </em>/<em>q<sub>n</sub>      </em>} denotes the standard capture avoiding substitution. We define the reduction relation of QIR expressions as the context closure of the relation &#x2192; <sup>       <em>&#x03B4;</em>      </sup>&#x222A; &#x2192; .</p>     </div>     <p>Crucially, embedded host expressions as well as database operator applications whose arguments are all reduced are irreducible.</p>    </section>    <section id="sec-11">     <header>     <div class="title-info">      <h3>       <span class="section-number">3.2</span> Extended semantics</h3>     </div>     </header>     <p>We next define how to interface host languages and databases with QIR. We introduce the notion of <em>driver</em>, a set of functions that translate values from one world to another.</p>     <div class="definition" id="enc5">     <Label>Definition 3.3 (Language driver).</Label>     <p> Let <span class="inline-equation"><span class="tex">$\mathcal {H}$</span>      </span> be a host language. A <em>language driver</em> for <span class="inline-equation"><span class="tex">$\mathcal {H}$</span>      </span> is a 3-tuple <span class="inline-equation"><span class="tex">$(^{\mathcal {H}}\overrightarrow{\texttt {EXP}}, \overrightarrow{\texttt {VAL}}^{\mathcal {H}}, ^{\mathcal {H}}\overrightarrow{\texttt {VAL}})$</span>      </span> of total functions such that:</p>     <p>      <ul class="list-no-style">       <li id="list12" label="&#x2022;"><span class="inline-equation"><span class="tex">$^{\mathcal {H}}\overrightarrow{\texttt {EXP}} : 2^{\mathsf {I}_{\mathcal {H}}\times \mathsf {V}_{\mathcal {H}}}\times \mathsf {E}_{\mathcal {\mathcal {H}}}\rightarrow \mathsf {E}_{\mathcal {\textsf {QIR}}} \cup \lbrace \Omega \rbrace$</span>        </span> takes an <span class="inline-equation"><span class="tex">$\mathcal {H}$</span>        </span> environment and an <span class="inline-equation"><span class="tex">$\mathcal {H}$</span>        </span> expression and translates the expression into QIR<br/></li>       <li id="list13" label="&#x2022;"><span class="inline-equation"><span class="tex">$\overrightarrow{\texttt {VAL}}^{\mathcal {H}} : \mathsf {V}_{\mathcal {\textsf {QIR}}} \rightarrow \mathsf {V}_{\mathcal {H}}\cup \lbrace \Omega \rbrace$</span>        </span> translates QIR values to <span class="inline-equation"><span class="tex">$\mathcal {H}$</span>        </span> values<br/></li>       <li id="list14" label="&#x2022;"><span class="inline-equation"><span class="tex">$^{\mathcal {H}}\overrightarrow{\texttt {VAL}} : \mathsf {V}_{\mathcal {H}} \rightarrow \mathsf {V}_{\mathcal {\textsf {QIR}}} \cup \lbrace \Omega \rbrace$</span>        </span> translates <span class="inline-equation"><span class="tex">$\mathcal {H}$</span>        </span> values to QIR values<br/></li>      </ul>     </p>     <p>where the special value <em>&#x03A9;</em> denotes a failure to translate.</p>     </div>     <div class="definition" id="enc6">     <Label>Definition 3.4.</Label>     <p> (Database driver) Let <span class="inline-equation"><span class="tex">$\mathcal {D}$</span>      </span> be a database language. A <em>database driver</em> for <span class="inline-equation"><span class="tex">$\mathcal {D}$</span>      </span> is a 3-tuple <span class="inline-equation"><span class="tex">$(\overrightarrow{\textsf {EXP}}^{\mathcal {D}}, \overrightarrow{\texttt {VAL}}^{\mathcal {D}}, ^{\mathcal {D}}\overrightarrow{\texttt {VAL}})$</span>      </span> of total functions such that:</p>     <p>      <ul class="list-no-style">       <li id="list15" label="&#x2022;"><span class="inline-equation"><span class="tex">$\overrightarrow{\textsf {EXP}}^{\mathcal {D}} : \mathsf {E}_{\mathcal {\textsf {QIR}}}\rightarrow \mathsf {E}_{\mathcal {\mathcal {D}}} \cup \lbrace \Omega \rbrace$</span>        </span> translates a QIR expression into <span class="inline-equation"><span class="tex">$\mathcal {D}$</span>        </span>        <br/></li>       <li id="list16" label="&#x2022;"><span class="inline-equation"><span class="tex">$\overrightarrow{\texttt {VAL}}^{\mathcal {D}} : \mathsf {V}_{\mathcal {\textsf {QIR}}} \rightarrow \mathsf {V}_{\mathcal {D}}\cup \lbrace \Omega \rbrace$</span>        </span> translates QIR values to <span class="inline-equation"><span class="tex">$\mathcal {D}$</span>        </span> values<br/></li>       <li id="list17" label="&#x2022;"><span class="inline-equation"><span class="tex">$^{\mathcal {D}}\overrightarrow{\texttt {VAL}} : \mathsf {V}_{\mathcal {D}} \rightarrow \mathsf {V}_{\mathcal {\textsf {QIR}}} \cup \lbrace \Omega \rbrace$</span>        </span> translates <span class="inline-equation"><span class="tex">$\mathcal {D}$</span>        </span> values to QIR values<br/></li>      </ul>     </p>     <p>where the special value <em>&#x03A9;</em> denotes a failure to translate.</p>     </div>     <p>We are now equipped to define the semantics of QIR terms, extended to host expressions and database operators.</p>     <div class="definition" id="enc7">     <Label>Definition 3.5 (Extended QIR semantics).</Label>     <p> Let <span class="inline-equation"><span class="tex">$\mathcal {H}$</span>      </span> be a host language, <span class="inline-equation"><span class="tex">$(^{\mathcal {H}}\overrightarrow{\texttt {EXP}},\overrightarrow{\texttt {VAL}}^{\mathcal {H}}, ^{\mathcal {H}}\overrightarrow{\texttt {VAL}})$</span>      </span> a driver for <span class="inline-equation"><span class="tex">$\mathcal {H}$</span>      </span>, <span class="inline-equation"><span class="tex">$\mathcal {D}$</span>      </span> a database language, and <span class="inline-equation"><span class="tex">$(\overrightarrow{\textsf {EXP}}^{\mathcal {D}}, \overrightarrow{\texttt {VAL}}^{\mathcal {D}}, ^{\mathcal {D}}\overrightarrow{\texttt {VAL}})$</span>      </span> a driver for <span class="inline-equation"><span class="tex">$\mathcal {D}$</span>      </span>. We define the extended semantics <em>&#x03C3;</em>, <em>q</em>&#x21A0;<em>&#x03C3;</em>&#x2032;, <em>q</em>&#x2032; of QIR by the following set of rules:</p>     <p>      <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic11.jpg" class="img-responsive" alt=""       longdesc=""/>     </p>     </div>     <p>Since QIR is an intermediate language from a host language to a database language, the evaluation of QIR terms will always be initiated from the host language runtime. It is therefore natural for the extended semantics to evaluate a QIR term in a given host language environment. If this QIR term is neither a database operator nor a host language expression, then the simple semantics of Definition&#x00A0;<a class="enc" href="#enc4">3.2</a> is used to evaluate the term, otherwise the extended semantics of Definition&#x00A0;<a class="enc" href="#enc7">3.5</a> is used. Host expressions are evaluated using the evaluation relation of the host language in the environment formed by the union of the current running environment and the captured environment. This allows us to simulate the behavior of most dynamic languages (in particular R, Python, and JavaScript) that allow a function to reference an undefined global variable as long as it is defined when the function is called. Last, but not least, the evaluation of a database operator consists in <em>(i)</em> finding a database language that supports this operator, <em>(ii)</em> use the database driver for that language to translate the QIR term into a native query, <em>(iii)</em> use the evaluation function of the database to evaluate the query, and <em>(iv)</em> translate the results back into QIR.</p>     <p>At this stage, we have defined a perfectly viable Query Intermediate Representation in the form of a <em>&#x03BB;</em>-calculus extended with data operators. We next address the two following problems:</p>     <ol class="list-no-style">     <li id="list18" label="(1)">How to create database drivers in practice?<br/></li>     <li id="list19" label="(2)">How to avoid query avalanches as much as possible?<br/></li>     </ol>    </section>   </section>   <section id="sec-12">    <header>     <div class="title-info">     <h2>      <span class="section-number">4</span> Database translation</h2>     </div>    </header>    <p>In this section, we describe how a database driver can define a translation from QIR to a database language. This translation must be able to translate QIR expressions into equivalent efficient queries of a database language, and handle QIR expressions in which subterms target different databases. Additionally, it must be seamlessly extendable with new database drivers. To that end, we separate this translation in two phases: a <em>generic</em> translation that determines the targeted query language for all subterms of a QIR expression, and a <em>specific</em> translation that makes use of database drivers.</p>    <section id="sec-13">     <header>     <div class="title-info">      <h3>       <span class="section-number">4.1</span> Generic translation</h3>     </div>     </header>     <p>The goal of the generic translation is to produce a QIR expression where as many subterms as possible have been translated into native database queries. Ideally, we want the whole QIR expression to be translated into a single database query, but this is not always possible and, in that case, parts of the expression have to be evaluated in the client side (where the QIR runtime resides). The QIR evaluator therefore relies on two components. First, a &#x201C;fallback&#x201D; implementation of QIR operators using the QIR itself, that we dub MEM for in-memory evaluation. MEM is a trivial database language for which the translations to and from the QIR are the identity function, and that supports the operators <span class="inline-equation"><span class="tex">$\texttt {Filter}$</span>     </span>, <span class="inline-equation"><span class="tex">$\texttt {Project}$</span>     </span>, and <span class="inline-equation"><span class="tex">$\texttt {Join}$</span>     </span> defined as plain QIR recursive functions. The full definition of MEM is straightforward and given in Appendix&#x00A0;. Second, to allow the QIR evaluator to send queries to a database and translate the results back into QIR values, we assume that for each supported database language <span class="inline-equation"><span class="tex">$\mathcal {D}\in \mathbb {D}$</span>     </span>, we have a basic QIR operator, <span class="inline-equation"><span class="tex">$\texttt {eval}^{\mathcal {D}}$</span>     </span> defined as:</p>     <p>     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic13.jpg" class="img-responsive" alt=""       longdesc=""/>     </p>     <p>Notice that in the case of the MEM language, the operator <span class="inline-equation"><span class="tex">$\texttt {eval}^{\textsf {MEM}}$</span>     </span> is simply the reduction of a QIR term.</p>     <p>The generic translation is given by the judgment <span class="inline-equation"><span class="tex">$q\,\leadsto \,e,\mathcal {D}$</span>     </span> where <span class="inline-equation"><span class="tex">$q\in \mathsf {E}_{\mathcal {\textsf {QIR}}}$</span>     </span> and <span class="inline-equation"><span class="tex">$e\in \mathsf {E}_{\mathcal {D}}\cup \lbrace \Omega \rbrace$</span>     </span>, which means a QIR expression <em>q</em> can either be rewritten into an expression <em>e</em> of the language <span class="inline-equation"><span class="tex">$\mathsf {E}_{\mathcal {D}}$</span>     </span> of the database <span class="inline-equation"><span class="tex">$\mathcal {D}$</span>     </span>, or fail when <em>e</em> = <em>&#x03A9;</em>. An excerpt of the set of inference rules used to derive this judgment is given in Figure&#x00A0;<a class="fig" href="#fig2">2</a>. Rule (db-op) states that given a database operator, if there exists a database <span class="inline-equation"><span class="tex">$\mathcal {D}$</span>     </span> distinct from MEM such that all data arguments can be translated into expressions of <span class="inline-equation"><span class="tex">$\mathsf {E}_{\mathcal {D}}$</span>     </span>, then if the specific translation <span class="inline-equation"><span class="tex">$\overrightarrow{\textsf {EXP}}^{\mathcal {D}}$</span>     </span> called on the operator yields a fully translated <span class="inline-equation"><span class="tex">$\mathsf {E}_{\mathcal {D}}$</span>     </span> expression <em>e</em>, then <em>e</em> is returned as a translation in <span class="inline-equation"><span class="tex">$\mathsf {E}_{\mathcal {D}}$</span>     </span>. This rule may fail in two cases: the data arguments of the operator could be translated to more than one database language; or the specific translation for <span class="inline-equation"><span class="tex">$\mathsf {E}_{\mathcal {D}}$</span>     </span> could yield an error <em>&#x03A9;</em> even if all data arguments of the operator have been successfully translated into expressions of the same language <span class="inline-equation"><span class="tex">$\mathsf {E}_{\mathcal {D}}$</span>     </span>, for instance, when the operator is not supported by <span class="inline-equation"><span class="tex">$\mathcal {D}$</span>     </span>, or when the specific translation of a configuration <em>q<sub>i</sub>     </em> fails. If the operator <em>o</em> at issue is one of the supported operators of MEM, then both cases are handled by the rule (mem-op): each translated subexpression <em>e<sub>i</sub>     </em> is wrapped in a call to the <span class="inline-equation"><span class="tex">$\texttt {eval}^{\mathcal {D}_i}$</span>     </span> operator and <em>o</em> is evaluated with its MEM semantics. All the other rules are bureaucratic and propagate the translation recursively to subterms.</p>    <figure id="fig2">     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-fig2.jpg" class="img-responsive" alt="Figure 2"      longdesc=""/>     <div class="figure-caption">     <span class="figure-number">Figure 2:</span>     <span class="figure-title">Some rules of the generic translation</span>     </div>    </figure>    </section>    <section id="sec-14">     <header>     <div class="title-info">      <h3>       <span class="section-number">4.2</span> Specific translation: SQL</h3>     </div>     </header>     <p>We document how to define specific translations using SQL as an example of a database language. QIR to SQL is an important translation as it allows BOLDR to target most relational databases and some distributed databases such as Hive or Cassandra. We assume that the set of values for SQL only contains basic constants (strings, numbers, Booleans, ...) and tables. The set of expressions <span class="inline-equation"><span class="tex">$\mathsf {E}_{\mathcal {\textsf {SQL}}}$</span>     </span> is the set of syntactically valid SQL queries [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0001">1</a>]. The set of supported operators <span class="inline-equation"><span class="tex">$\mathsf {O}_{\mathcal {\textsf {SQL}}}$</span>     </span> we consider is { <tt>Filter</tt>, <tt>Project</tt>, <tt>Join</tt>, <tt>From</tt>, <tt>GroupBy</tt>, <tt>Sort</tt> }. Due to space constraints, we describe these operators and the full translation from QIR to SQL in Appendix&#x00A0; and&#x00A0;. The translation from QIR to SQL is mostly straightforward. However, ensuring that it does not fail is challenging. Indeed, SQL is <em>not</em> Turing complete and relies on a flat data model: a SQL query should only deal with sequences of records whose fields have basic types. Another important aspect of this translation is to avoid query avalanche by translating as many QIR expressions as possible. <figure id="fig3">      <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-fig3.jpg" class="img-responsive" alt="Figure 3"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 3:</span>       <span class="figure-title">QIR type system for SQL</span>      </div>     </figure>     </p>     <p>We obtain these strong guarantees using an ad hoc SQL type system for QIR terms described in Figure&#x00A0;<a class="fig" href="#fig3">3</a>. This type system is straightforward, but in accordance with the semantics of SQL we require applications of basic operators and conditional expressions to take as arguments and return expressions that have basic types <em>B</em>, and data operators to take as sources flat record lists. We also use a rule to type a flat record list as a base type since SQL automatically extracts the contents of a table containing only one value (one line of one column). For instance, <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic15.jpg" class="img-responsive" alt=""       longdesc=""/> is allowed and returns 2.</p>     <p>Note that we <em>do not</em> require the host language to be statically typed. Given a QIR term <em>q</em> of type <em>T</em> in the SQL type system, we ensure that the reduction relation of Definition&#x00A0;<a class="enc" href="#enc4">3.2</a> terminates on <em>q</em> and yields a term <em>q</em>&#x2032; that has type <em>T</em>, and that if <em>q</em> is in normal form, then the generic translation of Figure&#x00A0;<a class="fig" href="#fig2">2</a> yields a single, syntactically correct SQL expression (using the translation of Appendix&#x00A0;).</p>     <p>We restrict <span class="inline-equation"><span class="tex">$\mathsf {E}_{\mathcal {\textsf {QIR}}}$</span>     </span> to non-recursive functions and by removing untranslatable terms (such as list destructors) as well as host expressions since we limit ourselves to pure queries, and by restricting data operators to <span class="inline-equation"><span class="tex">$\texttt {Project}$</span>     </span>, <span class="inline-equation"><span class="tex">$\texttt {From}$</span>     </span>, <span class="inline-equation"><span class="tex">$\texttt {Filter}$</span>     </span>, <span class="inline-equation"><span class="tex">$\texttt {Join}$</span>     </span>, <span class="inline-equation"><span class="tex">$\texttt {GroupBy}$</span>     </span>, and <span class="inline-equation"><span class="tex">$\texttt {Sort}$</span>     </span>. What we obtain is a simply typed <em>&#x03BB;</em>-calculus extended with records and sequences without recursive functions, which entails strong normalization. We also state an expected subject reduction theorem</p>     <div class="theorem" id="enc8">     <Label>Theorem 4.1 (Subject reduction).</Label>     <p> Let <span class="inline-equation"><span class="tex">$q \in \mathsf {E}_{\mathcal {\texttt {QIR}}}$</span>      </span> and <em>&#x0393;</em> an environment from QIR variables to QIR types. If <em>&#x0393;</em>&#x22A2;<em>q</em>: <em>T</em>, and <em>q</em> &#x2192; <em>q</em>&#x2032;, then <em>&#x0393;</em>&#x22A2;<em>q</em>&#x2032;: <em>T</em>.</p>     </div>     <p>and are now equipped to state our soundness of translation theorem</p>     <div class="theorem" id="enc9">     <Label>Theorem 4.2 (Soundness of translation).</Label>     <p> Let <span class="inline-equation"><span class="tex">$q \in \mathsf {E}_{\mathcal {\texttt {QIR}}}$</span>      </span> such that &#x2205;&#x22A2;<em>q</em>: <em>T</em>, <em>q</em> &#x2192; <sup>*</sup>      <em>v</em>, and <em>v</em> is in normal form. If <em>T</em> &#x2261; <em>B</em> or <em>T</em> &#x2261; <em>R</em> or <em>T</em> &#x2261; <em>R</em>&#x2009;      <strong>list</strong> then <span class="inline-equation"><span class="tex">$v\,\leadsto \,\texttt {s},\textsf {SQL}$</span>      </span>.</p>     </div>     <p>Proofs of these theorems are detailed in Appendix&#x00A0; in which we show that typable QIR terms have particular normal forms imposed by their type that can be translated into SQL expressions.</p>    </section>   </section>   <section id="sec-15">    <header>     <div class="title-info">     <h2>      <span class="section-number">5</span> QIR heuristic normalization</h2>     </div>    </header>    <p>Our guarantees only hold for a QIR query targeting one database supporting SQL. However, a QIR term may mix several databases or use features that escape the hypotheses of Theorem&#x00A0;<a class="enc" href="#enc9">4.2</a>. In particular, outside these hypotheses, we cannot guarantee the termination of the normalization. We are therefore stuck between two unsatisfactory options: either (<em>i</em>) trying to normalize the term (to fully reduce all applications) and yield the best possible term w.r.t. query translation but risk diverging, or (<em>ii</em>) translate the term as-is at the risk of introducing query avalanches. We tackle this problem with a heuristic normalization procedure that tries to reduce QIR terms enough to produce a good translation by combining subqueries.</p>    <p>To that end, we define a measure of &#x201C;good&#x201D; QIR terms, and ask that each reduction step taken yields a term with a smaller measure. To formally define this measure, we first introduce a few concepts.</p>    <p>     <div class="definition" id="enc10">     <Label>Definition 5.1 (Compatible data operator application).</Label>     <p> Let <span class="inline-equation"><span class="tex">$\mathbb {D}$</span>      </span> be the set of database languages. A QIR data operator <span class="inline-equation"><span class="tex">$o {\langle } q_1,\ldots ,q_n {\mid } q_1^{\prime },\ldots , q_m^{\prime } {\rangle }$</span>      </span> is a <em>compatible operator application</em> if and only if:</p>     <p>      <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic16.jpg" class="img-responsive" alt=""       longdesc=""/>     </p>     </div>    </p>    <p>Intuitively, a compatible data operator application is one where the configuration arguments are in a form that is accepted by the specific translation of the database language <span class="inline-equation"><span class="tex">$\mathcal {D}$</span>     </span>. We now define the related notion of <em>fragment</em>.</p>    <p>     <div class="definition" id="enc11">     <Label>Definition 5.2 (Fragment).</Label>     <p> A fragment <em>F</em> is a subterm of a QIR term <em>q</em> such that <em>q</em> = <em>C</em>[<em>T</em>(<em>q</em>      <sub>1</sub>, &#x2026;, <em>q</em>      <sub>       <em>i</em> &#x2212; 1</sub>, <em>F</em>[<em>e</em>      <sub>1</sub>, &#x2026;, <em>e<sub>n</sub>      </em>], <em>q</em>      <sub>       <em>i</em> + 1</sub>, &#x2026;, <em>q<sub>j</sub>      </em>)] where <em>C</em> is a one-hole context made of arbitrary expressions; <em>T</em> is a non-compatible j-ary expression; <em>q</em>      <sub>1</sub>, &#x2026;, <em>q</em>      <sub>       <em>i</em> &#x2212; 1</sub>, <em>q</em>      <sub>       <em>i</em> + 1</sub>, &#x2026;, <em>q<sub>j</sub>      </em> and <em>F</em> are the children of <em>T</em>; <em>F</em> is an <em>n</em>-hole context made only of compatible operators applications of the same database language <span class="inline-equation"><span class="tex">$\mathcal {D}$</span>      </span>; and all <em>e</em>      <sub>1</sub>, &#x2026;, <em>e<sub>n</sub>      </em> have head expressions that are not compatible.</p>     </div>    </p>    <figure id="fig4">     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-fig4.jpg" class="img-responsive" alt="Figure 4"      longdesc=""/>     <div class="figure-caption">     <span class="figure-number">Figure 4:</span>     <span class="figure-title">A fragment within a larger QIR term</span>     </div>    </figure>    <p>Figure&#x00A0;<a class="fig" href="#fig4">4</a> gives a graphical representation of a fragment. We can now define a measure of &#x201C;good&#x201D; QIR terms.</p>    <p>     <div class="definition" id="enc12">     <Label>Definition 5.3 (measure).</Label>     <p> Let <span class="inline-equation"><span class="tex">$q\in \mathsf {E}_{\mathcal {\textsf {QIR}}}$</span>      </span> be a QIR expression, we define the measure of <em>q</em> as the pair</p>     <p>      <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic18.jpg" class="img-responsive" alt=""       longdesc=""/>     </p>     <p>where <span class="inline-equation"><span class="tex">$\textsf {Op}(q)$</span>      </span> is the number of occurrences of data operators in <em>q</em>, <span class="inline-equation"><span class="tex">$\textsf {Comp}(q)$</span>      </span> is the number of occurrences of <em>compatible</em> data operator applications in <em>q</em> and <span class="inline-equation"><span class="tex">$\textsf {Frag}(q)$</span>      </span> is the number of fragments in <em>q</em>. The order associated with <em>M</em> is the lexicographic order on pairs.</p>     </div>    </p>    <p>This measure works as follows. During a step of reduction of a term <em>q</em> into a term <em>q</em>&#x2032;, <em>q</em>&#x2032; is considered a better term either if the number of operators decreases, or if <em>q</em>&#x2032; possesses more occurrences of <em>compatible</em> operator applications, meaning less cycles between QIR and the databases, or lastly, if the number of data operators does not change but the number of fragments decreases, meaning that some data operators were combined into a larger fragment.</p>    <p>Our heuristic-based normalization procedure uses this measure as a guide through the reduction of a QIR term: it applies all possible combinations of reduction steps to the term as long as its measure decreases after a number of steps fixed by heuristic. This allows us to generate a more efficient translation while ensuring termination.</p>    <p>Some practical choices impact the effectiveness of the QIR normalization such as choosing which reduction rule to apply at each step (e.g., choosing those with more arguments), or which maximum number of steps to use. Extensive experiments for both points are detailed in a technical report[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0022">22</a>]. In particular, we measure that the normalization represents a negligible fraction of the execution time of the whole process compared to tasks such as parsing, or exchanges on the network with databases.</p>   </section>   <section id="sec-16">    <header>     <div class="title-info">     <h2>      <span class="section-number">6</span> From a host language to QIR</h2>     </div>    </header>    <p>In this section, we outline how to interface a general-purpose programming language with BOLDR. As explained in Section&#x00A0;<a class="sec" href="#sec-7">1</a>, our aim is to allow programmers to write queries using the constructs of the language they already master. Therefore, instead of extending the syntax of the language, we extend its runtime by reusing existing functionalities, in particular by overloading existing functions.</p>    <p>We use the programming language R as example of a host language to show how to implement a language driver. The full details of our treatment to R can be found in Appendix&#x00A0;. R programs include first-class functions; side effects (&#x201C;<tt>=</tt>&#x201D; being the assignment operator as well as the variable definition operator); sequences of expressions separated by &#x201C;<tt>;</tt>&#x201D; or a newline; structured data types such as vectors and tables with named columns (called <em>data frames</em> in R&#x0027;s lingo); and static scoping as it is usually implemented in dynamic languages (e.g., as in Python or JavaScript) where identifiers that are not in the current static scope are assumed to be <em>global</em> identifiers even if they are undefined when the scope is created. For instance, the R program:</p>    <p>     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic19.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>is well-defined and stores <tt>5</tt> in <tt>z</tt> (but calling <tt>f</tt> before defining <tt>y</tt> yields an error). We next define the core syntax of R.</p>    <p>     <div class="definition" id="enc13">     <Label>Definition 6.1.</Label>     <p> The set <span class="inline-equation"><span class="tex">$\mathsf {E}_{\mathcal {\textsf {R}}}$</span>      </span> of expressions (<em>e</em>) and values (<em>v</em>) of R are generated by the following grammars:</p>     <p>      <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic20.jpg" class="img-responsive" alt=""       longdesc=""/>     </p>     <p>where <em>c</em> represents constants, <span class="inline-equation"><span class="tex">$\mathtt {x}\in \mathsf {I}_{\mathcal {\textsf {R}}}$</span>      </span>, and <span class="inline-equation"><span class="tex">$\sigma \in 2^{\mathsf {I}_{\mathcal {\textsf {R}}}\times \mathsf {V}_{\mathcal {\textsf {R}}}}$</span>      </span> is the environment of the closure.</p>     </div>    </p>    <p>We recall that, in R, <span class="inline-equation"><span class="tex">$\textsf {c}(e_1,\ldots ,e_n)$</span>     </span> builds a vector. Definition&#x00A0;<a class="enc" href="#enc13">6.1</a> only defines expressions that can be translated to QIR. Expressions not listed in the definition are translated into host expression nodes.</p>    <p>We now highlight how data frames are manipulated in standard R. As mentioned in Section&#x00A0;<a class="sec" href="#sec-7">1</a>, the <tt>subset</tt> function filters a data frame:</p>    <p>     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic21.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>This function returns the data frame given as first argument, filtered by the predicate given as second argument, and restricted to the columns listed in the third argument. Note that before resolving its second and third arguments, and for every row of the first argument, <tt>subset</tt> binds the values of each column of the row to a variable of the corresponding name. This is why in our example the variables <tt>sal</tt> and <tt>name</tt> occur free: they represent columns of the data frame <tt>t</tt>.</p>    <p>The join between two data frames is implemented with the function <tt>merge</tt>. We recall that the join operation returns the set of all combinations of rows in two tables that satisfy a given predicate.</p>    <p>To integrate <span class="inline-equation"><span class="tex">$\textsf {R}$</span>     </span> with BOLDR, we define two builtin functions:</p>    <ul class="list-no-style">     <li id="list20" label="&#x2022;"><tt>tableRef</tt> takes the name of a table and the name of the database the table belongs to, and returns a reference to the table<br/></li>     <li id="list21" label="&#x2022;"><tt>executeQuery</tt> takes a QIR expression, closes it by binding its free variables to the translation to QIR of their value from the current R environment, sends it to the QIR runtime for evaluation, and translate the results into <span class="inline-equation"><span class="tex">$\textsf {R}$</span>     </span> values<br/></li>    </ul>    <p>We also extend the set of values <span class="inline-equation"><span class="tex">$\mathsf {V}_{\mathcal {\textsf {R}}}$</span>     </span>:</p>    <p>     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic22.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>where <em>q<sub>&#x03C3;</sub>     </em> are <em>QIR closure values</em> representing queries associated with the R environment <em>&#x03C3;</em> used at their definition.</p>    <p>The functions <tt>subset</tt> and <tt>merge</tt> are overloaded to call the translation <span class="inline-equation"><span class="tex">$^{\textsf {R}}\overrightarrow{\texttt {EXP}}$</span>     </span> on themselves if their first argument is a reference to a database table created by <tt>tableRef</tt>, yielding a QIR term <em>q</em> to which the current scope is affixed, creating a QIR closure <em>q<sub>&#x03C3;</sub>     </em>. Free variables in <em>q<sub>&#x03C3;</sub>     </em> that are not in <em>&#x03C3;</em> are global identifiers whose bindings are to be resolved when <em>q<sub>&#x03C3;</sub>     </em> is executed using <tt>executeQuery</tt>.</p>    <p>We now illustrate the whole process on the introductory example of Section&#x00A0;<a class="sec" href="#sec-7">1</a>. <strong>Evaluation of the query expression:&#x00A0;</strong> When an expression recognized as a query is evaluated, it is translated to QIR (using Definition&#x00A0;). In the introductory example, the function call</p>    <p>     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic23.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>triggers the evaluation of the function <tt>atLeast</tt>:</p>    <p>     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic24.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>in which the function <tt>subset</tt> (Line&#x00A0;12) is evaluated with a table reference as first argument, and is therefore translated into a QIR expression. <tt>richUSPeople</tt> is then bound to the QIR closure value:</p>    <p>     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic25.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>     <strong>Query execution:&#x00A0;</strong> A QIR closure is executed using the function <tt>executeQuery</tt>. In our example, this happens at Line&#x00A0;16 and 17:</p>    <p>     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic26.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>     <tt>executeQuery</tt> then resolves each free variable by applying them to the translation to QIR of their value in the R environment:</p>    <p>     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic27.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>Next, the QIR runtime is called, and the query is normalized to:</p>    <p>     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic28.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>then translated to SQL as:</p>    <p>     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic29.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>This query is sent to PostgreSQL, and the results are translated back to QIR using <span class="inline-equation"><span class="tex">$^{\text{PostgreSQL}}\overrightarrow{\texttt {VAL}}$</span>     </span>, then to R using <span class="inline-equation"><span class="tex">$\overrightarrow{\texttt {VAL}}^{\mathcal {R}}$</span>     </span>.</p>   </section>   <section id="sec-17">    <header>     <div class="title-info">     <h2>      <span class="section-number">7</span> Implementation and results</h2>     </div>    </header>    <p>     <strong>Implementation</strong>. BOLDR consists of QIR, host languages, and databases. To evaluate our approach, we implemented the full stack, with R and SimpleLanguage as host languages and PostgreSQL, HBase and Hive as databases. Table&#x00A0;<a class="tbl" href="#tab1">1</a> gives the numbers of lines of Java code for each component to gauge the relative development effort needed to interface a host language or a database to BOLDR. All developments are done in Java using the Truffle framework.</p>    <div class="table-responsive" id="tab1">     <div class="table-caption">     <span class="table-number">Table 1:</span>     <span class="table-title">BOLDR components and their sizes in lines of code.</span>     </div>     <table class="table">     <tbody>      <tr>       <td style="text-align:left;">        <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic30.jpg" class="img-responsive" alt=""         longdesc=""/>       </td>      </tr>     </tbody>     </table>    </div>    <p>As expected, the bulk of our development lies in the QIR (its definition and normalization) which is completely shared between all languages and database backends. Compared to its 4000 l.o.c., the development cost of languages or database drivers, including translations to and from QIR is modest (between 700 and 1000 l.o.c.).</p>    <p>Even though our main focus is on Truffle-based languages, on which we have full control over their interpreters, all our requirements are also met by the introspection capabilities of modern dynamic languages. For instance, in R, the <tt>environment</tt> function returns the environment affixed to a closure as a modifiable R value, the <tt>body</tt> function returns the body of a closure as a manipulable abstract syntax tree, and the <tt>formals</tt> function returns the modifiable names of the arguments of a function. These introspection capabilities could be used to achieve an even more seamless integration.</p>    <p>     <strong>Experiments</strong>. The results of our evaluation<a class="fn" href="#fn1" id="foot-fn1"><sup>1</sup></a> are reported in Table&#x00A0;<a class="tbl" href="#tab2">2</a>. Queries named <tt>TPCH-<em>n</em>     </tt> are SQL queries taken from the TPC-H performance benchmark&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0021">21</a>]. These queries feature joins, nested queries, grouping, ordering, and various arithmetic subexpressions. Table&#x00A0;<a class="tbl" href="#tab2">2</a>.<strong>A</strong> and <a class="tbl" href="#tab2">2</a>.<strong>B</strong> illustrate how our approach fare against hand-written SQL queries. Each row reports the expected cost (in disk page fetches as reported by the <tt>EXPLAIN ANALYZE</tt> commands) as well as the actual execution time on a 1GB dataset. Row&#x00A0;SQL represents the hand-written SQL queries, Row&#x00A0;SQL+UDFs represents the same SQL queries where some subexpressions are expressed as function calls of stored functions written in PL/SQL. Row&#x00A0;R represents the SQL queries generated by BOLDR from equivalent R expressions, and Row&#x00A0;R+UDFs represents the same SQL queries as in Row&#x00A0;SQL+UDFs generated by BOLDR from equivalent R expressions with R UDFs. Lastly, for R+&#x25A0;, we added untranslatable subexpressions kept as host language nodes to impose a call to the database embedded R runtime. The results show that we can successfully match the performances of Row&#x00A0;SQL with Row&#x00A0;R, and that BOLDR outperforms PostgreSQL in Row&#x00A0;R+UDFs against Row&#x00A0;SQL+UDFs. This last result comes from the fact that PostgreSQL is not always able to inline function calls, even for simple functions written in PL/SQL. In stark contrast, no overhead is introduced for a SQL query generated from an R program, since the normalization is able to inline function calls properly, yielding a query as efficient as a hand-written one. As an example, the TPCH-15 query was written in R+UDFs as:</p>    <p>     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic31.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>BOLDR was able to inline this query, whereas the equivalent in SQL+UDFs could not be inlined by the optimizer of PostgreSQL.</p>    <div class="table-responsive" id="tab2">     <div class="table-caption">     <span class="table-number">Table 2:</span>     <span class="table-title">BOLDR components and their sizes in lines of code.</span>     </div>     <table class="table">     <tbody>      <tr>       <td style="text-align:left;">        <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic32.jpg" class="img-responsive" alt=""         longdesc=""/>       </td>      </tr>     </tbody>     </table>    </div>    <p>Table&#x00A0;<a class="tbl" href="#tab2">2</a>.<strong>B</strong> illustrates the overhead of calling the host language evaluator from PostgreSQL by comparing the cost of a <em>non-inlined</em> pure PL/SQL function with the cost of the same function embedded in a host expression within the query. While it incurs a high overhead, it remains reasonable even for expensive queries (such as TPCH-1) compared to the cost of network delays that would happen otherwise since host expressions represent expressions that are impossible to inline or to translate in the database language.</p>    <p>Table&#x00A0;<a class="tbl" href="#tab2">2</a>.<strong>C</strong> illustrates the overhead of calling the host language evaluator from Hive against a pure inlined Hive query. For instance</p>    <p>     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic33.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>against</p>    <p>     <img src="http://deliveryimages.acm.org/10.1145/3190000/3185973/images/www18companion-34-graphic34.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>where <tt>&#x2019;@...&#x2019;</tt> is the serialization of an R closure, and <tt>R.APPLY</tt> is a function we defined that applies an R closure to an array of values from Hive (including the necessary translations between Hive, QIR, and R). The results are that with one (Query&#x00A0;1/2) or two (Query&#x00A0;3) calls to the external language runtime, the overhead is negligible compared to the execution of the query in Map/Reduce.</p>    <p>Table&#x00A0;<a class="tbl" href="#tab2">2</a>.<strong>D</strong> gives the performances of queries mixing two data sources between a PostgreSQL, a HBase, and a Hive database. We executed the example in the Introduction and varied the data sources for the functions <tt>getRate</tt> and <tt>atLeast</tt>. In the current implementation, a join between tables from different databases is performed on the client side (see our future work in the Conclusion), therefore the queries in which the two functions target the same database perform better, since they are evaluated in a unique database implying less network delays and less work on the client side.</p>   </section>   <section id="sec-18">    <header>     <div class="title-info">     <h2>      <span class="section-number">8</span> Related work</h2>     </div>    </header>    <p>The work in the literature closest to BOLDR is T-LINQ and P-LINQ by&#x00A0;Cheney et&#x00A0;al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0007">7</a>] which subsumes previous work on LINQ and Links and gives a comprehensive &#x201C;practical theory of language integrated queries&#x201D;. In particular, it gives the strongest results to date for a language-integrated queries framework. Among their contributions stand out: <em>(<em>i</em>)</em> a quotation language (a <em>&#x03BB;</em>-calculus with list comprehensions) used to express queries in a host language, <em>(<em>ii</em>)</em> a normalization procedure ensuring that the translation of a query cannot cause a query avalanche, <em>(<em>iii</em>)</em> a type system which guarantees that well-typed queries can be normalized, <em>(<em>iv</em>)</em> a general recipe to implement language-integrated queries and <em>(<em>v</em>)</em> a practical implementation that outperforms Microsoft&#x0027;s LINQ. Some parts of our work are strikingly similar: our intermediate representation is a <em>&#x03BB;</em>-calculus using reduction as a normalization procedure. However, our work diverges radically from their approach because we target a different kind of host languages. T-LINQ requires a pure host language, with quotation and anti-quotation support and a type-system. Also, T-LINQ only supports one (type of) database per query and a limited set of operators (essentially, selection, projection, and join, expressed as comprehensions). While definitely possible, extending T-LINQ with other operators (e.g., &#x201C;group by&#x201D;) or other data models (e.g., graph databases) seems challenging since their normalization procedure hard-codes in several places the semantics of SQL. The host languages we target do not lend themselves as easily to formal treatment, as they are highly dynamic, untyped, and impure programming languages. We designed BOLDR to be target databases agnostic, and to be easily extendable to support new languages and databases. We also endeavored to lessen the work of driver implementers (adding support for a new language or database) through the use of embedded host language expressions, which take advantage of the capability of modern databases to execute foreign code. This contrasts with LINQ where adding new back-ends is known to be a difficult task&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0010">10</a>]. Lastly, we obtained formal results corresponding to those of T/P-LINQ by grafting a specific SQL type system on our framework.</p>    <p>QIR is not the first intermediate language of its kind. While LINQ proposes the most used intermediate query representation, recent work by&#x00A0;Ong et&#x00A0;al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0016">16</a>] introduced SQL++, an intermediary query representation whose goal is to subsume SQL and NoSQL. In this work, a carefully chosen set of operators is shown to be sufficient to express relational queries as well as NoSQL queries (e.g., queries over JSON databases). Each operator supports configuration options to account for the subtle differences in semantics for distinct query languages and data models (treatment of the special value <tt>NULL</tt>, semantics of basic operators such as equality, ...). In opposite, we chose to let the database expose the operators it supports in a driver.</p>    <p>Grust et&#x00A0;al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0012">12</a>] present an alternative compilation scheme for LINQ, where SQL and XML queries are compiled into an intermediate <em>table algebra</em> expression that can be efficiently executed in any modern relational database. While this algebra supports diverse querying primitives, it is designed to specifically target SQL databases, making it unfit for other back-ends.</p>    <p>Our current implementation of BOLDR is at an early stage and, as such, it suffers several shortcomings. Some are already addressed in existing literature. First, since we target dynamic programming languages, some forms of error cannot be detected until query evaluation. This problem has been widely studied and, besides T-LINQ, works such as SML#&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0015">15</a>] or ScalaDB&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0011">11</a>] use the static type system of the language to ensure the absence of a large class of runtime errors in generated queries. Second, our treatment of effects is rather crude. Local side effects, such as updating mutable references scoped inside a query, work as expected while observable effects, such as reading from a file on host machine memory, is unspecified behavior. The work of&#x00A0;Cook and Wiedermann [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0008">8</a>] shows how client-side effects can be re-ordered and split apart from queries. Third, at the moment, when two subqueries target different databases, their aggregation is done in the QIR runtime. Costa Seco et&#x00A0;al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0009">9</a>] present a language which allows manipulation of data coming from different sources, abstracting their nature and localization. A drawback of their work is the limitation in the set of expressions that can be handled. Our use of arbitrary host expressions would allow us to circumvent this problem.</p>   </section>   <section id="sec-19">    <header>     <div class="title-info">     <h2>      <span class="section-number">9</span> Conclusion and future work</h2>     </div>    </header>    <p>We presented BOLDR, a framework that allows programming languages to express complex queries containing application logic such as user-defined functions. These queries can target any source of data as long as it is interfaced with the framework, more precisely, with our intermediate language QIR. We provided methods for programming languages and databases to interface with QIR, as well as an implementation of the framework and interfaces for R, SimpleLanguage, PostgreSQL, HBase, and Hive. We described how QIR reduces and partially evaluates queries in order to take the most of database optimizations, and showed that BOLDR generates queries performing on a par with hand-written SQL queries.</p>    <p>Future work includes the creation of a domain-specific language to define translations from QIR to database languages, leaving the implementation details to the language itself, with the associated gains of speed, clarity, and concision. Currently, queries targeting more than one data sources are partially executed in the host language runtime. We plan to determine when such queries could be executed efficiently in one of the targeted data sources instead. For instance, in a join between two distinct data sources, it could be more efficient to send data from one data source to the other that will complete the join. ORMs and LINQ can type queries since they know the type of the data source. BOLDR cannot do it yet since QIR queries may contain dynamic code, and we do not want to type-check the whole host language. While we cannot foresee any general solution, we believe that to exploit any type information available we could use <em>gradual typing</em>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0020">20</a>], a recent technique blending static and dynamic typing in the same language. In particular, we would be able to use type information from database schemas (when available) to infer types for the queries.</p>   </section>  </section>  <section class="back-matter">   <section id="ref-001">    <header>     <div class="title-info">     <h2 class="page-brake-head">REFERENCES</h2>     </div>    </header>    <ul class="bibUl">     <li id="BibPLXBIB0001" label="[1]">2016. ISO/IEC 9075-2:2016, Information technology-Database languages&#x2013;SQL&#x2013;Part 2: Foundation (SQL/Foundation). (2016).</li>     <li id="BibPLXBIB0002" label="[2]">Amazon2017. Python Language Support for UDFs. (2017). <a class="link-inline force-break"      href="http://docs.aws.amazon.com/redshift/latest/dg/udf-python-language-support.html"      target="_blank">http://docs.aws.amazon.com/redshift/latest/dg/udf-python-language-support.html</a></li>     <li id="BibPLXBIB0003" label="[3]">Apache2017. Hive Manual - MapReduce scripts. (2017). <a class="link-inline force-break"      href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Transform"      target="_blank">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Transform</a></li>     <li id="BibPLXBIB0004" label="[4]">Apache2017. PySpark documentation - pyspark.sql.functions. (2017). <a class="link-inline force-break"      href="http://spark.apache.org/docs/1.6.2/api/python/pyspark.sql.html"      target="_blank">http://spark.apache.org/docs/1.6.2/api/python/pyspark.sql.html</a></li>     <li id="BibPLXBIB0005" label="[5]">Apache2017. User Defined Functions in Cassandra 3.0. (2017). <a class="link-inline force-break"      href="http://www.datastax.com/dev/blog/user-defined-functions-in-cassandra-3-0"      target="_blank">http://www.datastax.com/dev/blog/user-defined-functions-in-cassandra-3-0</a></li>     <li id="BibPLXBIB0006" label="[6]">BOLDR2018. Online appendix. (2018). <a class="link-inline force-break" href="https://www.lri.fr/~lopez/www.pdf"      target="_blank">https://www.lri.fr/~lopez/www.pdf</a></li>     <li id="BibPLXBIB0007" label="[7]">J. Cheney, S. Lindley, and P. Wadler. 2013. A Practical Theory of Language-Integrated Query. <em>In <em>ICFP 2013</em>     </em>. ACM, New York, NY, USA, 403&#x2013;416.</li>     <li id="BibPLXBIB0008" label="[8]">William&#x00A0;R. Cook and Ben Wiedermann. 2011. Remote Batch Invocation for SQL Databases. <em>In <em>Database Programming Languages - DBPL 201, 13th International Symposium, Seattle, Washington, USA, August 29, 2011. Proceedings</em>     </em>. <a class="link-inline force-break"      href="http://www.cs.cornell.edu/conferences/dbpl2011/papers/dbpl11-cook.pdf"      target="_blank">http://www.cs.cornell.edu/conferences/dbpl2011/papers/dbpl11-cook.pdf</a></li>     <li id="BibPLXBIB0009" label="[9]">Jo&#x00E3;o Costa Seco, Hugo Louren&#x00E7;o, and Paulo Ferreira. 2015. A Common Data Manipulation Language for Nested Data in Heterogeneous Environments. <em>In <em>Proceedings of the 15th Symposium on Database Programming Languages</em>     </em>(<em>DBPL 2015</em>). ACM, New York, NY, USA, 11&#x2013;20. <a class="link-inline force-break" href="https://doi.org/10.1145/2815072.2815074"      target="_blank">https://doi.org/10.1145/2815072.2815074</a></li>     <li id="BibPLXBIB0010" label="[10]">O. Eini. 2011. The Pain of Implementing LINQ Providers. <em>      <em>Commun. ACM</em>     </em>54, 8 (Aug. 2011), 55&#x2013;61.</li>     <li id="BibPLXBIB0011" label="[11]">Miguel Garcia, Anastasia Izmaylova, and Sibylle Schupp. 2010. Extending Scala with Database Query Capability. <em>      <em>Journal of Object Technology</em>     </em>9, 4 (2010), 45&#x2013;68.</li>     <li id="BibPLXBIB0012" label="[12]">Torsten Grust, Jan Rittinger, and Tom Schreiber. 2010. Avalanche-Safe LINQ Compilation. <em>      <em>PVLDB</em>     </em>3, 1 (2010), 162&#x2013;172. <a class="link-inline force-break"      href="http://www.comp.nus.edu.sg/~vldb2010/proceedings/files/papers/R14.pdf"      target="_blank">http://www.comp.nus.edu.sg/~vldb2010/proceedings/files/papers/R14.pdf</a></li>     <li id="BibPLXBIB0013" label="[13]">Microsoft2017. LINQ (Language-Integrated Query). (2017). <a class="link-inline force-break"      href="https://msdn.microsoft.com/en-us/library/bb397926.aspx"      target="_blank">https://msdn.microsoft.com/en-us/library/bb397926.aspx</a></li>     <li id="BibPLXBIB0014" label="[14]">MongoDB2017. MongoDB User Manual - Server-side JavaScript. (2017). <a class="link-inline force-break"      href="https://docs.mongodb.com/manual/core/server-side-javascript/"      target="_blank">https://docs.mongodb.com/manual/core/server-side-javascript/</a></li>     <li id="BibPLXBIB0015" label="[15]">A. Ohori and K. Ueno. 2011. Making standard ML a practical database programming language. <em>In <em>ICFP</em>     </em>. ACM, New York, NY, USA, 307&#x2013;319.</li>     <li id="BibPLXBIB0016" label="[16]">K.&#x00A0;W. Ong, Y. Papakonstantinou, and R. Vernoux. 2014. The SQL++ Semi-structured Data Model and Query Language: A Capabilities Survey of SQL-on-Hadoop, NoSQL and NewSQL Databases. <em>      <em>CoRR</em>     </em>abs/1405.3631(2014). <a class="link-inline force-break" href="http://arxiv.org/abs/1405.3631"      target="_blank">http://arxiv.org/abs/1405.3631</a></li>     <li id="BibPLXBIB0017" label="[17]">Oracle2017. FastR. (2017). <a class="link-inline force-break" href="https://github.com/graalvm/fastr"      target="_blank">https://github.com/graalvm/fastr</a></li>     <li id="BibPLXBIB0018" label="[18]">Oracle2017. Oracle R Enterprise. (2017). <a class="link-inline force-break"      href="http://www.oracle.com/technetwork/database/database-technologies/r"      target="_blank">http://www.oracle.com/technetwork/database/database-technologies/r</a></li>     <li id="BibPLXBIB0019" label="[19]">PostgreSQL2017. PL/Python - Python Procedural Language. (2017). <a class="link-inline force-break"      href="https://www.postgresql.org/docs/9.5/static/plpython.html"      target="_blank">https://www.postgresql.org/docs/9.5/static/plpython.html</a></li>     <li id="BibPLXBIB0020" label="[20]">J.&#x00A0;G. Siek and W. Taha. 2006. Gradual Typing for Functional Languages. <em>In <em>Proceedings, Scheme and Functional Programming Workshop 2006</em>     </em>. University of Chicago TR-2006-06, Chicago, USA, 81&#x2013;92.</li>     <li id="BibPLXBIB0021" label="[21]">TPC. 2017. The TPC-H benchmark. (2017). <a class="link-inline force-break" href="http://www.tpc.org/tpch/" target="_blank">http://www.tpc.org/tpch/</a></li>     <li id="BibPLXBIB0022" label="[22]">Romain Vernoux. 2016. Design of an intermediate representation for query languages. <em>      <em>CoRR</em>     </em>abs/1607.04197(2016). arxiv:1607.04197<a class="link-inline force-break" href="http://arxiv.org/abs/1607.04197"      target="_blank">http://arxiv.org/abs/1607.04197</a></li>     <li id="BibPLXBIB0023" label="[23]">T. W&#x00FC;rthinger, C. Wimmer, A. W&#x00F6;SS, L. Stadler, G. Duboscq, C. Humer, G. Richards, D. Simon, and M. Wolczko. 2013. One VM to Rule Them All. <em>In <em>Onward! 2013 Proceedings of the 2013 ACM international symposium on New ideas, new paradigms, and reflections on programming and software</em>     </em>. ACM, New York, NY, USA, 187&#x2013;204.</li>    </ul>   </section>  </section>  <section id="foot-001" class="footnote">   <header>    <div class="title-info">     <h2>FOOTNOTE</h2>    </div>   </header>   <p id="fn1"><a href="#foot-fn1"><sup>1</sup></a>The test machine was a PC with Ubuntu 16.04.2 LTS, kernel 4.4.0-83, with the latest master from the Truffle/Graal framework and PostgreSQL 9.5, Hive 2.1.1, and HBase 1.2.6 all with default parameters.</p>   <div class="bibStrip">    <p>This paper is published under the Creative Commons Attribution 4.0 International (CC-BY&#x00A0;4.0) license. Authors reserve their rights to disseminate the work on their personal and corporate Web sites with the appropriate attribution.</p>    <p>     <em>WWW '18, April 23-27, 2018, Lyon, France</em>    </p>    <p>&#x00A9; 2018; IW3C2 (International World Wide Web Conference Committee), published under Creative Commons CC-BY&#x00A0;4.0 License. ACM ISBN 978-1-4503-5640-4.<br/>DOI: <a class="link-inline force-break" target="_blank"     href="https://doi.org/10.1145/3184558.3185973">https://doi.org/10.1145/3184558.3185973</a>    </p>   </div>  </section>  <div class="pubHistory">   <p/>  </div>  </body> </html> 
