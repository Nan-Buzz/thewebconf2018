<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">  <head>  <title>Minimizing Latency in Online Ride and Delivery Services</title>  <!-- Copyright (c) 2010-2015 The MathJax Consortium --><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>  <meta name="viewport" content="width=device-width; initial-scale=1.0;"></meta>  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>  <link media="screen, print" rel="stylesheet"    href="../../../../dl.acm.org/pubs/lib/css/bootstrap.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../../dl.acm.org/pubs/lib/css/bootstrap-theme.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../../dl.acm.org/pubs/lib/css/main.css"/><script src="../../../../dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script>  <script src="../../../../dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script>  <script src="../../../../dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script>  <script src="../../../../dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script>  <script type="text/javascript"    src="../../../../dl.acm.org/pubs/lib/js/MathJax.js?config=TeX-AMS_CHTML"></script>  <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>  </head>  <body id="main">  <section class="front-matter">   <section>    <header class="title-info">     <div class="journal-title">     <h1>      <span class="title">Minimizing Latency in Online Ride and Delivery Services</span>      <br/>      <span class="subTitle"/>     </h1>     </div>    </header>    <div class="authorGroup">     <div class="author">     <span class="givenName">Abhimanyu</span>      <span class="surName">Das</span>,     Google Research, <a href="mailto:abhidas@google.com">abhidas@google.com</a>     </div>     <div class="author">     <span class="givenName">Sreenivas</span>      <span class="surName">Gollapudi</span>,     Google Research, <a href="mailto:sgollapu@google.com">sgollapu@google.com</a>     </div>     <div class="author">     <span class="givenName">Anthony</span>      <span class="surName">Kim</span><a class="fn" href="#fn1" id="foot-fn1"><sup>&#x204E;</sup></a>,     Stanford University, <a href="mailto:tonyekim@stanford.edu">tonyekim@stanford.edu</a>     </div>     <div class="author">     <span class="givenName">Debmalya</span>      <span class="surName">Panigrahi</span>,     Duke University, <a href="mailto:debmalya@cs.duke.edu">debmalya@cs.duke.edu</a>     </div>     <div class="author">     <span class="givenName">Chaitanya</span>      <span class="surName">Swamy</span>,     University of Waterloo, <a href="mailto:cswamy@uwaterloo.ca">cswamy@uwaterloo.ca</a>     </div>    </div>    <br/>    <div class="pubInfo">     <p>DOI: <a href="https://doi.org/10.1145/3178876.3186102" target="_blank">https://doi.org/10.1145/3178876.3186102</a>     <br/>WWW '18: <a href="https://doi.org/10.1145/3178876" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p>    </div>    <div class="abstract">     <p>     <small>Motivated by the popularity of online ride services such as Uber, Lyft, and Ola, we study natural variants of classical multi-vehicle minimum latency problems where the objective is to route a set of vehicles located at depots to serve request located on a metric space so as to minimize the total latency. In this paper, we consider point-to-point requests that come with source-destination pairs and release-time constraints that restrict when each request can be served. The point-to-point requests and release-time constraints model taxi rides and deliveries. For all the variants considered, we show constant-factor approximation algorithms based on a linear programming framework. To the best of our knowledge, these are the first set of results for the aforementioned variants of the minimum latency problems. Furthermore, we provide an empirical study of heuristics based on our theoretical algorithms on a real data set of taxi rides.</small>     </p>    </div>    <div class="CCSconcepts">     <p> <small> <span style="font-weight:bold;">CCS Concepts:</span> &#x2022;<strong> Theory of computation </strong>&#x2192; <strong>Routing and network design problems;</strong> <em>Discrete optimization;</em></small> </p>    </div>    <div class="classifications">     <div class="author">     <span style="font-weight:bold;">      <small>Keywords:</small>     </span>     <span class="keyword">      <small>Vehicle Routing</small>, </span>     <span class="keyword">      <small> Minimum Latency Problem</small>, </span>     <span class="keyword">      <small> Online Ride Services</small>     </span>     </div>     <br/>     <div class="AcmReferenceFormat">     <p>      <small>       <span style="font-weight:bold;">ACM Reference Format:</span>       <br/>       Abhimanyu Das, Sreenivas Gollapudi, Anthony Kim, Debmalya Panigrahi, and Chaitanya Swamy. 2018. Minimizing Latency in Online Ride and Delivery Services. In <em>WWW 2018: The 2018 Web Conference,</em>       <em>April 23&#x2013;27, 2018 (WWW 2018),</em>       <em> Lyon, France. ACM, New York, NY, USA</em> 11 Pages. <a href="https://doi.org/10.1145/3178876.3186102" class="link-inline force-break"        target="_blank">https://doi.org/10.1145/3178876.3186102</a></small>     </p>     </div>    </div>   </section>  </section>  <section class="body">   <section id="sec-6">    <header>     <div class="title-info">     <h2>      <span class="section-number">1</span> Introduction</h2>     </div>    </header>    <p>In recent years, ride-sharing platforms such as Lyft and Uber, and online delivery services such as DoorDash and GrubHub have become increasingly popular and have expanded their operations to many cities and countries. A central problem common to these online services is the vehicle routing problem where a fleet of vehicles are routed to serve ride and delivery requests over a geographical area. Indeed, this problem is also at the core of traditional city taxi services, such as Yellow Cab, where taxis are routed to serve ride requests received over the phone or the Internet. In all these settings, a request comprises a pair of source and destination locations, such as the rider&#x0027;s starting and ending coordinates for taxi services, and the restaurant and customer addresses for food delivery services. Furthermore, these &#x201C;point-to-point&#x201D; requests typically have release-time constraints, i.e., the customer specifies a desired service time before which the request cannot be serviced. The vehicle routing algorithm desires to minimize the average latency of customers, i.e., the difference between their requested service time and the actual service time. In this paper, we formally define this multi-vehicle routing problem, obtain an algorithm based on a linear programming framework with a formal guarantee on its performance, and demonstrate that heuristics based on this formal algorithm improve on benchmark greedy solutions on real data sets of city taxi rides. Most current systems, such as the online<a class="fn" href="#fn2" id="foot-fn2"><sup>1</sup></a> and traditional services mentioned above, employ simple greedy heuristics for a batch of requests to solve this vehicle routing problem in practice. In contrast, there is a rich history in the algorithmic literature on the so-called <em>vehicle routing problems</em> (or VRP), which covers a wide range of routing problems for one or more vehicles under a variety of constraints. For these problems, the formal literature comprises a wide array of sophisticated techniques, often based on linear programing formulations, that lead to approximation algorithms with provable guarantees. While we are not aware of any previous results on our exact problem formulation with point-to-point requests and release-time constraints, the related literature raises the natural question: can these sophisticated algorithmic techniques be brought to bear on this important practical problem of minimizing latency for point-to-point requests with release-time constraints? And if so, do these algorithmic ideas also lead to better heuristics in practice? We answer both these questions affirmatively by designing a constant approximation algorithm for this problem, which also leads to heuristics that outperform natural greedy strategies in practice.</p>    <section id="sec-7">     <header>     <div class="title-info">      <h3>       <span class="section-number">1.1</span> Our Contributions</h3>     </div>     </header>     <p>We formally define the minimum latency problems in Section&#x00A0;<a class="sec" href="#sec-9">2</a>. In Section&#x00A0;<a class="sec" href="#sec-10">3</a>, we present the linear programming framework due to Post and Swamy [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0022">22</a>] that will be central in our algorithms and analyses. Our theoretical contributions are to obtain <strong>constant approximation algorithms</strong> for the following problems:</p>     <ol class="list-no-style">     <li id="list1" label="(1)">(Section&#x00A0;<a class="sec" href="#sec-12">4.1</a>) For the minimum latency problem (MLP) and single-depot, multi-vehicle minimum latency problem (<em>k</em>-MLP) with point-to-point requests.<br/></li>     <li id="list2" label="(2)">(Section&#x00A0;<a class="sec" href="#sec-13">4.2</a>) For the multi-depot, multi-vehicle minimum latency problem (<em>k</em>-MLP) with point-to-point requests.<br/></li>     <li id="list3" label="(3)">(Section&#x00A0;<a class="sec" href="#sec-14">5</a>) For the above problems with release-time constraints for both point and point-to-point requests.<br/></li>     </ol>     <p>Additionally, we perform a large scale empirical analysis for the minimum latency problem by comparing our algorithms with a natural greedy baseline using two real-world taxi data sets. We show that our algorithms outperform the baseline on a set of different metrics including latency, tour length, and utilization (active time) of the cabs in the system.</p>     <p>See Table&#x00A0;<a class="tbl" href="#tab1">1</a> for a summary of our theoretical results with the precise constant approximation factors. To the best of our knowledge, <em>these results are the first polynomial-time approximation guarantees for the respective minimum latency problems</em>. For multi-depot problems, we obtain approximation guarantees with somewhat large constants via a constant-factor reduction (of ratio 3). We believe better approximation ratios are possible with use of more complicated constructs, but we do not explore these in this paper to keep our algorithms viable in practice.</p>     <p>     <em>&#x201C;Client-side&#x201D; vs &#x201C;Platform-side&#x201D; objectives:</em>Note the average latency objective that we study in this paper is a &#x201C;client-side&#x201D; objective whereas minimizing the total distance traveled by the vehicles, studied in problems such as the well-known <em>traveling salesman problem</em> (or TSP), is a &#x201C;platform-side&#x201D; objective. Our routing problem with point-to-point requests can be thought of as the &#x201C;client-side&#x201D; counterpart of what is known as the Dial-a-Ride problem with unit-capacity vehicles, where vehicles serve requests with point-to-point requests as in our problem, but seek to minimize the &#x201C;platform-side&#x201D; objective of total travel time. The latency minimization problem with point requests subject to release-time constraints has been proposed as an open problem in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0031">31</a>] and there exist polynomial-time approximation schemes for special cases such as a constant number of vehicles, or if the metric space has a special structure such as the Euclidean plane or weighted trees&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0029">29</a>]. Our result is the first one for a general metric space and an arbitrary number of vehicles, and generalizes further to point-to-point requests.</p>     <div class="table-responsive" id="tab1">     <div class="table-caption">      <span class="table-number">Table 1:</span>      <span class="table-title">The state-of-the-art approximation guarantees for various minimum latency problems (MLP/<em>k</em>-MLP) with point (P) requests and point-to-point (P2P) requests and with or without release times (RTs). Except those in the first column, the constant-factor approximation ratios are new and due to this paper.</span>     </div>     <table class="table">      <thead>       <tr>        <th style="text-align:left;"/>        <th style="text-align:center;">P Reqs.</th>        <th style="text-align:center;">P2P Reqs.</th>        <th style="text-align:center;">P Reqs. w/ RTs</th>        <th style="text-align:center;">P2P Reqs. w/ RTs</th>       </tr>      </thead>      <tbody>       <tr>        <td style="text-align:left;">MLP</td>        <td style="text-align:center;">3.591 ([<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"         href="#BibPLXBIB0009">9</a>])</td>        <td style="text-align:center;">3.591</td>        <td style="text-align:center;">7.183</td>        <td style="text-align:center;">7.183</td>       </tr>       <tr>        <td style="text-align:left;">Single-Depot <em>k</em>-MLP</td>        <td style="text-align:center;">7.183 ([<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"         href="#BibPLXBIB0022">22</a>])</td>        <td style="text-align:center;">8.978</td>        <td style="text-align:center;">7.183</td>        <td style="text-align:center;">8.978</td>       </tr>       <tr>        <td style="text-align:left;">Multi-Depot <em>k</em>-MLP</td>        <td style="text-align:center;">8.497 ([<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"         href="#BibPLXBIB0022">22</a>])</td>        <td style="text-align:center;">25.488</td>        <td style="text-align:center;">13.728</td>        <td style="text-align:center;">41.184</td>       </tr>      </tbody>     </table>     </div>    </section>    <section id="sec-8">     <header>     <div class="title-info">      <h3>       <span class="section-number">1.2</span> Related Work</h3>     </div>     </header>     <p>As mentioned above, our problem is an example of a vehicle routing problem, which is a generic term used to describe a wide range of routing problems over metric spaces. Of particular relevance to our context is the <em>minimum latency problem</em> (or MLP), also known as the traveling repairman problem or the delivery man problem, which has applications in diskhead scheduling and searching information in a network such as the world wide web&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0007">7</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0016">16</a>]. This problem is similar to our problem, with the exception that requests are at point locations (instead of point-to-point requests as in our setting) and there are no release-time constraints. MLP and <em>k</em>-MLP (respectively, a single or <em>k</em> vehicles) have been long studied in both the Operations Research and Computer Science communities. MLP was shown to be NP-complete and then MAXSNP-hard for general metrics&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0008">8</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0021">21</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0025">25</a>]. In fact, it is NP-hard even when the metric is a weighted tree with {0, 1} weights&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0028">28</a>] and is thought to be harder than the well-known traveling salesman problem.</p>     <p>There have been many works focused on exactly solving MLP/<em>k</em>-MLP and related problems, albeit not in polynomial time. A number of mixed integer formulations have been proposed and exact methods such as cutting-plane algorithms and branch-cut-and-price algorithms (e.g., [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0001">1</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0017">17</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0018">18</a>]) and various meta-heuristics (e.g., [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0019">19</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0020">20</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0027">27</a>]) have been proposed. More recently, several mixed integer formulations for <em>k</em>-MLP have been proposed and experimented with on routing and scheduling instances with the number of nodes ranging up to 80 [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0003">3</a>].</p>     <p>The first constant-factor approximation algorithm for MLP was obtained in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0008">8</a>] and the approximation factor was subsequently improved to 3.592 in a series of work&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0005">5</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0009">9</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0014">14</a>]. Similarly, we have constant-factor approximation algorithms for the multi-vehicle version, <em>k</em>-MLP, for both the multi-depot and single-depot variants due to a series of work&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0009">9</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0011">11</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0013">13</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0022">22</a>]: the current best-known approximation factors are 8.497 and 7.183 respectively. For several special cases, stronger guarantees are known. A quasi-polynomial time approximation scheme was known for weighted trees and Euclidean metrics in any finite dimensions [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0006">6</a>], and, more recently, a polynomial time approximation scheme was shown for weighted trees and the Euclidean plane for MLP and single-depot <em>k</em>-MLP for any constant <em>k</em> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0029">29</a>].</p>     <p>MLP/<em>k</em>-MLP are also closely to other vehicle routing problems such as the well-known traveling salesman problem, orienteering (cf. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0010">10</a>]) and the Dial-a-Ride problem (cf. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0012">12</a>]). They are also related to many sequencing problem with minimum total (weighted) completion time objective in the scheduling literature (cf. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0015">15</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0029">29</a>]). There is a large body of work on vehicle routing problems and scheduling problems beyond the scope of this paper. For further details on related problems, we refer to the above work and references therein.</p>     <p>Finally, we mention several work among many on other aspects of the ride and delivery services from the Data Mining and Artificial Intelligence communities. Different taxi dispatching strategies and route-recommendation systems have been studied in order to minimize passengers&#x2019; waiting times (cf. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0002">2</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0033">33</a>] in different settings from ours), to maximize drivers&#x2019; profits (cf. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0024">24</a>]), and to guarantee fairness within a group of competing drivers (cf. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0023">23</a>]). To address inefficiencies in taxi systems, several graph-based models and algorithms have been designed to minimize the total number of required taxis and to reduce the total idle time of taxi drivers (cf. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0032">32</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0034">34</a>]). Dynamic variants where ride requests arrive on demand have also been studied (cf. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0026">26</a>]).</p>    </section>   </section>   <section id="sec-9">    <header>     <div class="title-info">     <h2>      <span class="section-number">2</span> Problem Formulation</h2>     </div>    </header>    <p>We define the multi-vehicle minimum latency problem (<em>k</em>-MLP) with point-to-point requests as follows. Let <em>G</em> = (<em>V</em>, <em>E</em>) be a weighted complete undirected graph with a distance function on edges, <span class="inline-equation"><span class="tex">$c: E \rightarrow \mathbb {R}^+$</span>     </span>, that forms a metric space. There are <em>n</em> point-to-point requests where each request <em>R<sub>i</sub>     </em> is given by a pair (<em>s<sub>i</sub>     </em>, <em>d<sub>i</sub>     </em>) of source and destination nodes and to be satisfied without interruption, that is, a vehicle serves it by first going to the source node and then to the destination node directly. There are <em>k</em> vehicles located at respective designated depot nodes, equivalently, root nodes, <em>r</em>     <sub>1</sub>, &#x2026;, <em>r<sub>k</sub>     </em>. The objective is to find <em>k</em> paths <em>P</em>     <sub>1</sub>, &#x2026;, <em>P<sub>k</sub>     </em> starting from respective depots that serve all the requests and minimize the <em>total latency</em>, that is, the sum of latencies of requests, where the latency of a request is equal to the distance from the depot to the destination of the request on the path of the vehicle that serves it.</p>    <p>After appropriate scaling and rounding, we may assume <em>c<sub>e</sub>     </em> are integers and <span class="inline-equation"><span class="tex">$c_{r_i s_j} + c_{s_j d_j} \ge 1$</span>     </span> for every root node <em>r<sub>i</sub>     </em> and request <em>R<sub>j</sub>     </em>. For ease of exposition, we assume the distances <em>c<sub>e</sub>     </em> are given in a unit of time and interpret the latency of a request to be its completion time following the job scheduling literature.</p>    <p>The problem thus defined is the most general version to be studied in this paper and we refer to it as <em>multi-depot <em>k</em>-MLP with point-to-point requests</em>. We refer to the case when there is a single depot <em>r</em>     <sub>0</sub> for all vehicles (i.e., <em>r</em>     <sub>0</sub> = <em>r</em>     <sub>1</sub> = &#x22C5;&#x22C5;&#x22C5; = <em>r<sub>k</sub>     </em>) as <em>single-depot <em>k</em>-MLP with point-to-point requests</em>, and the case with exactly one vehicle (i.e., <em>k</em> = 1) as <em>MLP with point-to-point requests</em>. When the requests&#x2019; source and destination nodes are identical, we have the classical <em>k</em>-MLP and we refer to them as <em>(multi-depot/single-depot) <em>k</em>-MLP with point requests</em> (e.g., [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0022">22</a>]) to distinguish them from the more general problems with point-to-point requests.</p>    <p>MLP/<em>k</em>-MLP <em>with release times</em> is MLP/<em>k</em>-MLP with additional release-time constraints. Each request <em>R<sub>i</sub>     </em> has release time <em>T<sub>i</sub>     </em> such that it cannot be visited before time <em>T<sub>i</sub>     </em>. Both point and point-to-point requests can be considered with release times. When a vehicle is at the source node of a request, it may wait there until when the request become available at its release time. When clear from the context, we refer to these problems with shorter names.</p>    <p>     <em>Notation.</em>. We refer to the designated nodes using the <em>r<sub>i</sub>     </em>, <em>s<sub>i</sub>     </em> and <em>d<sub>i</sub>     </em>, and to arbitrary nodes of any kind using generic indexing variables such as <em>u</em> and <em>v</em>. We use <em>I</em> to denote the input size. A path may start from and end at different nodes and a tour must start from and end at the same node. We represent a path/tour by the sequence of nodes on the path/tour or simply by the sequence of requests in the order served if it is a vehicle&#x0027;s route. For example, if the order of the requests is <em>R</em>     <sub>1</sub>&#x22C5;&#x22C5;&#x22C5;<em>R<sub>n</sub>     </em>, the corresponding path is <em>P</em> = <em>r</em>     <sub>0</sub>     <em>s</em>     <sub>1</sub>     <em>d</em>     <sub>1</sub>&#x22C5;&#x22C5;&#x22C5;<em>s<sub>n</sub>d<sub>n</sub>     </em> (assuming the root <em>r</em>     <sub>0</sub>). For a path <em>P</em>, let <span class="inline-equation"><span class="tex">$\operatorname{Lat}(P, i)$</span>     </span> be the latency of the <em>i</em>-th request on the path, i.e., the distance along the path from the root of the path to the destination of the request, and <span class="inline-equation"><span class="tex">$\operatorname{Lat}(P) = \sum _{i=1}^n \operatorname{Lat}(P, i)$</span>     </span> be the total latency of the path. The total latency objective is the sum of the latencies of the paths of the <em>k</em> vehicles. Note that if there is one vehicle located at the root <em>r</em>     <sub>0</sub> that serves the all the requests in the order <em>R</em>     <sub>1</sub>&#x22C5;&#x22C5;&#x22C5;<em>R<sub>n</sub>     </em>, then <div class="table-responsive">     <div class="display-equation">      <span class="tex mytex">\[ \operatorname{Lat}(P, i) = {\left\lbrace \begin{array}{@{}l@{\quad }l@{}}\operatorname{Lat}(P, i-1) + c_{d_{i-1} s_i} + c_{s_i d_i}, &#x0026; i {\gt} 1 \\ 0, &#x0026; i = 0 \end{array}\right.} \,. \] </span>      <br/>     </div>     </div>    </p>    <p>Given a set of edges <em>Q</em> and a distance function <em>c</em>, let <em>c</em>(<em>Q</em>) be the sum of the lengths given by <em>c</em> of the edges in <em>Q</em>; if <em>P</em> is a path, then <em>c</em>(<em>P</em>) is the length of the path. We frequently perform concatenation and shortcutting operations on paths and tours. If two paths/tours meet at the same node, that is, one ending at and the other starting from the same node, we may concatenate them back to back to create a longer path/tour. We may shortcut a path/tour to avoid visiting a node twice by skipping it; this leads to a path/tour of at most the original length if the distances satisfy the triangle inequality, which holds in metric spaces.</p>   </section>   <section id="sec-10">    <header>     <div class="title-info">     <h2>      <span class="section-number">3</span> LP Framework</h2>     </div>    </header>    <p>We describe the linear programming framework due to Post and Swamy [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0022">22</a>] for single-depot <em>k</em>-MLP and MLP with point requests. Some of our algorithms utilize a directed metric, so we describe their LP in this general setting. Linear programs for multi-depot <em>k</em>-MLP are also given in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0022">22</a>] and are different, but we primarily focus on the linear program for the single-depot case in this paper. Let <em>r</em> denote the single depot for the point-request version.</p>    <p>Given a problem instance with point requests, let digraph <em>D</em> = (<em>V</em>, <em>A</em>) with arc-costs {<em>c</em>     <sub>     <em>u</em>, <em>v</em>     </sub>}<sub>     <em>u</em>, <em>v</em> &#x2208; <em>V</em>     </sub> represent the underlying directed metric. (If we have an undirected metric, we simply bidirect the edges to obtain <em>D</em>, setting <em>c</em>     <sub>     <em>u</em>, <em>v</em>     </sub> = <em>c</em>     <sub>     <em>v</em>, <em>u</em>     </sub> = <em>c<sub>uv</sub>     </em>.) We use <em>a</em> to index the arcs in <em>A</em>, <em>v</em> to index nodes in <em>V</em>&#x2216;{<em>r</em>}, <em>i</em> to index the <em>k</em> vehicles, and <em>t</em> to index time units in <span class="inline-equation"><span class="tex">$[\mathsf {T}]$</span>     </span>. We use variables <span class="inline-equation"><span class="tex">$x^i_{v,t}$</span>     </span> to denote if node <em>v</em> is visited at time <em>t</em> by the route originating at the root. Directing the vehicles&#x2019; routes away from the root in a solution, <span class="inline-equation"><span class="tex">$z^i_{a,t}$</span>     </span> indicates if arc <em>a</em> lies on the portion of vehicle <em>i</em>&#x2019;s route up to time <em>t</em>. Let <span class="inline-equation"><span class="tex">$\mathsf {T}$</span>     </span> be an easily certifiable upper bound on the maximum latency of a request. Consider the following LP. We will be able to ensure that either: (a) <span class="inline-equation"><span class="tex">$\mathsf {T}$</span>     </span> is polynomially bounded by scaling and rounding the metric (e.g., [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0006">6</a>]) while losing a (1 + &#x03F5;)-factor, in which case this LP can be solved efficiently; or (b) <span class="inline-equation"><span class="tex">$\log \mathsf {T}$</span>     </span> is polynomially bounded, and use ideas from [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0022">22</a>] to obtain a (1 + &#x03F5;)-approximate solution to this LP. <div class="table-responsive" id="eq1">     <div class="display-equation">      <span class="tex mytex">\begin{alignat} 3{\operatorname{min}}&#x0026; \hspace{5.0pt}&#x0026; \sum _{v,t,i} tx^i_{v,t} &#x0026; \end{alignat} </span>      <br/>      <span class="equation-number">(LP)</span>     </div>     </div>     <div class="table-responsive" id="eq2">     <div class="display-equation">      <span class="tex mytex">\begin{alignat} 3\text{s.t.} &#x0026;&#x0026; \sum _{t,i} x^i_{v,t} &#x0026; \ge 1 \quad &#x0026;&#x0026; \forall v \end{alignat} </span>      <br/>      <span class="equation-number">(1)</span>     </div>     </div>     <div class="table-responsive" id="eq3">     <div class="display-equation">      <span class="tex mytex">\begin{alignat} 3&#x0026;&#x0026; x^i_{v,t} &#x0026;=0\ \text{if $c_{r,v}{\gt}t$} \quad &#x0026;&#x0026; \forall v,t,i \end{alignat} </span>      <br/>      <span class="equation-number">(2)</span>     </div>     </div>     <div class="table-responsive" id="eq4">     <div class="display-equation">      <span class="tex mytex">\begin{alignat} 3&#x0026;&#x0026; \sum _{a\in \delta ^{\mathrm{in}}(S)}z^i_{a,t} &#x0026; \ge \sum _{t^{\prime }\le t} x^i_{v,t^{\prime }} \quad &#x0026;&#x0026; \forall S\subseteq V\setminus \lbrace r\rbrace , v\in S, \forall t, i \end{alignat} </span>      <br/>      <span class="equation-number">(3)</span>     </div>     </div>     <div class="table-responsive" id="eq5">     <div class="display-equation">      <span class="tex mytex">\begin{alignat} 3&#x0026;&#x0026; \sum _{a} c_az^i_{a,t} &#x0026; \le t \quad &#x0026;&#x0026; \forall t,i \end{alignat} </span>      <br/>      <span class="equation-number">(4)</span>     </div>     </div>     <div class="table-responsive" id="eq6">     <div class="display-equation">      <span class="tex mytex">\begin{alignat} 3&#x0026;&#x0026; \sum _{a\in \delta ^{\mathrm{in}}(v)}z^i_{a,t} &#x0026; \ge \sum _{a\in \delta ^{out}(v)}z^i_{a,t} \quad &#x0026;&#x0026; \forall v, t, i \end{alignat} </span>      <br/>      <span class="equation-number">(5)</span>     </div>     </div>     <div class="table-responsive" id="eq7">     <div class="display-equation">      <span class="tex mytex">\begin{alignat} 3&#x0026;&#x0026; x, z &#x0026; \ge 0. \end{alignat} </span>      <br/>      <span class="equation-number">(6)</span>     </div>     </div>    </p>    <p>Constraints (<a class="eqn" href="#eq2">1</a>) ensure that every non-root node is visited at some time, and constraints (<a class="eqn" href="#eq3">2</a>) ensure that each node cannot be visited before the distance from the root is covered. Constraints (<a class="eqn" href="#eq4">3</a>)&#x2013;(<a class="eqn" href="#eq6">5</a>) are for the vehicles&#x2019; routes: (<a class="eqn" href="#eq4">3</a>) ensures that the portion of a vehicle&#x0027;s route up to time <em>t</em> must visit every node visited by that vehicle by time <em>t</em>, (<a class="eqn" href="#eq5">4</a>) ensures that this route indeed has length at most <em>t</em>, and finally (<a class="eqn" href="#eq6">5</a>) seeks to encode that the route forms a path. (Note that constraints (<a class="eqn" href="#eq6">5</a>) are clearly valid, and one could also include the constraints <span class="inline-equation"><span class="tex">$\sum _{a\in \delta ^{\mathrm{out}}(r)}z^i_{a,t}\le 1$</span>     </span> for all <em>i</em>, <em>t</em>.)</p>    <p>To round a fractional solution to a set of routes for vehicles, we use a polynomial-time arborescence packing result for weighted digraphs and the concatenation graph. The following result does not require the edge costs are symmetric or form a metric, but holds for arbitrary nonnegative edge costs.</p>    <p>     <div class="theorem" id="enc1">     <Label>Theorem 3.1 (Theorem 3.1 in [22]).</Label>     <p> Let <em>D</em> = (<em>U</em> + <em>r</em>, <em>A</em>) be a digraph with nonnegative integer edge weights {<em>w<sub>e</sub>      </em>}, where <em>r</em>&#x2209;<em>U</em> is a root node and |<em>&#x03B4;</em>      <sup>in</sup>(<em>u</em>)| &#x2265; |<em>&#x03B4;</em>      <sup>out</sup>(<em>u</em>)| for all <em>u</em> &#x2208; <em>U</em>. For any integer <em>K</em> &#x2265; 0, one can find out-arborescences <em>F</em>      <sub>1</sub>, &#x2026;, <em>F<sub>q</sub>      </em> rooted at <em>r</em> and integers <em>&#x03B3;</em>      <sub>1</sub>, &#x2026;, <em>&#x03B3;<sub>q</sub>      </em> in polynomial time such that <span class="inline-equation"><span class="tex">$\sum _{i=1}^q\gamma _i=K$</span>      </span>, <span class="inline-equation"><span class="tex">$\sum _{i:e\in F_i}\gamma _i\le w_e$</span>      </span> for all <em>e</em> &#x2208; <em>A</em>, and <span class="inline-equation"><span class="tex">$\sum _{i:u\in F_i}\gamma _i={\operatorname{min}}\lbrace K,\lambda _D(r,u)\rbrace$</span>      </span> for all <em>u</em> &#x2208; <em>U</em>.</p>     </div>    </p>    <p>The <em>concatenation graph</em> was introduced by Goemans and Kleinberg [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0014">14</a>] and then extended by Archer and Blasiak [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0004">4</a>] as a convenient mean of representing the concatenation process of constructing vehicles&#x2019; routes from shorter paths. The concatenation graph corresponding to a sequence <em>w</em>     <sub>1</sub> = 0, &#x2026;, <em>w<sub>n</sub>     </em> of nonnegative numbers (that starts with a 0), denoted <em>CG</em>(<em>w</em>     <sub>1</sub>, &#x2026;, <em>w<sub>n</sub>     </em>), is a directed graph with <em>n</em> nodes and an arc (<em>i</em>, <em>j</em>) of length <span class="inline-equation"><span class="tex">$\bigl (n - \frac{i+j}{2} \bigr) w_j$</span>     </span> for all <em>i</em> < <em>j</em>. In our applications, a path through <em>CG</em>(<em>w</em>     <sub>1</sub>, &#x2026;, <em>w<sub>n</sub>     </em>) will correspond to the selection of certain partial solutions of smaller routes and the subsequent concatenation of these partial solutions to obtain a final solution of the vehicles&#x2019; routes. The length of the path will upper bound the total latency of the final solution.</p>    <p>We say that <em>w</em>     <sub>&#x2113;</sub> is an <em>extreme point</em> of the sequence (<em>w</em>     <sub>1</sub>, &#x2026;, <em>w<sub>n</sub>     </em>) if (&#x2113;, <em>w</em>     <sub>&#x2113;</sub>) is extreme-point of the convex hull of {(<em>j</em>, <em>w<sub>j</sub>     </em>): <em>j</em> = 1, &#x2026;, <em>n</em>}. Given a point-set <span class="inline-equation"><span class="tex">$C\subseteq \mathbb {R}_+^2$</span>     </span>, define its <em>lower-envelope curve</em>     <span class="inline-equation"><span class="tex">$f:[{\operatorname{min}}_{(x,y)\in C}x,{\operatorname{max}}_{(x,y)\in C}x]\mapsto \mathbb {R}_+$</span>     </span> by <span class="inline-equation"><span class="tex">$f(x)={\operatorname{min}}\lbrace y: (x,y) \in \operatorname{conv}(C)\rbrace$</span>     </span> where <span class="inline-equation"><span class="tex">$\operatorname{conv}(C)$</span>     </span> denotes the convex hull of <em>C</em>. We say that (&#x2113;, <em>w</em>     <sub>&#x2113;</sub>) is a <em>corner point</em> of the lower-envelope curve of {(<em>j</em>, <em>w<sub>j</sub>     </em>): <em>j</em> = 1, &#x2026;, <em>n</em>} if <em>w</em>     <sub>&#x2113;</sub> is an extreme point of (<em>w</em>     <sub>1</sub>, &#x2026;, <em>w<sub>n</sub>     </em>).</p>    <p>We have the following results on the concatenation graph:</p>    <p>     <div class="theorem" id="enc2">     <Label>Theorem 3.2 ([4, 14]).</Label>     <p> The shortest <span class="inline-equation"><span class="tex">$1\leadsto n$</span>      </span> path in <em>CG</em>(<em>w</em>      <sub>1</sub>, &#x2026;, <em>w<sub>n</sub>      </em>) has length at most <span class="inline-equation"><span class="tex">$\frac{\mu ^*}{2} \sum _{\ell =1}^n w_\ell$</span>      </span> where <em>&#x03BC;</em>      <sup>*</sup> < 3.5912 is the solution to <em>&#x03BC;</em>ln&#x2009;<em>&#x03BC;</em> = <em>&#x03BC;</em> + 1. Moreover, the shortest path only visits nodes corresponding to extreme points of (<em>w</em>      <sub>1</sub>, &#x2026;, <em>w<sub>n</sub>      </em>).</p>     </div>    </p>    <p>     <div class="corollary" id="enc3">     <Label>Corollary 3.3 (Corollary 2.2 in [22]).</Label>     <p> The shortest <span class="inline-equation"><span class="tex">$1\leadsto n$</span>      </span> path in <em>CG</em>(<em>w</em>      <sub>1</sub>, &#x2026;, <em>w<sub>n</sub>      </em>) has length at most <span class="inline-equation"><span class="tex">$\frac{\mu ^*}{2} \int _{1}^n f(x)dx$</span>      </span>, where <span class="inline-equation"><span class="tex">$f:[1,\ldots ,n]\mapsto \mathbb {R}_+$</span>      </span> is the lower-envelope curve of {(<em>j</em>, <em>w<sub>j</sub>      </em>): <em>j</em> = 1, &#x2026;, <em>n</em>}, and only visits nodes corresponding to extreme points of (<em>w</em>      <sub>1</sub>, &#x2026;, <em>w<sub>n</sub>      </em>).</p>     </div>    </p>   </section>   <section id="sec-11">    <header>     <div class="title-info">     <h2>      <span class="section-number">4</span> Point-to-Point Requests</h2>     </div>    </header>    <p>In this section, we present polynomial-time constant-factor approximation algorithms for MLP and single-depot/multi-depot <em>k</em>-MLP with point-to-point requests. The main idea is to first reduce the instance to a point-request instance in a modified metric and, then, solve linear program&#x00A0;(<a class="eqn" href="#eq1">LP</a>) and round the fractional optimal solution to nearly optimal routes via the arborescence-packing result and concatenation process described in Section&#x00A0;<a class="sec" href="#sec-10">3</a>. For single-depot <em>k</em>-MLP and MLP, we have a lossless reduction to a point-request instance in a <em>directed</em> metric; for multi-depot <em>k</em>-MLP, we reduce to the point-request version in an undirected metric incurring a factor-3 loss. Our main results are as follows. We prove the single-depot results in Section&#x00A0;<a class="sec" href="#sec-12">4.1</a> and the multi-depot ones in Section&#x00A0;<a class="sec" href="#sec-13">4.2</a>.</p>    <p>     <div class="theorem" id="enc4">     <Label>Theorem 4.1.</Label>     <p> For MLP with point-to-point requests, we can compute a (<em>&#x03BC;</em>      <sup>*</sup> + &#x03F5;)-approximate solution in time <span class="inline-equation"><span class="tex">$\operatorname{poly}(I, \frac{1}{\epsilon })$</span>      </span> for any &#x03F5; > 0.</p>     </div>    </p>    <p>     <div class="theorem" id="enc5">     <Label>Theorem 4.2.</Label>     <p> For single-depot <em>k</em>-MLP with point-to-point requests, we can compute a (2.5<em>&#x03BC;</em>      <sup>*</sup> + &#x03F5;)-approximate solution in time <span class="inline-equation"><span class="tex">$\operatorname{poly}(I, \frac{1}{\epsilon })$</span>      </span> for any &#x03F5; > 0. (2.5<em>&#x03BC;</em>      <sup>*</sup> &#x2248; 8.978.)</p>     </div>    </p>    <p>     <div class="theorem" id="enc6">     <Label>Theorem 4.3.</Label>     <p> For multi-depot <em>k</em>-MLP with point-to-point requests, we can compute a (25.488 + &#x03F5;)-approximate solution in time <span class="inline-equation"><span class="tex">$\operatorname{poly}(I, \frac{1}{\epsilon })$</span>      </span> for any &#x03F5; > 0.</p>     </div>    </p>    <section id="sec-12">     <header>     <div class="title-info">      <h3>       <span class="section-number">4.1</span> Single Depot</h3>     </div>     </header>     <p>The algorithm leading to Theorem&#x00A0;<a class="enc" href="#enc5">5</a> is given in Algorithm&#x00A0;<a class="fig" href="#fig4">1</a>; the improved ratio for MLP (Theorem&#x00A0;<a class="enc" href="#enc4">4</a>) is due to a simple observation and the underlying algorithm and analysis are essentially identical. As noted earlier, we transform the given undirected problem instance with point-to-point requests to point-request instance in a <em>directed</em> metric (see Step 1 of Algorithm 1) and apply the linear programming approach in Section&#x00A0;<a class="sec" href="#sec-10">3</a>. The transformation to a directed metric is lossless since there is a one-to-one correspondence between feasible solutions in <em>G</em> and <em>G</em>&#x2032; and corresponding solutions have the same total latency. Algorithm&#x00A0;<a class="fig" href="#fig4">1</a> works with the directed instance <em>G</em>&#x2032; in Steps 1&#x2013;7 and with the given undirected instance <em>G</em> in Steps 7, 8. 			 <figure id="fig4">      <img src="../../../../deliveryimages.acm.org/10.1145/3190000/3186104/images/www2018-113-fig1.svg" class="img-responsive" alt="Algorithm 1"       longdesc=""/>     </figure>     </p>     <p>The analysis closely resembles the one in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0022">22</a>] but is more involved due to &#x201C;directionality&#x201D; of the requests since a vehicle serves a request by going from the source to the destination, not the other way around. Lemma&#x00A0;<a class="enc" href="#enc7">7</a> relates the lower-envelope curve <em>f</em> of <em>C</em> in Step 5 and the objective value of the fractional optimal solution in Step 2 as in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0022">22</a>], since this only requires nonnegative edge costs.</p>     <div class="lemma" id="enc7">     <Label>Lemma 4.4.</Label>     <p> (i) <span class="inline-equation"><span class="tex">$\int _1^nf(x)dx\le 5\sum _{u\in V,t\in [\mathsf {T}]}tx^{\prime }_{u,t}$</span>      </span>. (ii) If <span class="inline-equation"><span class="tex">$\bigl (\ell ,f(\ell)\bigr)$</span>      </span> is a corner point of <em>f</em>, then there is a tree <span class="inline-equation"><span class="tex">$Q^*_\ell$</span>      </span> and time <span class="inline-equation"><span class="tex">$t^*_\ell$</span>      </span> satisfying the properties stated in Step 5 in Algorithm&#x00A0;<a class="fig" href="#fig4">1</a>.</p>     </div>     <div class="proof" id="proof1">     <Label>Proof.</Label>     <p> This is a modified version of Lemma 6.3 in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"       href="#BibPLXBIB0022">22</a>] and has essentially the same proof. The only difference is that we add the point <span class="inline-equation"><span class="tex">$\bigl (|V(Q^t_\ell)\cap S(t)|,\frac{3c^{\prime }(Q^t_\ell)}{k}+2t\bigr)$</span>      </span> to <em>C</em>. By Theorem&#x00A0;<a class="enc" href="#enc1">1</a>, <span class="inline-equation"><span class="tex">$\operatorname{E}[c^{\prime }(Q_\ell ^t)] \le kt$</span>      </span> and, hence, <span class="inline-equation"><span class="tex">$\operatorname{E}\left[\frac{3c^{\prime }(Q^t_\ell)}{k}+2t \right] \le 5t$</span>      </span>. The rest follows the same proof and the lemma follows.</p>     </div>     <div class="lemma" id="enc8">     <Label>Lemma 4.5.</Label>     <p> If (&#x2113;, <em>f</em>(&#x2113;)) is a corner point of <em>f</em>, each of the tours <em>Z</em>      <sub>1, &#x2113;</sub>, &#x2026;, <em>Z</em>      <sub>       <em>k</em>, &#x2113;</sub> created in Step 7 has length at most <span class="inline-equation"><span class="tex">$\frac{2 c^{\prime }(Q^*_\ell)}{k} + 2 t^*_\ell$</span>      </span>. In particular, the part of each tour without the first and last edges connecting to the root has length at most <span class="inline-equation"><span class="tex">$\frac{2 c^{\prime }(Q^*_\ell)}{k}$</span>      </span>.</p>     </div>     <div class="proof" id="proof2">     <Label>Proof.</Label>     <p> When breaking the cycle <em>Z</em>      <sub>&#x2113;</sub>, a break point can be either on a node or on an edge. In the former case, the node appears in two consecutive segments, and in the latter case, the edge is removed. In either case, all the nodes of <span class="inline-equation"><span class="tex">$Q^*_\ell$</span>      </span> will be contained in at least one segment and the corresponding request will be covered in one of the <em>k</em> tours <em>Z</em>      <sub>1, &#x2113;</sub>, &#x2026;, <em>Z</em>      <sub>       <em>k</em>, &#x2113;</sub> by the construction below.</p>     <p>Consider a segment and the corresponding tour <em>Z</em>      <sub>       <em>i</em>, &#x2113;</sub>. In the cycle <em>Z</em>      <sub>&#x2113;</sub>, we visit a node through a &#x201C;correctly&#x201D; oriented edge (i.e., in the same direction as the tour) for the first visit and through &#x201C;incorrectly&#x201D; oriented edges (i.e., in the opposite direction) for subsequent visits, and consequently, the segment consists of both correctly and incorrectly oriented edges. Without loss of generality, let <em>R</em>      <sub>1</sub>, &#x2026;, <em>R<sub>q</sub>      </em> be the requests corresponding to the vertices that are visited for the first time within the given segment in the Eulerian tour. Then, <em>Z</em>      <sub>       <em>i</em>, &#x2113;</sub> = <em>r</em>      <sub>0</sub>      <em>s</em>      <sub>1</sub>      <em>d</em>      <sub>1</sub>&#x22C5;&#x22C5;&#x22C5;<em>s<sub>q</sub>d<sub>q</sub>r</em>      <sub>0</sub>. For <em>P</em> = <em>d</em>      <sub>1</sub>      <em>s</em>      <sub>2</sub>      <em>d</em>      <sub>2</sub>&#x22C5;&#x22C5;&#x22C5;<em>s<sub>q</sub>d<sub>q</sub>      </em>, we show <span class="inline-equation"><span class="tex">$c(P) \le \frac{2c^{\prime }(Q^*_\ell)}{k}$</span>      </span>. By the definition of <em>c</em>&#x2032;, each arc in <em>G</em>&#x2032; corresponds to a path of length 2 in the original graph <em>G</em>. We replace the edges of the segment with corresponding paths of length 2 of the form <em>d<sub>i</sub>s<sub>j</sub>d<sub>j</sub>      </em>. The resulting path in <em>G</em> has length at most <span class="inline-equation"><span class="tex">$\frac{2 c^{\prime }(Q^*_\ell)}{k}$</span>      </span> and contains the nodes of <em>P</em> as a subsequence, not necessarily contiguously. We shortcut to get <em>P</em> exactly where shortcutting involves going directly from <em>d<sub>i</sub>      </em> to <em>s</em>      <sub>       <em>i</em> + 1</sub> for some <em>i</em> and truncating the beginning or end. Since <em>G</em> has metric edge costs {<em>c<sub>e</sub>      </em>}, it follows that <span class="inline-equation"><span class="tex">$c(P) \le \frac{2 c^{\prime }(Q^*_\ell)}{k}$</span>      </span>.</p>     <p>For the two paths <em>r</em>      <sub>0</sub>      <em>s</em>      <sub>1</sub>      <em>d</em>      <sub>1</sub> and <em>d<sub>q</sub>r</em>      <sub>0</sub> that complete <em>P</em> into <em>Z</em>      <sub>       <em>i</em>, &#x2113;</sub>, we upper bound the length of each path by <span class="inline-equation"><span class="tex">$t^*_\ell$</span>      </span>. Let <em>r</em> be the root in <em>G</em>&#x2032; and <em>v</em>      <sub>1</sub>, <em>v<sub>q</sub>      </em> &#x2208; <em>V</em>&#x2032; be the vertices corresponding to <em>d</em>      <sub>1</sub> and <em>d<sub>q</sub>      </em>, respectively. Since <em>v</em>      <sub>1</sub> and <em>v<sub>q</sub>      </em> are in <span class="inline-equation"><span class="tex">$Q^*_\ell \cap S(t^*_\ell)$</span>      </span>, <span class="inline-equation"><span class="tex">$c^{\prime }_{r v_1} \le t^*_\ell$</span>      </span> and <span class="inline-equation"><span class="tex">$c^{\prime }_{r v_q} \le t^*_\ell$</span>      </span>. Then, <span class="inline-equation"><span class="tex">$c_{r_0 s_1} + c_{s_1 d_1} = c^{\prime }_{r v_1} \le t^*_\ell$</span>      </span> and <span class="inline-equation"><span class="tex">$c_{r_0 d_q} \le c_{r_0 s_q} + c_{s_q d_q} = c^{\prime }_{r v_q} \le t^*_\ell$</span>      </span>. It follows that <span class="inline-equation"><span class="tex">$c(Z_{i,\ell }) = c(P) + c_{r_0 s_1} + c_{s_1 d_1} + c_{r_0 d_q} \le \frac{2 c^{\prime }(Q^*_\ell)}{k} + 2 t^*_\ell$</span>      </span>.</p>     </div>     <div class="proof" id="proof3">     <Label>Proof Proof of Theorem&#x00A0;5</Label>     <p> We claim that the solution returned by Algorithm&#x00A0;<a class="fig" href="#fig4">1</a> has total latency at most the length of <em>P<sub>C</sub>      </em> in the concatenation graph <em>CG</em>(<em>f</em>(1), &#x2026;, <em>f</em>(<em>n</em>)). By Corollary&#x00A0;<a class="enc" href="#enc3">3</a> and Lemma&#x00A0;<a class="enc" href="#enc7">7</a> part (i), the length of <em>P<sub>C</sub>      </em> is at most <span class="inline-equation"><span class="tex">$\frac{\mu ^*}{2}\int _{1}^n f(x)dx \le \frac{5 \mu ^*}{2} \sum _{v, t} t x^{\prime }_{v,t} = 2.5 \mu ^* \sum _{v, i, t} t x^i_{v,t}$</span>      </span>. Also, <span class="inline-equation"><span class="tex">$\sum _{v,i,t}t x^i_{v,t}$</span>      </span> is at most (1 + &#x03F5;) times the optimal latency, where the (1 + &#x03F5;)-factor is due to scaling and rounding.</p>     <p>We now prove the claim. More specifically, we show that the total latency is at most the length of <em>P<sub>C</sub>      </em> in <em>CG</em>(<em>f</em>(1), &#x2026;, <em>f</em>(<em>n</em>)) by induction. By Theorem&#x00A0;<a class="enc" href="#enc2">2</a>, there exist <span class="inline-equation"><span class="tex">$Q^*_\ell$</span>      </span> and <span class="inline-equation"><span class="tex">$t^*_\ell$</span>      </span> satisfying the properties stated in Step 5 for each corner point (&#x2113;, <em>f</em>(&#x2113;)) on <em>P<sub>C</sub>      </em>. By Lemma&#x00A0;<a class="enc" href="#enc8">8</a>, the tours that would be created from <span class="inline-equation"><span class="tex">$Q^*_\ell$</span>      </span> have length at most <span class="inline-equation"><span class="tex">$\frac{2 c^{\prime }(Q^*_\ell)}{k} + 2 t^*_\ell$</span>      </span> in the correct direction and cover all the requests corresponding to the vertices of <span class="inline-equation"><span class="tex">$Q^*_\ell$</span>      </span>. In particular, the part of each tour without the first and last edges connecting to the root has length at most <span class="inline-equation"><span class="tex">$\frac{2 c^{\prime }(Q^*_\ell)}{k}$</span>      </span> in the correct direction.</p>     <p>Suppose inductively that we have covered at least <em>o</em> requests by the partial solution constructed by concatenating tours corresponding to the nodes on <em>P<sub>C</sub>      </em> up to and including <em>o</em>. Assume we next take an edge (<em>o</em>, &#x2113;) and consider the additional contribution to the total latency when we concatenate <em>Z</em>      <sub>       <em>i</em>, &#x2113;</sub> to vehicle <em>i</em>&#x2019;s route for <em>i</em> &#x2208; [<em>k</em>]. Note the resulting partial solution covers at least &#x2113; requests.</p>     <p>Each request covered in the current concatenation step incurs additional latency of at most <span class="inline-equation"><span class="tex">$\frac{f(\ell)}{2}$</span>      </span> in expectation. To see this, let <em>L</em> be the length of the part of a tour <em>Z</em>      <sub>       <em>i</em>, &#x2113;</sub> without the root <em>r</em>      <sub>0</sub> and <em>L</em>&#x2032; be the length up to the destination of a request covered by the tour. With probability <span class="inline-equation"><span class="tex">$\frac{3}{4}$</span>      </span>, the additional latency incurred for the request is <em>t</em>      <sub>&#x2113;</sub> + <em>L</em>&#x2032;. With probability <span class="inline-equation"><span class="tex">$\frac{1}{4}$</span>      </span>, the additional latency is at most <em>t</em>      <sub>&#x2113;</sub> + 3(<em>L</em> &#x2212; <em>L</em>&#x2032;) because the length of a traversal in the opposite direction is upper bounded by 3 times the length of the corresponding traversal in the correct direction (accounting the <em>s<sub>i</sub>      </em>-<em>d<sub>i</sub>      </em> portions 3 times). For example, if <em>s</em>      <sub>1</sub>      <em>d</em>      <sub>1</sub>&#x2026;<em>s<sub>n</sub>d<sub>n</sub>      </em> is a traversal in the correct direction, the reverse traversal is a shortcut version of <em>d<sub>n</sub>s<sub>n</sub>d<sub>n</sub>s<sub>n</sub>      </em>&#x2026;<em>d</em>      <sub>1</sub>      <em>s</em>      <sub>1</sub>      <em>d</em>      <sub>1</sub>      <em>s</em>      <sub>1</sub> which has length at most 3 times that of <em>s</em>      <sub>1</sub>      <em>d</em>      <sub>1</sub>&#x2026;<em>s<sub>n</sub>d<sub>n</sub>      </em>. In expectation, the additional latency incurred for the request is at most <span class="inline-equation"><span class="tex">$\frac{3}{4}(t_\ell + L^{\prime }) + \frac{1}{4} (t_\ell + 3L - 3L^{\prime }) = t_\ell + \frac{3L}{4} \le \frac{f(\ell)}{2}$</span>      </span> as <span class="inline-equation"><span class="tex">$L \le \frac{2 c^{\prime }(Q^*_\ell)}{k}$</span>      </span>.</p>     <p>By a similar argument, each request that is still uncovered after concatenation incurs additional latency of at most <em>f</em>(&#x2113;) in expectation. The traversal in the correct direction has length at most 2<em>t</em>      <sub>&#x2113;</sub> + <em>L</em> and the one in the opposite direction has length at most 2<em>t</em>      <sub>&#x2113;</sub> + 3<em>L</em>. In expectation, the additional latency is at most <span class="inline-equation"><span class="tex">$2 t_\ell + \frac{3L}{2} \le f(\ell)$</span>      </span>.</p>     <p>There are exactly &#x2113; requests covered by the tours <em>Z</em>      <sub>1, &#x2113;</sub>, &#x2026;, <em>Z</em>      <sub>       <em>k</em>, &#x2113;</sub> and at most &#x2113; &#x2212; <em>o</em> new requests are covered in the current concatenation step. Each of these incurs additional latency at most <span class="inline-equation"><span class="tex">$\frac{f(\ell)}{2}$</span>      </span>. At most <em>n</em> &#x2212; &#x2113; requests remain to be covered and they each incur additional latency at most <em>f</em>(&#x2113;). The overall increase in the total latency is at most <span class="inline-equation"><span class="tex">$\frac{f(\ell)}{2} (\ell - o) + f(\ell) (n - \ell) = f(\ell) \left(n - \frac{o + \ell }{2}\right)$</span>      </span> which is equal to the length of the edge (<em>o</em>, &#x2113;) in <em>CG</em>(<em>f</em>(1), &#x2026;, <em>f</em>(<em>n</em>)). By induction, the total latency is at most the length of <em>P<sub>C</sub>      </em>.</p>     <p>For the running time, since <span class="inline-equation"><span class="tex">$\mathsf {T}=\operatorname{poly}(I,\frac{1}{\epsilon })$</span>      </span>, we can design a separation oracle for (<a class="eqn" href="#eq4">3</a>), which is a min-cut algorithm, and solve (<a class="eqn" href="#eq1">LP</a>) in time <span class="inline-equation"><span class="tex">$\operatorname{poly}(I, \frac{1}{\epsilon })$</span>      </span>.</p>     </div>     <div class="proof" id="proof4">     <Label>Proof Proof of Theorem&#x00A0;4</Label>     <p> We follow the same analysis above for Algorithm&#x00A0;<a class="fig" href="#fig4">1</a>. The improvement of the approximation ratio comes from the fact that we do not need to break the cycle <em>Z</em>      <sub>&#x2113;</sub> into <em>k</em> tours in Step 7 since we have exactly one vehicle. Moreover, we note that the length of a traversal of <em>Z</em>      <sub>&#x2113;</sub> in <em>either</em> direction is at most <span class="inline-equation"><span class="tex">$2c^{\prime }(Q^*_\ell)$</span>      </span>. In Step 4, we now add the point <span class="inline-equation"><span class="tex">$\bigl (|V(Q^t_\ell)\cap S(t)|, 2c^{\prime }(Q^t_\ell)\bigr)$</span>      </span> to <em>C</em> to leverage this fact. Following the proof of Theorem&#x00A0;<a class="enc" href="#enc5">5</a>, we now therefore obtain a <em>&#x03BC;</em>      <sup>*</sup>-approximation.</p>     </div>     <p>We remark that for single-depot <em>k</em>-MLP, we can avoid the additive &#x03F5; in the approximation factors by utilizing the more combinatorial approach presented in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0022">22</a>]. In this approach, we obtain the arborescences directly without solving an LP. Specifically, for each <em>i</em> = 1, &#x2026;, <em>n</em>, we aim to find the least <em>c</em>&#x2032;-cost arborescence spanning at least <em>i</em> requests (which in turn utilizes arborescence packings). We then again use the concatenation graph to select a subset that will be converted into tours which are then concatenated. This is closer to the approach we follow in our experimental results.</p>    </section>    <section id="sec-13">     <header>     <div class="title-info">      <h3>       <span class="section-number">4.2</span> Multiple Depots</h3>     </div>     </header>     <p>For the more general multi-depot <em>k</em>-MLP with point-to-point requests, we provide a reduction showing that an <em>&#x03B1;</em>-approximation algorithm for the point-request version on undirected metrics yields a 3<em>&#x03B1;</em>-approximation algorithm for the point-to-point request version on undirected metrics. This immediately yields Theorem&#x00A0;<a class="enc" href="#enc6">6</a> using the (8.496 + &#x03F5;)-approximation for multi-depot <em>k</em>-MLP with point-requests in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0022">22</a>]. The proofs in the remainder of this section are deferred to the final version of the paper.</p>     <p>     <em>Factor-3 Reduction.</em>. The main idea is to identify the requests by their source nodes and incorporate the request-specific distances <span class="inline-equation"><span class="tex">$c_{s_i d_i}$</span>     </span> into distances between sources in a symmetric way. We treat the root nodes as dummy requests with the identical source and destination nodes for the reduction. More specifically, <em>G</em>&#x2032; contains only root nodes and nodes representing the requests, and the distance between <em>v<sub>i</sub>     </em> and <em>v<sub>j</sub>     </em> in <em>G</em>&#x2032; is <span class="inline-equation"><span class="tex">$c^{\prime }_{v_i v_j} = c_{s_i s_j} + c_{s_i d_i} + c_{s_j d_j}$</span>     </span> It is easy to see that (<em>G</em>&#x2032;, <em>c</em>&#x2032;) is a metric. We then solve the resulting problem instance using an algorithm for the point requests and convert the computed paths into ones in the original problem instance. Via this reduction, observe that the latency of a rooted path in the (<em>G</em>&#x2032;, <em>c</em>&#x2032;) instance corresponds to the latency of a particular type of path, that we call a <em>backtracking path</em>, in the original problem instance, where a vehicle satisfies each request <em>i</em> by going from <em>s<sub>i</sub>     </em> to <em>d<sub>i</sub>     </em> and then returning to <em>s<sub>i</sub>     </em> before moving onto the next request. The backtracking paths are for the purpose of analysis only and we shortcut these paths to obtain the final routes for the vehicles. Clearly, there are bijective mappings between request-orderings and paths and backtracking paths. If the order of the requests is <em>R</em>     <sub>1</sub>&#x22C5;&#x22C5;&#x22C5;<em>R<sub>n</sub>     </em>, which equivalently corresponds to a path <em>P</em>, the corresponding backtracking path is <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ P_b = r_0 s_1 d_1 s_1 s_2 d_2 s_2 \cdots s_n d_n \,. \] </span>       <br/>      </div>     </div> If the order of the requests is <em>R</em>     <sub>1</sub>&#x22C5;&#x22C5;&#x22C5;<em>R<sub>n</sub>     </em> on the route <em>P</em> of a vehicle starting from, say, root <em>r</em>     <sub>0</sub>, the latency of the <em>i</em>-th request on the corresponding backtracking path <em>P<sub>b</sub>     </em> is determined as <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ \operatorname{Lat}(P_b, i) = {\left\lbrace \begin{array}{@{}l@{\quad }l@{}}\operatorname{Lat}(P_b, i-1) + c_{d_{i-1} s_{i-1}} + c_{s_{i-1} s_i} + c_{s_i d_i}, &#x0026; i {\gt} 1 \\ 0, &#x0026;i = 0 \end{array}\right.} \,. \] </span>       <br/>      </div>     </div> The total latency of <em>P<sub>b</sub>     </em> is <span class="inline-equation"><span class="tex">$\operatorname{Lat}(P_b) = \sum _{i=1}^n \operatorname{Lat}(P_b, i)$</span>     </span>.</p>     <div class="lemma" id="enc9">     <Label>Lemma 4.6.</Label>     <p> For any path <em>P</em> and corresponding backtracking path <em>P<sub>b</sub>      </em>, we have <span class="inline-equation"><span class="tex">$\operatorname{Lat}(P) \le \operatorname{Lat}(P_b) \le 3 \operatorname{Lat}(P)$</span>      </span>. Further, the factor of 3 is tight.</p>     </div>     <div class="corollary" id="enc10">     <Label>Corollary 4.7.</Label>     <p> Let <em>OPT</em> and <em>OPT</em>&#x2032; denote respectively the optimal values of the multi-depot <em>k</em>-MLP instance with point-to-point requests, and the multi-depot <em>k</em>-MLP instance with point-requests obtained by the above reduction under the <em>c</em>&#x2032; edge costs. Then <em>OPT</em> &#x2264; <em>OPT</em>&#x2032; &#x2264; 3 &#x00B7; <em>OPT</em>. Hence, an <em>&#x03B1;</em>-approximate solution to the point-requests instance yields a 3<em>&#x03B1;</em>-approximate solution to the point-to-point requests instance.</p>     </div>    </section>   </section>   <section id="sec-14">    <header>     <div class="title-info">     <h2>      <span class="section-number">5</span> Release-Time Constraints</h2>     </div>    </header>    <p>We show constant-factor approximation algorithms for the minimum latency problems with release-time constraints for both point-requests and point-to-point requests. We incorporate the release-time constraints into the linear program (<a class="eqn" href="#eq1">LP</a>) and solve the resulting linear program optimally as before. When rounding an optimal fractional solution to an integral solution, we follow the same analysis steps in Section&#x00A0;<a class="sec" href="#sec-11">4</a> but need to account for the release times. Our analysis can be easily modified to satisfy the release-time constraints with little or no extra cost in terms of approximation guarantees.</p>    <p>For point requests, we have the following results with similar approximation ratios as for the variants without release times:</p>    <p>     <div class="theorem" id="enc11">     <Label>Theorem 5.1.</Label>     <p> For point requests with release times, we obtain the following approximation guarantees in time <span class="inline-equation"><span class="tex">$\operatorname{poly}(I, \frac{1}{\epsilon })$</span>      </span> for any &#x03F5; > 0:</p>     <p>      <ol class="list-no-style">       <li id="list4" label="(1)">A (2<em>&#x03BC;</em>        <sup>*</sup> + &#x03F5;)-approximation for MLP and single-depot <em>k</em>-MLP; (2<em>&#x03BC;</em>        <sup>*</sup> &#x2248; 7.183)<br/></li>       <li id="list5" label="(2)">A (13.728 + &#x03F5;)-approximation for multi-depot <em>k</em>-MLP.<br/></li>      </ol>     </p>     </div>    </p>    <p>For point-to-point requests, we also have constant-factor approximation algorithms:</p>    <p>     <div class="theorem" id="enc12">     <Label>Theorem 5.2.</Label>     <p> For point-to-point requests with release times, we have the following approximation guarantees in time <span class="inline-equation"><span class="tex">$\operatorname{poly}(I, \frac{1}{\epsilon })$</span>      </span> for any &#x03F5; > 0:</p>     <p>      <ol class="list-no-style">       <li id="list6" label="(1)">A (2<em>&#x03BC;</em>        <sup>*</sup> + &#x03F5;)-approximation for MLP; (2<em>&#x03BC;</em>        <sup>*</sup> &#x2248; 7.183)<br/></li>       <li id="list7" label="(2)">A (2.5<em>&#x03BC;</em>        <sup>*</sup> + &#x03F5;)-approximation for single-depot <em>k</em>-MLP; (2.5<em>&#x03BC;</em>        <sup>*</sup> &#x2248; 8.978)<br/></li>       <li id="list8" label="(3)">A (41.184 + &#x03F5;)-approximation for multi-depot <em>k</em>-MLP.<br/></li>      </ol>     </p>     </div>    </p>    <p>We prove the above theorems in Sections&#x00A0;<a class="sec" href="#sec-15">5.1</a> and <a class="sec" href="#sec-16">5.2</a>, respectively.</p>    <p>As in the case without release times, the total latency objective is computed with respect to the beginning of the paths at the root nodes. This is analogous to the total-completion-time objective that is widely used in the scheduling literature (see, e.g.,&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0030">30</a>]). While, admittedly, measuring the latency of a request <em>R<sub>i</sub>     </em> by (time taken to reach <em>d<sub>i</sub>     </em>) &#x2212; <em>T<sub>i</sub>     </em>, which accounts for the actual time <em>R<sub>i</sub>     </em> spends in the system, yields a more natural objective that is akin to the <em>flow-time</em> objective in scheduling, the resulting optimization problem is much harder to approximate (as is the case in scheduling). Therefore, following much of the work in scheduling, we consider our latency objective, which is a reasonable first step in studying ride-sharing problems with release times.</p>    <p>To distinguish from the latency objective without release times, we use <span class="inline-equation"><span class="tex">$\operatorname{Lat}^+$</span>     </span> to denote latencies and incorporate the release times by making vehicles wait at the source of a request if it has not been released. For example, for path <em>P</em> = <em>r</em>     <sub>0</sub>     <em>s</em>     <sub>1</sub>     <em>d</em>     <sub>1</sub>&#x22C5;&#x22C5;&#x22C5;<em>s<sub>n</sub>d<sub>n</sub>     </em>, note that the latency of the <em>i</em>-th request on <em>P</em> is <div class="table-responsive">     <div class="display-equation">      <span class="tex mytex">\[ \operatorname{Lat}^+(P, i) = {\left\lbrace \begin{array}{@{}l@{\quad }l@{}}{\operatorname{max}}\lbrace \operatorname{Lat}^+(P, i-1) + c_{d_{i-1} s_i}, T_i \rbrace + c_{s_i d_i}, &#x0026; i {\gt} 1 \\ 0, &#x0026; i = 0 \end{array}\right.} \,. \] </span>      <br/>     </div>     </div> Similarly, the length of a path/tour needs to correspond to the traversal time subject to release-time constraints. Given a sequence of requests to be satisfied, the traversal time for the sequence consists of <em>driving times</em> for moving from one location to another <em>and waiting times</em> for staying fixed at a location before a request is released. We can still concatenate and shortcut in the sense that the total traversal time of concatenation of two paths meeting at a node is at most the sum of traversal times of the paths, and the traversal time of a shortcut path is at most that of the original path. The algorithms and their analyses stay essentially the same for traversal times as for lengths of paths/tours.</p>    <section id="sec-15">     <header>     <div class="title-info">      <h3>       <span class="section-number">5.1</span> Point Requests: Proof of Theorem&#x00A0;<a class="enc" href="#enc11">11</a>      </h3>     </div>     </header>     <p>     <em>Part (1).</em>. We incorporate the following release-time constraints into the linear program (<a class="eqn" href="#eq1">LP</a>) and solve for an optimal fractional solution as before: <div class="table-responsive" id="eq8">      <div class="display-equation">       <span class="tex mytex">\begin{equation} x^i_{v,t}=0\ \text{if $T_i{\gt}t$} \qquad \forall v,t,i \,. \end{equation} </span>       <br/>       <span class="equation-number">(7)</span>      </div>     </div> (Since we have point requests, the <em>c</em>&#x2032; edge costs used in Algorithm&#x00A0;<a class="fig" href="#fig4">1</a> are simply the bidirected <em>c</em> costs.) We now need to incorporate the <em>R<sub>i</sub>     </em>s in our upper bound <span class="inline-equation"><span class="tex">$\mathsf {T}$</span>     </span>, but <span class="inline-equation"><span class="tex">$\log \mathsf {T}$</span>     </span> is polynomially bounded and we can obtain a (1 + &#x03F5;)-approximate solution the LP. Then, we round the fractional solution as in Algorithm&#x00A0;<a class="fig" href="#fig4">1</a> by creating a set of tours starting and ending at the root and concatenating them.</p>     <p>In the analysis, we upper bound the traversal times of the tours using the same upper bound (or nearly the same) we have used for the lengths of the tours, and, hence, obtain the same or similar approximation guarantees with respect to the total latency objective as for the variants without release times. Specifically, Theorem 6.1 in Post and Swamy [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0022">22</a>], which is the equivalent of Theorem&#x00A0;<a class="enc" href="#enc5">5</a> for point requests with release times, obtains an approximation ratio of 2<em>&#x03BC;</em>     <sup>*</sup> for single-depot <em>k</em>-MLP with point requests without release times. We observe that the same upper bound of <span class="inline-equation"><span class="tex">$\frac{2c(Q^*_\ell)}{k} + 2t^*_\ell$</span>     </span> on the <em>c</em>-length of a tour obtained for time point <span class="inline-equation"><span class="tex">$t^*_\ell$</span>     </span> used in Theorem 6.1 in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0022">22</a>] also upper bounds the traversal time of any tour <em>Z</em>     <sub>      <em>i</em>, &#x2113;</sub> that we obtain in Step 7 of Algorithm&#x00A0;<a class="fig" href="#fig4">1</a>. This is because the upper bound of <span class="inline-equation"><span class="tex">$t^*_\ell$</span>     </span> on the lengths of the edges connecting the ends of <em>Z</em>     <sub>      <em>i</em>, &#x2113;</sub> to the root also upper bounds the waiting time portion of the traversal: since all requests on <em>Z</em>     <sub>      <em>i</em>, &#x2113;</sub> have release time at most <span class="inline-equation"><span class="tex">$t^*_\ell$</span>     </span> by the release-time constraints (<a class="eqn" href="#eq8">7</a>), <span class="inline-equation"><span class="tex">$t^*_\ell$</span>     </span> also accounts for the total waiting time of the traversal of <em>Z</em>     <sub>      <em>i</em>, &#x2113;</sub>. Thus, we do not incur any extra cost; the rest of the analysis is the same as that in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0022">22</a>], and the approximation guarantee follows.</p>     <p>     <em>Part (2).</em>. For this result, we use Algorithm 1 in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0022">22</a>] and its analysis, which uses a related but different linear program. We incorporate the release-time constraints (<a class="eqn" href="#eq8">7</a>) as before. Due to the space constraints, we omit the linear program and refer to [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0022">22</a>] for details. As before, we upper bound the traversal times of tours obtained for some time-point <em>t</em> by (the total driving time of at most <em>t</em> to visit the requests in the tour) + <em>t</em>, since <em>t</em> is an upper bound on the waiting time incurred as all requests on the tour have release time at most <em>t</em>. Consequently, following the analysis in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0022">22</a>], one can argue that for any constant 1 < <em>c</em> < <em>e</em>, we obtain an approximation ratio of at most <span class="inline-equation"><span class="tex">$\frac{(2c+1)(1-e^{-1})}{\ln c(1-ce^{-1})}+\epsilon$</span>     </span>. <a class="fn" href="#fn3" id="foot-fn3"><sup>2</sup></a> Taking <em>c</em> = 1.58726, we obtain an approximation ratio of at most 13.7272 + &#x03F5;.</p>    </section>    <section id="sec-16">     <header>     <div class="title-info">      <h3>       <span class="section-number">5.2</span> Point-to-Point Requests: Proof of Theorem&#x00A0;<a class="enc" href="#enc12">12</a>      </h3>     </div>     </header>     <p>The proof follows the same reasoning as in the proof of Theorem&#x00A0;<a class="enc" href="#enc11">11</a>. For parts (1) and (2), we move to a directed metric <em>c</em>&#x2032; as in Step 1 of Algorithm&#x00A0;<a class="fig" href="#fig4">1</a>, incorporate release times as in (<a class="eqn" href="#eq8">7</a>), solve the resulting LP (<a class="eqn" href="#eq1">LP</a>), and round it using Algorithm&#x00A0;<a class="fig" href="#fig4">1</a>. The guarantees in parts (1) and (2) rely on the analysis in Theorems&#x00A0;<a class="enc" href="#enc5">5</a> and&#x00A0;<a class="enc" href="#enc4">4</a> respectively, and the now-familiar fact that the waiting time for a tour for time <em>t</em> is at most <em>t</em>.</p>     <p>For part (3), we use the following factor-3 reduction to the point-requests and use part (2) of Theorem&#x00A0;<a class="enc" href="#enc11">11</a>. This yields a (41.184 + &#x03F5;)-approximation. The reduction is analogous to the constant-factor reduction presented in Section&#x00A0;<a class="sec" href="#sec-13">4.2</a> but proof details are more involved. For path <em>P</em> = <em>r</em>     <sub>0</sub>     <em>s</em>     <sub>1</sub>     <em>d</em>     <sub>1</sub>&#x22C5;&#x22C5;&#x22C5;<em>s<sub>n</sub>d<sub>n</sub>     </em>, we have the following relations for the latencies of the corresponding backtracking path <em>P<sub>b</sub>     </em>, <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ \operatorname{Lat}^+(P_b, i) = {\left\lbrace \begin{array}{@{}l@{\quad }l@{}}{\operatorname{max}}\left\lbrace \!\begin{aligned} &#x0026; \operatorname{Lat}^+(P_b, i-1) \\ &#x0026; + c_{d_{i-1} s_{i-1}} + c_{s_{i-1} s_i} \end{aligned} , T_i \right\rbrace + c_{s_i d_i}, &#x0026; i {\gt} 1 \\ 0, &#x0026;i = 0 \end{array}\right.} \,. \] </span>       <br/>      </div>     </div>     </p>     <div class="lemma" id="enc13">     <Label>Lemma 5.3.</Label>     <p> For any path <em>P</em> and corresponding backtracking path <em>P<sub>b</sub>      </em>, we have <span class="inline-equation"><span class="tex">$\operatorname{Lat}^+(P) \le \operatorname{Lat}^+(P_b) \le 3 \operatorname{Lat}^+(P)$</span>      </span>.</p>     </div>     <div class="corollary" id="enc14">     <Label>Corollary 5.4.</Label>     <p> Given point-to-point requests with release times, the optimal backtracking path has total latency at most 3 times that of the optimal path. More generally, an <em>&#x03B1;</em>-approximate backtracking path has total latency at most 3<em>&#x03B1;</em> times that of the optimal path.</p>     </div>    </section>   </section>   <section id="sec-17">    <header>     <div class="title-info">     <h2>      <span class="section-number">6</span> Experiments</h2>     </div>    </header>    <p>In this section, we will present a comparison of our algorithm and a natural greedy baseline on two public datasets, <em>viz.</em>, the Chicago taxi data<a class="fn" href="#fn4" id="foot-fn4"><sup>3</sup></a> and the NYC taxi data<a class="fn" href="#fn5" id="foot-fn5"><sup>4</sup></a>. We focused on the single depot k-MLP problem with release times (we also evaluated our algorithms for the k-MLP problem without release time on the same datasets and obtained qualitatively similar results).</p>    <section id="sec-18">     <header>     <div class="title-info">      <h3>       <span class="section-number">6.1</span> Datasets</h3>     </div>     </header>     <p>The Chicago dataset consists of 27 million taxi trips from 2013 to 2016, consisting of pick-up time, drop-off time, pick-up location, drop-off-location, trip-times and trip-lengths. The pick-up and drop-off locations are specified in terms of Census Tracts instead of precise latitude and longitude values. For our analysis and graph construction, we cover the city using equal-sized geographical cells of size 1000-sq meters, and map the Census Tracts to these cells. Each taxi trip is then treated as a trip between two cells. We assign pairwise distances between each pair of cells to be the driving time between centroids of each cell, computed using Google Maps API.</p>     <p>The New York taxi dataset consists of more than 1 billion taxi trips from 2009 to 2015 with location information. We discretize the pick-up and drop-off locations of each trip to their respective geographical cell, and compute pairwise driving distances between all cells in New York.</p>     <p>We randomly choose one weekday for both the datasets: 7/17/2015 for Chicago and 5/31/2013 for New York, and considered all taxi rides in a one-hour (5PM to 6PM) and two-hour (5PM to 7PM) window. Also, since the datasets do not contain release-times (when the trip-request arrived), we set the release-times to be equal to the pick-up times of the requests. We also choose a random cell in each city as the depot location.</p>     <p>Figure &#x00A0;<a class="fig" href="#fig1">1</a> plots a random sample of 100 taxi pick-up (white) and drop-off (red) locations in the 1-hour window for Chicago and New York. As seen from the figure, the distribution of taxi rides in Chicago is relatively more spread out. <figure id="fig1">      <img src="../../../../deliveryimages.acm.org/10.1145/3190000/3186104/images/www2018-113-fig1.jpg" class="img-responsive" alt="Figure 1"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 1:</span>       <span class="figure-title">Spatial distribution of random sample of 100 ride requests in New York City and Chicago.</span>      </div>     </figure>     </p>    </section>    <section id="sec-19">     <header>     <div class="title-info">      <h3>       <span class="section-number">6.2</span> Algorithm Implementations</h3>     </div>     </header>     <p>We first describe the natural greedy algorithm for the problem, that we use as a baseline. For each taxi that becomes idle, the greedy algorithm scans through all unassigned trip requests, and assigns the trip request with the smallest finish-time. The resulting solution has at most <em>k</em> paths branching out from the root and we refer to such solution as a <em>      <em>k</em>-path solution</em>. A path of a <em>k</em>-path solution will correspond to the path of a taxi.</p>     <p>Even though our Algorithm&#x00A0;<a class="fig" href="#fig4">1</a> from Section&#x00A0;<a class="sec" href="#sec-12">4.1</a> has constant approximation guarantees, it is relatively complex and hard to implement in practice. We therefore use the following practical heuristic (that we call kMLP-Fast) based on Algorithm&#x00A0;<a class="fig" href="#fig4">1</a>(in the sequel, <em>n</em> refers to the number of trip requests and <em>k</em> refers to the number of taxis):</p>     <ol class="list-no-style">     <li id="list9" label="(1)">Sort the requests in increasing order of their release times<br/></li>     <li id="list10" label="(2)">Define a layer(<em>i</em>) solution as the greedy <em>k</em>-path solution considering only the first 2<sup>       <em>i</em>      </sup> requests. Generate layers for <em>i</em> &#x2208; [1, 2, &#x2026;, log&#x2009;(<em>n</em>)].<br/></li>     <li id="list11" label="(3)">Create a &#x201C;concatenation graph&#x201D; as follows: Each node in the concatenation graph corresponds to a path in a given layer. We create an edge from path <em>P<sub>i</sub>      </em> in layer <em>i</em> to path <em>P<sub>j</sub>      </em> in layer <em>j</em> for <em>j</em> > <em>i</em>, and set the edge cost as follows: <span class="inline-equation"><span class="tex">$e(P_i, P_j) = \sum _{t \in P_j} (\operatorname{Lat}(P_i + P_j, t) - \operatorname{Lat}(P_j, t)) + (n - 2^j)\cdot \text{length}(P_j)$</span>      </span>, where <em>P<sub>i</sub>      </em> + <em>P<sub>j</sub>      </em> represents the path obtained by appending <em>P<sub>j</sub>      </em> to <em>P<sub>i</sub>      </em> and removing duplicates, and length(<em>P<sub>j</sub>      </em>) is the traversal time of the path (which includes both waiting and driving times). Essentially, the edge cost is an upper bound on the additional latency incurred by trips in <em>P<sub>j</sub>      </em> and all subsequent trips in higher layers, when appending <em>P<sub>j</sub>      </em> to <em>P<sub>i</sub>      </em>. Create a dummy start node <em>s</em> corresponding to an empty path, and connect every node to <em>s</em> with edge costs computed as before. Create a finish node <em>t</em> and connect every path in the last layer (<em>i</em> = log&#x2009;(<em>n</em>)) to <em>t</em>, with edge cost 0.<br/></li>     <li id="list12" label="(4)">Assign a capacity of 1 to each edge in the concatenation graph, and run a min-cost flow algorithm from <em>s</em> to <em>t</em> with flow amount <em>k</em>. Concatenate the paths traversed by each flow (removing duplicates) to generate the final solution.<br/></li>     </ol>     <p>The main simplification that the kMLP-Fast algorithm performs (compared to Algorithm&#x00A0;<a class="fig" href="#fig4">1</a>) is that it greedily defines requests for each layer by sorting them by their release times. For each layer, it then creates a <em>k</em>-path solution using the greedy-heuristic as a subroutine to cover all nodes in that layer. This differs from the paths obtained in Algorithm&#x00A0;<a class="fig" href="#fig4">1</a>. Finally, the algorithm concatenates the paths across different layers using a min-cost flow algorithm (as opposed to a shortest path in the concatenation-graph, since we now work with <em>k</em> paths per layer.)</p>    </section>    <section id="sec-20">     <header>     <div class="title-info">      <h3>       <span class="section-number">6.3</span> Latency objective</h3>     </div>     </header>     <p>We compare the kMLP-Fast and greedy algorithms on the total-latency objective, which includes both the waiting time and the driving time for a request. Figure&#x00A0;<a class="fig" href="#fig2">2</a> illustrates the performance of the algorithm on both datasets. Note that on the y-axis, we report values representing the <em>sum</em> of the corresponding metric over all requests in the observed interval. <figure id="fig2">      <img src="../../../../deliveryimages.acm.org/10.1145/3190000/3186104/images/www2018-113-fig2.jpg" class="img-responsive" alt="Figure 2"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 2:</span>       <span class="figure-title">Total latency of all trips in hours</span>      </div>     </figure>     <figure id="fig3">      <img src="../../../../deliveryimages.acm.org/10.1145/3190000/3186104/images/www2018-113-fig3.jpg" class="img-responsive" alt="Figure 3"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 3:</span>       <span class="figure-title">The performance of kMLP-Fast algorithm w.r.t. other natural measures.</span>      </div>     </figure>     </p>     <p>One trend we observe in both cities is that as the number of taxis increases, our algorithm outperforms the greedy algorithm by a wider margin. Indeed, in New York City, our algorithm does better by around 5% - 8% as the average number of trips for a taxi decreases from 25 to 5. A similar trend, with the difference ranging from 6% to 13%, is observed in Chicago. The reason for the higher difference in Chicago compared to New York City might be attributed to the different demand distributions in the two cities (cf Figure <a class="fig" href="#fig1">1</a>). The requests in New York are more densely concentrated in a smaller region, which helps the greedy algorithm.</p>    </section>    <section id="sec-21">     <header>     <div class="title-info">      <h3>       <span class="section-number">6.4</span> Other Desiderata</h3>     </div>     </header>     <p>While the user satisfaction in terms of latency is a good characteristic of a ride sharing service, other characteristics such as the total distance covered by the taxis in the system, the efficiency of the taxi in terms of taxi idle times, the load on each taxi, etc are also good properties of any ride sharing service. We measured the performance of the kMLP-Fast algorithm w.r.t. these metrics. Figures&#x00A0; illustrate the relative performance of our algorithm compared to the greedy baseline.</p>     <p>Even though the kMLP-Fast algorithm is optimized for the latency objective, it performs surprisingly well for minimizing the total distance a taxi travels to serve its rides. In fact, the cabs travel between 5% and 15% less on this measure. Another promising result is the performance on the measure of idle time a taxi spends transitioning between rides. Here again, our algorithm performance significantly better by 15% to 35% over the greedy baseline. Finally, we measured the fairness as the coefficient of variation of the total trip lengths of taxis. A fair allocation ensures taxis are generally equally loaded resulting in a smaller value of this measure. On this measure, the greedy algorithm under-performs in New York City while the difference is much less in Chicago. Note that the greedy algorithm tends to produce more balanced paths by its design.</p>    </section>   </section>  </section>  <section class="back-matter">   <section id="ref-001">    <header>     <div class="title-info">     <h2 class="page-brake-head">REFERENCES</h2>     </div>    </header>    <ul class="bibUl">     <li id="BibPLXBIB0001" label="[1]">Hern&#x00E1;n Abeledo, Ricardo Fukasawa, Artur Pessoa, and Eduardo Uchoa. 2013. The time dependent traveling salesman problem: polyhedra and algorithm. <em>      <em>Mathematical Programming Computation</em>     </em>5, 1 (01 Mar 2013), 27&#x2013;55. <a class="link-inline force-break"      href="https://doi.org/10.1007/s12532-012-0047-y"      target="_blank">https://doi.org/10.1007/s12532-012-0047-y</a></li>     <li id="BibPLXBIB0002" label="[2]">Aamena Alshamsi, Sherief Abdallah, and Iyad Rahwan. 2009. Multiagent Self-organization for a Taxi Dispatch System. In <em>      <em>Proceedings of the 8th International Conference on Autonomous Agents and Multiagent Systems</em>     </em>(AAMAS &#x2019;09).</li>     <li id="BibPLXBIB0003" label="[3]">F. Angel-Bello, Y. Cardona-Vald&#x00E9;s, and A. &#x00C1;lvarez. 2017. Mixed integer formulations for the multiple minimum latency problem. <em>      <em>Operational Research</em>     </em> (08 Feb 2017). <a class="link-inline force-break"      href="https://doi.org/10.1007/s12351-017-0299-4"      target="_blank">https://doi.org/10.1007/s12351-017-0299-4</a></li>     <li id="BibPLXBIB0004" label="[4]">Aaron Archer and Anna Blasiak. 2010. Improved Approximation Algorithms for the Minimum Latency Problem via Prize-collecting Strolls. In <em>      <em>Proceedings of the Twenty-first Annual ACM-SIAM Symposium on Discrete Algorithms</em>     </em>(SODA &#x2019;10). Society for Industrial and Applied Mathematics, Philadelphia, PA, USA, 429&#x2013;447. <a class="link-inline force-break"      href="http://dl.acm.org/citation.cfm?id=1873601.1873637"      target="_blank">http://dl.acm.org/citation.cfm?id=1873601.1873637</a></li>     <li id="BibPLXBIB0005" label="[5]">Aaron Archer, Asaf Levin, and David&#x00A0;P. Williamson. 2008. A Faster, Better Approximation Algorithm for the Minimum Latency Problem. <em>      <em>SIAM J. Comput.</em>     </em>37, 5 (2008), 1472&#x2013;1498. <a class="link-inline force-break" href="https://doi.org/10.1137/07068151X"      target="_blank">https://doi.org/10.1137/07068151X</a> arXiv:<a href="https://doi.org/10.1137/07068151X" target="_blank">https://doi.org/10.1137/07068151X</a></li>     <li id="BibPLXBIB0006" label="[6]">Sanjeev Arora and George Karakostas. 2003. Approximation Schemes for Minimum Latency Problems. <em>      <em>SIAM J. Comput.</em>     </em>32, 5 (2003), 1317&#x2013;1337. <a class="link-inline force-break"      href="https://doi.org/10.1137/S0097539701399654"      target="_blank">https://doi.org/10.1137/S0097539701399654</a> arXiv:<a href="https://doi.org/10.1137/S0097539701399654" target="_blank">https://doi.org/10.1137/S0097539701399654</a></li>     <li id="BibPLXBIB0007" label="[7]">Giorgio Ausiello, Stefano Leonardi, and Alberto Marchetti-Spaccamela. 2000. <em>      <em>On Salesmen, Repairmen, Spiders, and Other Traveling Agents</em>     </em>. Springer Berlin Heidelberg, Berlin, Heidelberg, 1&#x2013;16.</li>     <li id="BibPLXBIB0008" label="[8]">Avrim Blum, Prasad Chalasani, Don Coppersmith, Bill Pulleyblank, Prabhakar Raghavan, and Madhu Sudan. 1994. The Minimum Latency Problem. In <em>      <em>Proceedings of the Twenty-sixth Annual ACM Symposium on Theory of Computing</em>     </em>(STOC &#x2019;94). ACM, New York, NY, USA, 163&#x2013;171. <a class="link-inline force-break" href="https://doi.org/10.1145/195058.195125"      target="_blank">https://doi.org/10.1145/195058.195125</a></li>     <li id="BibPLXBIB0009" label="[9]">Kamalika Chaudhuri, Brighten Godfrey, Satish Rao, and Kunal Talwar. 2003. Paths, Trees, and Minimum Latency Tours. In <em>      <em>Proceedings of the 44th Annual IEEE Symposium on Foundations of Computer Science</em>     </em>(FOCS &#x2019;03). IEEE Computer Society, Washington, DC, USA, 36&#x2013;. <a class="link-inline force-break"      href="http://dl.acm.org/citation.cfm?id=946243.946316"      target="_blank">http://dl.acm.org/citation.cfm?id=946243.946316</a></li>     <li id="BibPLXBIB0010" label="[10]">Chandra Chekuri, Nitish Korula, and Martin P&#x00E1;l. 2012. Improved Algorithms for Orienteering and Related Problems. <em>      <em>ACM Trans. Algorithms</em>     </em>8, 3, Article 23 (July 2012), 27&#x00A0;pages. <a class="link-inline force-break" href="https://doi.org/10.1145/2229163.2229167"      target="_blank">https://doi.org/10.1145/2229163.2229167</a></li>     <li id="BibPLXBIB0011" label="[11]">Chandra Chekuri and Amit Kumar. 2004. <em>      <em>Maximum Coverage Problem with Group Budget Constraints and Applications</em>     </em>. Springer Berlin Heidelberg, Berlin, Heidelberg, 72&#x2013;83.</li>     <li id="BibPLXBIB0012" label="[12]">Willem&#x00A0;E. de Paepe, Jan&#x00A0;Karel Lenstra, Jiri Sgall, Ren&#x00E9;&#x00A0;A. Sitters, and Leen Stougie. 2004. Computer-Aided Complexity Classification of Dial-a-Ride Problems. <em>      <em>INFORMS Journal on Computing</em>     </em>16, 2 (2004), 120&#x2013;132. <a class="link-inline force-break" href="https://doi.org/10.1287/ijoc.1030.0052"      target="_blank">https://doi.org/10.1287/ijoc.1030.0052</a> arXiv:<a href="https://doi.org/10.1287/ijoc.1030.0052" target="_blank">https://doi.org/10.1287/ijoc.1030.0052</a></li>     <li id="BibPLXBIB0013" label="[13]">Jittat Fakcharoenphol, Chris Harrelson, and Satish Rao. 2003. The K-traveling Repairman Problem. In <em>      <em>Proceedings of the Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms</em>     </em>(SODA &#x2019;03). Society for Industrial and Applied Mathematics, Philadelphia, PA, USA, 655&#x2013;664. <a class="link-inline force-break"      href="http://dl.acm.org/citation.cfm?id=644108.644215"      target="_blank">http://dl.acm.org/citation.cfm?id=644108.644215</a></li>     <li id="BibPLXBIB0014" label="[14]">Michel Goemans and Jon Kleinberg. 1996. An Improved Approximation Ratio for the Minimum Latency Problem. In <em>      <em>Proceedings of the Seventh Annual ACM-SIAM Symposium on Discrete Algorithms</em>     </em>(SODA &#x2019;96). Society for Industrial and Applied Mathematics, Philadelphia, PA, USA, 152&#x2013;158. <a class="link-inline force-break"      href="http://dl.acm.org/citation.cfm?id=313852.313909"      target="_blank">http://dl.acm.org/citation.cfm?id=313852.313909</a></li>     <li id="BibPLXBIB0015" label="[15]">R.L. Graham, E.L. Lawler, J.K. Lenstra, and A.H.G.Rinnooy Kan. 1979. Optimization and Approximation in Deterministic Sequencing and Scheduling: a Survey. In <em>      <em>Discrete Optimization II</em>     </em>, P.L. Hammer, E.L. Johnson, and B.H. Korte (Eds.). Annals of Discrete Mathematics, Vol.&#x00A0;5. Elsevier, 287 &#x2013; 326. <a class="link-inline force-break"      href="https://doi.org/10.1016/S0167-5060(08)70356-X"      target="_blank">https://doi.org/10.1016/S0167-5060(08)70356-X</a></li>     <li id="BibPLXBIB0016" label="[16]">Elias Koutsoupias, Christos Papadimitriou, and Mihalis Yannakakis. 1996. <em>      <em>Searching a fixed graph</em>     </em>. Springer Berlin Heidelberg, Berlin, Heidelberg, 280&#x2013;289.</li>     <li id="BibPLXBIB0017" label="[17]">Zhixing Luo, Hu Qin, and Andrew Lim. 2014. Branch-and-price-and-cut for the multiple traveling repairman problem with distance constraints. <em>      <em>European Journal of Operational Research</em>     </em>234, 1 (2014), 49&#x2013;60. <a class="link-inline force-break"      href="https://EconPapers.repec.org/RePEc:eee:ejores:v:234:y:2014:i:1:p:49-60"      target="_blank">https://EconPapers.repec.org/RePEc:eee:ejores:v:234:y:2014:i:1:p:49-60</a></li>     <li id="BibPLXBIB0018" label="[18]">Isabel M&#x00E9;ndez-D&#x00ED;az, Paula Zabala, and Abilio Lucena. 2008. A New Formulation for the Traveling Deliveryman Problem. <em>      <em>Discrete Appl. Math.</em>     </em>156, 17 (Oct. 2008), 3223&#x2013;3237. <a class="link-inline force-break"      href="https://doi.org/10.1016/j.dam.2008.05.009"      target="_blank">https://doi.org/10.1016/j.dam.2008.05.009</a></li>     <li id="BibPLXBIB0019" label="[19]">Nenad Mladenovi&#x0107;, Dragan Uro&#x0161;evi&#x0107;, and Sa&#x00EF;d Hanafi. 2013. Variable neighborhood search for the travelling deliveryman problem. <em>      <em>4OR</em>     </em>11, 1 (01 Mar 2013), 57&#x2013;73. <a class="link-inline force-break"      href="https://doi.org/10.1007/s10288-012-0212-1"      target="_blank">https://doi.org/10.1007/s10288-012-0212-1</a></li>     <li id="BibPLXBIB0020" label="[20]">Samuel Nucamendi-Guill&#x00E9;n, Iris Mart&#x00ED;nez-Salazar, Francisco Angel-Bello, and J&#x00A0;Marcos Moreno-Vega. 2016. A mixed integer formulation and an efficient metaheuristic procedure for the k-Travelling Repairmen Problem. <em>      <em>Journal of the Operational Research Society</em>     </em>67, 8 (01 Aug 2016), 1121&#x2013;1134. <a class="link-inline force-break" href="https://doi.org/10.1057/jors.2015.113"      target="_blank">https://doi.org/10.1057/jors.2015.113</a></li>     <li id="BibPLXBIB0021" label="[21]">Christos&#x00A0;H. Papadimitriou and Mihalis Yannakakis. 1993. The Traveling Salesman Problem with Distances One and Two. <em>      <em>Math. Oper. Res.</em>     </em>18, 1 (Feb. 1993), 1&#x2013;11. <a class="link-inline force-break" href="https://doi.org/10.1287/moor.18.1.1"      target="_blank">https://doi.org/10.1287/moor.18.1.1</a></li>     <li id="BibPLXBIB0022" label="[22]">Ian Post and Chaitanya Swamy. 2015. Linear Programming-based Approximation Algorithms for Multi-vehicle Minimum Latency Problems. In <em>      <em>Proceedings of the Twenty-sixth Annual ACM-SIAM Symposium on Discrete Algorithms</em>     </em>(SODA &#x2019;15). Society for Industrial and Applied Mathematics, Philadelphia, PA, USA, 512&#x2013;531. <a class="link-inline force-break"      href="http://dl.acm.org/citation.cfm?id=2722129.2722164"      target="_blank">http://dl.acm.org/citation.cfm?id=2722129.2722164</a></li>     <li id="BibPLXBIB0023" label="[23]">Shiyou Qian, Jian Cao, Fr&#x00E9;d&#x00E9;ric&#x00A0;Le Mou&#x00EB;l, Issam Sahel, and Minglu Li. 2015. SCRAM: A Sharing Considered Route Assignment Mechanism for Fair Taxi Route Recommendations. In <em>      <em>Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</em>     </em>(KDD &#x2019;15). ACM, New York, NY, USA, 955&#x2013;964. <a class="link-inline force-break" href="https://doi.org/10.1145/2783258.2783261"      target="_blank">https://doi.org/10.1145/2783258.2783261</a></li>     <li id="BibPLXBIB0024" label="[24]">Meng Qu, Hengshu Zhu, Junming Liu, Guannan Liu, and Hui Xiong. 2014. A Cost-effective Recommender System for Taxi Drivers. In <em>      <em>Proceedings of the 20th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</em>     </em>(KDD &#x2019;14). ACM, New York, NY, USA, 45&#x2013;54. <a class="link-inline force-break" href="https://doi.org/10.1145/2623330.2623668"      target="_blank">https://doi.org/10.1145/2623330.2623668</a></li>     <li id="BibPLXBIB0025" label="[25]">Sartaj Sahni and Teofilo Gonzalez. 1976. P-Complete Approximation Problems. <em>      <em>J. ACM</em>     </em>23, 3 (July 1976), 555&#x2013;565. <a class="link-inline force-break" href="https://doi.org/10.1145/321958.321975"      target="_blank">https://doi.org/10.1145/321958.321975</a></li>     <li id="BibPLXBIB0026" label="[26]">Douglas&#x00A0;O. Santos and Eduardo&#x00A0;C. Xavier. 2013. Dynamic Taxi and Ridesharing: A Framework and Heuristics for the Optimization Problem. In <em>      <em>Proceedings of the Twenty-Third International Joint Conference on Artificial Intelligence</em>     </em>(IJCAI &#x2019;13). AAAI Press, 2885&#x2013;2891. <a class="link-inline force-break"      href="http://dl.acm.org/citation.cfm?id=2540128.2540544"      target="_blank">http://dl.acm.org/citation.cfm?id=2540128.2540544</a></li>     <li id="BibPLXBIB0027" label="[27]">Marcos&#x00A0;Melo Silva, Anand Subramanian, Thibaut Vidal, and Luiz&#x00A0;Satoru Ochi. 2012. A simple and effective metaheuristic for the Minimum Latency Problem. <em>      <em>European Journal of Operational Research</em>     </em>221, 3 (2012), 513 &#x2013; 520. <a class="link-inline force-break"      href="https://doi.org/10.1016/j.ejor.2012.03.044"      target="_blank">https://doi.org/10.1016/j.ejor.2012.03.044</a></li>     <li id="BibPLXBIB0028" label="[28]">Ren&#x00E9; Sitters. 2002. The Minimum Latency Problem Is NP-Hard for Weighted Trees. In <em>      <em>Proceedings of the 9th International IPCO Conference on Integer Programming and Combinatorial Optimization</em>     </em>. Springer-Verlag, London, UK, UK, 230&#x2013;239. <a class="link-inline force-break"      href="http://dl.acm.org/citation.cfm?id=645591.660083"      target="_blank">http://dl.acm.org/citation.cfm?id=645591.660083</a></li>     <li id="BibPLXBIB0029" label="[29]">Ren&#x00E9; Sitters. 2014. Polynomial Time Approximation Schemes for the Traveling Repairman and Other Minimum Latency Problems. In <em>      <em>Proceedings of the Twenty-fifth Annual ACM-SIAM Symposium on Discrete Algorithms</em>     </em>(SODA &#x2019;14). Society for Industrial and Applied Mathematics, Philadelphia, PA, USA, 604&#x2013;616. <a class="link-inline force-break"      href="http://dl.acm.org/citation.cfm?id=2634074.2634120"      target="_blank">http://dl.acm.org/citation.cfm?id=2634074.2634120</a></li>     <li id="BibPLXBIB0030" label="[30]">M. Skutella. 2006. List Scheduling in Order of <em>&#x03B1;</em>-Points on a Single Machine. In <em>      <em>Efficient Approximation and Online Algorithms</em>     </em>. Springer, 250&#x2013;291.</li>     <li id="BibPLXBIB0031" label="[31]">John&#x00A0;N. Tsitsiklis. 1992. Special cases of traveling salesman and repairman problems with time windows. <em>      <em>Networks</em>     </em>22, 3 (1992), 263&#x2013;282. <a class="link-inline force-break" href="https://doi.org/10.1002/net.3230220305"      target="_blank">https://doi.org/10.1002/net.3230220305</a></li>     <li id="BibPLXBIB0032" label="[32]">Xianyuan Zhan, Xinwu Qian, and Satish&#x00A0;V. Ukkusuri. 2014. Measuring the Efficiency of Urban Taxi Service System. In <em>      <em>The Third International Workshop on Urban Computing</em>     </em>(UrbComp &#x2019;14).</li>     <li id="BibPLXBIB0033" label="[33]">Xudong Zheng, Xiao Liang, and Ke Xu. 2012. Where to Wait for a Taxi?. In <em>      <em>Proceedings of the ACM SIGKDD International Workshop on Urban Computing</em>     </em>(UrbComp &#x2019;12). ACM, New York, NY, USA, 149&#x2013;156. <a class="link-inline force-break" href="https://doi.org/10.1145/2346496.2346520"      target="_blank">https://doi.org/10.1145/2346496.2346520</a></li>     <li id="BibPLXBIB0034" label="[34]">Chenguang Zhu and Balaji Prabhakar. 2017. Reducing Inefficiencies in Taxi Systems. In <em>      <em>Proceedings of the Fifty-Sixth IEEE Conference on Decision and Control</em>     </em>(CDC &#x2019;17).</li>    </ul>   </section>  </section>  <section id="foot-001" class="footnote">   <header>    <div class="title-info">     <h2>FOOTNOTE</h2>    </div>   </header>   <p id="fn1"><a href="#foot-fn1"><sup>&#x204E;</sup></a>Part of this work was done when the author was an intern at Google, Inc.</p>   <p id="fn2"><a href="#foot-fn2"><sup>1</sup></a>Note that we use &#x201C;online&#x201D; to refer to the requests being generated by web-based services, and not to refer to requests arriving &#x201C;online&#x201D; in an algorithmic sense.</p>   <p id="fn3"><a href="#foot-fn3"><sup>2</sup></a>Claim 5.2 (iii) in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0022">22</a>] changes as follows: conditioned on the random offset <em>h</em>, the expected latency of a node <em>v</em> first covered in iteration <em>j</em> of the algorithm is now at most <span class="inline-equation"><span class="tex">$(1+\epsilon)(3t_0+3t_1+\ldots +3t_{j-1}+2t_j)\le \frac{(1+\epsilon)(2c+1)}{c-1}\cdot t_j$</span>    </span>   </p>   <p id="fn4"><a href="#foot-fn4"><sup>3</sup></a><a href="http://digital.cityofchicago.org/index.php/chicago-taxi-data-released/" target="_blank">http://digital.cityofchicago.org/index.php/chicago-taxi-data-released/</a></p>   <p id="fn5"><a href="#foot-fn5"><sup>4</sup></a><a href="http://www.nyc.gov/html/tlc/html/about/trip_record_data.shtml" target="_blank">http://www.nyc.gov/html/tlc/html/about/trip_record_data.shtml</a></p>   <div class="bibStrip">    <p>This paper is published under the Creative Commons Attribution 4.0 International (CC-BY&#x00A0;4.0) license. Authors reserve their rights to disseminate the work on their personal and corporate Web sites with the appropriate attribution.</p>    <p>     <em>WWW '18, April 23-27, 2018, Lyon, France</em>    </p>    <p>&#x00A9; 2018; IW3C2 (International World Wide Web Conference Committee), published under Creative Commons CC-BY&#x00A0;4.0 License. ACM ISBN 978-1-4503-5639-8/18/04.<br/>DOI: <a class="link-inline force-break" target="_blank"     href="https://doi.org/10.1145/3178876.3186102">https://doi.org/10.1145/3178876.3186102</a>    </p>   </div>  </section>  <div class="pubHistory">   <p/>  </div>  </body> </html> 
