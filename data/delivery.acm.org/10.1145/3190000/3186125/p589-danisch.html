<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> <head>  <title>Listing k-cliques in Sparse Real-World Graphs</title>  <!-- Copyright (c) 2010-2015 The MathJax Consortium --><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>  <meta name="viewport" content="width=device-width; initial-scale=1.0;"></meta>  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>  <link media="screen, print" rel="stylesheet"    href="../../../../dl.acm.org/pubs/lib/css/bootstrap.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../../dl.acm.org/pubs/lib/css/bootstrap-theme.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../../dl.acm.org/pubs/lib/css/main.css"/><script src="../../../../dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script>  <script src="../../../../dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script>  <script src="../../../../dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script>  <script src="../../../../dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script>  <script type="text/javascript"    src="../../../../dl.acm.org/pubs/lib/js/MathJax.js?config=TeX-AMS_CHTML"></script>  <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script> </head> <body id="main">  <section class="front-matter">   <section>    <header class="title-info">    <div class="journal-title">     <h1>      <span class="title">Listing k-cliques in Sparse Real-World Graphs<a class="fn" href="#fn1" id="foot-fn1"><sup>&#x002A;</sup></a></a>      </span>      <br/>      <span class="subTitle"/>     </h1>    </div>    </header>    <div class="authorGroup">    <div class="author">     <span class="givenName">Maximilien</span>     <span class="surName">Danisch</span>,<a class="fn" href="#fn3" id="foot-fn3"><sup>&#x2020;</sup></a>     Sorbonne Universit&#x00E9;, CNRS, Laboratoire d&#x0027;Informatique de Paris 6, LIP6, F-75005 Paris, France, <a href="mailto:maximilien.danisch@lip6.fr">maximilien.danisch@lip6.fr</a>    </div>    <div class="author">     <span class="givenName">Oana</span>     <span class="surName">Balalau</span>,<a class="fn" href="#fn4" id="foot-fn4"><sup>&#x2021;</sup></a>     Max Planck Institute for Informatics, Saarbr&#x00FC;cken, Germany, <a href="mailto:obalalau@mpi-inf.mpg.de">obalalau@mpi-inf.mpg.de</a>    </div>    <div class="author">     <span class="givenName">Mauro</span>     <span class="surName">Sozio</span>,     LTCI, T&#x00E9;l&#x00E9;com ParisTech University, Paris, France, <a href="mailto:sozio@telecom-paristech.fr">sozio@telecom-paristech.fr</a>    </div>                </div>    <br/>    <div class="pubInfo">    <p>DOI: <a href="https://doi.org/10.1145/3178876.3186125" target="_blank">https://doi.org/10.1145/3178876.3186125</a>     <br/>WWW '18: <a href="https://doi.org/10.1145/3178876" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p>    </div>    <div class="abstract">    <p>     <small>Motivated by recent studies in the data mining community which require to efficiently list all <em>k</em>-cliques, we revisit the iconic algorithm of Chiba and Nishizeki and develop the most efficient parallel algorithm for such a problem. Our theoretical analysis provides the best asymptotic upper bound on the running time of our algorithm for the case when the input graph is sparse. Our experimental evaluation on large real-world graphs shows that our parallel algorithm is faster than state-of-the-art algorithms, while boasting an excellent degree of parallelism. In particular, we are able to list all <em>k</em>-cliques (for any <em>k</em>) in graphs containing up to tens of millions of edges as well as all 10-cliques in graphs containing billions of edges, within a few minutes and a few hours respectively. Finally, we show how our algorithm can be employed as an effective subroutine for finding the <em>k</em>-clique core decomposition and an approximate <em>k</em>-clique densest subgraphs in very large real-world graphs.</small>    </p>    </div>    <div class="CCSconcepts">    <p> <small> <span style="font-weight:bold;">CCS Concepts:</span> &#x2022;<strong> Mathematics of computing </strong>&#x2192; <strong>Graph algorithms;</strong></small> </p>    </div>    <div class="classifications">    <div class="author">     <span style="font-weight:bold;">      <small>Keywords:</small>     </span>     <span class="keyword">      <small>k-clique listing and counting</small>, </span>     <span class="keyword">      <small> real-world graph algorithms</small>     </span>    </div>    <br/>    <div class="AcmReferenceFormat">     <p>      <small>       <span style="font-weight:bold;">ACM Reference Format:</span>       <br/>       Maximilien Danisch, Oana Balalau, and Mauro Sozio. 2018. Listing k-cliques in Sparse Real-World Graphs. In <em>WWW 2018: The 2018 Web Conference,</em>       <em>April 23&#x2013;27, 2018, Lyon, France.</em> ACM, New York, NY, USA, 11 Pages. <a href="https://doi.org/10.1145/3178876.3186125" class="link-inline force-break"       target="_blank">https://doi.org/10.1145/3178876.3186125</a></small>     </p>    </div>    </div>   </section>  </section>  <section class="body">   <section id="sec-4">    <header>    <div class="title-info">     <h2>      <span class="section-number">1</span> Introduction</h2>    </div>    </header>    <p>Finding dense subgraphs is an important research area in graph mining&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0019">19</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0037">37</a>], with applications in community detection&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0020">20</a>], spam-link farms in web graphs&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0027">27</a>], real-time story identification&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0005">5</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0039">39</a>], motif detection in biological networks&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0026">26</a>], epilepsy prediction&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0030">30</a>], graph compression&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0013">13</a>], distance query indexing&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0032">32</a>], finding correlated genes&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0045">45</a>], finance&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0021">21</a>] and many others.</p>    <p>Cliques are the dense subgraphs par excellence. The concept of a clique has been originally introduced by sociologists to measure social cohesiveness before the advent of computers&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0052">52</a>]. In our work, we study the problem of listing all <em>k</em>-cliques in a graph, which are subgraphs with <em>k</em> nodes, each pair of which being connected with an edge. Such a problem is a natural generalization of the problem of listing triangles, which has been intensively studied by the research community. In particular, state-of-the-art algorithms can list all triangles in real-world graphs containing several billions of edges&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0036">36</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0040">40</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0049">49</a>] within a few hours. In contrast, listing all <em>k</em>-cliques is often deemed not feasible with most of the works focusing on approximately counting cliques&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0031">31</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0042">42</a>].</p>    <p>Recent works in the data mining and database community call for efficient algorithms for listing or counting all <em>k</em>-cliques in the input graph. In particular, in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0051">51</a>] the author develops an algorithm for finding subgraphs with maximum average number of <em>k</em>-cliques, with listing <em>k</em>-cliques being an important building block. In&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0046">46</a>] an algorithm for organizing cliques into hierarchical structures is presented, which requires to list all <em>k</em>-cliques. In&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0005">5</a>], algorithms for finding cliques and quasi-cliques (i.e. cliques where a few edges might be missing) with at most <em>k</em> nodes are used for story-identification in social media. Algorithms for listing <em>k</em>-cliques (and more generally <em>k</em>-motifs) may also be used to reveal the latent higher-order organization in real-world graphs&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0008">8</a>] or to compute percolated <em>k</em>-clique communities [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0028">28</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0043">43</a>].</p>    <p>Motivated by the aforementioned studies, we develop the most efficient algorithm for listing and counting all <em>k</em>-cliques in large sparse real-world graphs, with <em>k</em> being an input parameter. In fact, real-world graphs are often &#x201C;sparse&#x201D; and rarely contain very large cliques which allows us to solve such a problem efficiently. In our work, the sparsity of a graph is measured by its core value. We revisit the iconic algorithm developed by Chiba and Nishizeki&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0016">16</a>], which is one of the most efficient algorithms for this problem. By means of several improvements on such an algorithm, we are able to provide the best asymptotic upper bound on the running time, in the case when the input graph has &#x201C;low&#x201D; core value. Moreover, our algorithm can be efficiently parallelized resulting in even better performances in practice.</p>    <p>Our extensive experimental evaluation shows that both the sequential and parallel versions of our algorithm outperform significantly state-of-the-art approaches for the same problem. In particular, our parallel algorithm is able to list all cliques in graphs containing up to tens millions edges, as well as all 10-cliques in graphs containing billions of edges, within a few minutes or a few hours, respectively, while achieving an excellent degree of parallelism. We show that our algorithm can be employed as an effective subroutine for computing a <em>k</em>-clique core decomposition in large graphs, an approximation of the <em>k</em>-clique densest subgraph&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0051">51</a>], as well as, for finding quasi-cliques. Finally, we are able to estimate the accuracy of the approach proposed in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0031">31</a>] in approximating the number of <em>k</em>-cliques, for those graphs whose exact count of <em>k</em>-cliques was not known before our work.</p>    <p>The rest of the paper is organized as follows. We present the related work in Section&#x00A0;<a class="sec" href="#sec-5">2</a> and the notations we use in Section&#x00A0;<a class="sec" href="#sec-6">3</a>. In Section&#x00A0;<a class="sec" href="#sec-7">4</a>, we present our algorithm for listing <em>k</em>-cliques and prove its theoretical guarantees in Section&#x00A0;<a class="sec" href="#sec-11">5</a>. We then evaluate the performance of our algorithm against the state-of-the-art (Section&#x00A0;<a class="sec" href="#sec-12">6</a>). In Section&#x00A0;<a class="sec" href="#sec-17">6.5</a> we adapt our algorithm so as to compute the <em>k</em>-clique core decomposition of a graph and compute an approximation of the <em>k</em>-clique densest subgraph. In Section&#x00A0;<a class="sec" href="#sec-18">6.6</a>, we estimate the accuracy of the approach proposed in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0031">31</a>] for those graphs whose exact count of <em>k</em>-cliques was not known before our work. Finally, we conclude and present future work in Section&#x00A0;<a class="sec" href="#sec-19">7</a>.</p>   </section>   <section id="sec-5">    <header>    <div class="title-info">     <h2>      <span class="section-number">2</span> Related Work</h2>    </div>    </header>    <p>We organize the related work into the following sections: listing all <em>k</em>-cliques, listing all maximal cliques, counting <em>k</em>-cliques, counting <em>k</em>-motifs and finding <em>k</em>-clique densest subgraphs. Given that the related work in this research area is vast, our related work might not be comprehensive and will focus only on the most relevant works to our study.</p>    <p>    <strong>Listing all <em>k</em>-cliques.</strong> Prior to our work, the sequential algorithm with the best known asymptotic running time for listing <em>k</em>-cliques in sparse graphs was the algorithm of Chiba and Nishizeki&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0016">16</a>], to the best of our knowledge. Its running time is in <em>O</em>(<em>k</em> &#x00B7; <em>m</em> &#x00B7; <em>a</em>(<em>G</em>)<sup>     <em>k</em> &#x2212; 2</sup>), where <em>a</em>(<em>G</em>) is the arboricity of the graph. For our algorithm, we are able to provide an asymptotic upper bound of <span class="inline-equation"><span class="tex">$O(k\cdot m \cdot (\frac{c(G)}{2})^{k-2})$</span>    </span>, where <em>c</em>(<em>G</em>) is the core value of the graph. Given that <em>c</em>(<em>G</em>) &#x2264; 2<em>a</em>(<em>G</em>) &#x2212; 1 for any <em>G</em>, our upper bound becomes better when <em>k</em> is large enough. We defer to future work, a more rigorous study of the running time of the two algorithms. In practice, our algorithm is nearly an order of magnitude faster, while our parallel algorithm achieves an optimal degree of parallelism. We provide an efficient implementation of&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0016">16</a>] in C, which to the best of our knowledge was not publicly available.</p>    <p>The approach presented in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0040">40</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0049">49</a>] has been proved to be efficient in practice. Although initially devised for counting and listing maximal cliques it can also be adapted to <em>k</em>-clique listing and counting. It is based on the well-known Bron-Kerbosch algorithm&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0012">12</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0015">15</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0040">40</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0050">50</a>] for counting maximal cliques. An efficient implementation of such an algorithm is available at&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>]. According to our experiments, such an approach appears to be less efficient than our implementation of the algorithm of Chiba and Nishizeki.</p>    <p>Observe that those algorithms are sequential. Our experimental evaluation shows that one can highly benefit from uniformly distributing the computational load across several threads.</p>    <p>Triangle listing and counting (i.e. 3-clique listing) have been studied intensively in recent years, with the algorithms proposed in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0016">16</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0036">36</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0040">40</a>] being perhaps the most efficient ones in practice, when the input graph fits into main memory. In particular, the compact-forward algorithm developed in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0036">36</a>] has running time of <span class="inline-equation"><span class="tex">$O(m\cdot \sqrt {m})$</span>    </span>, while in the case when the degree distribution of the input graph <em>G</em> follows a power law distribution with exponent <em>&#x03B1;</em>(<em>G</em>) the running time is in <span class="inline-equation"><span class="tex">$O(m\cdot n^{\frac{1}{\alpha (G)}})$</span>    </span>. The algorithm presented in&#x00A0; [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0016">16</a>] has running time <em>O</em>(<em>m</em> &#x00B7; <em>a</em>(<em>G</em>)), where <em>a</em>(<em>G</em>) is the arboricity of the graph and <em>m</em> is the number of edges. In [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0040">40</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0049">49</a>], authors develop an algorithm to list all maximal cliques, while an implementation of their algorithm to count triangles efficiently is available at&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>]. From a theoretical point of view, the state of the art algorithm for triangle counting and listing are&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0004">4</a>] and&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0010">10</a>], respectively. The running time of&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0004">4</a>] is <span class="inline-equation"><span class="tex">$O(m^{\frac{2\omega }{\omega +1}})$</span>    </span>, where <em>&#x03C9;</em> denotes the fast matrix multiplication exponent. The algorithms proposed in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0010">10</a>] are output sensitive, i.e., they are fast if the number of triangles in the input graph is small. It is unclear whether the two latter algorithms work well in practice. Several algorithms have been proposed in the case when the graph does not fit into main memory, such as&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0034">34</a>] in the MapReduce architecture, [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0007">7</a>] in the semi-streaming model as well as the I/O-efficient algorithm presented in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0017">17</a>]. Generally speaking, MapReduce algorithms seem to be slower than main-memory based algorithms, however, they could scale to larger graphs&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0042">42</a>].</p>    <p>    <strong>Listing all maximal cliques.</strong> Most algorithms for listing all maximal cliques are based on the seminal algorithm developed by Bron and Kerbosch&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0012">12</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0015">15</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0040">40</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0050">50</a>]. The state of the art algorithm for this problem has running time <span class="inline-equation"><span class="tex">$O(c(G)\cdot n\cdot 3^{\frac{c(G)}{3}})$</span>    </span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0023">23</a>], where <em>c</em>(<em>G</em>) is the core number of the input graph. Such running time is almost tight as the largest number of maximal cliques in a graph with core number <em>c</em>(<em>G</em>) is <span class="inline-equation"><span class="tex">$(n-c(G))\cdot 3^{\frac{c(G)}{3}}$</span>    </span>. There are also efficient parallel versions of such an algorithm&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0047">47</a>]. In practice, algorithms for maximal cliques enumeration or counting can deal with large real-world graphs but hardly scale to very large graphs&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0024">24</a>]. Recent works have focused on devising distributed algorithms that can deal with large real-world graphs via a distributed computation on smaller blocks of data&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0015">15</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0018">18</a>].</p>    <p>    <strong>Counting <em>k</em>-cliques.</strong> Listing all <em>k</em>-cliques in a graph is often deemed not feasible with most of the works focusing on approximately counting cliques&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0031">31</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0042">42</a>]. Armed with our efficient algorithm for listing all <em>k</em>-cliques in a graph, we are able to estimate the accuracy of the approach proposed in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0031">31</a>] for those graphs whose exact count of <em>k</em>-cliques was not known before our work. An algorithm for computing the exact count of <em>k</em>-cliques has been developed in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0025">25</a>] for the MapReduce framework.</p>    <p>    <strong>Counting <em>k</em>-motifs.</strong>     <em>k</em>-cliques are a special case of <em>k</em>-motifs, therefore we also include the related work for counting <em>k</em>-motifs (also called graphlets). In [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0002">2</a>], the authors develop an algorithm for counting each of all possible 4-motifs in large graphs which was later generalized to 5-motifs&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0044">44</a>]. In [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0011">11</a>], the authors provide algorithms with statistical guarantees for the approximate counting of <em>k</em>-motifs. The former work is based on color coding&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0003">3</a>], a randomized algorithm for finding simple paths or cycles of length <em>k</em>.</p>    <p>    <strong>k-clique densest subgraph and core decomposition.</strong> In&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0051">51</a>], the author studies the <em>k</em>-clique densest subgraph problem, which consists of finding a subgraph with maximum ratio between the number of its <em>k</em>-cliques and its number of nodes. This is a generalization of the well-known densest subgraph problem, which has received increasing attention in recent years&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0006">6</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0019">19</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0022">22</a>]. In&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0051">51</a>], the author develops an algorithm to compute the <em>k</em>-clique core decomposition, which is a generalization of the well-known core decomposition. In our work, we show how to significantly speed up the computation of the two aforementioned problems by means of our algorithm for listing <em>k</em>-cliques.</p>   </section>   <section id="sec-6">    <header>    <div class="title-info">     <h2>      <span class="section-number">3</span> Definitions and Notation</h2>    </div>    </header>    <p>We assume w.l.g. that the input graph is connected with its size being <em>O</em>(<em>m</em>), where <em>m</em> is the number of edges. Otherwise, our algorithm can be executed on each of the connected components, separately. We denote with <em>V</em>(<em>G</em>) and <em>E</em>(<em>G</em>) the set of nodes and the set of edges of an undirected graph <em>G</em>, respectively. We denote with <em>&#x0394;<sub>G</sub>    </em>(<em>u</em>) the set of neighbors of a node <em>u</em> in <em>G</em>, while <em>G</em>[<em>S</em>] denotes the subgraph induced by the set of nodes <em>S</em>&#x2286;<em>V</em>(<em>G</em>).</p>    <p>We shall use the notation <span class="inline-equation"><span class="tex">$\vec{G}$</span>    </span> to denote a directed graph (where the set of edges are ordered pairs). A Directed Acyclic Graphs (DAG) is a directed graph with no directed cycles. We denote with <span class="inline-equation"><span class="tex">$\Delta ^+_{\vec{G}}(u)$</span>    </span> and <span class="inline-equation"><span class="tex">$\Delta _{\vec{G}}^-(u)$</span>    </span> the set of out-neighbors and the set of in-neighbors of node <em>u</em> in <span class="inline-equation"><span class="tex">$\vec{G}$</span>    </span>, respectively, while <em>&#x03B4;</em>    <sup>+</sup>(<em>u</em>) and <em>&#x03B4;</em>    <sup>&#x2212;</sup>(<em>u</em>) denote the number of out-neighbors and in-neighbors of <em>u</em>, respectively. We shall only refer to <span class="inline-equation"><span class="tex">$\Delta ^+_{\vec{G}}(u)$</span>    </span> in the rest of our paper, therefore we shall use the notation <span class="inline-equation"><span class="tex">$\Delta _{\vec{G}}(u):= \Delta ^+_{\vec{G}}(u)$</span>    </span>. Similarly to the case of undirected graphs, <span class="inline-equation"><span class="tex">$\vec{G}[S]$</span>    </span> denotes the induced subgraph by the set of nodes <em>S</em> in <span class="inline-equation"><span class="tex">$\vec{G}$</span>    </span>.</p>    <p>The <em>arboricity a</em>(<em>G</em>) of a graph <em>G</em> is defined as the minimum number of forests into which the set of edges of <em>G</em> can be partitioned. The <em>core value c</em>(<em>G</em>) (also called <em>degeneracy</em>) of a graph <em>G</em> is defined as the maximum integer <em>c</em> such that there exists an induced subgraph <em>H</em> of <em>G</em> with all nodes having degree at least <em>c</em>. It is known that for any graph <em>G</em>, <em>c</em>(<em>G</em>) is in [<em>a</em>(<em>G</em>), 2<em>a</em>(<em>G</em>) &#x2212; 1]&#x00A0;([<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0053">53</a>]).</p>    <p>The core value of a graph can be computed in linear time by the algorithm that repeatedly removes a node with minimum degree until the graph becomes empty. We shall refer to any ordering on the nodes induced by such an algorithm, as <em>core ordering</em>.</p>    <p>Let <em>G</em> be an undirected graph, let <em>&#x03B7;</em>: <em>V</em>(<em>G</em>)&#x21A6;[1, |<em>V</em>(<em>G</em>)|] be a total ordering on the nodes of <em>G</em> and let <span class="inline-equation"><span class="tex">$\vec{G}$</span>    </span> be a directed graph. We say that <span class="inline-equation"><span class="tex">$\vec{G}$</span>    </span> is induced by the ordering <em>&#x03B7;</em>, if <span class="inline-equation"><span class="tex">$V(G) := V(\vec{G})$</span>    </span> and there is an edge <em>v</em> &#x2192; <em>u</em> if <em>&#x03B7;</em>(<em>v</em>) < <em>&#x03B7;</em>(<em>u</em>) and (<em>u</em>, <em>v</em>) &#x2208; <em>E</em>(<em>G</em>). Observe that <span class="inline-equation"><span class="tex">$\vec{G}$</span>    </span> is a DAG. Moreover, observe that, if <em>&#x03B7;</em> is the core ordering, then the maximum out-degree in <span class="inline-equation"><span class="tex">$\vec{G}$</span>    </span> is the core value of <em>G</em>.</p>    <p>Our theoretical analysis is in the worst case, unless otherwise specified. We study the <em>parameterized complexity</em> of our problem. We measure the running time of our algorithm as a function of the input size <em>m</em>, as well as the parameters <em>k</em> and <em>c</em>(<em>G</em>) which significantly affect its running time.</p>   </section>   <section id="sec-7">    <header>    <div class="title-info">     <h2>      <span class="section-number">4</span> Algorithms</h2>    </div>    </header>    <section id="sec-8">    <header>     <div class="title-info">      <h3>       <span class="section-number">4.1</span> Algorithm of Chiba and Nishizeki</h3>     </div>    </header>    <p>We start by providing a compact description of the algorithm developed by Chiba and Nishizeki for listing <em>k</em>-cliques&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0016">16</a>]. The algorithm processes the nodes in non-increasing order of degree. For each node <em>u</em>, the algorithm computes the subgraph induced by its neighbors, and then it recurses on such a subgraph. When processing the nodes of a given subgraph, its nodes might have to be reordered in non-increasing order of degree (line 7 of Algorithm&#x00A0;1). After processing a node <em>u</em>, <em>u</em> is deleted from the current graph so as to prevent that any clique containing <em>u</em> is listed more than once (line 10 of Algorithm&#x00A0;1). A pseudocode of the algorithm is shown in Algorithm&#x00A0;1 .</p>    <p>Such an algorithm is relatively simple, yet it turns out to be one of the most efficient algorithms for listing <em>k</em>-cliques in sparse real-world graphs. This is obtained by using some efficient data structures, in particular, to compute the subgraphs induced on the neighbors of a given node (line 9 of Algorithm&#x00A0;1). An appealing feature of the algorithm is that its running time can be bounded as a function of the arboricity of the input graph, which is a natural way to measure the sparsity of a graph.</p>    <div class="theorem" id="enc1">     <Label>Theorem 4.1.</Label>     <p> (Running time of Algorithm&#x00A0;1 ([<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"       href="#BibPLXBIB0016">16</a>])) Algorithm&#x00A0;1 lists all <em>k</em>-cliques in <em>O</em>(<em>k</em> &#x00B7; <em>m</em> &#x00B7; <em>a</em>(<em>G</em>)<sup>       <em>k</em> &#x2212; 2</sup>) time (where <em>a</em>(<em>G</em>) is the arboricity of the input graph <em>G</em>), while it requires linear memory.</p>    </div>    <p>     <img src="../../../../deliveryimages.acm.org/10.1145/3190000/3186125/images/www2018-134-img1.svg" class="img-responsive" alt="" longdesc=""/>    </p>    <p>We shall focus our efforts on improving the following three aspects of Algorithm&#x00A0;1 .</p>    <ol class="list-no-style">     <li id="list1" label="(1)">Can the algorithm be efficiently parallelized? Line 10 of Algorithm&#x00A0;1 introduces a sequential dependency between the nodes in the input graph, which makes an efficient parallelization of the algorithm non-straightforward. In particular, it does not seem trivial to balance the workload across the different threads in a multicore implementation.<br/></li>     <li id="list2" label="(2)">Is there a more efficient way of processing the nodes of the input graph? Algorithm&#x00A0;1 processes the nodes by non-increasing degree. Although this simplifies the analysis of the running time of the algorithm, it might not be an optimal ordering in practice.<br/></li>     <li id="list3" label="(3)">Can the number of operations be decreased even further? In particular, we are planning to consider a directed version of the input graph which shall guide us in avoiding unnecessary computations.<br/></li>    </ol>    </section>    <section id="sec-9">    <header>     <div class="title-info">      <h3>       <span class="section-number">4.2</span> The <SmallCap>kClist</SmallCap> Algorithm</h3>     </div>    </header>    <p>A pseudocode of our algorithm, called <SmallCap>kClist</SmallCap>, is shown in Algorithm&#x00A0;2 . Observe the following differences. Our algorithm can receive in input any total ordering <em>&#x03B7;</em> on the nodes of the graph. According to our analysis and experiments, the core ordering is an ordering that performs well, however, other orderings on the nodes might be considered. A theoretical study on the best ordering is given in Section&#x00A0;<a class="sec" href="#sec-11">5</a>. Observe that such an ordering is used to obtain a DAG. The function <SmallCap>listing</SmallCap> is then modified as nodes are not sorted again inside the function (line 7 of Algorithm&#x00A0;1). Moreover, the DAG <span class="inline-equation"><span class="tex">$\vec{G}$</span>     </span> prevents that a same clique is listed more than once, which makes the deletion step in line 10 of Algorithm&#x00A0;1 not necessary anymore. This in turn, allows for a more efficient parallel implementation of our algorithm.</p>    <p>     <img src="../../../../deliveryimages.acm.org/10.1145/3190000/3186125/images/www2018-134-img2.svg" class="img-responsive" alt="" longdesc=""/>    </p>    <p>     <strong>Efficient Implementation.</strong> The algorithm can be implemented efficiently using the following data structures and operations which are an adaptation of the ones used in the algorithm of Chiba and Nishizeki&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0016">16</a>]. The DAG <span class="inline-equation"><span class="tex">$\vec{G}$</span>     </span> created in line 2 is represented as an adjacency list storing for each node <em>u</em>, its out-degree <em>&#x03B4;</em>     <sup>+</sup>(<em>u</em>) and all its out-neighbors in an array <em>&#x0394;</em>(<em>u</em>). No other adjacency lists will be created. In particular, given the current graph <span class="inline-equation"><span class="tex">$\vec{G}$</span>     </span> in the recursion, we make sure that the out-neighbors of any node <em>v</em> in <span class="inline-equation"><span class="tex">$\vec{G}$</span>     </span> always appear first in the array <em>&#x0394;</em>(<em>v</em>). This is obtained by reordering each time inside the recursion, which can be done efficiently. Given <span class="inline-equation"><span class="tex">$\vec{G}$</span>     </span>, <span class="inline-equation"><span class="tex">$\vec{G}[\Delta _{\vec{G}}(u)]$</span>     </span> is built as follows.</p>    <ul class="list-no-style">     <li id="list4" label="&#x2022;">Use an array with a label for each node initially set to <em>k</em>.<br/></li>     <li id="list5" label="&#x2022;">For each out-neighbor <em>v</em> of node <em>u</em> in <span class="inline-equation"><span class="tex">$\vec{G}$</span>      </span>, set its label to <em>l</em> &#x2212; 1 if the label was equal to <em>l</em>. We thus have that if a label of a node <em>v</em> is equal to <em>l</em> &#x2212; 1 it means that node <em>v</em> is in the new DAG <span class="inline-equation"><span class="tex">$\vec{G}[\Delta _{\vec{G}}(u)]$</span>      </span>.<br/></li>     <li id="list6" label="&#x2022;">For each out-neighbor <em>v</em> of <em>u</em>, move all the out-neighbors of <em>v</em> with label equal to <em>l</em> &#x2212; 1 in the first part of <em>&#x0394;</em>(<em>v</em>) (by swapping nodes) and compute the out-degree of node <em>v</em> in the new DAG <span class="inline-equation"><span class="tex">$\vec{G}[\Delta _{\vec{G}}(u)]$</span>      </span> updating <em>d</em>(<em>v</em>). The first <em>d</em>(<em>v</em>) nodes in <em>&#x0394;</em>(<em>v</em>) are thus the out-neighbors of <em>v</em> in <span class="inline-equation"><span class="tex">$\vec{G}[\Delta _{\vec{G}}(u)]$</span>      </span> .<br/></li>    </ul>    </section>    <section id="sec-10">    <header>     <div class="title-info">      <h3>       <span class="section-number">4.3</span> Efficient Parallel Algorithm</h3>     </div>    </header>    <p>One appealing feature of our algorithm is that the <span class="inline-equation"><span class="tex">$\vec{G}[\Delta _{\vec{G}}(u)]$</span>     </span>&#x2019;s can be processed independently. The same clique would not be listed more than once, thanks to the fact that <span class="inline-equation"><span class="tex">$\vec{G}$</span>     </span> is a directed graph. Such a problem has been circumvented in Algorithm&#x00A0;1 by line 10 (where each node is deleted after being processed), which unfortunately makes an efficient parallelization non-trivial. It does not seem straightforward to achieve good workload balancing across the threads.</p>    <p>We refer to the variant of our algorithm where the <span class="inline-equation"><span class="tex">$\vec{G}[\Delta _{\vec{G}}(u)]$</span>     </span>&#x2019;s are processed in parallel as <SmallCap>Node-Parallel</SmallCap>. It turns out that such a first attempt in parallelizing the algorithm suffers from a poor degree of parallelism, in particular when the number of threads is large (in our experiments larger than 10). This is due to the fact that the number of <em>k</em>-cliques in the input graph might not be distributed uniformly across the <span class="inline-equation"><span class="tex">$\vec{G}[\Delta _{\vec{G}}(u)]$</span>     </span>&#x2019;s, resulting in an unbalanced workload across the threads.</p>    <p>Such a problem is alleviated in what we call the <SmallCap>Edge-Parallel</SmallCap> variant of our algorithm. In such a variant, each subgraph <span class="inline-equation"><span class="tex">$\vec{G}[\Delta _{\vec{G}}(uv)]$</span>     </span> is processed independently in parallel, where <span class="inline-equation"><span class="tex">$\Delta _{\vec{G}}(uv)=\Delta _{\vec{G}}(u) \cap \Delta _{\vec{G}}(v)$</span>     </span> denotes the set of out-neighbors of <em>u</em> and <em>v</em> with (<em>u</em>, <em>v</em>) &#x2208; <em>E</em>(<em>G</em>). Since the <span class="inline-equation"><span class="tex">$\vec{G}[\Delta _{\vec{G}}(uv)]$</span>     </span>&#x2019;s are &#x201C;smaller&#x201D; than the <span class="inline-equation"><span class="tex">$\vec{G}[\Delta _{\vec{G}}(u)]$</span>     </span>&#x2019;s, we achieve a higher degree of parallelism. A pseudocode is shown in Algorithm&#x00A0;3, where the function <SmallCap>listing</SmallCap> has been defined in Algorithm&#x00A0;2 . A pseudocode for <SmallCap>Node-Parallel</SmallCap> can be easily obtained by replacing <SmallCap>listing</SmallCap><span class="inline-equation"><span class="tex">$\ {}(k-2,\vec{G}[\Delta _{\vec{G}}(uv)],\lbrace u,v\rbrace)$</span>     </span> with <SmallCap>listing</SmallCap> <span class="inline-equation"><span class="tex">$(k-1,\vec{G}[\Delta _{\vec{G}}(u)],\lbrace u\rbrace)$</span>     </span> in line 4 of Algorithm&#x00A0;3 (and looping in parallel over the nodes instead of the edges in line 3). Note that in the edge-parallel version when <em>k</em> = 3 (i.e. we seek to list triangles), we need to modify the recursive function <SmallCap>listing</SmallCap> so that it outputs triangles and terminates when <em>l</em> = 1 and not <em>l</em> = 2 (line 5 of Algorithm&#x00A0;2).</p>    <p>At any point in time, each thread processes one of the <span class="inline-equation"><span class="tex">$\vec{G}[\Delta _{\vec{G}}(uv)]$</span>     </span> subgraphs. Therefore, for each thread we need additionally <em>O</em>(<em>c</em>(<em>G</em>)<sup>2</sup>) space, in the case when the core ordering is used.</p>    <p>In Section <a class="sec" href="#sec-12">6</a> we evaluate both the <SmallCap>Node-Parallel</SmallCap> and <SmallCap>Edge-Parallel</SmallCap> variants of our algorithm, showing that <SmallCap>Edge-Parallel</SmallCap> boasts an excellent degree of parallelism on 40 threads or more.</p>    <p>     <img src="../../../../deliveryimages.acm.org/10.1145/3190000/3186125/images/www2018-134-img3.svg" class="img-responsive" alt="" longdesc=""/>    </p>    </section>   </section>   <section id="sec-11">    <header>    <div class="title-info">     <h2>      <span class="section-number">5</span> Analysis of the Algorithm</h2>    </div>    </header>    <p>    <div class="lemma" id="enc2">     <Label>Lemma 5.1.</Label>     <p> (Correctness) Algorithm&#x00A0;2 lists every <em>k</em>-clique exactly once.</p>    </div>    </p>    <div class="proof" id="proof1">    <Label>Proof.</Label>    <p> Let <em>v</em>     <sub>1</sub>, &#x2026;, <em>v<sub>k</sub>     </em> be the nodes of a <em>k</em>-clique. Suppose w.l.g that &#x2200;<em>l</em> &#x2208; [[2, <em>k</em>]], <em>&#x03B7;</em>(<em>v</em>     <sub>      <em>l</em> &#x2212; 1</sub>) > <em>&#x03B7;</em>(<em>v<sub>l</sub>     </em>). Observe that this is the only ordering such that &#x2200;<em>l</em> &#x2208; [[3, <em>k</em>]], <span class="inline-equation"><span class="tex">$v_{l-1} \in \Delta _{\vec{G}}(v_l)$</span>     </span> (line 10) and <span class="inline-equation"><span class="tex">$v_1 \in \Delta _{\vec{G}}(v_2)$</span>     </span> (line 7) . Therefore, such a <em>k</em>-clique is produced in output exactly once. &#x25A1;</p>    </div>    <p>    <div class="lemma" id="enc3">     <Label>Lemma 5.2.</Label>     <p> Let <span class="inline-equation"><span class="tex">$\vec{G}$</span>      </span> be a DAG. Let <em>C</em> be any subset of the nodes in <span class="inline-equation"><span class="tex">$\vec{G}$</span>      </span> with |<em>C</em>| &#x2264; (<em>k</em> &#x2212; 2). The running time of the function listing<span class="inline-equation"><span class="tex">$l,\vec{G},C$</span>      </span> in Algorithm&#x00A0;2 can be upper bounded by <span class="inline-equation"><span class="tex">$T(l,\vec{G})$</span>      </span> for which we can write the following recurrence: <div class="table-responsive">       <div class="display-equation">       <span class="tex mytex">\begin{eqnarray*} \nonumber \left\lbrace \begin{aligned} T(2,\vec{G})&#x0026;= \Theta (k\cdot |E (\vec{G})|) \\T(l,\vec{G}) &#x0026;= \Theta \left(\sum _{u\in V(\vec{G})} \sum _{v\in \Delta _{\vec{G}}(u)} |\Delta _{\vec{G}}(v)| \right) + \sum _{u \in V(\vec{G})} T\left(l-1,\vec{G}[\Delta _{\vec{G}} (u)] \right). \end{aligned} \right.\end{eqnarray*} </span>       <br/>       </div>      </div>     </p>    </div>    </p>    <div class="proof" id="proof2">    <Label>Proof.</Label>    <p> The time to output a <em>k</em>-clique for each edge in <span class="inline-equation"><span class="tex">$\vec{G}$</span>     </span> (line 7) is <span class="inline-equation"><span class="tex">$\Theta (k\cdot |E(\vec{G})|)$</span>     </span>. The algorithm builds <span class="inline-equation"><span class="tex">$\vec{G}[\Delta _{\vec{G}}(u)]$</span>     </span> for all <em>u</em> in <span class="inline-equation"><span class="tex">$V(\vec{G})$</span>     </span> (line 10) which requires <span class="inline-equation"><span class="tex">$\Theta (\sum _{u\in V(\vec{G})} \sum _{v\in \Delta _{\vec{G}}(u)} |\Delta _{\vec{G}}(v)|)$</span>     </span> time and then it recurses on each such a subgraph. &#x25A1;</p>    </div>    <p>Let <em>G</em> be an undirected graph. Let <em>&#x03B7;</em> be a total ordering on the nodes of <em>G</em>, while let <span class="inline-equation"><span class="tex">$\vec{G}$</span>    </span> be the directed version of <em>G</em> induced by <em>&#x03B7;</em>. From Lemma&#x00A0;<a class="enc" href="#enc3">5.2</a>, it follows that the running time of Algorithm&#x00A0;2 with input <em>G</em> is <span class="inline-equation"><span class="tex">$O(T(k,\vec{G}) + m)$</span>    </span>.</p>    <p>It turns out that the total ordering <em>&#x03B7;</em>, used in our algorithm (line 1), might have a significant impact on its running time. Therefore, a natural goal is to determine an optimal such ordering. To this end, we give a simple upper bound on the running of our algorithm for the case of listing triangles. We show that the problem of finding an ordering which minimizes such an upper bound is NP-hard even for the case when <em>k</em> = 3.</p>    <p>    <div class="lemma" id="enc4">     <Label>Lemma 5.3.</Label>     <p> (Running time for triangles) Let <em>G</em> be an undirected graph, let <em>&#x03B7;</em> be a total ordering on the nodes of <em>G</em>, while let <span class="inline-equation"><span class="tex">$\vec{G}$</span>      </span> be the directed graph induced by such ordering. Algorithm 2 lists all triangles in <span class="inline-equation"><span class="tex">$\Theta (m + \sum _{u \in V(\vec{G})} \delta _{\vec{G}}^+(u) \cdot \delta _{\vec{G}}^-(u))$</span>      </span>.</p>    </div>    </p>    <div class="proof" id="proof3">    <Label>Proof.</Label>    <p> From Lemma <a class="enc" href="#enc3">5.2</a>, <em>k</em> = 3, it follows that the running time of Algorithm 2 is <em>&#x0398;</em>(<em>T</em>(3, <em>G</em>     <sub>3</sub>) + <em>m</em>) where <em>T</em>(3, <em>G</em>     <sub>3</sub>) is in <span class="inline-equation"><span class="tex">$\Theta (\sum _{u\in V(\vec{G})}\sum _{v\in \Delta _{\vec{G}}(u)} |\Delta _{\vec{G}}(v)|)$</span>     </span>. The claim follows from the fact that each term <span class="inline-equation"><span class="tex">$|\Delta _{\vec{G}}(v)|$</span>     </span> occurs exactly <span class="inline-equation"><span class="tex">$\delta _{\vec{G}}^-(u)$</span>     </span> times in the latter sum. &#x25A1;</p>    </div>    <p>We can then state our NP-hardness theorem.</p>    <p>    <div class="theorem" id="enc5">     <Label>Theorem 5.4.</Label>     <p> (Minimizing the running time is NP-hard) Given a graph <em>G</em>, the problem of finding a total ordering <em>&#x03B7;</em> of the nodes in <em>G</em> which minimizes <span class="inline-equation"><span class="tex">$\sum _{u \in V(\vec{G})} \delta _{\vec{G}}^+(u) \cdot \delta _{\vec{G}}^-(u)$</span>      </span> is NP-hard.</p>    </div>    </p>    <div class="proof" id="proof4">    <Label>Proof.</Label>    <p> (Sketch) Assume <em>G</em> is a 3-regular graph. Given an optimal ordering, a solution to Max Cut can be obtained in polynomial time from the ordering and as Max Cut in 3-regular graphs is NP-hard [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0009">9</a>] the claim follows. We refer to [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0029">29</a>] for a full proof. &#x25A1;</p>    </div>    <p>Given that it is unlikely that there is an efficient algorithm for finding such an optimal ordering, we consider the core ordering which is widely used in graph mining&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0014">14</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0041">41</a>]. Such an ordering is appealing in that it can be computed in linear time, while it produces an induced DAG with the smallest maximum out-degree (equals to the core value of the input graph). Therefore, in view of Lemma&#x00A0;<a class="enc" href="#enc3">5.2</a> it seems a natural choice. Using such an ordering for our algorithm we can obtain a smaller asymptotic upper bound on its running time than the one provided in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0016">16</a>] (when <em>k</em> is sufficiently large). An interesting direction for future work is to provide a tight analysis of the running time of the two algorithms.</p>    <p>The following two lemmas shall be useful in our main theorem.</p>    <p>    <div class="lemma" id="enc6">     <Label>Lemma 5.5.</Label>     <p> Let <span class="inline-equation"><span class="tex">$\vec{G}$</span>      </span> be the directed graph induced on <em>G</em> by a core ordering. The following holds: <div class="table-responsive">       <div class="display-equation">       <span class="tex mytex">\[ \sum _{u\in V(\vec{G})}\sum _{v\in \Delta _{\vec{G}}(u)} |\Delta _{\vec{G}}(v)|\le c (G) \cdot |E(\vec{G})|. \] </span>       <br/>       </div>      </div>     </p>    </div>    </p>    <div class="proof" id="proof5">    <Label>Proof.</Label>    <p>     <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ \sum _{u\in V(\vec{G})}\sum _{v\in \Delta _{\vec{G}}(u)} |\Delta _{\vec{G}}(v)| \le \sum _{u\in V(\vec{G})}\sum _{v\in \Delta _{\vec{G}}(u)} c(G) \le c(G) \cdot |E(\vec{G})|. \] </span>       <br/>      </div>     </div> &#x25A1;</p>    </div>    <p>    <div class="lemma" id="enc7">     <Label>Lemma 5.6.</Label>     <p> Let <span class="inline-equation"><span class="tex">$\vec{G}$</span>      </span> be the directed graph induced on <em>G</em> by a core ordering. The following holds: <div class="table-responsive">       <div class="display-equation">       <span class="tex mytex">\[ \sum _{u \in V(\vec{G})} |E(\vec{G} [\Delta _{\vec{G}}(u)])| \le |E(\vec{G})| \cdot \frac{c(G)}{2} . \] </span>       <br/>       </div>      </div>     </p>    </div>    </p>    <div class="proof" id="proof6">    <Label>Proof.</Label>    <p> Let <span class="inline-equation"><span class="tex">$\vec{H}_u$</span>     </span> be the DAG induced by the out-neighbors of <em>u</em> in <span class="inline-equation"><span class="tex">$\vec{G}$</span>     </span>, that is, <span class="inline-equation"><span class="tex">$\vec{H}_u=\vec{G} [\Delta _{\vec{G}}(u)]$</span>     </span>. We have that: <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ \sum _{v\in \Delta _{\vec{G}}(u)} |\Delta _{\vec{H}_u}(v)| \le \frac{1}{2} \cdot |\Delta _{\vec{G}}(u)| \cdot (|\Delta _{\vec{G}}(u)| -1) {\lt} |\Delta _{\vec{G}}(u)| \cdot \frac{c(G)}{2}. \] </span>       <br/>      </div>     </div>    </p>    <p>Hence, we can derive the following inequalities: <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ \sum _{u \in V(\vec{G})}\sum _{v\in \Delta _{\vec{G}}(u)} |\Delta _{\vec{H}_u}(v)| \le \sum _{u \in V(\vec{G})} |\Delta _{\vec{G}}(u)|\cdot \frac{c(G)}{2} \le |E(\vec{G})| \cdot \frac{c(G)}{2}. \] </span>       <br/>      </div>     </div> &#x25A1;    </p>    </div>    <p>We now have all the ingredients to prove our main theorem. We measure the running time of our algorithm as a function of the parameters <em>k</em>, <em>c</em>(<em>G</em>) which significantly affect its running time.</p>    <p>    <div class="theorem" id="enc8">     <Label>Theorem 5.7.</Label>     <p> Let <em>G</em> be a connected graph with <em>m</em> edges and core value <em>c</em>(<em>G</em>). Algorithm 2 with core ordering lists all <em>k</em>-cliques in <em>G</em> in <span class="inline-equation"><span class="tex">$O(k \cdot m \cdot (\frac{c(G)}{2})^{k-2}+m)$</span>      </span> time, while it requires linear space in the size of <em>G</em>.</p>    </div>    </p>    <div class="proof" id="proof7">    <Label>Proof.</Label>    <p> As we need to store only the input graph, <em>O</em>(<em>m</em>) memory is sufficient. In the case when <em>c</em>(<em>G</em>) = 1 our algorithm terminates in linear time, in that, nodes in <span class="inline-equation"><span class="tex">$\vec{G}$</span>     </span> have outdegree 1 or less. When <em>c</em>(<em>G</em>) &#x2265; 2, our proof proceeds as follows. We prove by induction on l, 2 &#x2264; <em>l</em> &#x2264; <em>k</em>, that <span class="inline-equation"><span class="tex">$T(l,\vec{G}) \le \lambda \cdot (k + \frac{l}{2}) \cdot (\frac{c(G)}{2})^{l-2} \cdot |E(\vec{G})|$</span>     </span>, <em>&#x03BB;</em> > 0.</p>    <p>For <em>l</em> = 2, it follows from Lemma&#x00A0;<a class="enc" href="#enc3">5.2</a> that the running time is at most <span class="inline-equation"><span class="tex">$\lambda \cdot k\cdot |E(\vec{G})|$</span>     </span>. For <em>l</em> > 2 we have: <div class="table-responsive" id="eq1">      <div class="display-equation">       <span class="tex mytex">\begin{eqnarray} T(l,\vec{G}) \le &#x0026; \lambda \cdot c(G) \cdot |E({\vec{G}})| + \sum _{u \in V(\vec{G})}T(l-1,\vec{G}[\Delta _{\vec{G}}(u)]) \end{eqnarray} </span>       <br/>       <span class="equation-number">(1)</span>      </div>     </div>     <div class="table-responsive" id="eq2">      <div class="display-equation">       <span class="tex mytex">\begin{eqnarray} &#x0026;\le &#x0026; \lambda \cdot c(G) \cdot |E({\vec{G}})| \nonumber \\ &#x0026;+&#x0026; \lambda \cdot \sum _{u\in V(\vec{G})} (k+\frac{l-1}{2}) \cdot (\frac{c(G)}{2})^{l-3}\cdot |E(\vec{G}[\Delta _{\vec{G}}(u)])| \end{eqnarray} </span>       <br/>       <span class="equation-number">(2)</span>      </div>     </div>     <div class="table-responsive" id="eq3">      <div class="display-equation">       <span class="tex mytex">\begin{eqnarray} &#x0026;\le &#x0026; \lambda \cdot c(G) \cdot |E({\vec{G}})| \nonumber \\ &#x0026;+&#x0026; \lambda \cdot (k+\frac{l-1}{2}) \cdot (\frac{c(G)}{2})^{l-2}\cdot |E({\vec{G}})| \end{eqnarray} </span>       <br/>       <span class="equation-number">(3)</span>      </div>     </div>     <div class="table-responsive" id="eq4">      <div class="display-equation">       <span class="tex mytex">\begin{eqnarray} &#x0026;\le &#x0026; \lambda \cdot (k+\frac{l}{2})\cdot (\frac{c(G)}{2})^{l-2}\cdot |E({\vec{G}})|, \end{eqnarray} </span>       <br/>       <span class="equation-number">(4)</span>      </div>     </div> where Equation&#x00A0;(<a class="eqn" href="#eq2">2</a>) follows from the inductive hypothesis, Equation&#x00A0;(<a class="eqn" href="#eq3">3</a>) follows from Lemma&#x00A0;<a class="enc" href="#enc7">5.6</a>, while Equation&#x00A0;(<a class="eqn" href="#eq4">4</a>) follows from the fact that <span class="inline-equation"><span class="tex">$c(G)\le 2\cdot (\frac{c(G)}{2})^{l-2}$</span>     </span> for <em>k</em>, <em>c</em>(<em>G</em>) &#x2265; 2, <em>l</em> > 2. &#x25A1;</p>    </div>    <p>As <em>a</em>(<em>G</em>) &#x2264; <em>c</em>(<em>G</em>) &#x2264; 2 &#x00B7; <em>a</em>(<em>G</em>) &#x2212; 1 our algorithm is in <span class="inline-equation"><span class="tex">$O(k\cdot m\cdot (a(G)-\frac{1}{2})^{k-2})$</span>    </span> (for a connected graph) which is slightly better than the <em>O</em>(<em>k</em> &#x00B7; <em>m</em> &#x00B7; <em>a</em>(<em>G</em>)<sup>     <em>k</em> &#x2212; 2</sup>) bound provided by Chiba and Nishizeki. In graphs where <em>a</em>(<em>G</em>) = <em>c</em>(<em>G</em>) the advantage is more significant.</p>    <p>We also derive an output sensitive bound on the running time that we express as a function of <em>c</em>(<em>G</em>) and the number of <em>l</em>-cliques in the graph as shown in the following Theorem <a class="enc" href="#enc9">5.8</a>.</p>    <p>    <div class="lemma" id="enc9">     <Label>Lemma 5.8.</Label>     <p> (Output sensitive bound) Algorithm 2 with core ordering lists all <em>k</em>-cliques in <span class="inline-equation"><span class="tex">$O\big (c(G)\cdot \sum \limits _{l=2}^{k-1} N^l+k\cdot N^k\big)$</span>      </span> time where <em>N<sup>l</sup>      </em> is the number of <em>l</em>-cliques.</p>    </div>    </p>    <div class="proof" id="proof8">    <Label>Proof.</Label>    <p> With Lemma <a class="enc" href="#enc3">5.2</a> and Lemma <a class="enc" href="#enc6">5.5</a>, using core ordering, we have that for a given <em>l</em> < <em>k</em> &#x2212; 2 the time spent in the current level of recursion is <span class="inline-equation"><span class="tex">$O(|E(\vec{G})|\cdot c(G))$</span>     </span> (the time to build all the <span class="inline-equation"><span class="tex">$\vec{G}[\Delta _{\vec{G}}(u)]$</span>     </span>), while for <em>l</em> = <em>k</em> &#x2212; 2 the time is in <span class="inline-equation"><span class="tex">$O(k\cdot |E(\vec{G})|)$</span>     </span> (the time to output the <span class="inline-equation"><span class="tex">$|E(\vec{G})|$</span>     </span>     <em>k</em>-cliques). In addition, we notice that, for a given <em>l</em>, the sum of all <span class="inline-equation"><span class="tex">$|E(\vec{G})|$</span>     </span> is exactly the number of (<em>k</em> &#x2212; <em>l</em> + 2)-cliques in the input graph <em>G</em> (the <em>k</em> &#x2212; <em>l</em> + 2 nodes in the set <em>C</em>), that is <em>N</em>     <sup>      <em>k</em> &#x2212; <em>l</em> + 2</sup>. Summing it all we obtain the stated running time. &#x25A1;</p>    </div>    <p>Observe that to output all <em>k</em>-cliques, <em>&#x03A9;</em>(<em>k</em> &#x00B7; <em>N<sup>k</sup>    </em>) operations are needed. The running time of our algorithm is thus optimal in the case when the term <em>k</em> &#x00B7; <em>N<sup>k</sup>    </em> dominates the term <span class="inline-equation"><span class="tex">$c(G)\cdot \sum _{l=2}^{k-1} N^l$</span>    </span>.</p>   </section>   <section id="sec-12">    <header>    <div class="title-info">     <h2>      <span class="section-number">6</span> Experimental Evaluation</h2>    </div>    </header>    <section id="sec-13">    <header>     <div class="title-info">      <h3>       <span class="section-number">6.1</span> Experimental Setup</h3>     </div>    </header>    <p>We consider several real-world graphs that we obtained from [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0038">38</a>]. We divide them into two main groups: <em>large</em> graphs containing up to tens of millions of edges, for which we are able to list all <em>k</em>-cliques, as well as <em>very large</em> graphs containing up to billions of edges and being less sparse for which we could only list <em>k</em>-cliques of limited size. Tables&#x00A0;<a class="tbl" href="#tab1">1</a> and&#x00A0;<a class="tbl" href="#tab2">2</a> summarize the statistics of the two groups of datasets, respectively.</p>    <div class="table-responsive" id="tab1">    <div class="table-caption">     <span class="table-number">Table 1:</span>     <span class="table-title">Our set of large graphs (for which we are able to list all <em>k</em>-cliques). <em>c</em> is the core value, <em>k<sub>max</sub>      </em> is the size of a maximum clique and <span class="inline-equation"><span class="tex">$N_{k_{max}}$</span>      </span> is the number of maximum cliques.</span>    </div>    <table class="table">     <thead>      <tr>       <th style="text-align:center;">networks</th>       <th style="text-align:center;">       <em>n</em>       </th>       <th style="text-align:center;">       <em>m</em>       </th>       <th style="text-align:center;">       <em>c</em>       </th>       <th style="text-align:center;">       <em>k<sub>max</sub>       </em>       </th>       <th style="text-align:center;">       <span class="inline-equation"><span class="tex">$N_{k_{max}}$</span>       </span>       </th>      </tr> 					 </thead> 					 <tbody>      <tr>       <td style="text-align:center;">road-CA</td>       <td style="text-align:center;">1,965,206</td>       <td style="text-align:center;">2,766,607</td>       <td style="text-align:center;">3</td>       <td style="text-align:center;">4</td>       <td style="text-align:center;">42</td>      </tr>      <tr>       <td style="text-align:center;">Amazon</td>       <td style="text-align:center;">334,863</td>       <td style="text-align:center;">925,872</td>       <td style="text-align:center;">7</td>       <td style="text-align:center;">7</td>       <td style="text-align:center;">32</td>      </tr>      <tr>       <td style="text-align:center;">soc-pocket</td>       <td style="text-align:center;">1,632,803</td>       <td style="text-align:center;">22,301,964</td>       <td style="text-align:center;">47</td>       <td style="text-align:center;">29</td>       <td style="text-align:center;">6</td>      </tr>      <tr>       <td style="text-align:center;">loc-gowalla</td>       <td style="text-align:center;">196,591</td>       <td style="text-align:center;">950,327</td>       <td style="text-align:center;">51</td>       <td style="text-align:center;">29</td>       <td style="text-align:center;">2</td>      </tr>      <tr>       <td style="text-align:center;">Youtube</td>       <td style="text-align:center;">1,134,890</td>       <td style="text-align:center;">2,987,624</td>       <td style="text-align:center;">51</td>       <td style="text-align:center;">17</td>       <td style="text-align:center;">2</td>      </tr>      <tr>       <td style="text-align:center;">cit-patents</td>       <td style="text-align:center;">3,774,768</td>       <td style="text-align:center;">16,518,947</td>       <td style="text-align:center;">64</td>       <td style="text-align:center;">11</td>       <td style="text-align:center;">2</td>      </tr>      <tr>       <td style="text-align:center;">zhishi-baidu</td>       <td style="text-align:center;">2,140,198</td>       <td style="text-align:center;">17,014,946</td>       <td style="text-align:center;">78</td>       <td style="text-align:center;">31</td>       <td style="text-align:center;">4</td>      </tr>      <tr>       <td style="text-align:center;">WikiTalk</td>       <td style="text-align:center;">2,394,385</td>       <td style="text-align:center;">4,659,565</td>       <td style="text-align:center;">131</td>       <td style="text-align:center;">26</td>       <td style="text-align:center;">141</td>      </tr>     </tbody>    </table>    </div>    <div class="table-responsive" id="tab2">    <div class="table-caption">     <span class="table-number">Table 2:</span>     <span class="table-title">Our set of very large graphs (for which we are able to list <em>k</em>-cliques of limited size). <em>k</em> is the value till we could list all <em>k</em>-cliques within one day of computations using <SmallCap>       kClist      </SmallCap>      40, <em>N<sub>k</sub>      </em> is the number of such <em>k</em>-cliques.</span>    </div>    <table class="table">     <thead>      <tr>       <th style="text-align:center;">networks</th>       <th style="text-align:center;">       <em>n</em>       </th>       <th style="text-align:center;">       <em>m</em>       </th>       <th style="text-align:center;">       <em>c</em>       </th>       <th style="text-align:center;">       <em>k</em>       </th>       <th style="text-align:center;">       <em>N<sub>k</sub>       </em>       </th>      </tr> 					 </thead> 					 <tbody>      <tr>       <td style="text-align:center;">as-skitter</td>       <td style="text-align:center;">1,696,415</td>       <td style="text-align:center;">11,095,298</td>       <td style="text-align:center;">111</td>       <td style="text-align:center;">12</td>       <td style="text-align:center;">2.68 &#x00D7; 10<sup>14</sup>       </td>      </tr>      <tr>       <td style="text-align:center;">DBLP</td>       <td style="text-align:center;">425,957</td>       <td style="text-align:center;">1,049,866</td>       <td style="text-align:center;">113</td>       <td style="text-align:center;">11</td>       <td style="text-align:center;">8.23 &#x00D7; 10<sup>14</sup>       </td>      </tr>      <tr>       <td style="text-align:center;">Wikipedia</td>       <td style="text-align:center;">2,080,370</td>       <td style="text-align:center;">42,336,692</td>       <td style="text-align:center;">208</td>       <td style="text-align:center;">15</td>       <td style="text-align:center;">5.02 &#x00D7; 10<sup>14</sup>       </td>      </tr>      <tr>       <td style="text-align:center;">Orkut</td>       <td style="text-align:center;">3,072,627</td>       <td style="text-align:center;">117,185,083</td>       <td style="text-align:center;">253</td>       <td style="text-align:center;">12</td>       <td style="text-align:center;">4.15 &#x00D7; 10<sup>14</sup>       </td>      </tr>      <tr>       <td style="text-align:center;">Friendster</td>       <td style="text-align:center;">124,836,180</td>       <td style="text-align:center;">1,806,067,135</td>       <td style="text-align:center;">304</td>       <td style="text-align:center;">10</td>       <td style="text-align:center;">4.87 &#x00D7; 10<sup>14</sup>       </td>      </tr>      <tr>       <td style="text-align:center;">LiveJournal</td>       <td style="text-align:center;">4,036,538</td>       <td style="text-align:center;">34,681,189</td>       <td style="text-align:center;">360</td>       <td style="text-align:center;">7</td>       <td style="text-align:center;">4.49 &#x00D7; 10<sup>14</sup>       </td>      </tr>     </tbody>    </table>    </div>    <p>For each large graph, we report its core number (which according to our theoretical analysis affects the running time of our algorithm), the size of a maximum clique and the number of maximum cliques. For each very large graph, we report its core number and the largest <em>k</em> for which we could list all <em>k</em>-cliques within one day of computation, as well as, the number of such <em>k</em>-cliques.</p>    <p>In our experiments we consider the core ordering, as it turns out to be more efficient in practice as well as from a theoretical point of view.</p>    <p>We carried our experiments on a Linux machine equipped with 4 processors Intel Xeon CPU E5- 2660 @ 2.60 GHz with 10 cores (a total of 40 threads) and with 64 G of RAM DDR4 2133 MHz. We evaluate both the sequential version of our algorithm, denoted as <SmallCap>kClist</SmallCap>1, and the parallel version of our algorithm denoted as <SmallCap>kClist</SmallCap>     <em>n</em>, where <em>n</em> denotes the number of threads. We evaluate our method using 1, 10, and 40 threads (<SmallCap>kClist</SmallCap>1, <SmallCap>kClist</SmallCap>10 and <SmallCap>kClist</SmallCap>40, respectively) against the state-of-the-art for the exact listing of k-cliques<a class="fn" href="#fn5" id="foot-fn5"><sup>1</sup></a>. In particular, we consider the following approaches:</p>    <ul class="list-no-style">     <li id="list7" label="&#x2022;"><strong>CF:</strong> the compact-forward algorithm for listing triangles of [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"       href="#BibPLXBIB0036">36</a>], for which we used the C implementation available at the webpage of the authors.<br/></li>     <li id="list8" label="&#x2022;"><strong>MACE:</strong> the algorithm presented in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"       href="#BibPLXBIB0040">40</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"       href="#BibPLXBIB0049">49</a>], for which we used the C implementation available at the webpage of the authors.<br/></li>     <li id="list9" label="&#x2022;"><strong>Arbo:</strong> the algorithm of Chiba and Nishizeki presented in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"       href="#BibPLXBIB0016">16</a>]. As we are not aware of any efficient implementation for such an algorithm, we provide our own implementation in C and made it publicly available.<br/></li>    </ul>    </section>    <section id="sec-14">    <header>     <div class="title-info">      <h3>       <span class="section-number">6.2</span> Evaluation of our Sequential Algorithm</h3>     </div>    </header>    <p>We start by comparing our sequential algorithm for listing triangles against the state-of-the-art algorithms for the same problem. Table&#x00A0;<a class="tbl" href="#tab3">3</a> shows the running time of the algorithms for listing triangles (<SmallCap>kClist</SmallCap>1). We can see that even the sequential version of our algorithm outperforms the state-of-the-art algorithms for listing triangles. It also shows that the algorithm presented in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0036">36</a>] (CF) is very efficient for the task of listing triangles.</p>    <div class="table-responsive" id="tab3">     <div class="table-caption">      <span class="table-number">Table 3:</span>      <span class="table-title">Time to list triangles on our very large graphs.</span>     </div>     <table class="table">      <thead>       <tr>       <th colspan="2" style="text-align:center;">&#x00A0;<hr/>       </th>       <th colspan="4" style="text-align:center;">Algorithms<hr/>       </th>       </tr>       <tr>       <th style="text-align:center;">networks</th>       <th style="text-align:center;"># triangles</th>       <th style="text-align:center;">CF</th>       <th style="text-align:center;">MACE</th>       <th style="text-align:center;">Arbo</th>       <th style="text-align:center;">        <SmallCap>kClist</SmallCap>1</th>       </tr> 						</thead> 						<tbody>       <tr>       <td style="text-align:center;">as-skitter</td>       <td style="text-align:center;">28,769,868</td>       <td style="text-align:center;">5s</td>       <td style="text-align:center;">54s</td>       <td style="text-align:center;">5s</td>       <td style="text-align:center;">5s</td>       </tr>       <tr>       <td style="text-align:center;">DBLP</td>       <td style="text-align:center;">2,224,385</td>       <td style="text-align:center;">1s</td>       <td style="text-align:center;">4s</td>       <td style="text-align:center;">1s</td>       <td style="text-align:center;">1s</td>       </tr>       <tr>       <td style="text-align:center;">Wikipedia</td>       <td style="text-align:center;">145,707,846</td>       <td style="text-align:center;">37s</td>       <td style="text-align:center;">12m6s</td>       <td style="text-align:center;">3m10s</td>       <td style="text-align:center;">        <strong>29s</strong>       </td>       </tr>       <tr>       <td style="text-align:center;">Orkut</td>       <td style="text-align:center;">627,584,181</td>       <td style="text-align:center;">2m52s</td>       <td style="text-align:center;">17m15s</td>       <td style="text-align:center;">2m50s</td>       <td style="text-align:center;">        <strong>2m11s</strong>       </td>       </tr>       <tr>       <td style="text-align:center;">Friendster</td>       <td style="text-align:center;">4,173,724,142</td>       <td style="text-align:center;">1h50m41s</td>       <td style="text-align:center;">2h30m12s</td>       <td style="text-align:center;">2h48m16s</td>       <td style="text-align:center;">        <strong>1h0m7s</strong>       </td>       </tr>       <tr>       <td style="text-align:center;">LiveJournal</td>       <td style="text-align:center;">177,820,130</td>       <td style="text-align:center;">37s</td>       <td style="text-align:center;">3m23s</td>       <td style="text-align:center;">37s</td>       <td style="text-align:center;">        <strong>33s</strong>       </td>       </tr>      </tbody>     </table>    </div>    <p>We then consider the <em>k</em>-clique listing problem on our collection of large datasets. Table&#x00A0;<a class="tbl" href="#tab4">4</a> shows that our algorithm can list all <em>k</em>-cliques for any value of <em>k</em> in all those graphs, within a few minutes in most of the cases. It is faster than the other algorithms, up to a factor of 5. The full potential of our algorithm (including the parallel version) becomes apparent when listing <em>k</em>-cliques for larger <em>k</em> on very large graphs.</p>    <div class="table-responsive" id="tab4">     <div class="table-caption">      <span class="table-number">Table 4:</span>      <span class="table-title">Time to list all cliques on our large graphs.</span>     </div>     <table class="table">      <thead>       <tr>       <th style="text-align:center;">&#x00A0;</th>       <th colspan="3" style="text-align:center;">Algorithms</th>       </tr>       <tr>       <th style="text-align:center;">networks</th>       <th style="text-align:center;">MACE</th>       <th style="text-align:center;">Arbo</th>       <th style="text-align:center;">        <SmallCap>kClist</SmallCap>1</th>       </tr> 						</thead> 						<tbody>       <tr>       <td style="text-align:center;">road-CA</td>       <td style="text-align:center;">1s</td>       <td style="text-align:center;">1s</td>       <td style="text-align:center;">1s</td>       </tr>       <tr>       <td style="text-align:center;">Amazon</td>       <td style="text-align:center;">1s</td>       <td style="text-align:center;">1s</td>       <td style="text-align:center;">1s</td>       </tr>       <tr>       <td style="text-align:center;">soc-pocket</td>       <td style="text-align:center;">18m15s</td>       <td style="text-align:center;">3m29s</td>       <td style="text-align:center;">        <strong>1m5s</strong>       </td>       </tr>       <tr>       <td style="text-align:center;">loc-gowalla</td>       <td style="text-align:center;">4m49s</td>       <td style="text-align:center;">1m38s</td>       <td style="text-align:center;">        <strong>31s</strong>       </td>       </tr>       <tr>       <td style="text-align:center;">Youtube</td>       <td style="text-align:center;">1m12s</td>       <td style="text-align:center;">6m7s</td>       <td style="text-align:center;">        <strong>3.4s</strong>       </td>       </tr>       <tr>       <td style="text-align:center;">cit-patents</td>       <td style="text-align:center;">16s</td>       <td style="text-align:center;">15s</td>       <td style="text-align:center;">        <strong>13s</strong>       </td>       </tr>       <tr>       <td style="text-align:center;">zhishi-baidu</td>       <td style="text-align:center;">33m17s</td>       <td style="text-align:center;">7m54s</td>       <td style="text-align:center;">        <strong>2m28s</strong>       </td>       </tr>       <tr>       <td style="text-align:center;">WikiTalk</td>       <td style="text-align:center;"> > 24h</td>       <td style="text-align:center;">7h42m27s</td>       <td style="text-align:center;">        <strong>1h45m33s</strong>       </td>       </tr>      </tbody>     </table>    </div>    </section>    <section id="sec-15">    <header>     <div class="title-info">      <h3>       <span class="section-number">6.3</span> Degree of Parallelism</h3>     </div>    </header>    <p>Our next step is to evaluate the degree of parallelism of our parallel algorithms. Ideally, we wish that when using <em>t</em> threads the running time decreases by a factor of <em>t</em>. This is measured by the <em>speedup</em>, which is defined as the running time of the sequential algorithm (with one thread) divided by the running time of the parallel algorithm when using <em>t</em> threads. We evaluate both the <SmallCap>Node-Parallel</SmallCap> and the <SmallCap>Edge-Parallel</SmallCap> variants of our algorithms, which are discussed in Section&#x00A0;<a class="sec" href="#sec-10">4.3</a>.</p>    <p>Figure <a class="fig" href="#fig1">1</a> (left) shows the overall running time in linlog scale for <SmallCap>Node-Parallel</SmallCap> and <SmallCap>Edge-Parallel</SmallCap> for the problem of listing 8-cliques in DBLP, while Figure&#x00A0;<a class="fig" href="#fig1">1</a> (middle) shows the corresponding speedup. The running time required to perform I/O operations is also taken into account in that figure. We can see that <SmallCap>Edge-Parallel</SmallCap> boasts almost a linear speedup up to 40 threads, demonstrating that the computational load is always well balanced across the threads. In contrast, the speedup for <SmallCap>Node-Parallel</SmallCap> starts to worsen when the number of threads is larger than 10, with little benefit when using more than 20 threads.</p>    <p>This is consistent with what we observe in Figure <a class="fig" href="#fig1">1</a> (right). Such a figure shows the percentage of CPU usage when using 40 threads, as a function of time. A percentage of 4000% means that all 40 threads are fully working. We can see that both <SmallCap>Node-Parallel</SmallCap> and <SmallCap>Edge-Parallel</SmallCap> manage to keep busy all 40 threads for the first 50 seconds. However, later on the percentage of CPU usage for <SmallCap>Node-Parallel</SmallCap> drops significantly, with very few threads being busy after two minutes. This is a clear sign that in this case the computational load is not well balanced across the threads. 			 <figure id="fig1">      <img src="../../../../deliveryimages.acm.org/10.1145/3190000/3186125/images/www2018-134-fig1.jpg" class="img-responsive" alt="Figure 1"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 1:</span>       <span class="figure-title">(left) Running time and (middle) speedup of our algorithms as a function of the number of used threads for listing 8-cliques in DBLP. (right) CPU percentage usage as a function of time using 40 threads for listing 8-cliques in DBLP.</span>      </div>     </figure> </p>    <p>We observe a similar behavior on the other datasets and for different values of <em>k</em>. We conclude that when few threads are available (say 10 or less), then a parallelization on the nodes is enough and leads to a nearly optimal speedup. When many threads are available then a parallelization on the edges is preferable. In what follows we use a parallelization on the edges for both <SmallCap>kClist</SmallCap>10 and <SmallCap>kClist</SmallCap>40.    </p>    </section>    <section id="sec-16">    <header>     <div class="title-info">      <h3>       <span class="section-number">6.4</span>       <em>k</em>-clique Listing: Comparison</h3>     </div>    </header>    <p>Figure&#x00A0;<a class="fig" href="#fig2">2</a> shows the running time of the algorithms as a function of <em>k</em>, when executed on the very large graphs. It shows that our sequential algorithm is significantly more efficient than the other approaches, with its running growing more gracefully as a function of <em>k</em>. For the largest values of <em>k</em> considered, it is at least one order of magnitude faster than [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0016">16</a>], which is the most efficient algorithm after ours according to our experimental evaluation.    <figure id="fig2">     <img src="../../../../deliveryimages.acm.org/10.1145/3190000/3186125/images/www2018-134-fig2.jpg" class="img-responsive" alt="Figure 2"      longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 2:</span>      <span class="figure-title">Running time of the algorithms as a function of k. We truncated the curves at 24 hours.</span>     </div>    </figure> </p>    <p>We can also see that the parallelization of our algorithm allows to deal with larger values of <em>k</em> (up to an additional term of 3), while requiring less than one day of computation. In particular, our parallel algorithm using 10 (resp. 40 threads) is the only one that can list all 9-cliques (resp. 10-cliques) in Friendster within a reasonable amount of time.</p>    <p>We also carried experiments in a Twitter graph [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0035">35</a>], this graph has more than 1.6 billion edges and a high core value of 2647. Our parallel algorithm with 40 threads can list all 4-cliques within two hours of computations, while other approaches can only list triangles within a reasonable amount of time. It can also list all 3.39 &#x00D7; 10<sup>15</sup> 5-cliques within a week of computation.</p>    </section>    <section id="sec-17">    <header>     <div class="title-info">      <h3>       <span class="section-number">6.5</span>       <em>k</em>-clique Densest Subgraph &#x0026; <em>k</em>-clique Core Decomposition</h3>     </div>    </header>    <p>We show that our algorithm can be used as an efficient subroutine to compute the <em>      <em>k</em>-clique core decomposition</em> and an approximation to the <em>k</em>-clique densest subgraph, as defined in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0051">51</a>]. It turns out that using our algorithm one could solve those problems much faster, for larger values of <em>k</em> and on larger datasets than before. This, in turn, allows to efficiently find quasi-cliques, as pointed out in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0051">51</a>].</p>    <p>The <em>k</em>-clique density of a graph is defined as the number of <em>k</em>-cliques divided by the number of nodes in such a graph. The <em>k</em>-clique densest subgraph problem consists of finding a subgraph of the input graph with maximum <em>k</em>-clique density. As observed in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0051">51</a>], one could find an approximation to a <em>k</em>-clique densest subgraph by means of either one of the following two algorithms.</p>    <ol class="list-no-style">     <li id="list10" label="(1)">The algorithm which removes in each round a vertex belonging to the minimum number of <em>k</em>-cliques and returns the subgraph that achieves the largest <em>k</em>-clique density, is a <em>k</em>-approximation for the <em>k</em>-clique densest subgraph problem. It also produces the so-called <em>       <em>k</em>-clique core decomposition</em>.<br/></li>     <li id="list11" label="(2)">The algorithm which removes in each round the set of vertices belonging to less than <em>k</em>(1 + &#x03F5;)<em>&#x03C1;<sub>k</sub> k</em>-cliques and returns the subgraph that achieves the largest <em>k</em>-clique density, where <em>&#x03C1;<sub>k</sub>      </em> is the <em>k</em>-clique density of the subgraph at that round. Such an algorithm gives a <em>k</em>(1 + &#x03F5;)-approximation, while it terminates in <span class="inline-equation"><span class="tex">$O(\frac{\log n}{\epsilon })$</span>      </span> round, for every &#x03F5; > 0.<br/></li>    </ol>    <p>Our algorithm can be used to give a full pass on all <em>k</em>-cliques of the input graph, without storing any such a clique. Therefore, it can be effectively employed to solve each of the aforementioned problems. In particular, a <em>k</em>(1 + &#x03F5;)-approximation for the <em>k</em>-clique densest subgraph problem can be computed in <span class="inline-equation"><span class="tex">$O(\log _{1+\epsilon }(n) \cdot k \cdot m \cdot (\frac{c(G)}{2})^{k-2}+m)$</span>     </span> time, while the <em>k</em>-clique core decomposition can be computed in <span class="inline-equation"><span class="tex">$O(n \cdot k \cdot m \cdot (\frac{c(G)}{2})^{k-3}+m)$</span>     </span> time (in this version we update the <em>k</em>-clique degrees of the neighbors of a removed node by listing the (<em>k</em> &#x2212; 1)-cliques on the subgraph induced by its neighbors). Both algorithms require linear space in the size of the input.</p>    <p>In our experimental evaluation, using 40 threads, &#x03F5; = 0.01 we were able to compute a 13.13-approximation of the 13-clique densest subgraph in Wikipedia and a 9.09-approximation of the 9-clique densest subgraph in Friendster within one day of computation. In this case, we consider the <em>k</em>(1 + &#x03F5;)-approximation algorithm for the <em>k</em>-clique densest subgraph which requires <span class="inline-equation"><span class="tex">$O(\frac{\log n}{\epsilon })$</span>     </span> passes over the set of <em>k</em>-cliques. We were also able to compute within one day of computation while using one single thread, the 11-clique core decomposition of Wikipedia and the 7-clique core decomposition of Friendster.</p>    <p>The core decomposition (<em>k</em> = 2) is an effective tool in graph mining, for instance, to find best spreaders [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0033">33</a>], find outliers [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0048">48</a>], as well as speeding up algorithms (e.g. it is used as a subroutine in our own algorithm). An efficient algorithm for the <em>k</em>-clique core decomposition for <em>k</em> > 2 might unleash its full potential as a graph mining tool. In Figure&#x00A0;<a class="fig" href="#fig3">3</a>, we show that such a decomposition can be used to efficiently find quasi-cliques. In such a figure, we measure the edge density of the <em>k</em>-approximation of the <em>k</em>-clique densest subgraph that we obtained using the <em>k</em>-clique core decomposition as a function of <em>k</em>, where the edge density of a subgraph is defined as its number of edges divided by the number of edges in a clique with the same number of nodes. We also report the number of nodes in the computed subgraph. We can see that the edge density of the subgraphs found by our algorithm quickly converges towards 1, which is the density of a clique. This makes it an effective heuristic to find cliques and quasi-cliques in large graphs. <figure id="fig3">      <img src="../../../../deliveryimages.acm.org/10.1145/3190000/3186125/images/www2018-134-fig3.jpg" class="img-responsive" alt="Figure 3"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 3:</span>       <span class="figure-title">Number of nodes and edge density of the k-densest subgraph approximation versus k.</span>      </div>     </figure> </p>    </section>    <section id="sec-18">    <header>     <div class="title-info">      <h3>       <span class="section-number">6.6</span> Counting <em>k</em>-cliques</h3>     </div>    </header>    <p>Because of the computational bottlenecks in computing the exact number of <em>k</em>-cliques in a graph, there have been several methods for approximating such a number. Most notably, in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0031">31</a>] the authors developed a technique based on Turan&#x0027;s theorem, which is able to efficiently compute a good approximation of such a number. In particular, the authors show that their technique boasts an error of at most 2% in almost all the graphs considered in their work. However, for a few of those graphs, the exact count was not known at the time when their work was published.</p>    <p>Armed with our algorithm for listing all <em>k</em>-cliques in a graph, we are able to compute the exact number of <em>k</em>-cliques in all but two of the graphs considered in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0031">31</a>] and fill Table&#x00A0;2 of&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0031">31</a>] with five additional values that were missing. The results are shown in Table&#x00A0;<a class="tbl" href="#tab5">5</a>. Our experiments confirm a very good accuracy of their technique, with all results boasting an error smaller than 1%<a class="fn" href="#fn6" id="foot-fn6"><sup>2</sup></a> in terms of relative error (|true - estimate|/<em>true</em>). Moreover, the running time of their algorithm for approximately counting the number of <em>k</em>-cliques is faster than our algorithm for listing all <em>k</em>-cliques. In particular, all our experiments required at most 8 hours of computation with 40 threads, while the running time of their approach is in the order of minutes using a single thread, except for com-orkut which required three hours of computation.</p>    <div class="table-responsive" id="tab5">     <div class="table-caption">      <span class="table-number">Table 5:</span>      <span class="table-title">Completion of Table 2 of [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"       href="#BibPLXBIB0031">31</a>].</span>     </div>     <table class="table">      <thead>       <tr>       <th style="text-align:center;">graph</th>       <th style="text-align:center;">        <em>m</em>       </th>       <th style="text-align:center;">        <em>k</em>       </th>       <th style="text-align:center;">        <em>N<sub>k</sub>        </em>       </th>       <th style="text-align:center;">Estimated <em>N<sub>k</sub>        </em>       </th>       <th style="text-align:center;">error</th>       </tr> 						</thead> 						<tbody>       <tr>       <td style="text-align:center;">web-Stanf.</td>       <td style="text-align:center;">1,992,636</td>       <td style="text-align:center;">10</td>       <td style="text-align:center;">5.8333 &#x00D7; 10<sup>12</sup>       </td>       <td style="text-align:center;">5.8358 &#x00D7; 10<sup>12</sup>       </td>       <td style="text-align:center;">0.04%</td>       </tr>       <tr>       <td style="text-align:center;">com-orkut</td>       <td style="text-align:center;">117,185,083</td>       <td style="text-align:center;">10</td>       <td style="text-align:center;">3.0288 &#x00D7; 10<sup>13</sup>       </td>       <td style="text-align:center;">3.0360 &#x00D7; 10<sup>13</sup>       </td>       <td style="text-align:center;">0.24%</td>       </tr>       <tr>       <td style="text-align:center;">com-lj</td>       <td style="text-align:center;">34,681,189</td>       <td style="text-align:center;">5</td>       <td style="text-align:center;">2.4663 &#x00D7; 10<sup>11</sup>       </td>       <td style="text-align:center;">2.4764 &#x00D7; 10<sup>11</sup>       </td>       <td style="text-align:center;">0.40%</td>       </tr>       <tr>       <td style="text-align:center;"/>       <td style="text-align:center;"/>       <td style="text-align:center;">7</td>       <td style="text-align:center;">4.4902 &#x00D7; 10<sup>14</sup>       </td>       <td style="text-align:center;">4.5134 &#x00D7; 10<sup>14</sup>       </td>       <td style="text-align:center;">0.52%</td>       </tr>       <tr>       <td style="text-align:center;">as-skitter</td>       <td style="text-align:center;">11,095,298</td>       <td style="text-align:center;">10</td>       <td style="text-align:center;">1.4217 &#x00D7; 10<sup>13</sup>       </td>       <td style="text-align:center;">1.4312 &#x00D7; 10<sup>13</sup>       </td>       <td style="text-align:center;">0.67%</td>       </tr>      </tbody>     </table>    </div>    <p>Our conclusion is that the technique proposed in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0031">31</a>] is valuable in case a quick approximate count is needed, however, our algorithm could be used in case one wishes to list all <em>k</em>-cliques or an exact count is needed.</p>    <p>All datasets and our implementation<a class="fn" href="#fn7" id="foot-fn7"><sup>3</sup></a> are publicly available.</p>    </section>   </section>   <section id="sec-19">    <header>    <div class="title-info">     <h2>      <span class="section-number">7</span> Conclusion and Future Work</h2>    </div>    </header>    <p>We developed a parallel algorithm for listing all <em>k</em>-cliques in very large real-world graphs which leverages the sparsity of the input graph. Our algorithm has the best known asymptotic running time, while it requires a linear amount of memory in the size of the input. In practice, for medium values of <em>k</em>, the sequential version of our algorithm is faster than state-of-the-art algorithms for the same problem, while the parallel version allows the gain of an order of magnitude with respect to state-of-the-art approaches. Our experimental analysis shows that our parallel algorithm is able to list all cliques in graphs containing up to tens of millions of edges, as well as all 10-cliques in graphs containing billions of edges, within a few minutes or a few hours, respectively, while boasting a near-optimal degree of parallelism. Observe that there are up to several quadrillions of <em>k</em>-cliques in the input graphs considered in our experiments. We showed that our algorithm can be used as an effective subroutine when computing the <em>k</em>-clique core decomposition or a <em>k</em>-clique densest subgraph. In particular, we showed how to use our algorithm so as to produce a stream of <em>k</em>-cliques without storing any such a clique in main memory. For future work, we would like to investigate further whether such an approach could be successfully employed in graph compression, community and event detection.</p>    <p>According to our theoretical analysis and experiments, the node ordering used in our algorithm significantly affects its running time, with core ordering performing well. One interesting direction for future work is to investigate whether one could speed up our algorithm even further by considering other node orderings. We showed that the edge-parallel version of our algorithm achieves a near-optimal degree of parallelism on up to 40 threads or more. A natural question is whether one could maintain or improve such a degree of parallelism on a larger number of threads. To this end, we speculate that one could benefit from parallelizing on higher order cliques (such as triangles or 4-cliques). We defer this study to future work.</p>    <p>    <strong>Acknowledgements.</strong> We thank Qinna Wang for assistance with implementing a first version of the algorithm.</p>   </section>  </section>  <section class="back-matter">   <section id="ref-001">    <header>    <div class="title-info">     <h2 class="page-brake-head">REFERENCES</h2>    </div>    </header>    <ul class="bibUl">    <li id="BibPLXBIB0001" label="[1]">[n. d.]. <a class="link-inline force-break" href="http://research.nii.ac.jp/~uno/codes.htm"      target="_blank">http://research.nii.ac.jp/~uno/codes.htm</a>. ([n. d.]).</li>    <li id="BibPLXBIB0002" label="[2]">Nesreen&#x00A0;K Ahmed, Jennifer Neville, Ryan&#x00A0;A Rossi, and Nick Duffield. 2015. Efficient graphlet counting for large networks. In <em>      <em>Data Mining (ICDM), 2015 IEEE International Conference on</em>     </em>. IEEE, 1&#x2013;10.</li>    <li id="BibPLXBIB0003" label="[3]">Noga Alon, Raphael Yuster, and Uri Zwick. 1995. Color-coding. <em>      <em>J. ACM</em>     </em>42, 4 (July 1995), 844&#x2013;856. <a class="link-inline force-break" href="https://doi.org/10.1145/210332.210337"      target="_blank">https://doi.org/10.1145/210332.210337</a></li>    <li id="BibPLXBIB0004" label="[4]">Noga Alon, Raphael Yuster, and Uri Zwick. 1997. Finding and counting given length cycles. <em>      <em>Algorithmica</em>     </em>17, 3 (1997), 209&#x2013;223.</li>    <li id="BibPLXBIB0005" label="[5]">Albert Angel, Nick Koudas, Nikos Sarkas, Divesh Srivastava, Michael Svendsen, and Srikanta Tirthapura. 2014. Dense subgraph maintenance under streaming edge weight updates for real-time story identification. <em>      <em>VLDB J.</em>     </em>23, 2 (2014), 175&#x2013;199.</li>    <li id="BibPLXBIB0006" label="[6]">Oana&#x00A0;Denisa Balalau, Francesco Bonchi, T.-H.&#x00A0;Hubert Chan, Francesco Gullo, and Mauro Sozio. 2015. Finding Subgraphs with Maximum Total Density and Limited Overlap. In <em>      <em>WSDM</em>     </em>. 379&#x2013;388.</li>    <li id="BibPLXBIB0007" label="[7]">Luca Becchetti, Paolo Boldi, Carlos Castillo, and Aristides Gionis. 2008. Efficient semi-streaming algorithms for local triangle counting in massive graphs. In <em>      <em>SIGKDD</em>     </em>. 16&#x2013;24.</li>    <li id="BibPLXBIB0008" label="[8]">Austin&#x00A0;R Benson, David&#x00A0;F Gleich, and Jure Leskovec. 2016. Higher-order organization of complex networks. <em>      <em>Science</em>     </em>353, 6295 (2016), 163&#x2013;166.</li>    <li id="BibPLXBIB0009" label="[9]">Piotr Berman and Marek Karpinski. 1999. On some tighter inapproximability results. In <em>      <em>International Colloquium on Automata, Languages, and Programming</em>     </em>. Springer, 200&#x2013;209.</li>    <li id="BibPLXBIB0010" label="[10]">Andreas Bj&#x00F6;rklund, Rasmus Pagh, Virginia&#x00A0;Vassilevska Williams, and Uri Zwick. 2014. Listing triangles. In <em>      <em>Automata, Languages, and Programming</em>     </em>. Springer, 223&#x2013;234.</li>    <li id="BibPLXBIB0011" label="[11]">Marco Bressan, Flavio Chierichetti, Ravi Kumar, Stefano Leucci, and Alessandro Panconesi. 2017. Counting Graphlets: Space vs Time. In <em>      <em>Proceedings of the Tenth ACM International Conference on Web Search and Data Mining</em>     </em>(WSDM &#x2019;17). ACM, New York, NY, USA, 557&#x2013;566. <a class="link-inline force-break" href="https://doi.org/10.1145/3018661.3018732"      target="_blank">https://doi.org/10.1145/3018661.3018732</a></li>    <li id="BibPLXBIB0012" label="[12]">Coen Bron and Joep Kerbosch. 1973. Algorithm 457: finding all cliques of an undirected graph. <em>      <em>Commun. ACM</em>     </em>16, 9 (1973), 575&#x2013;577.</li>    <li id="BibPLXBIB0013" label="[13]">Gregory Buehrer and Kumar Chellapilla. 2008. A scalable pattern mining approach to web graph compression with communities. In <em>      <em>WSDM</em>     </em>. 95&#x2013;106.</li>    <li id="BibPLXBIB0014" label="[14]">Moses Charikar. 2000. Greedy approximation algorithms for finding dense components in a graph. In <em>      <em>Approximation Algorithms for Combinatorial Optimization</em>     </em>. Springer, 84&#x2013;95.</li>    <li id="BibPLXBIB0015" label="[15]">James Cheng, Linhong Zhu, Yiping Ke, and Shumo Chu. 2012. Fast algorithms for maximal clique enumeration with limited memory. In <em>      <em>SIGKDD</em>     </em>. ACM, 1240&#x2013;1248.</li>    <li id="BibPLXBIB0016" label="[16]">Norishige Chiba and Takao Nishizeki. 1985. Arboricity and subgraph listing algorithms. <em>      <em>SIAM J. Comput.</em>     </em>14, 1 (1985), 210&#x2013;223.</li>    <li id="BibPLXBIB0017" label="[17]">Shumo Chu and James Cheng. 2011. Triangle listing in massive networks and its applications. In <em>      <em>SIGKDD</em>     </em>. 672&#x2013;680.</li>    <li id="BibPLXBIB0018" label="[18]">Alessio Conte, Roberto&#x00A0;De Virgilio, Antonio Maccioni, Maurizio Patrignani, and Riccardo Torlone. 2016. Finding All Maximal Cliques in Very Large Social Networks Categories. (2016).</li>    <li id="BibPLXBIB0019" label="[19]">Maximilien Danisch, T-H&#x00A0;Hubert Chan, and Mauro Sozio. 2017. Large Scale Density-friendly Graph Decomposition via Convex Programming. In <em>      <em>Proceedings of the 26th International Conference on World Wide Web</em>. International World Wide Web Conferences Steering Committee</em>, 233&#x2013;242.</li>    <li id="BibPLXBIB0020" label="[20]">Yon Dourisboure, Filippo Geraci, and Marco Pellegrini. 2009. Extraction and classification of dense implicit communities in the Web graph. <em>      <em>TWEB</em>     </em>3, 2 (2009).</li>    <li id="BibPLXBIB0021" label="[21]">Xiaoxi Du, Ruoming Jin, Liang Ding, Victor&#x00A0;E. Lee, and John H.&#x00A0;Thornton Jr.2009. Migration motif: a spatial - temporal pattern mining approach for financial markets. In <em>      <em>SIGKDD</em>     </em>. 1135&#x2013;1144.</li>    <li id="BibPLXBIB0022" label="[22]">Alessandro Epasto, Silvio Lattanzi, and Mauro Sozio. 2015. Efficient Densest Subgraph Computation in Evolving Graphs. In <em>      <em>Proceedings of the 24th International Conference on World Wide Web, WWW 2015, Florence, Italy, May 18-22, 2015</em>     </em>. 300&#x2013;310.</li>    <li id="BibPLXBIB0023" label="[23]">David Eppstein, Maarten L&#x00F6;ffler, and Darren Strash. 2010. <em>      <em>Listing all maximal cliques in sparse graphs in near-optimal time</em>     </em>. Springer.</li>    <li id="BibPLXBIB0024" label="[24]">David Eppstein, Maarten L&#x00F6;ffler, and Darren Strash. 2013. Listing all maximal cliques in large sparse real-world graphs. <em>      <em>Journal of Experimental Algorithmics (JEA)</em>     </em>18 (2013), 3&#x2013;1.</li>    <li id="BibPLXBIB0025" label="[25]">Irene Finocchi, Marco Finocchi, and Emanuele&#x00A0;G Fusco. 2015. Clique counting in mapreduce: Algorithms and experiments. <em>      <em>Journal of Experimental Algorithmics (JEA)</em>     </em>20 (2015), 1&#x2013;7.</li>    <li id="BibPLXBIB0026" label="[26]">Eugene Fratkin, Brian&#x00A0;T. Naughton, Douglas&#x00A0;L. Brutlag, and Serafim Batzoglou. 2006. MotifCut: regulatory motifs finding with maximum density subgraphs. In <em>      <em>Proceedings 14th International Conference on Intelligent Systems for Molecular Biology 2006, Fortaleza, Brazil, August 6-10, 2006</em>     </em>. 156&#x2013;157.</li>    <li id="BibPLXBIB0027" label="[27]">David Gibson, Ravi Kumar, and Andrew Tomkins. 2005. Discovering Large Dense Subgraphs in Massive Graphs. In <em>      <em>PVLDB</em>     </em>. 721&#x2013;732.</li>    <li id="BibPLXBIB0028" label="[28]">Enrico Gregori, Luciano Lenzini, and Simone Mainardi. 2013. Parallel k-clique community detection on large-scale networks. <em>      <em>IEEE Transactions on Parallel and Distributed Systems</em>     </em>24, 8 (2013), 1651&#x2013;1660.</li>    <li id="BibPLXBIB0029" label="[29]">Mikhail&#x00A0;Rudoy (<a class="link-inline force-break" href="https://cstheory.stackexchange.com/users/34401/mikhail"      target="_blank">https://cstheory.stackexchange.com/users/34401/mikhail</a> rudoy). [n. d.]. Is this vertex ordering optimization NP-Hard?Theoretical Computer Science Stack Exchange. ([n. d.]).</li>    <li id="BibPLXBIB0030" label="[30]">Leonidas&#x00A0;D. Iasemidis, Deng-Shan Shiau, Wanpracha&#x00A0;Art Chaovalitwongse, J.&#x00A0;Chris Sackellares, Panos&#x00A0;M. Pardalos, Jose&#x00A0;C. Principe, Paul&#x00A0;R. Carney, Awadhesh Prasad, Balaji Veeramani, and Kostas Tsakalis. 2003. Adaptive epileptic seizure prediction system. <em>      <em>IEEE Trans. Biomed. Engineering</em>     </em>50, 5 (2003), 616&#x2013;627.</li>    <li id="BibPLXBIB0031" label="[31]">Shweta Jain and C Seshadhri. 2017. A Fast and Provable Method for Estimating Clique Counts Using Tur&#x00E1;n&#x0027;s Theorem. In <em>      <em>Proceedings of the 26th International Conference on World Wide Web</em> International World Wide Web Conferences Steering Committee</em>. , 441&#x2013;449.</li>    <li id="BibPLXBIB0032" label="[32]">Ruoming Jin, Yang Xiang, Ning Ruan, and David Fuhry. 2009. 3-HOP: a high-compression indexing scheme for reachability query. In <em>      <em>SIGMOD</em>     </em>. 813&#x2013;826.</li>    <li id="BibPLXBIB0033" label="[33]">Maksim Kitsak, Lazaros&#x00A0;K Gallos, Shlomo Havlin, Fredrik Liljeros, Lev Muchnik, H&#x00A0;Eugene Stanley, and Hern&#x00E1;n&#x00A0;A Makse. 2010. Identification of influential spreaders in complex networks. <em>      <em>Nature physics</em>     </em>6, 11 (2010), 888&#x2013;893.</li>    <li id="BibPLXBIB0034" label="[34]">Tamara&#x00A0;G Kolda, Ali Pinar, Todd Plantenga, C Seshadhri, and Christine Task. 2014. Counting triangles in massive graphs with MapReduce. <em>      <em>SIAM Journal on Scientific Computing</em>     </em>36, 5 (2014), S48&#x2013;S77.</li>    <li id="BibPLXBIB0035" label="[35]">Haewoon Kwak, Changhyun Lee, Hosung Park, and Sue Moon. 2010. What is Twitter, a social network or a news media?. In <em>      <em>Proceedings of the 19th international conference on World wide web</em>     </em>. ACM, 591&#x2013;600.</li>    <li id="BibPLXBIB0036" label="[36]">Matthieu Latapy. 2008. Main-memory triangle computations for very large (sparse (power-law)) graphs. <em>      <em>Theoretical Computer Science</em>     </em>407, 1 (2008), 458&#x2013;473.</li>    <li id="BibPLXBIB0037" label="[37]">Victor&#x00A0;E. Lee, Ning Ruan, Ruoming Jin, and Charu&#x00A0;C. Aggarwal. 2010. A Survey of Algorithms for Dense Subgraph Discovery. In <em>      <em>Managing and Mining Graph Data</em>     </em>. 303&#x2013;336.</li>    <li id="BibPLXBIB0038" label="[38]">Jure Leskovec and Andrej Krevl. 2014. SNAP Datasets: Stanford Large Network Dataset Collection. <a class="link-inline force-break" href="http://snap.stanford.edu/data"      target="_blank">http://snap.stanford.edu/data</a>. (June 2014).</li>    <li id="BibPLXBIB0039" label="[39]">Matthaios Letsios, Oana&#x00A0;Denisa Balalau, Maximilien Danisch, Emmanuel Orsini, and Mauro Sozio. 2016. Finding heaviest k-subgraphs and events in social media. In <em>      <em>Data Mining Workshops (ICDMW), 2016 IEEE 16th International Conference on</em>     </em>. IEEE, 113&#x2013;120.</li>    <li id="BibPLXBIB0040" label="[40]">Kazuhisa Makino and Takeaki Uno. 2004. New algorithms for enumerating all maximal cliques. In <em>      <em>Algorithm Theory-SWAT 2004</em>     </em>. Springer, 260&#x2013;272.</li>    <li id="BibPLXBIB0041" label="[41]">David&#x00A0;W. Matula and Leland&#x00A0;L. Beck. 1983. Smallest-last Ordering and Clustering and Graph Coloring Algorithms. <em>      <em>J. ACM</em>     </em>30, 3 (July 1983), 417&#x2013;427.</li>    <li id="BibPLXBIB0042" label="[42]">Michael Mitzenmacher, Jakub Pachocki, Richard Peng, Charalampos Tsourakakis, and Shen&#x00A0;Chen Xu. 2015. Scalable large near-clique detection in large-scale networks via sampling. In <em>      <em>Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</em>     </em>. ACM, 815&#x2013;824.</li>    <li id="BibPLXBIB0043" label="[43]">Gergely Palla, Imre Der&#x00E9;nyi, Ill&#x00E9;s Farkas, and Tam&#x00E1;s Vicsek. 2005. Uncovering the overlapping community structure of complex networks in nature and society. <em>      <em>Nature</em>     </em>435, 7043 (2005), 814&#x2013;818.</li>    <li id="BibPLXBIB0044" label="[44]">Ali Pinar, C. Seshadhri, and Vaidyanathan Vishal. 2017. ESCAPE: Efficiently Counting All 5-Vertex Subgraphs. In <em>      <em>Proceedings of the 26th International Conference on World Wide Web, WWW 2017, Perth, Australia, April 3-7, 2017</em>     </em>. 1431&#x2013;1440. <a class="link-inline force-break" href="https://doi.org/10.1145/3038912.3052597"      target="_blank">https://doi.org/10.1145/3038912.3052597</a></li>    <li id="BibPLXBIB0045" label="[45]">Angela&#x00A0;P. Presson, Eric&#x00A0;M. Sobel, Jeanette&#x00A0;C. Papp, Charlyn&#x00A0;J. Suarez, Toni Whistler, Mangalathu&#x00A0;S. Rajeevan, Suzanne&#x00A0;D. Vernon, and Steve Horvath. 2008. Integrated Weighted Gene Co-expression Network Analysis with an Application to Chronic Fatigue Syndrome. <em>      <em>BMC Systems Biology</em>     </em>2(2008), 95.</li>    <li id="BibPLXBIB0046" label="[46]">Ahmet&#x00A0;Erdem Sariy&#x00FC;ce, C. Seshadhri, Ali Pinar, and &#x00DC;mit&#x00A0;V. &#x00C7;ataly&#x00FC;rek. 2015. Finding the Hierarchy of Dense Subgraphs using Nucleus Decompositions. In <em>      <em>WWW</em>     </em>. 927&#x2013;937.</li>    <li id="BibPLXBIB0047" label="[47]">Matthew&#x00A0;C Schmidt, Nagiza&#x00A0;F Samatova, Kevin Thomas, and Byung-Hoon Park. 2009. A scalable, parallel algorithm for maximal clique enumeration. <em>      <em>J. Parallel and Distrib. Comput.</em>     </em>69, 4 (2009), 417&#x2013;428.</li>    <li id="BibPLXBIB0048" label="[48]">Kijung Shin, Tina Eliassi-Rad, and Christos Faloutsos. 2016. CoreScope: Graph Mining Using k-Core Analysis Patterns, Anomalies and Algorithms. In <em>      <em>Data Mining (ICDM), 2016 IEEE 16th International Conference on</em>     </em>. IEEE, 469&#x2013;478.</li>    <li id="BibPLXBIB0049" label="[49]">UNO Takeaki. 2012. Implementation issues of clique enumeration algorithm. <em>      <em>Special issue: Theoretical computer science and discrete mathematics, Progress in Informatics</em>     </em>9(2012), 25&#x2013;30.</li>    <li id="BibPLXBIB0050" label="[50]">Etsuji Tomita, Akira Tanaka, and Haruhisa Takahashi. 2006. The worst-case time complexity for generating all maximal cliques and computational experiments. <em>      <em>Theoretical Computer Science</em>     </em>363, 1 (2006), 28&#x2013;42.</li>    <li id="BibPLXBIB0051" label="[51]">Charalampos Tsourakakis. 2015. The k-clique densest subgraph problem. In <em>      <em>Proceedings of the 24th international conference on world wide web</em>     </em>. ACM, 1122&#x2013;1132.</li>    <li id="BibPLXBIB0052" label="[52]">Stanley Wasserman and Katherine Faust. 1994. <em>      <em>Social network analysis: Methods and applications</em>     </em>. Vol.&#x00A0;8. Cambridge university press.</li>    <li id="BibPLXBIB0053" label="[53]">Xiao Zhou and Takao Nishizeki. 1999. Edge-Coloring and f-Coloring for Various Classes of Graphs. <em>      <em>MATCH Commun. Math. Comput. Chem</em>     </em>51 (1999), 111&#x2013;118.</li>    </ul>   </section>  </section>  <section id="foot-001" class="footnote">   <header>    <div class="title-info">    <h2>FOOTNOTE</h2>    </div>   </header>   <p id="fn1"><a href="#foot-fn1"><sup>&#x002A;</sup></a>This research was partially supported by French National Agency (ANR) under project FIELDS (ANR-15-CE23-0006) and by a Google Faculty Award.<br/>This work is also funded in part by the European Commission H2020 FETPROACT 2016-2017 program under grant 732942 (ODYCCEUS), by the ANR (French National Agency of Research) under grant ANR-15-CE38-0001 (AlgoDiv), by the Ile-de-France Region and its program FUI21 under grant 16010629 (iTRAC).</p>   <p id="fn3"><a href="#foot-fn3"><sup>&#x2020;</sup></a>Most of the work was done while the author was a postdoc at T&#x00E9;l&#x00E9;com ParisTech.</p>   <p id="fn4"><a href="#foot-fn4"><sup>&#x2021;</sup></a>Most of the work was done while the author was a student at T&#x00E9;l&#x00E9;com ParisTech.</p>   <p id="fn5"><a href="#foot-fn5"><sup>1</sup></a>Our code is available at <a class="link-inline force-break" href="https://github.com/maxdan94/kClist">https://github.com/maxdan94/kClist</a>. </p>   <p id="fn6"><a href="#foot-fn6"><sup>2</sup></a>We remark that these results are significantly more accurate than initially reported due to a bug in their code, which has been later fixed by the authors.</p>   <p id="fn7"><a href="#foot-fn7"><sup>3</sup></a>Available at <a class="link-inline force-break" href="https://github.com/maxdan94/kClist">https://github.com/maxdan94/kClist</a>. </p>   <div class="bibStrip">    <p>This paper is published under the Creative Commons Attribution 4.0 International (CC-BY&#x00A0;4.0) license. Authors reserve their rights to disseminate the work on their personal and corporate Web sites with the appropriate attribution.</p>    <p>    <em>WWW' 18, April 23&#x2013;27, 2018, Lyon, France</em>    </p>    <p>&#x00A9; 2018; IW3C2 (International World Wide Web Conference Committee), published under Creative Commons CC-BY&#x00A0;4.0 License. ACM ISBN 978-1-4503-5639-8/18/04.<br/>DOI: <a class="link-inline force-break" target="_blank"     href="https://doi.org/10.1145/3178876.3186125">https://doi.org/10.1145/3178876.3186125</a>    </p>   </div>  </section>  <div class="pubHistory">   <p/>  </div> </body> </html> 
