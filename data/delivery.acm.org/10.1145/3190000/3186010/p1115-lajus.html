<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">  <head>  <title>Are All People Married?Determining Obligatory Attributes in Knowledge Bases</title>  <!-- Copyright (c) 2010-2015 The MathJax Consortium --><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>  <meta name="viewport" content="width=device-width; initial-scale=1.0;"></meta>  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>  <link media="screen, print" rel="stylesheet"    href="../../../../dl.acm.org/pubs/lib/css/bootstrap.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../../dl.acm.org/pubs/lib/css/bootstrap-theme.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../../dl.acm.org/pubs/lib/css/main.css"/><script src="../../../../dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script>  <script src="../../../../dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script>  <script src="../../../../dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script>  <script src="../../../../dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script>  <script type="text/javascript"    src="../../../../dl.acm.org/pubs/lib/js/MathJax.js?config=TeX-AMS_CHTML"></script>  <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>  </head>  <body id="main">  <section class="front-matter">   <section>    <header class="title-info">     <div class="journal-title">     <h1>      <span class="title">Are All People Married?Determining Obligatory Attributes in Knowledge Bases</span>      <br/>      <span class="subTitle"/>     </h1>     </div>    </header>    <div class="authorGroup">     <div class="author">     <span class="givenName">Jonathan</span>      <span class="surName">Lajus</span>,     Telecom ParisTech, Paris, France, <a href="mailto:jlajus@telecom-paristech.fr">jlajus@telecom-paristech.fr</a>     </div>     <div class="author">     <span class="givenName">Fabian M.</span>      <span class="surName">Suchanek</span>,     Telecom ParisTech, Paris, France, <a href="mailto:suchanek@telecom-paristech.fr">suchanek@telecom-paristech.fr</a>     </div>            </div>    <br/>    <div class="pubInfo">     <p>DOI: <a href="https://doi.org/10.1145/3178876.3186010" target="_blank">https://doi.org/10.1145/3178876.3186010</a>     <br/>WWW '18: <a href="https://doi.org/10.1145/3178876" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p>    </div>    <div class="abstract">     <p>     <small>An attribute is obligatory for a class in a Knowledge Base (KB), if all instances of the class have the attribute in the real world. For example, <em>hasBirthDate</em> is an obligatory attribute for the class <em>Person</em>, while <em>hasSpouse</em> is not. In this paper, we propose a new way to model incompleteness in KBs. From this model, we derive a method to automatically determine obligatory attributes &#x2013; using only the data from the KB. Our algorithm can detect such attributes with a precision of up to 90%.</small>     </p>    </div>    <div class="classifications">     <div class="author">     <span style="font-weight:bold;">      <small>Keywords:</small>     </span>     <span class="keyword">      <small>Knowledge Bases</small>, </span>     <span class="keyword">      <small> Completeness</small>, </span>     <span class="keyword">      <small> Classes</small>, </span>     <span class="keyword">      <small> Attributes</small>     </span>     </div>     <br/>     <div class="AcmReferenceFormat">     <p>      <small>       <span style="font-weight:bold;">ACM Reference Format:</span>       <br/>       Jonathan Lajus and Fabian M. Suchanek. 2018. Are All People Married?Determining Obligatory Attributes in Knowledge Bases. In <em>WWW 2018: The 2018 Web Conference,</em>       <em>April 23&#x2013;27, 2018,</em>       <em> Lyon, France. ACM, New York, NY, USA</em> 10 Pages. <a href="https://doi.org/10.1145/3178876.3186010" class="link-inline force-break"        target="_blank">https://doi.org/10.1145/3178876.3186010</a></small>     </p>     </div>    </div>   </section>  </section>  <section class="body">   <section id="sec-3">    <header>     <div class="title-info">     <h2>      <span class="section-number">1</span> Introduction</h2>     </div>    </header>    <p>Recent years have seen the rise of large knowledge bases (KBs). These include, among others, YAGO, Wikidata, DBpedia, BabelNet, and NELL on the academic side, and Google&#x0027;s Knowledge Vault and Microsoft&#x0027;s Satori on the industrial side. These KBs contain millions of entities (such as cities, universities, or famous people), and billions of facts about them (such as which city is located in which country, or which scientist works at which university). The KBs find applications in information retrieval, machine translation, and question answering.</p>    <p>The usefulness of these applications depends on the data quality of the knowledge base. One important dimension of quality is the correctness of the data. But there is another important dimension: the completeness of the data &#x2013; i.e., whether or not a statement about an entity is missing from the KB. Data completeness affects queries about cardinalities, about existence, and about top-ranked entities. For example, if the population of Tokyo is missing from the KB, then a query about the top-10 most populous cities in the world will return a factually wrong result.</p>    <p>If we knew that every city has to have a population, we could know that the reason for Tokyo&#x0027;s missing population is not that Tokyo does not have a population in the real world, but that the number was not added to the KB. We could thus alert the user that the data on which the query is computed is known to be incomplete. We say that the population is an <em>obligatory attribute</em> for the class <em>city</em>. Not all attributes are obligatory. For example, not every city has to be the capital of a region. The same goes for other classes: Every person has to have a birth date, but not every person has to be married.</p>    <p>If we were able to distinguish obligatory attributes from optional ones, we could see more easily where information is missing in the KB. This, in turn, could help us qualify the answers to our queries. Several approaches allow querying incomplete data, if the degree of completeness is known&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0013">13</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0015">15</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0018">18</a>]. The obligatory attributes can also help the designers of the knowledge base focus their effort on completing the data. For example, collaborative knowledge bases such as Wikidata could ask contributors specifically for the obligatory attributes of a new entity. Finally, the obligatory attributes can give semantics to classes. For example, the characteristics of actors is that they act in a movie. Such information can help decide whether an entity belongs to a class or not, it can guide the process of taxonomy design, and it can help define schema constraints&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0011">11</a>]. We note that even obligatory attributes with a few counter-examples would be helpful for these goals. For example, it is good to know that people generally have a nationality &#x2013; even if there are some people who do not have one. Our goal is to find the rule rather than the exception.</p>    <p>It is not easy to determine whether an attribute is obligatory or not. Today&#x0027;s KBs contain not just people and cities, but literally hundreds of thousands of other classes. They also contain hundreds, if not thousands of attributes. It is thus infeasible to specify the obligatory attributes manually. It is also hard to find them automatically: In YAGO, e.g., 2% of soccer players have a club &#x2013; and that is an obligatory attribute for professional soccer players. At the same time, 2% of people have a spouse &#x2013; and that is an optional attribute. Using the available data to determine obligatory attributes thus amounts to generalizing from a few instances to all instances of a class. This is a very difficult endeavor &#x2013; even for humans. The case of KBs is even more intricate, because most KBs do not explicitly say that a statement does not hold in reality. For example, the KBs do not say that Pope Francis is <em>not married</em>. Rather, they operate under the Open World Assumption: A statement may be missing from the KB either because it was not added, or because it does not hold in reality. Thus, we find ourselves with the task of generalizing from a few instances in the absence of counter-examples.</p>    <p>In this paper, we present methods that can detect obligatory attributes automatically. Our key idea is to use the class hierarchy: Most modern KBs contain extensive class hierarchies (YAGO, e.g., contains 650,000 classes; DBpedia and Wikidata have manually designed taxonomies). And yet, the KBs use the class hierarchy mainly to specify domain and range constraints. They do not exploit the semantics of the hierarchy any further. Our idea is to make use of the classes to determine obligatory attributes. More precisely, our contributions are as follows:</p>    <ul class="list-no-style">     <li id="list1" label="&#x2022;">a formal definition of the problem of obligatory attributes<br/></li>     <li id="list2" label="&#x2022;">a probabilistic model for the incompleteness of a KB<br/></li>     <li id="list3" label="&#x2022;">an algorithm that can determine obligatory attributes automatically<br/></li>     <li id="list4" label="&#x2022;">extensive experiments on different datasets with different competitors, showing that obligatory attributes can be detected with a precision of up to 90%.<br/></li>    </ul>    <p>This paper is structured as follows. We first discuss related work in Section&#x00A0;<a class="sec" href="#sec-4">2</a> and the preliminaries in Section&#x00A0;<a class="sec" href="#sec-5">3</a>. Then we present the formal definition of our problem in Section&#x00A0;<a class="sec" href="#sec-6">4</a>, and our approach in Section&#x00A0;<a class="sec" href="#sec-11">5</a>. Section&#x00A0;<a class="sec" href="#sec-15">6</a> presents experiments, before Section&#x00A0;<a class="sec" href="#sec-22">7</a> concludes.</p>   </section>   <section id="sec-4">    <header>     <div class="title-info">     <h2>      <span class="section-number">2</span> Related Work</h2>     </div>    </header>    <p>     <em>Query Completeness</em>. Much recent work&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0013">13</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0015">15</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0018">18</a>] has investigated the completeness of queries when the completeness of the data is known. These approaches are orthogonal to our work, which aims to establish whether the data is complete in the first place.</p>    <p>     <em>Measuring Incompleteness</em>. Several studies have confirmed that KBs are incomplete. A watermarking study&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0020">20</a>] reports that 69%&#x2013;99% of instances in YAGO and DBpedia lack at least one property that other entities in the same class have. In Freebase, 71% of people have no known place of birth, and 75% have no known nationality&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0003">3</a>]. Wikidata is aware of the problem of incompleteness, and has developed tools to specify completeness&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0004">4</a>], as well as tools to manually add completeness information&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0002">2</a>]. Unlike our work, these approaches do not aim at determining completeness automatically.</p>    <p>     <em>Determining Incompleteness</em>. Closest to our work, several approaches have recently taken to measure the incompleteness in knowledge bases&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0007">7</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0019">19</a>]. However, these works determine whether a particular subject (such as Emmanuel Macron) is incomplete with respect to a particular attribute (such as <em>birthDate</em>). Our work, in contrast, aims at determining whether an attribute is obligatory or not for a given class. It thus operates on the schema level.</p>    <p>     <em>Schema Mining</em>. Other work has investigated the more general problem of schema mining&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0008">8</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0010">10</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0017">17</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0022">22</a>]. The work of&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0017">17</a>] mines domain and range constraints for relations. Our work, in contrast, mines relations that are obligatory for classes. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0010">10</a>] uses machine learning to find OWL class descriptions. However, they rely on negative facts given by the user, or on prior knowledge about the schema &#x2013; while we require none of these. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0022">22</a>] mines Horn rules on a KB. However, this approach is not targeted towards sparse obligatory attributes. We use it as a baseline in our experiments. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0008">8</a>] also mines Horn rules, and can deal with sparse data. At the same time, it cannot mine rules with existential variables in the head. Any such rule would trivially have a confidence of 100% in their model, because the model makes the Partial Completeness Assumption. Another work&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>] mines definitions of classes. This approach comes closer to our goal, but is not exactly targeted towards obligatory attributes. We use such an approach as a baseline in our experiments.</p>   </section>   <section id="sec-5">    <header>     <div class="title-info">     <h2>      <span class="section-number">3</span> Preliminaries</h2>     </div>    </header>    <p>     <em>Knowledge Bases</em>. We are concerned with KBs such as YAGO, DBpedia, and Wikidata. These use a set <span class="inline-equation"><span class="tex">$\mathcal {I}$</span>     </span> of instances (such as <em>Macron</em> or the year <em>2017</em>)<a class="fn" href="#fn1" id="foot-fn1"><sup>1</sup></a> and a set <span class="inline-equation"><span class="tex">$\mathcal {P}$</span>     </span> of property names (such as <em>presidentOf</em>). We assume that <span class="inline-equation"><span class="tex">$\mathcal {P}$</span>     </span> contains for every <span class="inline-equation"><span class="tex">$p\in \mathcal {P}$</span>     </span> also its inverse <em>p</em>     <sup>&#x2212;</sup>. Furthermore, in all of the following, we assume that <span class="inline-equation"><span class="tex">$\mathcal {I}$</span>     </span> and <span class="inline-equation"><span class="tex">$\mathcal {P}$</span>     </span> are fixed and global sets. In this context, a KB can be seen as a set <span class="inline-equation"><span class="tex">$K \subseteq \mathcal {I} \times \mathcal {P} \times \mathcal {I}$</span>     </span> of facts (such as &#x27E8;<em>Macron</em>, <em>presidentOf</em>, <em>France</em>&#x27E9;). Each fact consists of a subject <span class="inline-equation"><span class="tex">$s \in \mathcal {I}$</span>     </span>, a property <span class="inline-equation"><span class="tex">$p \in \mathcal {P}$</span>     </span>, and an object <span class="inline-equation"><span class="tex">$o \in \mathcal {I}$</span>     </span>, and we write it as <em>p</em>(<em>s</em>, <em>o</em>). We assume that for every <em>p</em>(<em>s</em>, <em>o</em>) &#x2208; <em>K</em>, we also have <em>p</em>     <sup>&#x2212;</sup>(<em>o</em>, <em>s</em>) &#x2208; <em>K</em>. A property <em>p</em> is a function in a KB <em>K</em>, if it has at most one object for each subject. Each KB <em>K</em> also defines a set <span class="inline-equation"><span class="tex">$\mathcal {C}_K \subseteq 2^\mathcal {I}$</span>     </span> of named classes (such as <em>Person</em> or <em>President</em>).</p>    <p>     <em>Ideal KB</em>. For our problem, we consider a (hypothetical) ideal KB <span class="inline-equation"><span class="tex">$\mathcal {W}$</span>     </span>, which contains all facts of the real world. With this, our work is in line with the other work in the area&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0007">7</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0013">13</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0015">15</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0018">18</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0019">19</a>], which also assumes an ideal KB. The problems of determining how such a KB could look are discussed in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0019">19</a>].</p>    <p>A knowledge base <em>K</em> is <em>correct</em> if <span class="inline-equation"><span class="tex">$K \subseteq \mathcal {W}$</span>     </span> and it is <em>complete</em> if <span class="inline-equation"><span class="tex">$\mathcal {W} \subseteq K$</span>     </span>. The assumption that the KB is complete is called the <em>Closed-World Assumption (CWA)</em>: <div class="table-responsive" id="Xeq1">     <div class="display-equation">      <span class="tex mytex">\begin{equation} \forall r, a, b: r(a,b) \notin K \Rightarrow r(a,b) \notin \mathcal {W} \end{equation} </span>      <br/>      <span class="equation-number">(1)</span>     </div>     </div> The CWA is too strong in practice. The <em>Partial Completeness Assumption (PCA)</em>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0008">8</a>] states that if a KB <em>K</em> knows a fact about an instance, then it knows all facts with the same property about the instance: <div class="table-responsive" id="eq1">     <div class="display-equation">      <span class="tex mytex">\begin{equation} \forall r, a, b, b^{\prime }: r(a,b) \in K \wedge r(a,b^{\prime }) \notin K \Rightarrow r(a,b^{\prime }) \notin \mathcal {W} \end{equation} </span>      <br/>      <span class="equation-number">(2)</span>     </div>     </div> Finally, the <em>Open-World Assumption (OWA)</em> states that nothing follows from the absence of a fact in the KB, i.e., the absence of evidence is not evidence of absence.</p>    <p>     <em>Generalization Rules</em>. The <em>subject set p<sub>K</sub>     </em> of a property <em>p</em> in a knowledge base <em>K</em> is the set of all instances that have the property <em>p</em> in <em>K</em>: <em>p<sub>K</sub>     </em> = {<em>x</em>|&#x2203;<em>y</em>: <em>p</em>(<em>x</em>, <em>y</em>) &#x2208; <em>K</em>}. A <em>generalization rule</em> for a KB <em>K</em> is a formula of the form <em>A</em>&#x2286;<em>B</em>, where <em>A</em> and <em>B</em> are classes of <em>K</em>, subject sets of <em>K</em>, or intersections thereof. For example, if <span class="inline-equation"><span class="tex">$President_\mathcal {W}$</span>     </span> is the class of presidents in the real world, then the following generalization rule says that all presidents are presidents of some country: <div class="table-responsive">     <div class="display-equation">      <span class="tex mytex">\[ President_\mathcal {W} \subseteq {\it presidentOf}_\mathcal {W} \] </span>      <br/>     </div>     </div> With this, we can already make a simple observation:</p>    <p>     <div class="proposition" id="enc1">     <Label>Proposition 1 (Heredity).</Label>     <p> In any KB <em>K</em>, for every class <span class="inline-equation"><span class="tex">$c_K\in \mathcal {C}_K$</span>      </span>, any subclass <em>s<sub>K</sub>      </em>&#x2286;<em>c<sub>K</sub>      </em>, and every property <em>p</em>: if <em>c<sub>K</sub>      </em>&#x2286;<em>p<sub>K</sub>      </em> then <em>s<sub>K</sub>      </em>&#x2286;<em>p<sub>K</sub>      </em>.</p>     </div>    </p>    <p>This proposition tells us that if a generalization rule holds for a class, it also holds for all subclasses. The <em>confidence</em> of a generalization rule is defined as <div class="table-responsive">     <div class="display-equation">      <span class="tex mytex">\[ {\it conf}(A \subseteq B) = \frac{|A \cap B|}{|A|} \] </span>      <br/>     </div>     </div> Finally, we can make a second simple observation:</p>    <p>     <div class="proposition" id="enc2">     <Label>Proposition 2 (Separation).</Label>     <p> If <em>c<sub>K</sub>      </em>&#x2286;<em>p<sub>K</sub>      </em> for some class <em>c<sub>K</sub>      </em> of some KB <em>K</em> and some property <em>p</em>, then the following holds for any class <span class="inline-equation"><span class="tex">$c^{\prime }_K$</span>      </span> of <em>K</em>: <div class="table-responsive">       <div class="display-equation">        <span class="tex mytex">\[ {\it conf}(c_K \cap p_K \subseteq c^{\prime }_K) = {\it conf}(c_K \subseteq c^{\prime }_K) \] </span>        <br/>       </div>      </div>     </p>     </div>    </p>   </section>   <section id="sec-6">    <header>     <div class="title-info">     <h2>      <span class="section-number">4</span> Model</h2>     </div>    </header>    <section id="sec-7">     <header>     <div class="title-info">      <h3>       <span class="section-number">4.1</span> Problem Definition</h3>     </div>     </header>     <p>     <em>Goal</em>. In this paper, we aim to find generalization rules of the form <span class="inline-equation"><span class="tex">$c_\mathcal {W} \subseteq p_\mathcal {W}$</span>     </span>. Such a rule says that every instance of <span class="inline-equation"><span class="tex">$c_\mathcal {W}$</span>     </span> must have the property <em>p</em> in the real world. We call <em>p</em> an <em>obligatory attribute</em> of the class <em>c</em>. For example, we aim to mine <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ \mathit {Film}_{\mathcal {W}} \subseteq \mathit {directed}^{-}_{\mathcal {W}} \] </span>       <br/>      </div>     </div> Here, <em>directed</em>     <sup>&#x2212;</sup> is an obligatory attribute for the class <em>Film</em>, i.e., every film has to have a director. The difficulty is to find such a rule in <span class="inline-equation"><span class="tex">$\mathcal {W}$</span>     </span> by looking only at the data of a given KB <em>K</em>. In the following, we write <span class="inline-equation"><span class="tex">$c_\mathcal {W}$</span>     </span> for the class <em>c</em> in the real world, and <em>c<sub>K</sub>     </em> for the corresponding class in <em>K</em>.</p>     <p>     <em>Baseline 1</em>. One way to find obligatory attributes is assume that the KB is complete (Closed World Assumption) and correct. Under these assumptions, we can predict that an attribute <em>p</em> is obligatory for a class <em>c</em> if and only if all instances of <em>c</em> have <em>p</em> in the KB <em>K</em>: <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ (c_K \subseteq p_K) ~~~~\overset{?}{\Rightarrow }~~~~ (c_\mathcal {W} \subseteq p_\mathcal {W}) \] </span>       <br/>      </div>     </div> This is how a rule mining system under the Closed World Assumption would proceed&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0022">22</a>], if applied naively to our problem. In practice, however, KBs are rarely complete. They operate under the Open World Assumption. There will be hardly any property <em>p</em> that all instances of class <em>c</em> have.</p>     <p>     <em>Baseline 2</em>. Another method would be to predict that an attribute <em>p</em> is obligatory for a class <em>c</em>, if the corresponding generalization rule has a confidence above a threshold <em>&#x03B8;</em> in the KB <em>K</em>: <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ {\it conf}(c_K \subseteq p_K)\ge \theta ~~~~\overset{?}{\Rightarrow }~~~~ (c_\mathcal {W} \subseteq p_\mathcal {W}) \] </span>       <br/>      </div>     </div> For example, if more than 90% of presidents in <em>K</em> have the property <em>presidentOf</em>, then we would predict that <em>presidentOf</em> is an obligatory attribute for the class of presidents. The problem is that an attribute may be very prevalent without being obligatory. For example, many film directors also acted in movies &#x2013; but acting in a movie is not an obligatory attribute for film directors.</p>     <p>     <em>Baseline 3</em>. Yet another idea (inspired by&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0001">1</a>]) is to make use of the taxonomy. Given a property <em>p</em> and a KB <em>K</em>, we can find the lowest class <em>c<sub>K</sub>     </em> of the taxonomy such that nearly all instances with <em>p</em> fall into that class. This is motivated by the contraposition of Proposition&#x00A0;<a class="enc" href="#enc2">2</a>. Formally, the method predicts that, for any property <em>p</em>, for any class <em>c<sub>K</sub>     </em> of a KB <em>K</em>, and for a threshold <em>&#x03B8;</em>: <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ \begin{array}{l} {\it conf}(p_K \subseteq c_K)\ge \theta \;\;\;\;\;\wedge \\ \forall c^{\prime }_K \subset c_K: {\it conf}(p_K \subseteq c^{\prime }_K) {\lt} \theta \\ \end{array} ~~\overset{?}{\Rightarrow }~~(c_\mathcal {W} \subseteq p_\mathcal {W}) \] </span>       <br/>      </div>     </div> This approach will work well for properties whose domain is a class, such as the property <em>presidentOf</em> with the class <em>President</em>. However, it will work less well if the attribute applies to only a subset of the class. For example, every person <em>x</em> with <span class="inline-equation"><span class="tex">$\exists y: \mathit {hasSpouse}(x, y) \in K$</span>     </span> belongs to the class <em>Person</em>. Thus, the above confidence will be 1 for <em>hasSpouse</em> and <em>Person</em>, and the method will conclude that every person is married.</p>    </section>    <section id="sec-8">     <header>     <div class="title-info">      <h3>       <span class="section-number">4.2</span> Our Approach</h3>     </div>     </header>     <figure id="fig1">     <img src="../../../../deliveryimages.acm.org/10.1145/3190000/3186010/images/www2018-19-fig1.svg" class="img-responsive" alt="Figure 1"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 1:</span>      <span class="figure-title">Examples of attributes and classes.</span>     </div>     </figure>     <p>Our idea is based on the assumption that the incompleteness of the KB is distributed equally across all classes of the KB. If we find a class that has a very low density of an attribute (while others have a high density), then we conclude that this low density indicates that the attribute is not obligatory for that class.</p>     <p>As an example, consider the class of all adult people (i.e., all persons without the class of children, Figure&#x00A0;<a class="fig" href="#fig1">1</a>). The attribute <em>hasSpouse</em> is much more prevalent in that class than in the class of children. It is unlikely that all missing <em>hasSpouse</em> facts in the class <em>Child</em> are due to incompleteness. Therefore, we can conclude that not all children are married in the real world. This means that <em>hasSpouse</em> cannot be obligatory for <em>Child</em> (and, hence, not for <em>Person</em>).</p>     <p>Now consider the example in Figure&#x00A0;<a class="fig" href="#fig1">1</a> on the right. Some instances of the class <em>Director</em> have the attribute <em>actedIn</em>. However, the density of that attribute increases if we consider the intersection of <em>Director</em> with <em>Actor</em>. Hence, <em>actedIn</em> cannot be obligatory for the class <em>Director</em>.</p>     <p>We will now show how to formalize this idea, and under which conditions we can guarantee that an attribute is not obligatory for a class.</p>    </section>    <section id="sec-9">     <header>     <div class="title-info">      <h3>       <span class="section-number">4.3</span> Assumptions</h3>     </div>     </header>     <p>In order to deduce formal statements about obligatory attributes in the real world from our KB <em>K</em>, we have to make a number of assumptions about <em>K</em>.</p>     <div class="assumption" id="enc3">     <Label>Assumption 1 (Correctness of the KB K).</Label>     <p> Every fact that appears in the KB <em>K</em> also appears in the ideal KB <span class="inline-equation"><span class="tex">$\mathcal {W}$</span>      </span>: <span class="inline-equation"><span class="tex">$K \subseteq \mathcal {W}$</span>      </span>.</p>     </div>     <p>This assumption basically says that the KB does not contain wrong statements. This is a strong assumption, which may not hold in practice&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0005">5</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0021">21</a>]. However, we use it here mainly for our theoretical model. Our experiments will show that our method works even if there is some amount of noise in the data. We make a second assumption:</p>     <div class="assumption" id="enc4">     <Label>Assumption 2 (Class Hierarchy of the KB K).</Label>     <p> The classes of the KB <em>K</em> are correct and complete, i.e., <span class="inline-equation"><span class="tex">$\mathcal {C}_K=\mathcal {C}_\mathcal {W}$</span>      </span>.</p>     </div>     <p>Again, this is a strong assumption that we use mainly for our theoretical model. In practice, three types of problems can appear. First, an instance can belong to a wrong class in the knowledge base. Second, an instance may be tagged with a too general class (e.g., <em>Macron</em> belongs to <em>Person</em>, but not to <em>President</em>). Finally, a class may be missing altogether (such as <em>SciencesPoAlumni</em> for <em>Macron</em>). These problems impact our method, as we discuss in Section&#x00A0;<a class="sec" href="#sec-20">6.5</a>. However, for Wikidata, the class system that we use appears sufficiently complete and correct to make our method work. For YAGO, the data is known to be highly accurate&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0021">21</a>], and furthermore, the Wikipedia categories are included in the class hierarchy. This makes the hierarchy sufficiently complete for our method to work. In DBpedia, in contrast, each instance is tagged with only one class. This results in so much incompleteness that our method cannot work. For example, in DBpedia, the proportion of singers who wrote a song is higher than the proportion of song-writers who wrote a song. This indicates that many singers should actually (also) be tagged as song-writers &#x2013; which they are not.</p>     <p>Assumption&#x00A0;<a class="enc" href="#enc4">2</a> allows us to omit the subscript from the classes from now on. With Assumptions&#x00A0;<a class="enc" href="#enc3">1</a> and&#x00A0;<a class="enc" href="#enc4">2</a>, we can already show:</p>     <div class="proposition" id="enc5">     <Label>Proposition 3 (Upper bound for Confidence).</Label>     <p> Under Assumptions&#x00A0;<a class="enc" href="#enc3">1</a> and&#x00A0;<a class="enc" href="#enc4">2</a>, <div class="table-responsive">       <div class="display-equation">        <span class="tex mytex">\[ {\it conf}(c \subseteq p_K) \le {\it conf}(c \subseteq p_\mathcal {W}) \] </span>        <br/>       </div>      </div> for any KB <em>K</em>, any class <em>c</em>, and any property <em>p</em>.</p>     </div>     <p>This proposition holds because Assumption&#x00A0;<a class="enc" href="#enc3">1</a> tells us that <em>x</em> &#x2208; <em>p<sub>K</sub>     </em> implies <span class="inline-equation"><span class="tex">$x\in p_\mathcal {W}$</span>     </span>. Furthermore, Assumption&#x00A0;<a class="enc" href="#enc4">2</a> tells us that the classes of <em>K</em> are the classes of <span class="inline-equation"><span class="tex">$\mathcal {W}$</span>     </span>.</p>    </section>    <section id="sec-10">     <header>     <div class="title-info">      <h3>       <span class="section-number">4.4</span> Random sampling model</h3>     </div>     </header>     <p>Our method assumes that the incompleteness of the KB is evenly distributed. More formally, let us consider the space of all possible KBs under Assumption&#x00A0;<a class="enc" href="#enc3">1</a>. These are <span class="inline-equation"><span class="tex">$\Omega = 2^\mathcal {W}$</span>     </span>. We assume a probability distribution <span class="inline-equation"><span class="tex">$\mathbb{P}$</span>(&#x00B7;) over this space. Given a property <em>p</em> and instances <em>s</em>, <em>o</em>, the statement <em>p</em>(<em>s</em>, <em>o</em>) &#x2208; <em>K</em> becomes a boolean random variable defined on a KB <em>K</em>, and we denote it by <em>p</em>(<em>s</em>, <em>o</em>). In the same way, the expression |<em>p<sub>K</sub>     </em>&#x2229;<em>c</em>| becomes a numerical random variable defined on a KB <em>K</em>, and we denote it by |<em>p</em>&#x2229;<em>c</em>|. Likewise, <em>conf</em>(<em>c</em>&#x2286;<em>p<sub>K</sub>     </em>) becomes a numerical random variable, and we denote it by <em>conf</em>(<em>c</em>&#x2286;<em>p</em>). We constrain <span class="inline-equation"><span class="tex">$\mathbb{P}$</span>(&#x00B7;) by the following assumption:</p>     <div class="assumption" id="enc6">     <Label>Assumption 3 (Random sampling).</Label>     <p> On the space of all KBs in <span class="inline-equation"><span class="tex">$\Omega = 2^\mathcal {W}$</span>      </span>, there exists a probability <em>l<sub>p</sub>      </em> for each property <em>p</em> such that: <div class="table-responsive">       <div class="display-equation">        <span class="tex mytex">\[ \forall x,y. \mathbb{P}(p(x,y)) = \left\lbrace \begin{array}{@{}l@{\quad }l@{}}l_p, &#x0026; \text{if } p(x,y) \in \mathcal {W} \\ 0, &#x0026; \text{otherwise} \end{array}\right. \] </span>        <br/>       </div>      </div>     </p>     </div>     <p>The second case follows from Assumption&#x00A0;<a class="enc" href="#enc3">1</a>. The first case states that facts with the property <em>p</em> in our KB come from a uniform random sampling of all true facts with property <em>p</em> in the real-world.</p>     <p>Several factors can thwart this assumption. First, the KB may be biased towards popular instances. For example, Wikipedia contains more information about American actors than about Polish actors, and people magazines are more concerned about the extra-marital affairs of actors than about the affairs of an architect. Thus, any KB that extracts from these sources will be biased. Second, the information extraction itself may have a bias. For example, several information extraction methods feed from the Wikipedia infoboxes. These infoboxes come in a number of pre-defined templates, and these templates define the properties. This entails that the presence or absence of a property in the KB depends on whether the instance happens to belong to an infobox template that defines this property or not. That said, making such simplifying assumptions about the probability distribution of facts is not unusual&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0003">3</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0012">12</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0016">16</a>]. Our experiments will show that our model works also in cases where this assumption is violated to some degree.</p>     <p>We constrain <span class="inline-equation"><span class="tex">$\mathbb{P}$</span>(&#x00B7;) further by adding in the PCA (Equation&#x00A0;<a class="eqn" href="#eq1">2</a>).</p>     <div class="assumption" id="enc7">     <Label>Assumption 4 (PCA).</Label>     <p> On the space of all KBs in <span class="inline-equation"><span class="tex">$\Omega = 2^\mathcal {W}$</span>      </span>, <span class="inline-equation"><span class="tex">$\mathbb{P}$</span>(<em>K</em>) = 0 if there exists a property <em>p</em> (which is not an inverse) and instances <em>x</em>, <em>y</em>, <em>y</em>&#x2032; with <em>p</em>(<em>x</em>, <em>y</em>) &#x2208; <em>K</em>, <em>p</em>(<em>x</em>, <em>y</em>&#x2032;)&#x2209;<em>K</em> and <span class="inline-equation"><span class="tex">$p(x, y^{\prime }) \in \mathcal {W}$</span>      </span>.</p>     </div>     <p>The PCA is a common assumption for the KBs we consider&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0003">3</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0008">8</a>]. It has been experimentally shown to be correct in a large number of cases&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0009">9</a>]. Again, we need the PCA mainly for our model. Our experiments will show that our method gracefully translates to scenarios where the PCA does not hold for all properties. In particular, our method is robust enough to work also with the inverses of properties, for which the PCA usually does not hold. In the appendix, we prove:</p>     <div class="assumption" id="enc7a">     <Label>Theorem 1. (Random sampling under PCA)</Label>     <p>Under Assumptions&#x00A0;<a class="enc" href="#enc6">3</a> and&#x00A0;<a class="enc" href="#enc7">4</a>, for each property <em>p</em> with probability <em>l<sub>p</sub>     </em> (as given by Assumption&#x00A0;<a class="enc" href="#enc6">3</a>), <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ \forall x: \mathbb{P}(\exists y: p(x,y)) = \left\lbrace \begin{array}{@{}l@{\quad }l@{}}l_p, &#x0026; \text{if } x \in p_\mathcal {W} \\ 0, &#x0026; \text{otherwise} \end{array}\right. \] </span>       <br/>      </div>     </div></div> Theorem&#x00A0;<a class="sec" href="#sec-10">1</a> tells us that the truth value of &#x2203;<em>y</em>: <em>p</em>(<em>x</em>, <em>y</em>) &#x2208; <em>K</em> for an instance <em>x</em> in a KB <em>K</em> can be seen as a random draw of a Bernoulli variable with a parameter <em>l<sub>p</sub>     </em>. This allows us to derive <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ |p \cap c| \sim \sum _{x \in c, x\in p_\mathcal {W}}\text{B}{\rm\small ERNOULLI}(l_p) = \text{B}{\rm\small INOM}(|p_\mathcal {W} \cap c|, l_p) \] </span>       <br/>      </div>     </div> This allows for the following proposition.</p>     <div class="proposition" id="enc8">     <Label>Proposition 4 (Biased estimator).</Label>     <p> The confidence of a generalization rule in <em>&#x03A9;</em> follows a binomial distribution divided by a constant: <div class="table-responsive">       <div class="display-equation">        <span class="tex mytex">\[ conf(c \subseteq p) \sim \frac{\text{B}{\rm\small INOM}(|c \cap p_\mathcal {W}|, l_p)}{|c|} \] </span>        <br/>       </div>      </div> Hence, the expected confidence of the rule in <em>&#x03A9;</em> is a biased estimator for the confidence of the rule in <span class="inline-equation"><span class="tex">$\mathcal {W}$</span>      </span>: <div class="table-responsive">       <div class="display-equation">        <span class="tex mytex">\[ \mathbb{E}[conf(c \subseteq p)] = l_p \times conf(c \subseteq p_\mathcal {W}) \] </span>        <br/>       </div>      </div>     </p>     </div>     <p>This proposition confirms that, in our model, the confidence of <span class="inline-equation"><span class="tex">$c \subseteq p_\mathcal {W}$</span>     </span> cannot be estimated from the data in our KB alone, as long as <em>l<sub>p</sub>     </em> remains unknown. The proposition also allows us to predict the behavior of Baseline 2 with parameter <em>&#x03B8;</em> (see again Section&#x00A0;<a class="sec" href="#sec-7">4.1</a>). For a predicate <em>p</em>, if <em>&#x03B8;</em> > <em>l<sub>p</sub>     </em>, then the baseline is less likely to find all the correct classes for the predicate <em>p</em>, but the classes it finds have a high probability of being correct. We show in the appendix:     <div class="proposition" id="enc1">     <Label>Proposition 5 (Unbiased estimator).</Label> Given two classes <em>c</em>, <em>c</em>&#x2032; and a property <em>p</em>, the expected confidence of <em>c</em>&#x2229;<em>p</em>&#x2286;<em>c</em>&#x2032; in <em>&#x03A9;</em> is an unbiased estimator for the confidence in <span class="inline-equation"><span class="tex">$\mathcal {W}$</span>     </span>: <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ \mathbb{E}[conf(c \cap p \subseteq c^{\prime })] = conf(c \cap p_\mathcal {W} \subseteq c^{\prime }) \] </span>       <br/>      </div>     </div></div> This proposition finally establishes a link between the (expected) observed confidence in our KB and the confidence in the real world.</p>    </section>   </section>   <section id="sec-11">    <header>     <div class="title-info">     <h2>      <span class="section-number">5</span> Algorithm</h2>     </div>    </header>    <p>In this section, we first define our main indicator score for obligatory attributes. We then present our algorithm and propose some variations of this algorithm.</p>    <section id="sec-12">     <header>     <div class="title-info">      <h3>       <span class="section-number">5.1</span> Confidence Ratio</h3>     </div>     </header>     <p>Our main indicator score for obligatory attributes is defined as follows:</p>     <div class="definition" id="enc9">     <Label>Definition 1 (Confidence ratio).</Label>     <p> Given a KB <em>K</em>, a property <em>p</em>, and two classes <em>c</em> and <em>c</em>&#x2032; with |<em>c</em>&#x2229;<em>c</em>&#x2032;| &#x2260; 0 and |<em>c</em>&#x2216;<em>c</em>&#x2032;| &#x2260; 0, the confidence ratio is <div class="table-responsive">       <div class="display-equation">        <span class="tex mytex">\[ s_p^K(c,c^{\prime }) = \frac{{\it conf}(c \setminus c^{\prime } \subseteq p_K)}{{\it conf}(c \cap c^{\prime } \subseteq p_K)} \] </span>        <br/>       </div>      </div>     </p>     </div>     <p>This expression compares the ratio of instances with <em>p</em> in <em>c</em>&#x2229;<em>c</em>&#x2032; to the ratio of instances with <em>p</em> in <em>c</em>&#x2216;<em>c</em>&#x2032;. It represents the influence of being in the class <em>c</em>&#x2032; for the instances of a class <em>c</em> on <em>p</em>. This ratio is similar to the relative risk that is used in clinical tests. We can now make the following observation (which we prove in the appendix):     <div class="proposition" id="enc1a">     <Label>Proposition 6 (Main observation).</Label> If <em>p</em> is an obligatory attribute for some class <em>c</em>, then for every class <em>c</em>&#x2032; with |<em>c</em>&#x2229;<em>c</em>&#x2032;| &#x2260; 0 and |<em>c</em>&#x2216;<em>c</em>&#x2032;| &#x2260; 0, <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ \mathbb{E}[s_p(c, c^{\prime })]=1 \] </span>       <br/>      </div>     </div></div> Here, <em>s<sub>p</sub>     </em>(<em>c</em>, <em>c</em>&#x2032;) is a random variable, and hence does not carry the <em>K</em>. The observation tells us that the density of <em>p</em> in <em>c</em> should not be influenced by <em>c</em>&#x2032; if <em>p</em> is obligatory for <em>c</em>. The probability of a KB where <em>c</em>&#x2032; influences <em>p</em> is low in our probability space.</p>     <p>     <em>Measure instability</em>. Our confidence ratio estimate will suffer from instability when the expected number of instances with a property <em>p</em> in an intersection is inferior to 1. In that case, there might be no instance with the property <em>p</em> in the intersection, and the confidence ratio will be infinite. In practice, this happens in small intersections for highly incomplete properties. Therefore, we decide to consider only <em>stable classes</em>. Given a class <em>c</em> and a property <em>p</em> in a KB <em>K</em>, an intersecting class <em>c</em>&#x2032; is stable if either the expected number of instances (<em>conf</em>(<em>c</em>&#x2286;<em>p<sub>K</sub>     </em>) &#x00D7; |<em>c</em>&#x2229;<em>c</em>&#x2032;|) or the actual number (|<em>c</em>&#x2229;<em>c</em>&#x2032;&#x2229;<em>p<sub>K</sub>     </em>|) is at least 1. The same has to hold for class differences.</p>    </section>    <section id="sec-13">     <header>     <div class="title-info">      <h3>       <span class="section-number">5.2</span> Algorithm</h3>     </div>     </header>     <p>Proposition&#x00A0;<a class="sec" href="#sec-12">6</a> allows us to make statements about a generalization rule <span class="inline-equation"><span class="tex">$c \subseteq p_\mathcal {W}$</span>     </span> in the real world purely by observing an incomplete knowledge base <em>K</em>. All we have to do is to check the classes <em>c</em>&#x2032; that intersect with the class <em>c</em>. If the ratio of instances of <em>p<sub>K</sub>     </em> in <em>c</em>&#x2229;<em>c</em>&#x2032; is very different from the ratio in <em>c</em>&#x2216;<em>c</em>&#x2032;, then it is very unlikely that <span class="inline-equation"><span class="tex">$c \subseteq p_\mathcal {W}$</span>     </span> holds. Furthermore, if <span class="inline-equation"><span class="tex">$s^K_p(c^{\prime },c)\gg 1$</span>     </span>, then <em>p</em> cannot be obligatory for <em>c</em>&#x2229;<em>c</em>&#x2032;. Thus, it cannot be obligatory for <em>c</em> and <em>c</em>&#x2032;.</p>     <p>These considerations give us Algorithm&#x00A0;1 . This algorithm takes as input a KB <em>K</em>, a class <em>c</em>, and a property <em>p</em>. The algorithm also uses two thresholds: <em>&#x03B8;</em> is the margin that we allow <span class="inline-equation"><span class="tex">$s^K_p$</span>     </span> to deviate from 1. The larger the threshold, the more obligatory attributes the algorithm will find &#x2013; and the more likely it is that some of them will be wrong. The threshold <em>&#x03B8;</em>&#x2032; is the minimum support allowed for the rule <em>c</em>&#x2286;<em>p</em> to be considered. In practice, we set <em>&#x03B8;</em>&#x2032; to 100, as in AMIE&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0008">8</a>]. Our algorithm returns <em>false</em> if the generalization rule <span class="inline-equation"><span class="tex">$c \subseteq p_\mathcal {W}$</span>     </span> should be rejected &#x2013; either because the support is too small (Lines&#x00A0;1-2), or because there is a stable intersecting class <em>c</em>&#x2032; with <span class="inline-equation"><span class="tex">$s^K_p(c,c^{\prime })\ne 1$</span>     </span> (Lines&#x00A0;4-5), or <span class="inline-equation"><span class="tex">$s^K_p(c^{\prime },c)\gg 1$</span>     </span> (Lines&#x00A0;6-7). If neither is the case, the algorithm returns <em>true</em>.</p>     <p>     <em>Caveat</em>. Our algorithm will return <em>true</em> if it finds no reason to reject a class. This, however, does not necessarily mean that the attribute is obligatory in this class. In particular, our algorithm may perform poorly if there is no class where the attribute is obligatory. However, our experiments show that despite this caveat, the method works well in practice.</p>     <p>     <img src="../../../../deliveryimages.acm.org/10.1145/3190000/3186010/images/www2018-19-img1.svg" class="img-responsive" alt="" longdesc=""/>     </p>     <p>     <strong>Example.</strong> Consider again the second example in Figure&#x00A0;<a class="fig" href="#fig1">1</a>. On YAGO data, we obtain: <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ s^{{\it YAGO}}_{{\it actedIn}}(\mathit {Director}, \mathit {Actor}) = 0 \] </span>       <br/>      </div>     </div> This means that directors are unlikely to act in a movie if they are not also actors. Thus, our algorithm will reject the hypothesis that <em>actedIn</em> would be obligatory for the class <em>Director</em>. We also obtain <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ s^{{\it YAGO}}_{{\it actedIn}}(\mathit {Actor}, \mathit {Director}) = 0.77 \] </span>       <br/>      </div>     </div> Since this value is closer to 1, we understand that actors act no matter whether they are also directors or not. Hence, the class <em>Actor</em> will be accepted for thresholds <em>&#x03B8;</em> above <span class="inline-equation"><span class="tex">$\frac{1}{0.77} \approx 1.3$</span>     </span>.</p>    </section>    <section id="sec-14">     <header>     <div class="title-info">      <h3>       <span class="section-number">5.3</span> Variations</h3>     </div>     </header>     <p>     <em>Relaxation</em>. In practice, classes in a KB intersect only in small areas. Thus, when <span class="inline-equation"><span class="tex">$s^K_\phi (c, c^{\prime }) \gg 1$</span>     </span>, we decided to reject only <em>c</em>&#x2032;. In this relaxed variant, the condition in Line&#x00A0;4 of Algorithm&#x00A0;1 becomes <span class="inline-equation"><span class="tex">$log(s_p^K(c,c^{\prime })) {\lt} -log(\theta)$</span>     </span>.</p>     <p>     <em>Fisher&#x0027;s Exact Test</em>. We also experimented the Fisher&#x0027;s Exact Test&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0006">6</a>] instead of the confidence ratio. We replace the logarithm of the confidence ratio <em>s</em> in Line&#x00A0;4 of Algorithm&#x00A0;1 by the probability that <em>c</em>&#x2229;<em>c</em>&#x2032; has higher values, and in Line&#x00A0;6 with the probability that it has lower values over the set of possible contingency tables with fixed marginals.</p>    </section>   </section>   <section id="sec-15">    <header>     <div class="title-info">     <h2>      <span class="section-number">6</span> Experiments</h2>     </div>    </header>    <p>In this section, we evaluate our approach experimentally on large real-world KBs. We first evaluate our approach on YAGO, a KB for which we know that our Assumptions&#x00A0;<a class="enc" href="#enc3">1</a> and <a class="enc" href="#enc4">2</a> hold by and large. Then, we submit our approach to a stress test: We run it on Wikidata, where less is known about our assumptions. Finally, we investigate how our approach could be generalized to composite classes.</p>    <section id="sec-16">     <header>     <div class="title-info">      <h3>       <span class="section-number">6.1</span> Datasets</h3>     </div>     </header>     <p>     <em>YAGO</em>. We chose the YAGO3 knowledge base&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0014">14</a>] for our experiments, because the data is of good quality (Assumption&#x00A0;<a class="enc" href="#enc3">1</a>) and the taxonomy is extensive (Assumption&#x00A0;<a class="enc" href="#enc4">2</a>). We use the facts of all instances, the full taxonomy, and the transitive closure of types. With this, our dataset contains more than 5 million instances and around 54,000 classes with more than 50 (direct or indirect) instances.</p>     <p>     <em>Wikidata</em>. As a stress-test, we also evaluated our approach in Wikidata, where less is known about our Assumptions 1-4. We used the version from 2017-06-07, which contains more than 16,000 properties. This makes a manual evaluation impractical. Hence, we reduced the dataset to only people. However, all people are in only one class: <em>Human</em>. Therefore, we used the <em>occupation</em> property (P106) to define classes. For example, in Wikidata, Elvis Presley (Q303) has the occupations <em>FilmActor</em>, <em>Actor</em>, <em>Singer</em>, <em>Screenwriter</em>, <em>Guitarist</em> and <em>Soldier</em>. These occupations form their own hierarchy, which we use as class hierarchy. For example, <em>FilmActor</em> is a sub-occupation of <em>Actor</em>, and thus becomes a subclass of it. This subset of Wikidata contains 1023 classes, around 1.6 million instances, and 2569 properties.</p>    </section>    <section id="sec-17">     <header>     <div class="title-info">      <h3>       <span class="section-number">6.2</span> Gold Standard</h3>     </div>     </header>     <p>Since our problem is novel, there is no previously published gold standard for it. Therefore, we had to construct a gold standard manually. For YAGO, we considered 68 properties (37 properties and their inverses), we determined the classes where more than 100 instances have the property, and we manually evaluated whether the attribute is obligatory or not. For Wikidata, we randomly selected 100 properties, and evaluated the output of each method manually. Our manual evaluation gives us an estimate for precision. Since Baseline&#x00A0;3 has a recall of 100% at maximal <em>&#x03B8;</em>, we can use it to estimate our recall.</p>     <p>It is not always easy to determine manually whether an attribute is obligatory. For example, consider the attribute <em>isAffiliatedTo</em>. Is it obligatory for an artist to be affiliated to a museum, for a football player to be affiliated to a football club, or for people in general to be affiliated to their relatives? For our gold standard, we restricted ourselves to cases where we could clearly establish whether an attribute is obligatory or not, and removed all other cases.</p>     <p>Another problem arises for classes where the huge majority of instances have a particular attribute. For example, should we discard <em>hasNationality</em> as an obligatory attribute for <em>Person</em> because there exist stateless people? In such cases, we decided that the absence of the attribute is an exception to the rule that our method should not predict. Hence, we considered <em>hasNationality</em> obligatory. A related problem is that an attribute may not necessarily be obligatory for a class, but that de facto all instances have it. For example, we expect all instances of the class <em>RomanEmperor</em> to be dead by now, but what if a renewed Roman empire arises in the future? In such cases, we considered an attribute obligatory if de facto all known instances have it.</p>     <p>We constructed our gold standard according to these principles, and refer the reader to&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0019">19</a>] for a more detailed discussion of such evaluations. All our datasets, as well as the gold standard and the evaluation results, are available at <a class="link-inline force-break"      href="https://suchanek.name/work/publications/www-2018-data">https://suchanek.name/work/publications/www-2018-data</a>. </p>    </section>    <section id="sec-18">     <header>     <div class="title-info">      <h3>       <span class="section-number">6.3</span> Evaluation Metric</h3>     </div>     </header>     <p>The most intuitive way to evaluate the prediction of obligatory attributes would be to consider each predicted pair of a class and an attribute, and to compare this set to the gold standard. However, this comparison would not take into account the size of the class. For example, it is more important to predict that all organizations have a headquarters than that all Qatari ski champions have a gender, because there are many more of the former than of the latter. However, weighting each class by the number of instances causes another problem. Consider, e.g., the classes <em>Man</em> and <em>Woman</em>, which partition the class <em>Person</em> in our data<a class="fn" href="#fn2" id="foot-fn2"><sup>2</sup></a>. If we predict that an attribute is obligatory for <em>Man</em> and for <em>Woman</em>, but not for <em>Person</em>, we would obtain a recall of only 50% &#x2013; even though we predicted the attribute correctly for all instances. <figure id="fig2">      <img src="../../../../deliveryimages.acm.org/10.1145/3190000/3186010/images/www2018-19-fig2.jpg" class="img-responsive" alt="Figure 2"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 2:</span>       <span class="figure-title">Influence of <em>&#x03B8;</em> on precision, recall and F1 for the different algorithms.</span>      </div>     </figure>     </p>     <p>To mitigate this problem, we compare, for each class <em>c</em> and for each property <em>p</em>, the actual set of predicted instances with the instances in the gold standard, i.e., we compare <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ P_p = \lbrace x \in c | c \subseteq p_W \text{ predicted by our algorithm}\rbrace \] </span>       <br/>      </div>     </div> with <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ G_p = \lbrace x \in c | c \subseteq p_W \text{ in the gold standard}\rbrace \] </span>       <br/>      </div>     </div> The true positives are the instances in the intersection of these sets. Then we compute the precision and recall as follows: <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ precision = \frac{\sum _p |P_p \cap G_p|}{\sum _p |P_p|} \] </span>       <br/>      </div>     </div>     <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ recall = \frac{\sum _p |P_p \cap G_p|}{\sum _p |G_p|} \] </span>       <br/>      </div>     </div> The F1-measure is computed as the harmonic mean of these.</p>    </section>    <section id="sec-19">     <header>     <div class="title-info">      <h3>       <span class="section-number">6.4</span> YAGO Experiment</h3>     </div>     </header>     <p>We ran all three baselines (Section&#x00A0;<a class="sec" href="#sec-6">4</a>) as well as our approaches (Section&#x00A0;<a class="sec" href="#sec-11">5</a>) on our YAGO dataset. Figure&#x00A0;<a class="fig" href="#fig2">2</a> shows the recall over the precision for each approach, with varying threshold <em>&#x03B8;</em>.</p>     <p>     <em>Baseline 1</em>. Recall that this baseline (inspired by&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0022">22</a>]) labels an attribute as obligatory in a class, if all instances of the class have this attribute in the KB. This baseline performs like Baseline&#x00A0;2 at <em>&#x03B8;</em> = 1. Unsurprisingly, it has a very good precision, but a very bad recall: Only very few attributes (such as <em>label</em>) appear on all instances.</p>     <p>     <em>Baseline 2</em>. This baseline relaxes Baseline&#x00A0;1 by labeling an attribute as obligatory if it is very prevalent in the class. For smaller <em>&#x03B8;</em>, this method has a better recall than Baseline&#x00A0;1. However, it cannot exceed an F1 value of 45%. This is because there is no global threshold <em>&#x03B8;</em> that would work well for all attributes. The baseline will work better if the KB is more complete. At the same time, the more complete the KB is, the less novel information there is to predict.</p>     <p>     <em>Baseline 3</em>. This baseline (inspired by&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0001">1</a>]) considers an attribute obligatory for a class if the vast majority of instances with that attribute fall in that class. The somewhat unusual curve comes from the fact that the baseline chooses the deepest class in the taxonomy where the target rule holds. While the method achieves slightly better F1 values (55%), its precision never exceeds 42%.</p>     <p>     <em>Confidence Ratio (Strict)</em>. This is our approach, based on the ratio of an attribute in a class and its intersections with the other classes (Algorithm&#x00A0;1). Different from Baseline&#x00A0;2, it delivers a very high precision (always <span class="inline-equation"><span class="tex">${\gt}80\%$</span>     </span>) &#x2013; at the expense of somewhat lower recall. The best F1 measure is 37%.</p>     <p>     <em>Confidence Ratio (Relaxed)</em>. The relaxed variant of our method is less conservative. It trades off precision for higher recall. Indeed, we see that recall increases steadily with growing <em>&#x03B8;</em>, while precision decreases gently. This allows for very good trade-offs between the two, with the maximum F1 value easily surpassing 55%. It is thus our method of choice.</p>     <p>     <em>Fisher&#x0027;s Test</em>. This variation of our approach aims to make the Confidence Ratio less vulnerable to small data sizes. This is indeed what happens. However, the method errs on the side of caution: it has a very good precision (always <span class="inline-equation"><span class="tex">${\gt}90\%$</span>     </span>), but a mediocre recall. Hence, the best F1 value is quite low (12%). To increase this recall, the significance level of this test would have to be increased by a factor of several orders of magnitude, which would defy its purpose. The method should thus be seen as a stable, but inherently precision-oriented method.</p>     <p>     <em>Comparison</em>. Figure&#x00A0;<a class="fig" href="#fig3">3</a> plots precision and recall for each of the methods across the spectrum of parameter values.<a class="fn" href="#fn3" id="foot-fn3"><sup>3</sup></a> Baseline&#x00A0;3 achieves the highest recall. However, its precision never exceeds 42%, which makes the method unusable in practice. On the other side of the spectrum, Baseline&#x00A0;2 offers very good precision &#x2013; but it cannot achieve good recall. Our relaxed confidence ratio occupies a sweet spot between the two: a precision between 75% and 95%, at a recall of 45% and 10%, respectively. It thus dominates the other methods in the mid-range between good recall and good precision. <figure id="fig3">      <img src="../../../../deliveryimages.acm.org/10.1145/3190000/3186010/images/www2018-19-fig3.jpg" class="img-responsive" alt="Figure 3"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 3:</span>       <span class="figure-title">Precision and Recall on YAGO.</span>      </div>     </figure>      <strong>Completeness of the attributes.</strong> By identifying classes in which an attribute is obligatory, our method identifies the entities that should have this attribute. If we compute the proportion of these entities that actually have the attribute in the data, we get an approximation of the completeness of the data. Table&#x00A0;<a class="tbl" href="#tab1">1</a> shows the estimated completeness of the data according to different methods: the gold standard, Baseline&#x00A0;2 at different thresholds, and our method at different thresholds. We show 3 attributes that are obligatory in certain classes, and the deviation from the gold standard across all attributes. The small deviation for our method shows that we can approximate the real completeness quite well.</p>     <p>We can now also algorithmically answer the question raised in the title of this paper: No, not all people are married. Our method finds that <em>isMarriedTo</em> is an optional attribute for the class <em>Person</em>. However, marriage is obligatory for the classes <em>Spouse</em> and <em>RoyalConsort</em>.</p>     <div class="table-responsive" id="tab1">     <div class="table-caption">      <span class="table-number">Table 1:</span>      <span class="table-title">Approximation of completeness of attributes.</span>     </div>     <table class="table"> 				 <thead>       <tr>        <th style="text-align:left;"/>        <th style="text-align:center;"/>        <th colspan="2" style="text-align:center;">Baseline 2<hr/>        </th>        <th colspan="2" style="text-align:center;">CR (Relaxed)<hr/>        </th>       </tr>       <tr>        <th style="text-align:left;">Attribute</th>        <th style="text-align:center;">Gold Standard</th>        <th style="text-align:center;">0.5</th>        <th style="text-align:center;">0.9</th>        <th style="text-align:center;">1.5</th>        <th style="text-align:center;">3</th>       </tr> 				 </thead>      <tbody>       <tr>        <td style="text-align:left;">hasGender</td>        <td style="text-align:center;">0.58</td>        <td style="text-align:center;">0.51</td>        <td style="text-align:center;">0.91</td>        <td style="text-align:center;">0.79</td>        <td style="text-align:center;">0.58</td>       </tr>       <tr>        <td style="text-align:left;">wasBornIn</td>        <td style="text-align:center;">0.14</td>        <td style="text-align:center;">0.47</td>        <td style="text-align:center;">0.93</td>        <td style="text-align:center;">0.46</td>        <td style="text-align:center;">0.25</td>       </tr>       <tr>        <td style="text-align:left;">isMarriedTo</td>        <td style="text-align:center;">0.57</td>        <td style="text-align:center;">0.51</td>        <td style="text-align:center;">0.93</td>        <td style="text-align:center;">0.59</td>        <td style="text-align:center;">0.23</td>       </tr>       <tr>        <td colspan="2" style="text-align:left;">Avg-Squared error to GS (all <em>p</em>)        </td>        <td style="text-align:center;">0.21</td>        <td style="text-align:center;">0.59</td>        <td style="text-align:center;">0.17</td>        <td style="text-align:center;">0.08</td>       </tr>      </tbody>     </table>     </div>    </section>    <section id="sec-20">     <header>     <div class="title-info">      <h3>       <span class="section-number">6.5</span> Wikidata Experiment</h3>     </div>     </header>     <figure id="fig4">     <img src="../../../../deliveryimages.acm.org/10.1145/3190000/3186010/images/www2018-19-fig4.jpg" class="img-responsive" alt="Figure 4"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 4:</span>      <span class="figure-title">Stress test: Precision and Recall on Wikidata.</span>     </div>     </figure>     <p>As a stress test, we also evaluated our method on Wikidata, where less is known about our assumptions. Figure&#x00A0;<a class="fig" href="#fig4">4</a> shows our results. We first note that all methods exhibit a similar behavior to the YAGO experiment. Baseline&#x00A0;3 has high recall, low precision (<span class="inline-equation"><span class="tex">${\lt} 55\%$</span>     </span>) and remains unstable. Baseline&#x00A0;2 performs well, with a precision of 97% and a recall of 33% for threshold <em>&#x03B8;</em> = 0.7. This indicates that some of the properties in our data are already highly complete. Our method performs similarly to Baseline&#x00A0;2 in the precision range of 97%. However, in precision range of 93%, it has a higher recall than Baseline&#x00A0;2.</p>    </section>    <section id="sec-21">     <header>     <div class="title-info">      <h3>       <span class="section-number">6.6</span> Artificial Classes</h3>     </div>     </header>     <p>In the following two experiments, we investigate how our algorithm performs on artificially constructed classes. For this purpose, we constructed classes that depend on the facts in our KB. Since the facts are incomplete, these classes are incomplete, too, and Assumption&#x00A0;<a class="enc" href="#enc4">2</a> no longer holds.</p>     <p>     <em>Life Expectancy</em>. We construct artificial classes for all people born before a certain decade <em>t</em>: <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ C_t = \lbrace x | \exists y: \mathit {birthDate}(x,y) \wedge y{\lt}t\rbrace \] </span>       <br/>      </div>     </div> These classes form a taxonomy: <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ C_t \subseteq C_{t+10} \] </span>       <br/>      </div>     </div> In this way, we generated the classes <em>C<sub>t</sub>     </em> for <em>t</em> = 1700, 1710, ..., 2020 in YAGO. We can now mine obligatory attributes also on these artificial classes. In particular we mine the generalization rule <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ C_t \subseteq \mathit {deathDate}_{\mathcal {W}} \] </span>       <br/>      </div>     </div> Table&#x00A0;<a class="tbl" href="#tab2">2</a> shows the <em>t</em> for which the rule holds, according to our relaxed algorithm. We see that for a conservative <em>&#x03B8;</em> < 3 (which delivered high precision also in the previous experiments), we get again very good estimates for <em>t</em>. As <em>&#x03B8;</em> increases, our method starts to believe that all people (even younger ones) should have a death date &#x2013; as expected. This experiment shows that our approach has the potential to mine obligatory attributes even on intensionally defined classes.</p>     <div class="table-responsive" id="tab2">     <div class="table-caption">      <span class="table-number">Table 2:</span>      <span class="table-title">Life expectancy experiment.</span>     </div>     <table class="table">      <tbody>       <tr>        <td style="text-align:left;">        <em>&#x03B8;</em> up to</td>        <td style="text-align:center;">1.3</td>        <td style="text-align:center;">2.5</td>        <td style="text-align:center;">5.0</td>        <td style="text-align:center;">9.5</td>        <td style="text-align:center;">10</td>        <td style="text-align:center;">20</td>        <td style="text-align:center;">30</td>       </tr>       <tr>        <td style="text-align:left;">        <em>t</em> mined</td>        <td style="text-align:center;">1920</td>        <td style="text-align:center;">1930</td>        <td style="text-align:center;">1940</td>        <td style="text-align:center;">1950</td>        <td style="text-align:center;">1960</td>        <td style="text-align:center;">1970</td>        <td style="text-align:center;">1980</td>       </tr>      </tbody>     </table>     </div>     <p>     <em>Cardinality experiment</em>. To illustrate the effect of more fine-grained classes on our algorithm, we constructed for every attribute <em>p</em> and every number <em>n</em> the classes <em>p</em>     <sub>      <em>n</em> +</sub> as the set of entities having more than <em>n</em> objects for attribute <em>p</em>: <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ p_{n+} = \lbrace x | \exists _{{\gt}n} y: p(x,y) \rbrace \] </span>       <br/>      </div>     </div> These classes form a taxonomy, with <em>p</em>     <sub>(<em>n</em> + 1) +</sub>&#x2286;<em>p</em>     <sub>      <em>n</em> +</sub>. We added these classes to YAGO and we ran our algorithm with a small modification: for an attribute <em>p</em>, we never considered any class <em>p</em>     <sub>      <em>n</em> +</sub> for the intersections. This is to exclude trivial rules of the form <em>p</em>     <sub>      <em>n</em> +</sub>&#x2286;<em>p</em>. In the end, our algorithm with threshold <em>&#x03B8;</em> = log&#x2009;(3) outputs 248 rules with cardinality classes. The new classes produce two effects (exemplified in Table&#x00A0;<a class="tbl" href="#tab3">3</a>): First, the algorithm now overfits and deduces that a birth date would be obligatory (only) for certain subclasses of people. Second, the algorithm can now make very fine grained predictions about the real world. Thus, it predicts that anyone who has more than 8 children in the KB is most likely married in the real world. We see this as an encouragement to investigate the potential of artificially constructed classes for future work.</p>     <div class="table-responsive" id="tab3">     <div class="table-caption">      <span class="table-number">Table 3:</span>      <span class="table-title">Cardinality experiment.</span>     </div>     <table class="table">      <tbody>       <tr>        <td colspan="2" style="text-align:center;">        <strong>Overfitting rules</strong>        <hr/>        </td>       </tr>       <tr>        <td style="text-align:left;">        <em>created</em>        <sub>80 +</sub>        </td>        <td style="text-align:left;">&#x21D2;<em>wasBornIn</em>        </td>       </tr>       <tr>        <td style="text-align:left;">        <em>playsFor</em>        <sub>14 +</sub>        </td>        <td style="text-align:left;">&#x21D2;<em>wasBornIn</em>        </td>       </tr>       <tr>        <td style="text-align:left;">        <em>edited</em>        <sub>6 +</sub>        </td>        <td style="text-align:left;">&#x21D2;<em>wasBornIn</em>        </td>       </tr>       <tr>        <td colspan="2" style="text-align:center;">        <strong>Fine-grained Predictions</strong>        <hr/>        </td>       </tr>       <tr>        <td style="text-align:left;">        <em>hasChild</em>        <sub>8 +</sub>        </td>        <td style="text-align:left;">&#x21D2;<em>isMarriedTo</em>        </td>       </tr>       <tr>        <td style="text-align:left;">        <em>actedIn</em>        <sub>49 +</sub>        </td>        <td style="text-align:left;">&#x21D2;<em>isMarriedTo</em>        </td>       </tr>       <tr>        <td style="text-align:left;">        <em>isMarriedTo</em>        <sub>3 +</sub>        </td>        <td style="text-align:left;">&#x21D2;<em>hasChild</em>        </td>       </tr>       <tr>        <td style="text-align:left;">        <em>actedIn</em>        <sub>24 +</sub>        </td>        <td style="text-align:left;">&#x21D2;<em>hasChild</em>        </td>       </tr>      </tbody>     </table>     </div>    </section>   </section>   <section id="sec-22">    <header>     <div class="title-info">     <h2>      <span class="section-number">7</span> Conclusion</h2>     </div>    </header>    <p>In this paper, we have introduced the novel problem of mining obligatory attributes from knowledge bases. This is the problem of determining whether all instances of a given class have a given attribute in the real world &#x2013; while all we have at our disposal is an incomplete KB. We have developed a new way to model the incompleteness of a KB statistically. From this model, we were able to derive the necessary conditions for obligatory attributes. Based on this, we have proposed an algorithm that can mine such attributes with a precision of up to 92%.</p>    <p>For future work, we plan to study generalizations of our approach to artificially constructed classes, to rules with negation, or to rules with more complex general statements. We see this line of work as a first step towards deriving statistical confidence about real-world rules from an incomplete knowledge base. We hope that this research can deliver insights about the completeness of existing KBs, and that it can help making KBs ever more complete in the future.</p>    <p>     <strong>Acknowledgments.</strong> This research was partially supported by the grant ANR-16-CE23-0007-01 (&#x201C;DICOS&#x201D;). We would also like to thank the four anonymous reviewers for their helpful insights and comments.</p>   </section>  </section>  <section class="back-matter">   <Appendix>    <section id="sec-23">     <header>     <div class="title-info">      <h2>       <span class="section-number">A</span> Proofs of the theoretical results</h2>     </div>     </header>     <p>    <div class="assumption" id="enc7b">     <Label>Theorem 1. (Random sampling under PCA)</Label>     <p>Under Assumptions&#x00A0;<a class="enc" href="#enc6">3</a> and&#x00A0;<a class="enc" href="#enc7">4</a>, for each property <em>p</em> with probability <em>l<sub>p</sub>     </em> (as given by Assumption&#x00A0;<a class="enc" href="#enc6">3</a>), <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ \forall x: \mathbb{P}(\exists y: p(x,y)) = \left\lbrace \begin{array}{@{}l@{\quad }l@{}}l_p, &#x0026; \text{if } x \in p_\mathcal {W} \\ 0, &#x0026; \text{otherwise} \end{array}\right. \] </span>       <br/>      </div>     </div></div></p>     <div class="proof" id="proof1">     <Label>Proof.</Label>     <p> Let us assume that <span class="inline-equation"><span class="tex">$\not\exists y: p(x,y) \in \mathcal {W}$</span>      </span>. Then Assumption&#x00A0;<a class="enc" href="#enc6">3</a> tells us that &#x2200;<em>y</em>: <em>P</em>(<em>p</em>(<em>x</em>, <em>y</em>)) = 0, and thus the second case of our theorem holds. Now let us consider the case where there exists <em>z</em> with <span class="inline-equation"><span class="tex">$p(x,z) \in \mathcal {W}$</span>      </span>. For any KB <em>K</em>, if <em>K</em> contains <em>p</em>(<em>x</em>, <em>z</em>), then &#x2203;<em>y</em>: <em>p</em>(<em>x</em>, <em>y</em>) in <em>K</em>. If &#x2203;<em>y</em>: <em>p</em>(<em>x</em>, <em>y</em>) in <em>K</em>, then Assumption&#x00A0;<a class="enc" href="#enc7">4</a> tells us that <em>K</em> either contains <em>p</em>(<em>x</em>, <em>z</em>), or else <em>P</em>(<em>K</em>) = 0. As <em>p</em>(<em>x</em>, <em>z</em>) and &#x2203;<em>y</em>: <em>p</em>(<em>x</em>, <em>y</em>) coincide on any KB <em>K</em> such that <em>P</em>(<em>K</em>) > 0, <em>P</em>(&#x2203;<em>y</em>: <em>p</em>(<em>x</em>, <em>y</em>)) = <em>P</em>(<em>p</em>(<em>x</em>, <em>z</em>)). Assumption&#x00A0;<a class="enc" href="#enc6">3</a> tells us that <em>P</em>(<em>p</em>(<em>x</em>, <em>z</em>)) = <em>l<sub>p</sub>      </em>, which proves the first case of our theorem.&#x00A0;&#x00A0;&#x00A0;&#x00A0; &#x25A1;</p>     </div>     <p>    <div class="proposition" id="enc1">     <Label>Proposition 5 (Unbiased estimator).</Label> Given two classes <em>c</em>, <em>c</em>&#x2032; and a property <em>p</em>, the expected confidence of <em>c</em>&#x2229;<em>p</em>&#x2286;<em>c</em>&#x2032; in <em>&#x03A9;</em> is an unbiased estimator for the confidence in <span class="inline-equation"><span class="tex">$\mathcal {W}$</span>     </span>: <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ \mathbb{E}[conf(c \cap p \subseteq c^{\prime })] = conf(c \cap p_\mathcal {W} \subseteq c^{\prime }) \] </span>       <br/>      </div>     </div></div></p>     <div class="proof" id="proof2">     <Label>Proof.</Label>     <p> Consider the following two random variables: <div class="table-responsive">       <div class="display-equation">        <span class="tex mytex">\[ X = |p \cap c \cap c^{\prime }| \sim \text{B}{\rm\small INOM}(|p_\mathcal {W} \cap c \cap c^{\prime }|, l_p) \] </span>        <br/>       </div>      </div>      <div class="table-responsive">       <div class="display-equation">        <span class="tex mytex">\[ Y = |p \cap c \setminus c^{\prime }| \sim \text{B}{\rm\small INOM}(|p_\mathcal {W} \cap c \setminus c^{\prime }|, l_p) \] </span>        <br/>       </div>      </div> Let <em>n</em> be a natural number. <em>X</em> given <em>X</em> + <em>Y</em> = <em>n</em> follows a hypergeometric distribution with parameters <span class="inline-equation"><span class="tex">$(|p_\mathcal {W} \cap c|, n, conf(c \cap p_\mathcal {W} \subseteq c^{\prime }))$</span>      </span>. Then, <span class="inline-equation"><span class="tex">${E}[X \:\vert \:X + Y = n] = n \times conf(c \cap p_\mathcal {W} \subseteq c^{\prime })$</span>      </span>. This implies <div class="table-responsive">       <div class="display-equation">        <span class="tex mytex">\[ {E}[conf(c \cap p \subseteq c^{\prime }) \:\vert \:X + Y = n] = conf(c \cap p_\mathcal {W} \subseteq c^{\prime }) \] </span>        <br/>       </div>      </div> This is true for all estimates <em>n</em>.&#x00A0;&#x00A0;&#x00A0;&#x00A0; &#x25A1;</p>     </div>     <p><div class="proposition" id="enc1a">     <Label>Proposition 6 (Main observation).</Label> If <em>p</em> is an obligatory attribute for some class <em>c</em>, then for every class <em>c</em>&#x2032; with |<em>c</em>&#x2229;<em>c</em>&#x2032;| &#x2260; 0 and |<em>c</em>&#x2216;<em>c</em>&#x2032;| &#x2260; 0, <div class="table-responsive">      <div class="display-equation">       <span class="tex mytex">\[ \mathbb{E}[s_p(c, c^{\prime })]=1 \] </span>       <br/>      </div>     </div></div></p>     <div class="proof" id="proof3">     <Label>Proof.</Label>     <p>We first show that <div class="table-responsive">       <div class="display-equation">        <span class="tex mytex">\[ s^K_p(c, c^{\prime }) = \frac{| c \cap c^{\prime }|}{|c \setminus c^{\prime }|}\times \frac{ 1 - conf(c \cap p_K \subseteq c^{\prime }) }{conf(c \cap p_K \subseteq c^{\prime })} \] </span>        <br/>       </div>      </div> Proposition&#x00A0;<a class="sec" href="#sec-10">5</a> then tells us that <div class="table-responsive">       <div class="display-equation">        <span class="tex mytex">\[ {E}[s_p(c, c^{\prime })]= \frac{| c \cap c^{\prime }|}{|c \setminus c^{\prime }|}\times \frac{ 1 - conf(c \cap p_\mathcal {W} \subseteq c^{\prime }) }{conf(c \cap p_\mathcal {W} \subseteq c^{\prime })} \] </span>        <br/>       </div>      </div> Proposition&#x00A0;<a class="enc" href="#enc2">2</a> then implies <div class="table-responsive">       <div class="display-equation">        <span class="tex mytex">\[ {E}[s_p(c, c^{\prime })]=\frac{| c \cap c^{\prime }|}{|c \setminus c^{\prime }|}\times \frac{ 1 - conf(c \subseteq c^{\prime }) }{conf(c \subseteq c^{\prime })}=1 \ \ \ \ \ &#x25A1; \] </span>        <br/>       </div>      </div>     </p>     </div>    </section>   </Appendix>   <section id="ref-001">    <header>     <div class="title-info">     <h2 class="page-brake-head">REFERENCES</h2>     </div>    </header>    <ul class="bibUl">     <li id="BibPLXBIB0001" label="[1]">Mehwish Alam, Aleksey Buzmakov, Victor Codocedo, and Amedeo Napoli. Mining Definitions from RDF Annotations Using Formal Concept Analysis. In <em>IJCAI</em>, 2015.</li>     <li id="BibPLXBIB0002" label="[2]">F.&#x00A0;Darari, S.&#x00A0;Razniewski, R.&#x00A0;Prasojo, and W.&#x00A0;Nutt. Enabling fine-grained RDF data completeness assessment. In <em>ICWE</em>, 2016.</li>     <li id="BibPLXBIB0003" label="[3]">X.&#x00A0;Dong, E.&#x00A0;Gabrilovich, G.&#x00A0;Heitz, W.&#x00A0;Horn, N.&#x00A0;Lao, K.&#x00A0;Murphy, T.&#x00A0;Strohmann, S.&#x00A0;Sun, and W.&#x00A0;Zhang. Knowledge vault: a web-scale approach to probabilistic knowledge fusion. In <em>SIGKDD</em>, 2014.</li>     <li id="BibPLXBIB0004" label="[4]">F.&#x00A0;Erxleben, M.&#x00A0;G&#x00FC;nther, M.&#x00A0;Kr&#x00F6;tzsch, J.&#x00A0;Mendez, and D.&#x00A0;Vrandecic. Introducing Wikidata to the linked data web. In <em>ISWC</em>, 2014.</li>     <li id="BibPLXBIB0005" label="[5]">Michael F&#x00E4;rber, Frederic Bartscherer, Carsten Menne, and Achim Rettinger. Linked data quality of DBpedia, Freebase, Opencyc, Wikidata, and Yago. <em>Semantic Web</em>, 2016.</li>     <li id="BibPLXBIB0006" label="[6]">R.&#x00A0;A. Fisher. On the interpretation of chi square from contingency tables, and the calculation of p. <em>Journal of the Royal Statistical Society</em>, 85(1), Jan 1922.</li>     <li id="BibPLXBIB0007" label="[7]">Luis Gal&#x00E1;rraga, Simon Razniewski, Antoine Amarilli, and Fabian&#x00A0;M. Suchanek. Predicting Completeness in Knowledge Bases. In <em>WSDM</em>, 2017.</li>     <li id="BibPLXBIB0008" label="[8]">Luis Gal&#x00E1;rraga, Christina Teflioudi, Katja Hose, and Fabian&#x00A0;M. Suchanek. AMIE: association rule mining under incomplete evidence in ontological knowledge bases. In <em>WWW</em>, 2013.</li>     <li id="BibPLXBIB0009" label="[9]">Luis Gal&#x00E1;rraga, Christina Teflioudi, Katja Hose, and Fabian&#x00A0;M. Suchanek. Fast Rule Mining in Ontological Knowledge Bases with AMIE+ . In <em>VLDBJ</em>, 2015.</li>     <li id="BibPLXBIB0010" label="[10]">Sebastian Hellmann, Jens Lehmann, and Soeren Auer. Learning of OWL class descriptions on very large knowledge bases. <em>Int. J. Semantic Web Inf. Syst.</em>, 5, 04 2009.</li>     <li id="BibPLXBIB0011" label="[11]">Holger Knublauch and Dimitris Kontokostas. Shapes constraint language (SHACL). W3C recommendation, W3C, July 2017. <a class="link-inline force-break"      href="https://www.w3.org/TR/2017/REC-shacl-20170720/">https://www.w3.org/TR/2017/REC-shacl-20170720/</a>.</li>     <li id="BibPLXBIB0012" label="[12]">Ni&#x00A0;Lao, Tom&#x00A0;M. Mitchell, and William&#x00A0;W. Cohen. Random walk inference and learning in a large scale knowledge base. In <em>EMNLP</em>, 2011.</li>     <li id="BibPLXBIB0013" label="[13]">A.&#x00A0;Y. Levy. Obtaining complete answers from incomplete databases. In <em>VLDB</em>, 1996.</li>     <li id="BibPLXBIB0014" label="[14]">Farzaneh Mahdisoltani, Joanna&#x00A0;Asia Biega, and Fabian&#x00A0;M. Suchanek. YAGO3: A Knowledge Base from Multilingual Wikipedias. In <em>CIDR</em>, 2015.</li>     <li id="BibPLXBIB0015" label="[15]">A.&#x00A0;Motro. Integrity = Validity + Completeness. <em>TODS</em>, 1989.</li>     <li id="BibPLXBIB0016" label="[16]">Ndapandula Nakashole, Gerhard Weikum, and Fabian&#x00A0;M. Suchanek. PATTY: A Taxonomy of Relational Patterns with Semantic Types . In <em>EMNLP</em>, 2012.</li>     <li id="BibPLXBIB0017" label="[17]">Heiko Paulheim and Christian Bizer. Type inference on noisy RDF data. In <em>ISWC</em>, 2013.</li>     <li id="BibPLXBIB0018" label="[18]">S.&#x00A0;Razniewski, F.&#x00A0;Korn, W.&#x00A0;Nutt, and D.&#x00A0;Srivastava. Identifying the extent of completeness of query answers over partially complete databases. In <em>SIGMOD</em>, 2015.</li>     <li id="BibPLXBIB0019" label="[19]">S.&#x00A0;Razniewski, F.&#x00A0;M. Suchanek, and W.&#x00A0;Nutt. But what do we actually know? In <em>AKBC workshop</em>, 2016.</li>     <li id="BibPLXBIB0020" label="[20]">F.&#x00A0;M. Suchanek, D.&#x00A0;Gross-Amblard, and S.&#x00A0;Abiteboul. Watermarking for Ontologies. In <em>ISWC</em>, 2011.</li>     <li id="BibPLXBIB0021" label="[21]">F.&#x00A0;M. Suchanek, G.&#x00A0;Kasneci, and G.&#x00A0;Weikum. Yago: a core of semantic knowledge. In <em>WWW</em>, 2007.</li>     <li id="BibPLXBIB0022" label="[22]">Johanna V&#x00F6;lker and Mathias Niepert. Statistical schema induction. In <em>ESWC</em>, 2011.</li>    </ul>   </section>  </section>  <section id="foot-001" class="footnote">   <header>    <div class="title-info">     <h2>FOOTNOTE</h2>    </div>   </header>   <p id="fn1"><a href="#foot-fn1"><sup>1</sup></a>For our work, we do not distinguish literals and instances.</p>   <p id="fn2"><a href="#foot-fn2"><sup>2</sup></a>We are talking about a property of our data, not about genders in the real world.</p>   <p id="fn3"><a href="#foot-fn3"><sup>3</sup></a>Different values for <em>&#x03B8;</em> can give the same combination of precision and recall, whence the &#x201C;loop&#x201D; of Baseline&#x00A0;3.</p>   <div class="bibStrip">    <p>This paper is published under the Creative Commons Attribution 4.0 International (CC-BY&#x00A0;4.0) license. Authors reserve their rights to disseminate the work on their personal and corporate Web sites with the appropriate attribution.</p>    <p>     <em>WWW '18, April 23-27, 2018, Lyon, France</em>    </p>    <p>&#x00A9; 2018; IW3C2 (International World Wide Web Conference Committee), published under Creative Commons CC-BY&#x00A0;4.0 License. ACM ISBN 978-1-4503-5639-8/18/04.<br/>DOI: <a class="link-inline force-break" target="_blank"     href="https://doi.org/10.1145/3178876.3186010">https://doi.org/10.1145/3178876.3186010</a>    </p>   </div>  </section>  <div class="pubHistory">   <p/>  </div>  </body> </html> 
