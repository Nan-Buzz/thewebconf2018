<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> <head>  <title>FAUST Domain Specific Audio DSP Language Compiled to WebAssembly</title>  <!-- Copyright (c) 2010-2015 The MathJax Consortium --><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>  <meta name="viewport" content="width=device-width; initial-scale=1.0;"></meta>  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>  <link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/bootstrap.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/bootstrap-theme.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/main.css"/><script src="../../../data/dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script>  <script type="text/javascript"    src="../../../data/dl.acm.org/pubs/lib/js/MathJax.js?config=TeX-AMS_CHTML"></script>  <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script> </head> <body id="main">  <section class="front-matter">   <section>    <header class="title-info">    <div class="journal-title">     <h1>      <span class="title">FAUST Domain Specific Audio DSP Language Compiled to WebAssembly</span>      <br/>      <span class="subTitle"/>     </h1>    </div>    </header>    <div class="authorGroup">    <div class="author">     <span class="givenName">St&#x00E9;phane</span>     <span class="surName">Letz</span>,     GRAME, France, <a href="mailto:letz@grame.fr">letz@grame.fr</a>    </div>    <div class="author">     <span class="givenName">Yann</span>     <span class="surName">Orlarey</span>,     GRAME, France, <a href="mailto:orlarey@grame.fr">orlarey@grame.fr</a>    </div>    <div class="author">     <span class="givenName">Dominique</span>     <span class="surName">Fober</span>,     GRAME, France, <a href="mailto:fober@grame.fr">fober@grame.fr</a>    </div>                </div>    <br/>    <div class="pubInfo">    <p>DOI: <a href="https://doi.org/10.1145/3184558.3185970" target="_blank">https://doi.org/10.1145/3184558.3185970</a>     <br/>WWW '18: <a href="https://doi.org/10.1145/3184558" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p>    </div>    <div class="abstract">    <p>     <small>This paper demonstrates how FAUST, a functional programming language for sound synthesis and audio processing, can be used to develop efficient audio code for the Web. After a brief overview of the language, its compiler and the architecture system allowing to deploy the same program as a variety of targets, the generation of WebAssembly code and the deployment of specialized WebAudio nodes will be explained. Several use cases will be presented. Extensive benchmarks to compare the performance of native and WebAssembly versions of the same set of DSP have be done and will be commented.</small>    </p>    </div>    <div class="CCSconcepts">    <p> <small> <span style="font-weight:bold;">CCS Concepts:</span> &#x2022;<strong> Applied computing </strong>&#x2192; <strong>Sound and music computing;</strong> &#x2022;<strong> Software and its engineering </strong>&#x2192; <strong>Functional languages;</strong> <strong>Data flow languages;</strong> <strong>Compilers;</strong> <strong>Domain specific languages;</strong></small> </p>    </div>    <div class="classifications">    <div class="author">     <span style="font-weight:bold;">      <small>Keywords:</small>     </span>     <span class="keyword">      <small>Signal processing; Domain Specific Language; audio; Faust; DSP; compilation; WebAssembly; WebAudio</small>     </span>    </div>    <br/>    <div class="AcmReferenceFormat">     <p>      <small>       <span style="font-weight:bold;">ACM Reference Format:</span>       <br/>       St&#x00E9;phane Letz, Yann Orlarey, and Dominique Fober. 2018. FAUST Domain Specific Audio DSP Language Compiled to WebAssembly. In <em>WWW '18 Companion: The 2018 Web Conference Companion,</em>       <em>April 23&#x2013;27, 2018,</em>       <em> Lyon, France. ACM</em>, New York, NY, USA, 9 Pages. <a href="https://doi.org/10.1145/3184558.3185970" class="link-inline force-break"       target="_blank">https://doi.org/10.1145/3184558.3185970</a></small>     </p>    </div>    </div>   </section>  </section>  <section class="body">   <section id="sec-4">    <header>    <div class="title-info">     <h2>      <span class="section-number">1</span> Introduction</h2>    </div>    </header>    <p>FAUST [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0007">7</a>], [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0008">8</a>], [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0009">9</a>], is a Domain Specific Language for sound synthesis and audio processing. It is used by audio DSP developers as an alternative to C/C++ to design and implement efficient DSP code as native applications or plugins. Built as a multi-languages code generator, the FAUST compiler can be easily extended to target new audio platforms (section 2 and 3).</p>    <p>With the advent of both HTML5 and the Web Audio API (a high-level JavaScript API for audio processing and synthesis), complex audio applications can now be developed for the Web. The Web Audio API even offers developers the possibility to add specialized and efficient audio nodes, to be used with the Web Audio API natively defined ones (sections 4.1 to 4.3).</p>    <section id="sec-5">    <header>     <div class="title-info">      <h3>       <span class="section-number">1.1</span> Extending the Web Audio API</h3>     </div>    </header>    <p>Various JavaScript DSP libraries or musical languages have been developed over the years [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0002">2</a>], [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0010">10</a>], to extend, abstract and empower the capabilities of the official API. They offer users a richer set of audio DSP algorithms and sound models to be directly used in JavaScript code. In this case, developments have to be restarted from scratch, or by adapting already written code (often in more real-time friendly languages like C/C++) into JavaScript.</p>    <p>An interesting alternative has been developed by the Csound team [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0005">5</a>]. Using the C/C++ to JavaScript Emscripten compiler, the complete C written Csound runtime and DSP language is now available in the context of the Web Audio API.</p>    </section>    <section id="sec-6">    <header>     <div class="title-info">      <h3>       <span class="section-number">1.2</span> Extending the Web Audio API with FAUST</h3>     </div>    </header>    <p>The paper shows how the FAUST compilation chain has been moved to the Web. After a general introduction of the language and its compiler organization, developments done to target the WebAudio API and the recently defined WebAssembly low-level format will be detailed (section 4.3 to 4.5). As a Domain Specific Language targeting highly demanding mathematical code, generating WebAssembly code from the FAUST language shows specific code generation issues that compiler writers in related domains could be interested in.</p>    <p>Two main applications will be exposed: creating ready to use Web Audio nodes and HTML pages using the FAUST compiler in an <em>offline</em> manner, or even more interesting and flexible, <em>embedding</em> and <em>using</em> the compiler itself in Web pages (section 5).</p>    <p>Several benchmarks to compare the performances of native and WebAssembly versions of the same set of DSP, and the performance of the different WebAssembly aware browsers will be presented (section 6).</p>    </section>   </section>   <section id="sec-7">    <header>    <div class="title-info">     <h2>      <span class="section-number">2</span> FAUST language overview</h2>    </div>    </header>    <p>FAUST is a functional programming language for sound synthesis and audio processing with a strong focus on the design of synthesizers, musical instruments, audio effects, etc. Its main sources of inspiration are <em>lambda-calculus</em>, <em>combinatory logic</em>, John Backus&#x2019; <em>FP</em> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>], and Stefanescu&#x0027;s <em>Algebra of Flownomials</em> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0011">11</a>].</p>    <section id="sec-8">    <header>     <div class="title-info">      <h3>       <span class="section-number">2.1</span> Introduction</h3>     </div>    </header>    <p>FAUST is used on stage for concerts and artistic productions, in education and research, in open-source projects as well as in commercial applications. Typical users are musicians, sound engineers, researchers, musical assistants, etc. They often have a background in signal processing or at least a clear idea of how audio effects and sound synthesis systems should work or sound. But users are not necessarily computer scientists or professional developers. The development of real-time audio software in C is usually out of reach for most of them. The ambition of FAUST is to offer them a viable and efficient high-level alternative. The FAUST compiler can generate optimized code for a variety of languages: C++, C, Java, JavaScript, asm.js, LLVM, and WebAssembly.</p>    </section>    <section id="sec-9">    <header>     <div class="title-info">      <h3>       <span class="section-number">2.2</span> Syntax and semantic</h3>     </div>    </header>    <p>As we will see through various examples, programming in FAUST is essentially combining <em>signal processors</em> using a set of binary operations that form the Block-Diagram Algebra. The functional programming approach is particularly suited for this purpose. <em>Signals</em> are discrete-time functions. <em>Signal processors</em> are second-order functions operating on <em>signals</em>. The <em>block-diagram algebra</em> used to combine signal processors together is a set of third-order composition operations on <em>signal processors</em>. Finally, user-defined functions are higher-order functions on block-diagram expressions. Powerful means, like pattern matching, are available to algorithmically generate complex audio circuits. <figure id="fig1">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-fig1.jpg" class="img-responsive" alt="Figure 1"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 1:</span>       <span class="figure-title">FAUST programs have a straightforward visual representation as block-diagrams, as well as a simple and well defined formal semantics. The block-diagram is a useful intermediate step to compute the semantics of a program.</span>      </div>     </figure>    </p>    <p>FAUST is a textual language, but programs have straightforward translations into visual block-diagrams as well as mathematical descriptions. The relation between the FAUST code, and its translations is represented (Figure <a class="fig" href="#fig1">1</a>). The FAUST compiler is able to automatically produce these diagrams and the mathematical semantics of a program. This feature is used in particular for preservation purposes, an important concern for music pieces relying on real time programs. But these features are also very useful when learning FAUST to better understand the meaning of expressions and programs.</p>    </section>    <section id="sec-10">    <header>     <div class="title-info">      <h3>       <span class="section-number">2.3</span> DSP source code example</h3>     </div>    </header>    <p>Here is a simple organ instrument coded in FAUST (Figure <a class="fig" href="#fig2">2</a>). An oscillator signal is first defined using a <em>phasor</em> periodic signal connected to the <em>sin</em> function. The organ timbre is defined as the summation of three oscillator signals at different frequencies and volumes. An <em>envelop</em> is then defined to be applied on the continuous timbre to build a <em>voice</em>. An finally control items to be displayed as buttons or sliders to start the note, change its frequency and volume are defined. <figure id="fig2">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-fig2.jpg" class="img-responsive" alt="Figure 2"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 2:</span>       <span class="figure-title">Example of a simple organ instrument coded in FAUST.</span>      </div>     </figure>    </p>    </section>   </section>   <section id="sec-11">    <header>    <div class="title-info">     <h2>      <span class="section-number">3</span> Compiler internals</h2>    </div>    </header>    <p>The FAUST compiler is organized in successive stages, from the DSP block diagram to signals, and finally to the FIR (FAUST Imperative Representation) which is then translated in several target languages. The FIR language describes the computation performed on the samples in a generic manner. It contains primitives to read and write variables and arrays, do arithmetic operations, and defines the necessary control structures (<em>for</em> and <em>while</em> loops, <em>if</em> structure etc.).</p>    <p>Furthermore, the FAUST compiler itself has been packaged as an embeddable library called <em>libfaust</em>, published with an associated API [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0006">6</a>] based on a factory/instance model. This model allows to develop standalone IDE like the FaustLive [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0003">3</a>] application for instance.</p>    <section id="sec-12">    <header>     <div class="title-info">      <h3>       <span class="section-number">3.1</span> FIR backends</h3>     </div>    </header>    <p>Several backends have been developed (Figure <a class="fig" href="#fig3">3</a>) to translate the FIR in C, C++, Java, asm.js, WebAssembly and LLVM IR<a class="fn" href="#fn1" id="foot-fn1"><sup>1</sup></a>. <figure id="fig3">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-fig3.jpg" class="img-responsive" alt="Figure 3"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 3:</span>       <span class="figure-title">Compilation chain: from DSP source code to output language.</span>      </div>     </figure>    </p>    <p>A generated DSP object has a compiled time known memory footprint and a bounded CPU usage. Its memory is statically allocated by the architecture at initialization time. Memory zones <a class="fn" href="#fn2" id="foot-fn2"><sup>2</sup></a> corresponding to the controller value (sliders, buttons, bargraph...) are shared between the external control code and the DSP itself.</p>    <p>Depending of the target language, each backend has to adapt its code generation strategy so that the resulting code can be deployed and run in an execution context. For instance memory can be accessed using variable names or just indexes. Some needed mathematical functions will be available in the target langage, other will have to be externally found and <em>linked</em> with the generated code. Their prototype may have to be generated in a so called <em>import section</em>. Some primitives (like <em>min/max</em>) functions are possibly available in the execution context, or will have to be explicitly generated.</p>    <p>The C++ backend will typically generate a class, with named fields (as integer or float scalar or arrays) to describe the DSP object internal state (made up from delay lines and controller values), as well as a set of methods to get/set the DSP state, initialize it, and process samples at each cycle.</p>    <p>An extract of the C++ class generated from the previously described organ instrument shows the <em>compute</em> method (Figure <a class="fig" href="#fig4">4</a>), which will be called with input/output audio buffers at each cycle to produce samples. <figure id="fig4">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-fig4.jpg" class="img-responsive" alt="Figure 4"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 4:</span>       <span class="figure-title">The C++ compute function compiled from the organ instrument.</span>      </div>     </figure>    </p>    </section>    <section id="sec-13">    <header>     <div class="title-info">      <h3>       <span class="section-number">3.2</span> Deploying the code</h3>     </div>    </header>    <p>The generated code is then combined with an <em>architecture file</em> describing how to relate the audio computation with the external world.</p>    <p>Native audio drivers are developed as subclasses of a base audio class, controllers as subclasses of a base UI class. Typical Graphical User Interface architectures are based on well established frameworks like QT or JUCE, and allow to display a ready to use window with sliders, text zones and buttons. Audio and UI parts are finally combined with the actual DSP computation to produce the final audio application or plugin (Figure <a class="fig" href="#fig5">5</a>). <figure id="fig5">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-fig5.jpg" class="img-responsive" alt="Figure 5"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 5:</span>       <span class="figure-title">DSP code is generated by the compiler, audio and UI codes are added from the generic architecture files.</span>      </div>     </figure>    </p>    <p>Thanks to this approach, the exact same source code can be used to generate native applications and plugins for more than 20 different targets, from VST and Unity plugins to Android applications, from embedded systems to Web Audio applications.</p>    </section>   </section>   <section id="sec-14">    <header>    <div class="title-info">     <h2>      <span class="section-number">4</span> Web Audio API</h2>    </div>    </header>    <p>The Web Audio API specification describes a high-level JavaScript API for processing and synthesizing audio in Web applications. The design model is based on an audio graph, where a set of AudioNode objects are created and connected together to describe the desired audio computation.</p>    <p>The actual processing is usually executed in the underlying implementation (typically optimized Assembly/C++ code), and direct JavaScript processing and synthesis is also supported using the <em>ScriptProcessorNode</em> interface, in a non-real-time rendering context, thus possibly causing annoying audio glitches.</p>    <p>The AudioWorklet specification<a class="fn" href="#fn3" id="foot-fn3"><sup>3</sup></a> aims at improving the situation, having the audio graph definition done in the main thread, but rendering it (including user-defined nodes coded in pure JavaScript or WebAssembly) in a separated real-time thread. This new specification can now be tested in Chrome Canary development version.</p>    <section id="sec-15">    <header>     <div class="title-info">      <h3>       <span class="section-number">4.1</span> From asm.js to WebAssembly</h3>     </div>    </header>    <p>Mozilla developers have started in 2011 the Emscripten compiler project [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0012">12</a>], based on LLVM technology. From C/C++ sources, it allows to generate a statically compilable and garbage-collection free typed subset of JavaScript named <em>asm.js</em>. This approach has been successful, demonstrating that near native code performance could be achieved on the Web.</p>    <p>Starting from this asm.js experience, core developers of the PNaCL<a class="fn" href="#fn4" id="foot-fn4"><sup>4</sup></a> and asm.js projects have designed WebAssembly<a class="fn" href="#fn5" id="foot-fn5"><sup>5</sup></a>, a new efficient low-level programming language for in-browser client-side scripting. As a portable stack machine model, it aims to be faster than JavaScript to parse and execute.</p>    <p>WebAssembly initial goal is to support compilation from C/C++ using specialized compilers like Emscripten, or as a compilation target for other high level or Domain Specific Languages. The minimum viable product (MVP) specification has been finalized early 2017, with a binary format, as well as a textual format that looks like traditional assembly languages.</p>    <p>WebAssembly is now officially supported in all major browsers. Porting well established C/C++ codebase with Emscripten <a class="fn" href="#fn6" id="foot-fn6"><sup>6</sup></a>, like the Csound <a class="fn" href="#fn7" id="foot-fn7"><sup>7</sup></a> framework as an example, or using DSL languages like FAUST, will then naturally benefit from improved and more stable performances.</p>    </section>    <section id="sec-16">    <header>     <div class="title-info">      <h3>       <span class="section-number">4.2</span> Compiling to WebAssembly</h3>     </div>    </header>    <p>The WebAssembly specification precisely defines the semantic of the language as well as the module format. With the previous experience of the asm.js format, the designers decided to create a binary encoding with a dense representation of module information, that enables small files, fast decoding, and reduced memory usage, aimed to be <em>streamed and decoded on the fly</em>.</p>    <p>Thus the binary format requires the module to be structured so that relevant information is always available while decoding the file. For developers, the textual format is simpler to deal with, can be read, understood, and possibly manually written, while working on the tools.</p>    <p>Two new <em>wast</em> and <em>wasm</em> FAUST backends have been developed to generate these formats. The <em>wast</em> one has been done first and generates the textual human-readable code, easier to test and debug. The <em>wasm</em> one generates the binary format to be directly loaded and executed in browsers or wasm aware standalone runtimes. The equivalent of the C++ class (generated by the C++ backend), is generated using the WebAssembly module model.</p>    <section id="sec-17">     <p><em>4.2.1 Module definition.</em> A module is a distributable, loadable, and executable unit of code in WebAssembly, instantiated at runtime with a set of imported values (like JavaScript functions or memory segments) to produce instances. The two WebAssembly backends must translate the intermediate FIR code to comply to the required module format.</p>     <p>Some WebAssembly focused projects like Binaryen <a class="fn" href="#fn8" id="foot-fn8"><sup>8</sup></a> define and implement their own abstract syntax tree model, and a client API to build, manipulate it, and save if as textual or binary formats. To avoid having to work on a new memory structure, and adding an external library dependency to the FAUST compiler, it was chosen not to use them, and directly work on the FIR format.</p>    </section>    <section id="sec-18">     <p><em>4.2.2 Memory management.</em> Modules work on <em>linear memory</em> blocks, contiguous, byte-addressable range of memory spanning from offset 0 and extending up to a varying memory size. Memory segments are either defined internally in the module, or imported from the JavaScript context. Since the DSP memory size is known at compile time, it is easy to define the proper memory layout to represent the DSP state.</p>     <p>The memory block of the generated DSP contains the main DSP object, <em>inlined</em> sub-objects <a class="fn" href="#fn9" id="foot-fn9"><sup>9</sup></a>, as well as audio buffers and their corresponding pointers <a class="fn" href="#fn10" id="foot-fn10"><sup>10</sup></a>. In C++, fields in the C++ object would be accessed using their name. In WebAssembly, memory has to be accessed using an index in the memory block. All fields indexes are thus computed in a preliminary compilation pass, as offsets from the DSP object base address, to be used later in the code for load/store operations.</p>     <p>When a single monophonic DSP object is generated, the module internal memory is used. In our own defined memory layout, we can decide to locate the DSP object at address 0, thus simplifying and speeding up access of the DSP fields, since they can simply be defined as <em>offsets in the DSP object</em>, without having to generate the code to add the DSP base address. Audio buffers and their pointers are placed after the DSP (Figure <a class="fig" href="#fig6">6</a>). <figure id="fig6">       <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-fig6.jpg" class="img-responsive" alt="Figure 6"        longdesc=""/>       <div class="figure-caption">       <span class="figure-number">Figure 6:</span>       <span class="figure-title">Wasm memory block layout for a monophonic DSP.</span>       </div>      </figure>     </p>     <p>If the DSP object is going to be used in a more complex memory layout (like when allocating several DSP objects in a polyphonic instrument for instance), a JavaScript created WebAssembly memory block is imported. Audio buffers and their pointers are placed starting at address 0 followed by DSP objects. Since the base address of each DSP will change, more complex field access code which adds the DSP base address and the field offset will be generated (Figure <a class="fig" href="#fig7">7</a>). <figure id="fig7">       <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-fig7.jpg" class="img-responsive" alt="Figure 7"        longdesc=""/>       <div class="figure-caption">       <span class="figure-number">Figure 7:</span>       <span class="figure-title">Wasm memory block layout for a polyphonic DSP (here with 4 voices).</span>       </div>      </figure>     </p>    </section>    <section id="sec-19">     <p><em>4.2.3 Functions generation.</em> All FIR functions are compiled and exported in the module <em>export</em> section. Prototypes of required mathematical functions which are not part of the WebAssembly specification are generated in the module <em>import</em> section, to be retrieved from the enclosing JavaScript environment at execution time. Code for 32 or 64 bits float format can be generated, with the adapted version of mathematical functions and memory access code.</p>     <p>Some specific functions like <em>integer version of min/max functions</em> (which are not yet part of WebAssembly specification) are internally generated and inlined in the resulting code. Specialized FIR passes <a class="fn" href="#fn11" id="foot-fn11"><sup>11</sup></a> must be written: to move all local variables definition at the beginning of the functions, or to count local variables (stack/loop) with their types, etc., as required by the binary encoding specification.</p>     <p>The code generation requires a first pass to compute all scalar and array fields offset in memory, then possibly additional FIR passes to transform the FIR, or compute needed informations. The <em>wast</em> backend is easier to write since part of this information (like for instance the number of local variables with their types) does not need to be explicitly generated. On the contrary, the <em>wasm</em> backend is much more demanding, and several preliminary passes have to be done before the final code can be generated.</p>    </section>    <section id="sec-20">     <p><em>4.2.4 Additional code.</em> In both cases, a full description of the DSP object state as a JSON string is generated in the module data segment <a class="fn" href="#fn12" id="foot-fn12"><sup>12</sup></a> (including memory indexes of all controllers). Glue code will get and decode this JSON description, and use whatever parts of the description it needs to run the DSP code. In particular, control memory zones (corresponding to the UI items like buttons, sliders, bargraph...) can be directly read/written by the wrapper code.</p>    </section>    <section id="sec-21">     <p><em>4.2.5 Float denormals handling.</em> A specific problem occurs when audio computation produces <em>denormal</em> <a class="fn" href="#fn13" id="foot-fn13"><sup>13</sup></a> float values, which is quite common with recursive filters. Denormals are very small numbers, close to zero, that doesn&#x0027;t follow the format of normal floating point numbers. The problem is that denormal computations take much longer to calculate than normal computations on some processors, like the Intel family for instance.</p>     <p>Since audio DSP algorithms can usually afford to approximate computations with very small numbers and replace denormals with 0, a Flush To Zero (FTZ) mode for denormals can usually be set at hardware level, in order to completely avoid those costly computations.</p>     <p>The hardware FTZ mode is not yet available in WebAssembly MVP version, which strictly conforms to the IEEE 754 norm <a class="fn" href="#fn14" id="foot-fn14"><sup>14</sup></a>. An automatic software strategy which consists in adding FTZ code in all recursive loops has been implemented in the FAUST compiler. To activate it, the <em>-ftz</em> compilation parameter must be used at compilation time:</p>     <ul class="list-no-style">      <li id="list1" label="&#x2022;">the <em>-ftz 1</em> mode adds a test in each recursive loop which uses the <em>fabs</em> function and a threshold to detect denormal samples (slower).<br/></li>      <li id="list2" label="&#x2022;">the <em>-ftz 2</em> mode adds a test in each recursive loop which uses a mask to detect denormal samples (faster).<br/></li>     </ul>     <p>Even if this strategy is not perfect, this additionally generated code <a class="fn" href="#fn15" id="foot-fn15"><sup>15</sup></a> will avoid the production of most of denormals values with their associated CPU consumption peaks.</p>    </section>    </section>    <section id="sec-22">    <header>     <div class="title-info">      <h3>       <span class="section-number">4.3</span> WebAssembly code in Web Audio nodes</h3>     </div>    </header>    <p>JavaScript code is used to load the wasm file into a typed array, compile it to a module with <em>WebAssembly.compile</em>, then instantiate it using <em>WebAssembly.Instance</em> function, and finally get the callable exported functions. The DSP memory is either allocated inside the wasm module, or externally in the wrapping JavaScript code, and given as parameter when creating the module.</p>    <p>An extended <em>AudioNode</em> object <a class="fn" href="#fn16" id="foot-fn16"><sup>16</sup></a> with some additional methods is created. As an AudioNode type it will be usable like a regular AudioNode, possibly connected to other nodes, etc.</p>    <p>Starting from a <tt>karplus.dsp</tt> FAUST source file for example, the following function has to be used, taking as parameters: the wasm filename, the Web Audio context, the buffer size, and a callback to use the extended WebAudio node:</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-img1.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>Assuming a <em>karplus</em> variable finally contains the created object, the user interface can be retrieved as a JSON description:</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-img2.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>The WebAudio node can be controlled with the following kind of code:</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-img3.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    </section>    <section id="sec-23">    <header>     <div class="title-info">      <h3>       <span class="section-number">4.4</span> Embedding the JavaScript FAUST compiler in the browser</h3>     </div>    </header>    <p>Since the Emscripten compiler helps deploying any C++ code on the Web, it becomes possible to <em>compile the FAUST compiler itself with its embedded wasm backend</em> in pure JavaScript and WebAssembly (Figure <a class="fig" href="#fig8">8</a>).</p> <figure id="fig8">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-fig8.jpg" class="img-responsive" alt="Figure 8"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 8:</span>       <span class="figure-title">Compiling C++ libfaust to libfaust.js with Emscripten.</span>      </div>     </figure>    <p>It has been done by compiling the C++ <em>libfaust</em> library in a <em>libfaust.js</em> library combined with a <em>libfaust.wasm</em> file. A unique low-level <tt>createWasmCDSPFactoryFromString</tt> entry point has been defined, compiling the DSP source code using the wasm backend, and producing the module as an array of bytes and the helper JavaScript function as a string (Figure <a class="fig" href="#fig9">9</a>).</p> <figure id="fig9">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-fig9.jpg" class="img-responsive" alt="Figure 9"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 9:</span>       <span class="figure-title">libfaust.js + wasm dynamic compilation chain.</span>      </div>     </figure>    <p>Using WebAssembly API again and JavaScript <em>eval</em> function, allows to deploy it in the JavaScript context. Some additional glue code has been written, so that from the JavaScript side, a DSP factory will be created from the DSP source code with the following code:    </p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-img4.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>Here <em>argv</em> is a array of possible additional compilation arguments, and <em>cb</em> a callback to use the created DSP factory.</p>    <p>A fully working DSP instance as an extended Web Audio node is then created with the following code;</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-img5.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>and can be controlled with the API described in section 4.3.    </p>    </section>   </section>   <section id="sec-24">    <header>    <div class="title-info">     <h2>      <span class="section-number">5</span> Use cases</h2>    </div>    </header>    <p>Using the previously explained technologies, three different use cases have been experimented:</p>    <ul class="list-no-style">    <li id="list3" label="&#x2022;">compiling self-contained ready to use Web Audio nodes<br/></li>    <li id="list4" label="&#x2022;">using FAUST static compilation chain to produce HTML pages with Web Audio nodes<br/></li>    <li id="list5" label="&#x2022;">using the FAUST dynamic compilation chain to directly <em>program DSP</em> on the Web.<br/></li>    </ul>    <section id="sec-25">    <header>     <div class="title-info">      <h3>       <span class="section-number">5.1</span> Programming Web Audio nodes with FAUST</h3>     </div>    </header>    <p>Self contained ready to use Web Audio nodes can be produced from a DSP source using the <em>faust2wasm</em> script, which basically calls the FAUST compiler targeting the wasm backend, then wraps the produced code with a generic JavaScript API to be usable in the Web Audio context.</p>    <p>Audio nodes are created and activated. The full JSON description of the control parameters and their layout is available and can be used to create customized Graphical User Interfaces. Control parameters can then be read and written. This model has to be used when a custom control or Graphical User Interface is developed later on.</p>    </section>    <section id="sec-26">    <header>     <div class="title-info">      <h3>       <span class="section-number">5.2</span> Deploying FAUST DSP examples on the Web</h3>     </div>    </header>    <p>Using the <em>faust2webaudiowasm</em> script, a DSP source file can be compiled to a self-contained ready to run HTML page, and wrapping the wasm/JavaScript generated code in a HTML CSS/SVG based Graphical User Interface (Figure <a class="fig" href="#fig10">10</a>). <figure id="fig10">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-fig10.jpg" class="img-responsive" alt="Figure 10"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 10:</span>       <span class="figure-title">Self-contained HTML page loading the wasm module.</span>      </div>     </figure>    </p>    </section>    <section id="sec-27">    <header>     <div class="title-info">      <h3>       <span class="section-number">5.3</span> Web embedded compiler</h3>     </div>    </header>    <p>Having the FAUST compiler itself as a library in the browser opens interesting capabilities, experimented in two different tools.</p>    <section id="sec-28">     <p><em>5.3.1 The FAUST Editor.</em> The <em>FAUST Editor</em> application<a class="fn" href="#fn17" id="foot-fn17"><sup>17</sup></a> can be used to edit, compile and run FAUST code from any recent Web Browser with WebAssembly support (Figure <a class="fig" href="#fig11">11</a>). This editor completely works on the client side and it is therefore very convenient for situations with many simultaneous users (workshops, classrooms, etc.).</p>     <p>It embeds the latest version of the FAUST compiler with the wasm backend and offers polyphonic MIDI support. The editor engine is based on codemirror. It offers syntax highlighting, auto completion and direct access to the online documentation. <figure id="fig11">       <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-fig11.jpg" class="img-responsive" alt="Figure 11"        longdesc=""/>       <div class="figure-caption">       <span class="figure-number">Figure 11:</span>       <span class="figure-title">FAUST Editor online tool.</span>       </div>      </figure>     </p>    </section>    <section id="sec-29">     <p><em>5.3.2 The FaustPlayground.</em> The <em>FaustPlayground</em> application<a class="fn" href="#fn18" id="foot-fn18"><sup>18</sup></a> lets the user develop an audio application by graphically connecting high-level modules written in FAUST. The source code can be dropped as a string, a file, or a Web URL, or loaded from a library of predefined modules included in the platform (Figure <a class="fig" href="#fig12">12</a>).</p> <figure id="fig12">       <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-fig12.jpg" class="img-responsive" alt="Figure 12"        longdesc=""/>       <div class="figure-caption">       <span class="figure-number">Figure 12:</span>       <span class="figure-title">FaustPlayground dynamic compilation platform.</span>       </div>      </figure>     <p>Using libfaust.js, the DSP is compiled in the browser on the client machine, to become a functional Web Audio node that can be connected to others. At any time, the node source code can be edited and recompiled.</p>     <p>The user can then export his work to all the platforms supported by the online compilation service, from pure standalone applications, various plugins formats (VST, Max/MSP...), projects in source code form (JUCE, iOS...) <a class="fn" href="#fn19" id="foot-fn19"><sup>19</sup></a>. In order to perform this export, the graph must first be transformed into a single FAUST source code obtained by collecting the FAUST implementations of each node of the graph [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"       href="#BibPLXBIB0004">4</a>].     </p>    </section>    </section>   </section>   <section id="sec-30">    <header>    <div class="title-info">     <h2>      <span class="section-number">6</span> Benchmarks</h2>    </div>    </header>    <section id="sec-31">    <header>     <div class="title-info">      <h3>       <span class="section-number">6.1</span> Comparing the FAUST C++, LLVM IR and wast/wasm backends</h3>     </div>    </header>    <p>The WebAssembly approach promises <em>near native</em> performances for C/C++ written code compiled to WebAssembly using the Emscripten tool chain. Other languages like Rust (using the <em>mir2wasm</em> <a class="fn" href="#fn20" id="foot-fn20"><sup>20</sup></a> tool) experiment with direct WebAssembly generation. It seems clear that as the WebAssembly specification and its implementation stabilizes, more and more languages will directly generate wasm to be deployed in browsers. The question of the <em>code generation quality at each step of the compilation chain</em> will rapidly emerge.</p>    <p>Since our compiler is generating code for the quite focused audio domain, which is caracterized by a lot of memory access and mathematical operations, we can possibly expect to generate high quality code, even beating in some cases the generic Emscripten compilation chain based generated code.</p>    <p>While WebAssembly is initially designed to run on the Web, it may be deployed in non Web environnement like nodejs <a class="fn" href="#fn21" id="foot-fn21"><sup>21</sup></a>, or even in standalone Virtual Machines like WAVM, developed in C++, which JIT compile WebAssembly to native code using the LLVM technology <a class="fn" href="#fn22" id="foot-fn22"><sup>22</sup></a>. Thus WebAssembly becomes a portable binary format that can be used in a large variety of situations. This is especially of interest for a DSL language like FAUST.</p>    </section>    <section id="sec-32">    <header>     <div class="title-info">      <h3>       <span class="section-number">6.2</span> Benchmark of C++, LLVM IR and wast/wasm generated code</h3>     </div>    </header>    <p>Since FAUST already generates C++ or LLVM IR code, the performances of those two backends can be compared with the new wasm one. Using the WAVM C++ written machine allows to deploy the same measuring code <a class="fn" href="#fn23" id="foot-fn23"><sup>23</sup></a>. The first benchmark compares the speed of C++, LLVM IR and wasm backends, running a set of DSP on a MacBook Pro 2,2 GHz Core I7 with OSX El capitan. The same 4.0 version of LLVM toolchain has been used with the three backends.</p>    <p>C++ and LLVM IR code has been compiled with the <em>-Ofast</em> optimization flag, the WAVM runtime is the standard version one (without any specific audio optimization, see later) (Figure <a class="fig" href="#fig13">13</a>). <figure id="fig13">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-fig13.jpg" class="img-responsive" alt="Figure 13"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 13:</span>       <span class="figure-title">MBytes/sec for a test set of DSPs (higher is better).</span>      </div>     </figure>    </p>    <p>The diagram clearly shows that the wasm code is still slower than C++ or LLVM IR code, but speed difference is not so high in most cases. The poor performances of some DSP need to be analyzed in more detail.</p>    </section>    <section id="sec-33">    <header>     <div class="title-info">      <h3>       <span class="section-number">6.3</span> Optimizing the WAVM runtime for audio code</h3>     </div>    </header>    <p>The WAVM runtime strictly conforms to the WebAssembly specification, thus behaving as an interesting base reference. In the audio domain, the C/C++ generated code is usually compiled with specific optimization flags <a class="fn" href="#fn24" id="foot-fn24"><sup>24</sup></a>. Since C++ WAVM runtime can be quite easily modified, we did several changes into the reference implementation to improve the generated code performances (Figure <a class="fig" href="#fig14">14</a>).</p>    <ul class="list-no-style">     <li id="list6" label="&#x2022;">removing the <em>atomic</em> flag in all load/store <a class="fn" href="#fn25" id="foot-fn25"><sup>25</sup></a> that are added to pass all spec WebAssembly tests<br/></li>     <li id="list7" label="&#x2022;">adding the equivalent of <em>-fast-math</em> compilation flag that has to be done at LLVM IR and JIT (= native) <a class="fn" href="#fn26" id="foot-fn26"><sup>26</sup></a> generation steps<br/></li>     <li id="list8" label="&#x2022;">and finally simplifying some mathematical operators, using their standard definition <a class="fn" href="#fn27" id="foot-fn27"><sup>27</sup></a> instead of the specific WAVM coded ones that strictly implement the WebAssembly official semantic <a class="fn" href="#fn28" id="foot-fn28"><sup>28</sup></a> (see for instance the definition of <em>f32.min/f32.max</em> operations with their handling of NaN values)<br/></li>    </ul>    <figure id="fig14">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-fig14.jpg" class="img-responsive" alt=""      longdesc=""/>          <div class="figure-caption">       <span class="figure-number">Figure 14</span>       <span class="figure-title"> </span>      </div> </figure>    <p>The diagram shows the difference between a runtime strictly conforming to the WebAssembly specification, and the same runtime optimized for audio code. This somewhat characterizes the <em>incompressible speed difference</em> that will always exist between the C++ or LLVM IR version of FAUST generated code, and the wasm generated one.</p>    <p>Note that after generating the LLVM IR code, the WAVM runtime runs a set of LLVM IR to IR optimizations passes. It remains to be tested if adding more optimization passes (especially the <em>auto-vectorization</em> ones) could help producing even better code.</p>    </section>    <section id="sec-34">    <header>     <div class="title-info">      <h3>       <span class="section-number">6.4</span> Module optimization with Binaryen</h3>     </div>    </header>    <p>Binaryen is a compiler and toolchain infrastructure library for WebAssembly <a class="fn" href="#fn29" id="foot-fn29"><sup>29</sup></a>, written in C++. Its contains <em>wasm to wasm</em> optimisations passes, possibly allowing to even improve the speed of the FAUST generated wasm code. We tested the <em>wasm-opt</em> tool at <em>-O3</em> level on FAUST generated wasm modules to estimate which speedup we can expect. The diagram shows limited gains, with no more than 5% in some of the tested cases (Figure <a class="fig" href="#fig15">15</a>). <figure id="fig15">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-fig15.jpg" class="img-responsive" alt=""       longdesc=""/>           <div class="figure-caption">       <span class="figure-number">Figure 15</span>       <span class="figure-title"> </span>      </div>    </figure>    </p>    </section>    <section id="sec-35">    <header>     <div class="title-info">      <h3>       <span class="section-number">6.5</span> Float denormal handling</h3>     </div>    </header>    <p>The software float denormal code can be easily tested in the WAVM machine <a class="fn" href="#fn30" id="foot-fn30"><sup>30</sup></a>. Here is the result of code generated with -ftz from 0 to 2 (Figure <a class="fig" href="#fig16">16</a>). The code is continuously a bit slower when software FTZ is activated, the point being obviously to avoid pathological cases where the CPU consumption would raise dramatically in the presence of denormals values. The <em>-ftz 2</em> mode appears to be the most efficient one and will preferably be used. <figure id="fig16">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-fig16.jpg" class="img-responsive" alt=""       longdesc=""/>           <div class="figure-caption">       <span class="figure-number">Figure 16</span>       <span class="figure-title"> </span>      </div>    </figure>    </p>    </section>    <section id="sec-36">    <header>     <div class="title-info">      <h3>       <span class="section-number">6.6</span> Emscripten versus FAUST direct compilation</h3>     </div>    </header>    <p>Wasm code directly generated by the FAUST wasm backend can be compared to wasm code generated by compiling (with Emscripten) the code generated by the FAUST C backend. All sophisticated optimizations passes the LLVM based Emscripten compiler can possibly be used on the C side, a simpler <em>FIR to wasm</em> generation model, but coupled with some specific optimizations (for instance the optimized memory layout one described in section 4.2.2) on the direct wasm side. Compilation of FAUST generated C has been done using <em>-s SIDE_MODULE=1</em> mode to produce a light wasm module, without any runtime, to be loaded and activated by additional JavaScript glue code.</p>    <p>Done under Firefox Nightly, the diagram shows that direct wasm code generation can even beat Emscripten generated wasm code (Figure <a class="fig" href="#fig17">17</a>). <figure id="fig17">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-fig17.jpg" class="img-responsive" alt=""       longdesc=""/>           <div class="figure-caption">       <span class="figure-number">Figure 17</span>       <span class="figure-title"> </span>      </div>    </figure>    </p>    </section>    <section id="sec-37">    <header>     <div class="title-info">      <h3>       <span class="section-number">6.7</span> Comparing three browsers</h3>     </div>    </header>    <p>HTML test pages <a class="fn" href="#fn31" id="foot-fn31"><sup>31</sup></a> were prepared to compare the performances of the three main browsers. The DSP code is compiled with float denormal protection on. The generated wasm module&#x0027;s <em>compute</em> method is called repeatedly in a timed loop, using successive slices of a big allocated circular audio buffer to avoid cache effects. Here are the results (Figure <a class="fig" href="#fig18">18</a>). <figure id="fig18">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-fig18.jpg" class="img-responsive" alt=""       longdesc=""/>           <div class="figure-caption">       <span class="figure-number">Figure 18</span>       <span class="figure-title"> </span>      </div>    </figure>    </p>    <p>The fasted one (Chrome for now) can be compared with C++, LLVM IR, WAVM native engines, all compiled with float denormal protection on (Figure <a class="fig" href="#fig19">19</a>). <figure id="fig19">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185970/images/www18companion-31-fig19.jpg" class="img-responsive" alt=""       longdesc=""/>          <div class="figure-caption">       <span class="figure-number">Figure 19</span>       <span class="figure-title"> </span>      </div>     </figure>    </p>    </section>   </section>   <section id="sec-38">    <header>    <div class="title-info">     <h2>      <span class="section-number">7</span> Comments on benchmarks</h2>    </div>    </header>    <p>Testing wasm JIT machines across different browsers is not an easy task. Thus being able to use a simpler standalone WebAssembly aware runtime was a good starting point. The C++ WAVM runtime revealed to be an excellent tool to compare the FAUST C++, LLVM IR and wasm backends. Since its code can be easily adapted, what can be expected deploying wasm DSP modules in pure native environments can also be estimated (that is outside of the browser, where some audio specific optimizations may be considered).</p>    <p>Measurements done on a set of FAUST DSPs show that WebAssembly code still runs slower than C++ or LLVM IR generated code in most cases, up to almost 66% slower in the less favorable examples. This value will typically be a bit worse when deploying in browsers, since float denormal protection code has to be used.</p>    <p>Comparing the Chrome, Firefox and WebKit browsers on the tested machine shows that Chrome was the fastest engine in most cases (at the time of testing), with Firefox and WebKit quite similar (with a slight plus for WebKit).</p>    <p>Comparing the Chrome browser with native engines shows results from 4,8 times slower (filterBank.dsp), 2,8 times slower (sTunedBar6.dsp) up to much more favorable cases (karplus32.dsp). Note that filterBank.dsp example is a bit of a pathological case, since Chrome is significantly slower than Firefox and WebKit in this case, and filterBank.dsp uses a lot of pow(10, x) code that is rewritten and optimized as exp10(x) with the C++ backend path.</p>    <p>And finally it has to be said that all those benchmarks compare the browsers and the WAVM standalone runtime at time t, in a fast changing situation that hopefully will improve progressively.</p>   </section>   <section id="sec-39">    <header>    <div class="title-info">     <h2>      <span class="section-number">8</span> Conclusion</h2>    </div>    </header>    <p>The WebAssembly format promises to be an excellent compilation target for Domain Specific Like languages like FAUST. Performance in the different tested browsers is already quite good, and we can expect improvements as the wasm implementation matures.</p>    <p>The float denormals handling remains a serious issue, since adding software protection code cannot be considered a long terme and satisfactory solution. We hope that future versions of the WebAssembly specification will properly address this question.</p>    <p>The WAVM project shows that non-Web embeddings are perfectly possible, even with audio code aware customized runtimes, and opens interesting deployment possibilities.</p>    <p>In the context of the WebAudio API, the AudioWorklet implementation is still quite fresh and needs to be more thoroughly tested.</p>   </section>  </section>  <section class="back-matter">   <section id="ref-001">    <header>    <div class="title-info">     <h2 class="page-brake-head">REFERENCES</h2>    </div>    </header>    <ul class="bibUl">    <li id="BibPLXBIB0001" label="[1]">John Backus. Can Programming Be Liberated from the von Neumann Style ? <em>ACM Turing Award lecture</em>, pages 613&#x2013;641, 1978.</li>    <li id="BibPLXBIB0002" label="[2]">C.&#x00A0;Clark and A.&#x00A0;Tindale. Flocking: a framework for declarative music-making on the Web. In <em>Proceedings of the International Computer Music Conference</em>, 2014.</li>    <li id="BibPLXBIB0003" label="[3]">Sarah Denoux, St&#x00E9;phane Letz, Yann Orlarey, and Dominique Fober. FAUSTLIVE, Just-In-Time Faust Compiler... and much more. In <em>Proceedings of the Linux Audio Conference 2014, ZKM, Karlsruhe, Germany</em>, 2014.</li>    <li id="BibPLXBIB0004" label="[4]">Sarah Denoux, Yann Orlarey, St&#x00E9;phane Letz, and Dominique Fober. Calcul d&#x0027;une expression Faust &#x00E9;quivalente &#x00E0; partir d&#x0027;un graphe d&#x0027;applications. In <em>Journ&#x00E9;es d&#x0027;Informatique Musicale</em>, 2016.</li>    <li id="BibPLXBIB0005" label="[5]">V.&#x00A0;Lazzarini, E.&#x00A0;Costello, S.&#x00A0;Yi, and J.&#x00A0;Fitch. Csound on the Web. In <em>Proceedings of the Linux Audio Conference</em>, 2014.</li>    <li id="BibPLXBIB0006" label="[6]">S.&#x00A0;Letz, Y.&#x00A0;Orlarey, and D.&#x00A0;Fober. Comment embarquer le compilateur Faust dans vos applications? In <em>In Proceedings of the Journees d&#x0027;Informatique Musicale</em>, 2013.</li>    <li id="BibPLXBIB0007" label="[7]">Yann Orlarey, Dominique Fober, and Stephane Letz. An algebra for block diagram languages. In ICMA, editor, <em>Proceedings of International Computer Music Conference</em>, pages 542&#x2013;547, 2002.</li>    <li id="BibPLXBIB0008" label="[8]">Yann Orlarey, Dominique Fober, and Stephane Letz. Syntactical and Semantical Aspects of Faust. <em>Soft Computing</em>, 8(9):623&#x2013;632, 2004.</li>    <li id="BibPLXBIB0009" label="[9]">Yann Orlarey, Dominique Fober, and Stephane Letz. Parallelization of audio applications with Faust. In <em>Proc. of the 6th Sound and Music Computing Conference, Porto, PT</em>, pages 99&#x2013;112, 2009.</li>    <li id="BibPLXBIB0010" label="[10]">Charlie Roberts. Strategies for Per-Sample Processing of Audio Graphs in the Browser. In <em>Proceedings of the Web Audio Conference</em>, 2017.</li>    <li id="BibPLXBIB0011" label="[11]">Gheorghe Stefanescu. Algebra of flownomials. <em>Institut f&#x00FC;r Informatik, Technical University Munich, Report TUM- I9437</em>, 1994.</li>    <li id="BibPLXBIB0012" label="[12]">A.&#x00A0;Zakai. Emscripten: an LLVM to JavaScript compiler. In <em>In Proceedings of the ACM international conference companion on Object oriented programming systems languages and applications</em>, 2011.</li>    </ul>   </section>  </section>  <section id="foot-001" class="footnote">   <header>    <div class="title-info">    <h2>FOOTNOTE</h2>    </div>   </header>   <p id="fn1"><a href="#foot-fn1"><sup>1</sup></a>Low Level Virtual Machine Intermediate Representation.</p>   <p id="fn2"><a href="#foot-fn2"><sup>2</sup></a>As float* or double* memory addresses</p>   <p id="fn3"><a href="#foot-fn3"><sup>3</sup></a><a class="link-inline force-break"    href="https://webaudio.github.io/web-audio-api/#rendering-loop">https://webaudio.github.io/web-audio-api/#rendering-loop</a>   </p>   <p id="fn4"><a href="#foot-fn4"><sup>4</sup></a>Google Portable Native Client (PNaCl) is a sandboxing technology for running a subset of Intel x86, ARM, or MIPS native code in a sandbox.</p>   <p id="fn5"><a href="#foot-fn5"><sup>5</sup></a>As asm.js model done correctly, see <a class="link-inline force-break" href="http://webassembly.org">http://webassembly.org</a>   </p>   <p id="fn6"><a href="#foot-fn6"><sup>6</sup></a><a class="link-inline force-break"    href="http://kripken.github.io/emscripten-site/">http://kripken.github.io/emscripten-site/</a>   </p>   <p id="fn7"><a href="#foot-fn7"><sup>7</sup></a><a class="link-inline force-break" href="https://www.mansoft.nl/csound/">https://www.mansoft.nl/csound/</a>   </p>   <p id="fn8"><a href="#foot-fn8"><sup>8</sup></a><a class="link-inline force-break" href="https://github.com/WebAssembly/binaryen">https://github.com/WebAssembly/binaryen</a>   </p>   <p id="fn9"><a href="#foot-fn9"><sup>9</sup></a>The FAUST backend for a more structured langage like C++ typically generates sub-classes in this case.</p>   <p id="fn10"><a href="#foot-fn10"><sup>10</sup></a>At each cycle, audio buffers will be copied with data coming from the audio wrapper</p>   <p id="fn11"><a href="#foot-fn11"><sup>11</sup></a>The FIR tree can be traversed using a visitor like pattern, possibly doing <em>FIR to FIR</em> kind of transformations.</p>   <p id="fn12"><a href="#foot-fn12"><sup>12</sup></a><a class="link-inline force-break" href="http://webassembly.org/docs/modules/">http://webassembly.org/docs/modules/</a>   </p>   <p id="fn13"><a href="#foot-fn13"><sup>13</sup></a><a class="link-inline force-break"    href="https://en.wikipedia.org/wiki/Denormal_number">https://en.wikipedia.org/wiki/Denormal_number</a>   </p>   <p id="fn14"><a href="#foot-fn14"><sup>14</sup></a><a class="link-inline force-break"    href="https://github.com/WebAssembly/design/issues/148">https://github.com/WebAssembly/design/issues/148</a>   </p>   <p id="fn15"><a href="#foot-fn15"><sup>15</sup></a>which is actually a bit more costly to compute</p>   <p id="fn16"><a href="#foot-fn16"><sup>16</sup></a><a class="link-inline force-break"    href="https://webaudio.github.io/web-audio-api/#the-audionode-interface">https://webaudio.github.io/web-audio-api/#the-audionode-interface</a>   </p>   <p id="fn17"><a href="#foot-fn17"><sup>17</sup></a><a class="link-inline force-break" href="http://faust.grame.fr/editor">http://faust.grame.fr/editor</a>   </p>   <p id="fn18"><a href="#foot-fn18"><sup>18</sup></a><a class="link-inline force-break" href="http://faust.grame.fr/faustplayground">http://faust.grame.fr/faustplayground</a>   </p>   <p id="fn19"><a href="#foot-fn19"><sup>19</sup></a><a class="link-inline force-break" href="http://faustservice.grame.fr">http://faustservice.grame.fr</a>   </p>   <p id="fn20"><a href="#foot-fn20"><sup>20</sup></a><a class="link-inline force-break" href="https://github.com/brson/mir2wasm">https://github.com/brson/mir2wasm</a>   </p>   <p id="fn21"><a href="#foot-fn21"><sup>21</sup></a><a class="link-inline force-break" href="http://webassembly.org/docs/non-web/">http://webassembly.org/docs/non-web/</a>   </p>   <p id="fn22"><a href="#foot-fn22"><sup>22</sup></a><a class="link-inline force-break"    href="https://github.com/AndrewScheidecker/WAVM">https://github.com/AndrewScheidecker/WAVM</a>   </p>   <p id="fn23"><a href="#foot-fn23"><sup>23</sup></a><a class="link-inline force-break"    href="http://faust.grame.fr/news/2017/04/26/optimizing-compilation-parameters.html">http://faust.grame.fr/news/2017/04/26/optimizing-compilation-parameters.html</a>   </p>   <p id="fn24"><a href="#foot-fn24"><sup>24</sup></a>like <em>-fast-math</em> which lets the compiler generate faster (but less precise) mathematical operations</p>   <p id="fn25"><a href="#foot-fn25"><sup>25</sup></a><a class="link-inline force-break"    href="https://github.com/sletz/WAVM/commit/cf6011026aa75dfd0f88e051da271ce0c0d525a9">https://github.com/sletz/WAVM/commit/cf6011026aa75dfd0f88e051da271ce0c0d525a9</a>   </p>   <p id="fn26"><a href="#foot-fn26"><sup>26</sup></a><a class="link-inline force-break"    href="https://github.com/sletz/WAVM/commit/1aa96a2088ed1c6eb918b7f292f4571aecdfc6da">https://github.com/sletz/WAVM/commit/1aa96a2088ed1c6eb918b7f292f4571aecdfc6da</a>   </p>   <p id="fn27"><a href="#foot-fn27"><sup>27</sup></a><a class="link-inline force-break"    href="https://github.com/sletz/WAVM/commit/a9e2a91c53e79168fb7e193beb36e99d81d0be21">https://github.com/sletz/WAVM/commit/a9e2a91c53e79168fb7e193beb36e99d81d0be21</a>   </p>   <p id="fn28"><a href="#foot-fn28"><sup>28</sup></a><a class="link-inline force-break" href="http://webassembly.org/docs/semantics/">http://webassembly.org/docs/semantics/</a>   </p>   <p id="fn29"><a href="#foot-fn29"><sup>29</sup></a><a class="link-inline force-break" href="https://github.com/WebAssembly/binaryen">https://github.com/WebAssembly/binaryen</a>   </p>   <p id="fn30"><a href="#foot-fn30"><sup>30</sup></a>by explicitly deactivating hardware FTZ mode on the CPU running in this native runtime.</p>   <p id="fn31"><a href="#foot-fn31"><sup>31</sup></a><a class="link-inline force-break" href="http://faust.grame.fr/bench/">http://faust.grame.fr/bench/</a>   </p>   <div class="bibStrip">    <p>This paper is published under the Creative Commons Attribution 4.0 International (CC-BY&#x00A0;4.0) license. Authors reserve their rights to disseminate the work on their personal and corporate Web sites with the appropriate attribution.</p>    <p>    <em>WWW '18, April 23-27, 2018, Lyon, France</em>    </p>    <p>&#x00A9; 2018; IW3C2 (International World Wide Web Conference Committee), published under Creative Commons CC-BY&#x00A0;4.0 License.<br/> ACM ISBN 978-1-4503-5640-4/18/04.<br/>DOI: <a class="link-inline force-break" target="_blank"     href="https://doi.org/10.1145/3184558.3185970">https://doi.org/10.1145/3184558.3185970</a>    </p>   </div>  </section>  <div class="pubHistory">   <p/>  </div> </body> </html> 
