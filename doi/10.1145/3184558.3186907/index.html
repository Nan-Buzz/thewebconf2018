<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">  <head>  <title>PDSM: Pregel-Based Distributed Subgraph Matching on Large Scale RDF Graphs</title>  <!-- Copyright (c) 2010-2015 The MathJax Consortium --><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>  <meta name="viewport" content="width=device-width; initial-scale=1.0;"></meta>  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>  <link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/bootstrap.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/bootstrap-theme.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/main.css"/><script src="../../../data/dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script>  <script type="text/javascript"    src="../../../data/dl.acm.org/pubs/lib/js/MathJax.js?config=TeX-AMS_CHTML"></script>  <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>  </head>  <body id="main">  <section class="front-matter">   <section>    <header class="title-info">     <div class="journal-title">     <h1>      <span class="title">PDSM: Pregel-Based Distributed Subgraph Matching on Large Scale RDF Graphs</span>      <br/>      <span class="subTitle"/>     </h1>     </div>    </header>    <div class="authorGroup">     <div class="author">     <span class="givenName">Qiang</span>      <span class="surName">Xu</span>,     School of Computer Science and Technology, Tianjin University, Tianjin, China, Tianjin Key Laboratory of Cognitive Computing and Application, Tianjin, China, <a href="mailto:xuqiang3@tju.edu.cn">xuqiang3@tju.edu.cn</a>     </div>     <div class="author">     <span class="givenName">Xin</span>      <span class="surName">Wang</span>,     School of Computer Science and Technology, Tianjin University, Tianjin, China, Tianjin Key Laboratory of Cognitive Computing and Application, Tianjin, China, <a href="mailto:wangx@tju.edu.cn">wangx@tju.edu.cn</a>     </div>     <div class="author">     <span class="givenName">Yueqi</span>      <span class="surName">Xin</span><a class="fn" href="#fn1" id="foot-fn1"><sup>&#x204E;</sup></a>,     School of Computer Science and Technology, Tianjin University, Tianjin, China, Tianjin Key Laboratory of Cognitive Computing and Application, Tianjin, China, <a href="mailto:xinyueqi@tju.edu.cn">xinyueqi@tju.edu.cn</a>     </div>     <div class="author">     <span class="givenName">Zhiyong</span>      <span class="surName">Feng</span>,     School of Computer Software, Tianjin University, Tianjin, China, Tianjin Key Laboratory of Cognitive Computing and Application, Tianjin, China, <a href="mailto:zyfeng@tju.edu.cn">zyfeng@tju.edu.cn</a>     </div>     <div class="author">     <span class="givenName">Renhai</span>      <span class="surName">Chen</span>,     School of Computer Science and Technology, Tianjin University, Tianjin, China, <a href="mailto:renhai.chen@tju.edu.cn">renhai.chen@tju.edu.cn</a>     </div>        </div>    <br/>    <div class="pubInfo">     <p>DOI: <a href="https://doi.org/10.1145/3184558.3186907" target="_blank">https://doi.org/10.1145/3184558.3186907</a>     <br/>WWW '18: <a href="https://doi.org/10.1145/3184558" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p>    </div>    <div class="abstract">     <p>     <small>This paper presents a novel <span style="text-decoration: underline;">P</span>regel-based <span style="text-decoration: underline;">D</span>istributed <span style="text-decoration: underline;">S</span>ubgraph <span style="text-decoration: underline;">M</span>atching method <tt>PDSM</tt> to answer subgraph matching queries on big RDF graphs. In our method, the query graph is transformed to a spanning tree based on the breadth-first search (BFS). Two optimization techniques are proposed to filter out part of the unpromising intermediate results and postpone the Cartesian product operations in the Pregel iterative computation. The extensive experiments on both synthetic and real-world datasets show that <tt>PDSM</tt> outperforms the state-of-the-art methods by an order of magnitude.</small>     </p>    </div>    <div class="classifications">     <div class="AcmReferenceFormat">     <p>      <small>       <span style="font-weight:bold;">ACM Reference Format:</span>       <br/>       Qiang Xu, Xin Wang, Yueqi Xin, Zhiyong Feng, and Renhai Chen. 2018. PDSM: Pregel-Based Distributed Subgraph Matching on Large Scale RDF Graphs. In <em>WWW '18 Companion: The 2018 Web Conference Companion,</em>       <em>April 23&#x2013;27, 2018,</em>       <em> Lyon, France. ACM, New York, NY, USA</em> 3 Pages. <a href="https://doi.org/10.1145/3184558.3186907" class="link-inline force-break"        target="_blank">https://doi.org/10.1145/3184558.3186907</a></small>     </p>     </div>    </div>   </section>  </section>  <section class="body">   <section id="sec-7">    <header>     <div class="title-info">     <h2>      <span class="section-number">1</span> Introduction</h2>     </div>    </header>    <p>RDF can be represented as a labeled, directed graph consisting of a set of triples (<em>s</em>, <em>p</em>, <em>o</em>), where <em>s</em> is the <em>subject</em>, <em>p</em> the <em>predicate</em>, and <em>o</em> the <em>object</em>. Given an RDF graph <em>G</em> and a query graph <em>G<sub>Q</sub>     </em>, subgraph matching is to find subgraphs over <em>G</em> that satisfy all the triple patterns in <em>G<sub>Q</sub>     </em>, which is a <em>conjunctive query</em> (CQ). It is known that the complexity of CQ is NP-complete. For instance, the CQ <span class="inline-equation"><span class="tex">$Q_1(?x) \leftarrow (?x, \texttt {rdf:type}, \texttt {Student}) \wedge (?x, \texttt {takesCourse}, ?y) \wedge (?x, \texttt {advisor}, ?z) \wedge (?z, \texttt {teacherOf}, ?y)$</span>     </span> over the RDF graph <em>G</em>     <sub>1</sub> in Figure <a class="fig" href="#fig1">1</a> finds those students who take courses that their advisors teach, and one of the query results is highlighted in green. <figure id="fig1">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186907/images/www18companion-147-fig1.svg" class="img-responsive" alt="Figure 1"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 1:</span>      <span class="figure-title">An example RDF graph <em>G</em><sub>1</sub> and a CQ <em>Q</em><sub>1</sub> over <em>G</em><sub>1</sub>.      </span>     </div>     </figure>    </p>    <p>There has been some research works on subgraph matching in distributed environments. In [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0003">3</a>], a query graph is decomposed into a set of subqueries, i.e., triple patterns and STwigs; partial results of these subqueries are joined together to form the final answer. However, the performance of these methods highly depends on decomposition and join order of the subqueries, thus a large number of joins may incur expensive costs. Although PSgl [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0002">2</a>] employs graph traversal without joins, it cannot be easily adapted to the characteristics of RDF graphs.</p>    <p>We propose a join-less method <tt>PDSM</tt> which transforms a query graph to a spanning-tree variant <tt>MHT</tt> (Minimum Height Tree), which is then matched against an RDF graph <em>in parallel</em> using Pregel, a <em>vertex-centric</em> parallel graph computational model. The experiments have verified the efficiency and scalability of our method.</p>   </section>   <section id="sec-8">    <header>     <div class="title-info">     <h2>      <span class="section-number">2</span> Problem and our algorithm</h2>     </div>    </header>    <p>Let <em>V</em>, <em>E</em>, and <em>&#x03A3;</em> denote the set of vertices, edges, and edge labels in an RDF graph <em>G</em>, respectively. Assume there exists an infinite set <em>Var</em> of variables disjoint from <em>V</em>, and the name of every element in <em>Var</em> starts with the character ?, e.g., ?<em>x</em> &#x2208; <em>Var</em>. A CQ <em>Q</em> over <em>G</em> is defined as: <span class="inline-equation"><span class="tex">$Q(z_1,...,z_n) \leftarrow \bigwedge _{1 \le i \le m} tp_i$</span>     </span>, where <em>tp<sub>i</sub>     </em> = (<em>x<sub>i</sub>     </em>, <em>a<sub>i</sub>     </em>, <em>y<sub>i</sub>     </em>) is a <em>triple pattern</em>, <em>x<sub>i</sub>     </em>, <em>y<sub>i</sub>     </em> &#x2208; <em>V</em>&#x222A;<em>Var</em>, <em>a<sub>i</sub>     </em> &#x2208; <em>&#x03A3;</em>, <em>z<sub>j</sub>     </em> &#x2208; {<em>x<sub>i</sub>     </em>&#x2223;1 &#x2264; <em>i</em> &#x2264; <em>m</em>}&#x222A;{<em>y<sub>i</sub>     </em>&#x2223;1 &#x2264; <em>i</em> &#x2264; <em>m</em>}. A CQ <em>Q</em> is also referred to as a query graph <em>G<sub>Q</sub>     </em>, e.g., <span class="inline-equation"><span class="tex">$G_{Q_1}$</span>     </span> in Figure&#x00A0;<a class="fig" href="#fig1">1</a>. Let <span class="inline-equation"><span class="tex">$\bar{x}=(x_1,...,x_m)$</span>     </span>, <span class="inline-equation"><span class="tex">$\bar{y} = (y_1,...,y_m)$</span>     </span>, and <span class="inline-equation"><span class="tex">$\bar{z} = (z_1,...,z_n)$</span>     </span>. The semantics of CQ <em>Q</em> over <em>G</em> is: (1) <em>&#x03BC;</em> is a mapping from vertices in <span class="inline-equation"><span class="tex">$\bar{x}$</span>     </span> and <span class="inline-equation"><span class="tex">$\bar{y}$</span>     </span> to vertices in <em>V</em>; (2) (<em>G</em>, <em>&#x03BC;</em>)&#x22A8;<em>Q</em> iff (<em>&#x03BC;</em>(<em>x<sub>i</sub>     </em>), <em>a<sub>i</sub>     </em>, <em>&#x03BC;</em>(<em>y<sub>i</sub>     </em>)) &#x2208; <em>G</em> and <em>x<sub>i</sub>     </em> and <em>y<sub>i</sub>     </em> match <em>&#x03BC;</em>(<em>x<sub>i</sub>     </em>) and <em>&#x03BC;</em>(<em>y<sub>i</sub>     </em>), respectively; and (3) <em>&#x03A9;<sub>Q</sub>     </em> is the answer set of <em>Q</em> over <em>G</em>, i.e., the set of <span class="inline-equation"><span class="tex">$\mu (\bar{z})$</span>     </span>, such that (<em>G</em>, <em>&#x03BC;</em>)&#x22A8;<em>Q</em>.</p>    <p>We first transform a query graph <em>G<sub>Q</sub>     </em> to an <tt>MHT</tt>     <em>T</em>, which is a tree rooted at <em>v<sub>r</sub>     </em>, the <em>central vertex</em> in the <em>diameter</em> of <em>G<sub>Q</sub>     </em>, to minimize the height of <em>T</em>. The breadth-first search is used to construct <em>T</em> from <em>v<sub>r</sub>     </em>. First, children of <em>v<sub>r</sub>     </em> are added to <em>T</em>, i.e., all triple patterns (<em>v<sub>r</sub>     </em>, <em>p<sub>i</sub>     </em>, <em>v<sub>i</sub>     </em>) or (<em>v<sub>i</sub>     </em>, <em>p<sub>i</sub>     </em>, <em>v<sub>r</sub>     </em>) &#x2208; <em>G<sub>Q</sub>     </em> are copied to <em>T</em>. Let <em>Child</em>(<em>v</em>) denote the set of children of node <em>v</em> and <em>v<sub>i</sub>     </em> &#x2208; <em>Child</em>(<em>v<sub>r</sub>     </em>). Next, for each node <em>v<sub>i</sub>     </em>, children of <em>v<sub>i</sub>     </em> are generated in <em>T</em> similarly by exploring the edges that are not visited yet in <em>G<sub>Q</sub>     </em>. This process continues until all edges in <em>G<sub>Q</sub>     </em> are visited. For example, <em>T</em>     <sub>1</sub> is the <tt>MHT</tt> of <span class="inline-equation"><span class="tex">$G_{Q_1}$</span>     </span> in Figure <a class="fig" href="#fig1">1</a>. Note that there exists duplicate nodes in <em>T</em> if <em>G<sub>Q</sub>     </em> contains a circle, e.g., node ?<em>z</em> in the <tt>MHT</tt>     <em>T</em>     <sub>1</sub>. For each node <em>u</em> in <em>T</em>, let <em>&#x03A9;</em>(<em>u</em>) be the partial matching results of the subtree rooted at <em>u</em>, thus <em>&#x03A9;</em>(<em>v<sub>r</sub>     </em>) is the answer set of <em>G<sub>Q</sub>     </em>.</p>    <p>Our join-less method employs the Pregel model to match nodes of an <tt>MHT</tt>     <em>T</em> against <em>G</em> in a bottom-up manner. Given an RDF graph <em>G</em>, each vertex <em>v</em> &#x2208; <em>G</em> is in either <em>active</em> or <em>inactive</em> state, and the function <tt>voteToHalt</tt> makes <em>v</em> to deactivate itself. The Pregel <em>parallel computation</em> is defined as a sequence of iterations, i.e., <em>supersteps</em> separated by global synchronization barriers, on active vertices. In our <tt>PDSM</tt> algorithm, (1) in superstep 0, all vertices are active, every vertex <em>v</em> matches leaves of <em>T in parallel</em> and sends the partial matching results of these leaves to their neighboring vertices (lines 7-9); (2) in the following supersteps, vertices who receive massages <em>Msg</em> are reactivated and match parents of those nodes matched in the previous superstep (lines 10-17). Similarly, these vertices send messages of partial matching results of subtrees rooted at these parents (line 17); and (3) this process is iterated until the root is matched (line 16). We can see that one level of the tree <em>T</em> is matched in each superstep. Moreover, <tt>val</tt>(<em>v</em>) = (<em>M<sub>P</sub>     </em>, <em>Res</em>) denotes the value of vertex <em>v</em>, where <em>M<sub>P</sub>     </em> is the set of <em>&#x03A9;</em>(<em>u</em>) and <em>Res</em> is the set of query results. We have proved that <tt>PDSM</tt> is correct and can finish in <em>d</em> supersteps, where <em>d</em> is the height of <em>T</em>.</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186907/images/www18companion-147-img1.svg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>As to the optimization strategies, we employ the W3C <em>RDF Shapes</em> standard as the <em>priori</em> knowledge to filter out part of the unpromising intermediate results. Furthermore, we also decompose an <tt>MHT</tt> into a set of paths to postpone Cartesian product operations. For example, one such path of the <tt>MHT</tt>     <em>T</em>     <sub>1</sub> in Figure <a class="fig" href="#fig1">1</a> is highlighted in red. Since the matching of these paths can be executed <em>in parallel</em>, the query efficiency is independent of a specific matching order.</p>   </section>   <section id="sec-9">    <header>     <div class="title-info">     <h2>      <span class="section-number">3</span> Experiments</h2>     </div>    </header>    <p>Our prototype system, implemented in Scala using Spark GraphX, is deployed on a 10-site cluster. Each site has one CPU with 4 cores, 16GB memory, and 250GB disk storage. We use Hadoop 2.7.4 and Spark 2.2.0. All the experiments were carried out on Linux (64-bit CentOS) operating systems. For the datasets, we used the WatDiv benchmark synthetic data and the DBpedia real-world data (23.4M triples). RDF queries are grouped into four categories according to their shapes, including <em>linear</em>, <em>star</em>, <em>snowflake</em>, and <em>complex</em>. In WatDiv, the benchmark contains 20 basic query templates. Due to the absence of query templates in DBpedia, we designed 8 queries, covering all four query categories mentioned above. <figure id="fig2">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186907/images/www18companion-147-fig2.jpg" class="img-responsive" alt="Figure 2"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 2:</span>      <span class="figure-title">Comparison of <tt>PDSM</tt> and S2X.</span>     </div>     </figure>    </p>    <p>Figure&#x00A0;<a class="fig" href="#fig2">2</a> illustrates the efficiency and scalability of <tt>PDSM</tt> by comparing with S2X. We can observe that <tt>PDSM</tt> demonstrates a much better query efficiency on both datasets and all query categories. The main reason is that our join-less <tt>PDSM</tt>, based on Pregel, employs graph traversal to avoid the expensive cost of join operations. Furthermore, we randomly selected one query from each of the four categories to verify the scalability of <tt>PDSM</tt>. Varying the size of WatDiv from 1M to 100M, query times of both methods have increased, however, the growth rate of query times of S2X is higher than that of <tt>PDSM</tt>. With the number of sites varying from 4 to 10, the speedup ratio of <tt>PDSM</tt> is about 1.71 times of S2X.</p>   </section>   <section id="sec-10">    <header>     <div class="title-info">     <h2>      <span class="section-number">4</span> Conclusion</h2>     </div>    </header>    <p>In this paper, we proposed the join-less method <tt>PDSM</tt> for efficiently answering the subgraph matching problem on large-scale RDF graph data using Pregel. Our extensive experimental results on both synthetic and real-word datasets have verified the efficiency and scalability of our method, which outperforms the state-of-the-art subgraph matching method S2X by one order of magnitude.</p>   </section>  </section>  <section class="back-matter">   <section id="sec-11">    <header>     <div class="title-info">     <h2>ACKNOWLEDGMENTS</h2>     </div>    </header>    <p>This work is supported by the National Natural Science Foundation of China (61572353, 61672377) and the Natural Science Foundation of Tianjin (17JCYBJC15400).</p>   </section>   <section id="ref-001">    <header>     <div class="title-info">     <h2 class="page-brake-head">REFERENCES</h2>     </div>    </header>    <ul class="bibUl">     <li id="BibPLXBIB0001" label="[1]">Alexander Sch&#x00E4;tzle, Martin Przyjaciel-Zablocki, Thorsten Berberich, and Georg Lausen. 2015. S2X: graph-parallel querying of RDF with GraphX. In <em>      <em>VLDB Workshop on Big Graphs Online Querying</em>     </em>. Springer, 155&#x2013;168.</li>     <li id="BibPLXBIB0002" label="[2]">Yingxia Shao, Bin Cui, Lei Chen, Lin Ma, Junjie Yao, and Ning Xu. 2014. Parallel subgraph listing in a large-scale graph. In <em>      <em>Proc. SIGMOD</em>     </em>. ACM, 625&#x2013;636.</li>     <li id="BibPLXBIB0003" label="[3]">Zhao Sun, Hongzhi Wang, Haixun Wang, Bin Shao, and Jianzhong Li. 2012. Efficient subgraph matching on billion node graphs. <em>      <em>Proceedings of the VLDB Endowment</em>     </em>5, 9 (2012), 788&#x2013;799.</li>    </ul>   </section>  </section>  <section id="foot-001" class="footnote">   <header>    <div class="title-info">     <h2>FOOTNOTE</h2>    </div>   </header>   <p id="fn1"><a href="#foot-fn1"><sup>&#x204E;</sup></a>Xin Wang is the corresponding author.</p>   <div class="bibStrip">    <p>This paper is published under the Creative Commons Attribution 4.0 International (CC-BY&#x00A0;4.0) license. Authors reserve their rights to disseminate the work on their personal and corporate Web sites with the appropriate attribution.</p>    <p>     <em>WWW '18, April 23-27, 2018, Lyon, France</em>    </p>    <p>&#x00A9; 2018; IW3C2 (International World Wide Web Conference Committee), published under Creative Commons CC-BY&#x00A0;4.0 License. ACM ISBN 978-1-4503-5640-4/18/04.<br/>DOI: <a class="link-inline force-break" target="_blank"     href="https://doi.org/10.1145/3184558.3186907">https://doi.org/10.1145/3184558.3186907</a>    </p>   </div>  </section>  <div class="pubHistory">   <p/>  </div>  </body> </html> 
