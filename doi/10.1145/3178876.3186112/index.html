<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta name="generator" content=
  "HTML Tidy for HTML5 for Linux version 5.7.16" />
  <title>Mining Tours and Paths in Activity Networks</title>
  <!-- Copyright (c) 2010-2015 The MathJax Consortium -->
  <meta http-equiv="Content-Type" content=
  "text/html; charset=utf-8" />
  <meta name="viewport" content=
  "width=device-width; initial-scale=1.0;" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="screen, print" rel="stylesheet" href=
  "../../../data/dl.acm.org/pubs/lib/css/bootstrap.min.css" />
  <link media="screen, print" rel="stylesheet" href=
  "../../../data/dl.acm.org/pubs/lib/css/bootstrap-theme.min.css" />
  <link media="screen, print" rel="stylesheet" href=
  "../../../data/dl.acm.org/pubs/lib/css/main.css" />
  <script src="../../../data/dl.acm.org/pubs/lib/js/jquery.min.js" type=
  "text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/bootstrap.min.js"
  type="text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/bibCit.js" type=
  "text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/divTab.js" type=
  "text/javascript"></script>
  <script type="text/javascript" src=
  "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>
  <script type="text/x-mathjax-config">
  <![CDATA[
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  ]]>
  </script>
</head>
<body id="main">
  <section class="front-matter">
    <section>
      <header class="title-info">
        <div class="journal-title">
          <h1><span class="title">Mining Tours and Paths in
          Activity Networks</span><br />
          <span class="subTitle"></span></h1>
        </div>
      </header>
      <div class="authorGroup">
        <div class="author">
          <span class="givenName">Sofia Maria</span> <span class=
          "surName">Nikolakaki</span>, Boston University, <a href=
          "mailto:smnikol@bu.edu">smnikol@bu.edu</a>
        </div>
        <div class="author">
          <span class="givenName">Charalampos</span> <span class=
          "surName">Mavroforakis</span>, Boston University,
          <a href="mailto:cmav@bu.edu">cmav@bu.edu</a>
        </div>
        <div class="author">
          <span class="givenName">Alina</span> <span class=
          "surName">Ene</span>, Boston University, <a href=
          "mailto:aene@bu.edu">aene@bu.edu</a>
        </div>
        <div class="author">
          <span class="givenName">Evimaria</span> <span class=
          "surName">Terzi</span>, Boston University, <a href=
          "mailto:evimaria@bu.edu">evimaria@bu.edu</a>
        </div>
      </div><br />
      <div class="pubInfo">
        <p>DOI: <a href="https://doi.org/10.1145/3178876.3186112"
        target=
        "_blank">https://doi.org/10.1145/3178876.3186112</a><br />
        WWW '18: <a href="https://doi.org/10.1145/3178876" target=
        "_blank">Proceedings of The Web Conference 2018</a>, Lyon,
        France, April 2018</p>
      </div>
      <div class="abstract">
        <p><small>The proliferation of online social networks and
        the spread of smart mobile devices enable the collection of
        information related to a multitude of users’ activities.
        These networks, where every node is associated with a type
        of action and a frequency, are usually referred to as
        <em>activity networks</em>. Examples of such networks
        include road networks, where the nodes are intersections
        and the edges are road segments. Each node is associated
        with a number of geo-located actions that users of an
        online platform took in its vicinity. In these networks, we
        define a <em>prize-collecting subgraph</em> to be a
        connected set of nodes, which exhibits high levels of
        activity, and is compact, i.e., the nodes are close to each
        other.</small></p>
        <p><small>The <em>k</em> <font style=
        "font-variant: small-caps">-PCSubgraphs</font> problem we
        address in this paper is defined as follows: given an
        activity network and an integer <em>k</em>, identify <em>k
        non-overlapping</em> and <em>connected</em> subgraphs of
        the network such that the nodes of each subgraph are close
        to each other, and the total number of actions they are
        associated with is high. Here, we define and study two new
        variants of the <em>k</em> <font style=
        "font-variant: small-caps">-PCSubgraphs</font> problem,
        where the subgraphs of interest are tours and paths. Since
        both these problems are NP-hard, we provide approximate and
        heuristic algorithms that run in time
        <em>nearly-linear</em> to the number of edges. In our
        experiments, we use real activity networks obtained by
        combining road networks and projecting on them user
        activity from Twitter and Flickr. Our experimental results
        demonstrate both the efficiency and the practical utility
        of our methods.</small></p>
      </div>
      <div class="classifications">
        <div class="AcmReferenceFormat">
          <p><small><span style="font-weight:bold;">ACM Reference
          Format:</span><br />
          Sofia Maria Nikolakaki, Charalampos Mavroforakis, Alina
          Ene, and Evimaria Terzi. 2018. Mining Tours and Paths in
          Activity Networks. In <em>WWW 2018: The 2018 Web
          Conference,</em> <em>April 23–27, 2018,</em> <em>Lyon,
          France. ACM, New York, NY, USA</em> 10 Pages. <a href=
          "https://doi.org/10.1145/3178876.3186112" class=
          "link-inline force-break" target=
          "_blank">https://doi.org/10.1145/3178876.3186112</a></small></p>
        </div>
      </div>
    </section>
  </section>
  <section class="body">
    <section id="sec-5">
      <header>
        <div class="title-info">
          <h2><span class="section-number">1</span>
          Introduction</h2>
        </div>
      </header>
      <p>Recently, there has been a significant increase in the
      level of user engagement with online platforms, such as
      social networks or content-sharing websites. Simultaneous to
      this, and in part responsible, is the broad availability of
      smart devices. This phenomenon has given rise to a new breed
      of networks, the <em>activity networks</em>. The nodes in
      activity networks are enriched with extra information
      resulting from users’ engagement (typically a list of action
      types and the corresponding counts). For example, in a road
      activity network, the intersections (nodes) can be enriched
      with geo-located posts, photos, or reviews that are being
      published in their vicinity to capture human mobility
      patterns. Another example is that of a social network; each
      user (node) can now be characterized by her aggregate
      activity in many disparate platforms. In these settings, we
      define a <em>prize-collecting subgraph</em> to be a connected
      set of nodes in the network, which is <em>compact</em>, i.e.,
      the nodes are close to each other, and exhibits <em>high
      levels of activity</em>. Intuitively, prize-collecting
      subgraphs can be thought of as parts of the network with
      unusually high levels of activity restricted in a small
      area.</p>
      <p>The <em>k</em> <font style=
      "font-variant: small-caps">-PCSubgraphs</font> problem we
      address in this paper is defined as follows: given an
      activity network <em>G</em> = (<em>V</em>, <em>E</em>), the
      edge cost and the node prize values, and an integer
      <em>k</em>, identify <em>k non-overlapping</em> and
      <em>connected</em> subgraphs of <em>G</em>, such that each
      subgraph consists of nodes that are highly active and close
      to each other. The case where the subgraphs are required to
      be trees has been studied extensively in the past both for
      <em>k</em> = 1, known as the Prize Collecting Steiner Tree
      (<font style=
      "font-variant: small-caps">PCST</font>)&nbsp;[<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0010">10</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0011">11</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0013">13</a>] problem, and for
      <em>k</em> &gt; 1, known as the Prize Collecting Steiner
      Forest (<em>k</em> <font style=
      "font-variant: small-caps">-PCSF</font>)
      problem&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0012">12</a>]. In this paper, we introduce and
      study two new variants of the <em>k</em> <font style=
      "font-variant: small-caps">-PCSubgraphs</font> problem, where
      we require the subgraphs to be (1) tours, and (2) paths. We
      refer to these variants as the <em>k</em> <font style=
      "font-variant: small-caps">-PCTours</font> and the <em>k</em>
      <font style="font-variant: small-caps">-PCPaths</font>
      problem respectively.</p>
      <p>To the best of our knowledge, we are the first to propose
      <em>k</em> <font style=
      "font-variant: small-caps">-PCTours</font> and <em>k</em>
      <font style="font-variant: small-caps">-PCPaths</font>. Prior
      work on these problems&nbsp;[<a class="bib" data-trigger=
      "hover" data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0001">1</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0002">2</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0004">4</a>], has studied only the variant of a
      single tour or path over points in a metric space. Here, we
      extend the definition for <em>k</em> tours and paths to go
      beyond metric spaces and, use the connection between
      <em>k</em> <font style=
      "font-variant: small-caps">-PCTours</font> and <em>k</em>
      <font style="font-variant: small-caps">-PCPaths</font> with
      <em>k</em> <font style=
      "font-variant: small-caps">-PCSF</font> to design efficient
      algorithms for solving them.</p>
      <p>Our methods for both problems use a nearly-linear time
      algorithm for <em>k</em> <font style=
      "font-variant: small-caps">-PCSF</font>&nbsp;[<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0012">12</a>] as a building block. This
      algorithm is linear in the number of edges and logarithmic to
      the number of nodes. As a result, and given that the number
      of subgraphs we seek to find is much smaller than the number
      of nodes, our algorithms also run in time nearly-linear to
      the number of edges in the network.</p>
      <p>The <em>k</em> <font style=
      "font-variant: small-caps">-PCTours</font> and the <em>k</em>
      <font style="font-variant: small-caps">-PCPaths</font>
      problems arise in many applications, including road activity
      networks, which is also the main focus of this paper. In this
      application, tours and paths correspond to routes that users
      follow as they travel in a city. For instance, as a tourist,
      it makes sense to know <em>k</em> paths that are short enough
      and along which people have captured many beautiful
      pictures&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0019">19</a>].</p>
      <p>For our experiments, we compile real activity networks; we
      start with the road networks of three major cities in the US
      and project on them geo-located posts and photos from Twitter
      and Flickr respectively. We demonstrate the efficacy and the
      efficiency of our algorithms in optimizing our objectives,
      and present some of the notable subgraphs that are
      uncovered.</p>
      <p>Our paper is closely related to the work of
      Rozenshtein&nbsp;et al. &nbsp;[<a class="bib" data-trigger=
      "hover" data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0020">20</a>], where they also analyze activity
      networks. The key difference from our work is that their aim
      is to find a single tree, while we focus on finding multiple
      subgraphs in the forms of tours or paths. Our contributions
      are summarized as follows:</p>
      <ul class="list-no-style">
        <li id="list1" label="•">We propose an algorithmic
        framework for identifying <em>multiple</em>,
        <em>high-activity</em> subgraphs in activity networks.
        Moreover, we identify two new problems in this framework,
        namely the <em>k</em> <font style=
        "font-variant: small-caps">-PCTours</font> and the
        <em>k</em> <font style=
        "font-variant: small-caps">-PCPaths</font>
        problems.<br /></li>
        <li id="list2" label="•">We design approximation and
        heuristic algorithms for both problems. These are motivated
        by the connection between our problems and <em>k</em>
        <font style="font-variant: small-caps">-PCSF</font>. In
        fact, we extend the algorithm for <em>k</em> <font style=
        "font-variant: small-caps">-PCSF</font> by introducing fast
        dynamic-programming methods on trees. As a result, for the
        cases where the number of subgraphs is small, we get an
        almost linear-time algorithm for both of our
        problems.<br /></li>
        <li id="list3" label="•">In our extensive experiments with
        data that record users’ social network activity in
        different US cities, we demonstrate the efficiency and the
        efficacy of our methods at discovering interesting routes
        that people follow in their cities.<br /></li>
      </ul>
      <p><strong>Roadmap:</strong> In Section&nbsp;<a class="sec"
      href="#sec-6">2</a> we describe our general problem
      definition and the two problem variants we consider. In
      Section&nbsp;<a class="sec" href="#sec-10">3</a> we describe
      the algorithms we design to solve our problems. We
      experimentally evaluate our solutions in
      Section&nbsp;<a class="sec" href="#sec-13">4</a> and discuss
      related work in Section&nbsp;<a class="sec" href=
      "#sec-20">5</a>. We conclude the paper in
      Section&nbsp;<a class="sec" href="#sec-21">6</a>.</p>
    </section>
    <section id="sec-6">
      <header>
        <div class="title-info">
          <h2><span class="section-number">2</span> Problem
          definitions</h2>
        </div>
      </header>
      <p>In this section, we provide the definitions and the
      notational conventions we use throughout the paper. We also
      formally define our problems and discuss their
      complexity.</p>
      <section id="sec-7">
        <header>
          <div class="title-info">
            <h3><span class="section-number">2.1</span>
            Preliminaries</h3>
          </div>
        </header>
        <p>Throughout the paper, we assume that our input consists
        of a weighted undirected graph <em>G</em> = (<em>V</em>,
        <em>E</em>, <em>c</em>, <em>π</em>), where <em>V</em> is a
        set of <em>n</em> nodes and <em>E</em> is a set of
        <em>m</em> edges. Each edge <em>e</em> ∈ <em>E</em> is
        associated with a non-negative <em>edge cost
        c</em>(<em>e</em>) ≥ 0, and each node <em>v</em> ∈
        <em>V</em> has a non-negative <em>vertex prize
        π</em>(<em>v</em>) ≥ 0. One can think of the cost of an
        edge as a measure of the distance between the nodes it
        connects. The prize of a vertex is the intensity level of
        the activity observed in the corresponding vertex, e.g.,
        the number of tweets, the number of photo uploads, etc. We
        refer to this graph as the <em>activity network</em>.</p>
        <p>We also use the following conventions: Given
        <em>S</em>⊆<em>V</em>, we use <em>G</em>[<em>S</em>] to
        denote the subgraph of <em>G induced</em> by <em>S</em>.
        This is the subgraph with nodes <em>S</em> and edges
        <em>E</em>[<em>S</em>]⊆<em>E</em>, such that the endpoints
        of every edge in <em>E</em>[<em>S</em>] are two nodes in
        <em>S</em>. Thus, <em>G</em>[<em>S</em>] = (<em>S</em>,
        <em>E</em>[<em>S</em>], <em>c</em>, <em>π</em>).
        Furthermore, we refer to the prize of <em>S</em> as the sum
        of the prizes of the nodes in <em>S</em>. That is,
        <em>π</em>(<em>S</em>) = ∑ <sub><em>v</em> ∈
        <em>S</em></sub> <em>π</em>(<em>v</em>). Also, we use
        <span class="inline-equation"><span class=
        "tex">$\overline{S}$</span></span> to denote the complement
        of <em>S</em> with respect to <em>V</em>, i.e.,
        <span class="inline-equation"><span class=
        "tex">$\overline{S}= V \setminus S$</span></span> .
        Finally, for <em>E</em>′⊆<em>E</em>, we refer to the sum of
        the costs of the edges in <em>E</em>′ as the cost of the
        set <em>E</em>′. That is, <span class=
        "inline-equation"><span class="tex">$c(E^{\prime }) = \sum
        _{e\in E^{\prime }} c(e)$</span></span> .</p>
        <p>We use the following definitions for tours and paths on
        a graph. A <em>tour</em> is a node sequence in which any
        two consecutive nodes are connected with an edge, and in
        which the last node is the same as the first. A
        <em>path</em> is a sequence of edges that connect a
        sequence of nodes. Each node may only appear in the path at
        most once.</p>
      </section>
      <section id="sec-8">
        <header>
          <div class="title-info">
            <h3><span class="section-number">2.2</span> The
            <em>k</em> <font style=
            "font-variant: small-caps">-PCSubgraphs</font>
            problem</h3>
          </div>
        </header>
        <p>The general problem that we address in this paper can be
        defined as follows: given a graph <em>G</em> = (<em>V</em>,
        <em>E</em>, <em>c</em>, <em>π</em>) and a positive integer
        <em>k</em>, identify <em>k connected</em> and
        <em>non-overlapping</em> subgraphs of <em>G</em>, each of
        which includes nodes with high prize and low-cost edges.
        This is formally expressed as follows:</p>
        <div class="problem" id="enc1">
          <label>Problem 1 (<em>k</em><font style=
          "font-variant: small-caps">-PCSubgraphs</font>).</label>
          <p>Given a graph <em>G</em> = (<em>V</em>, <em>E</em>,
          <em>c</em>, <em>π</em>), a positive integer <em>k</em>
          and <em>λ</em> ∈ <em>R</em> <sup>+</sup>, find a set of
          subgraphs <span class="inline-equation"><span class=
          "tex">$\mathcal {G}=\lbrace G_1, \ldots , G_k
          \rbrace$</span></span> with <span class=
          "inline-equation"><span class=
          "tex">$G_i=(V_{G_i},E_{G_i})$</span></span> , such
          that</p>
          <div class="table-responsive" id="eq1">
            <div class="display-equation">
              <span class="tex mytex">\begin{equation} \sum _{e \in
              \bigcup _i \lbrace E_{G_i} \rbrace }{c(e)} + \lambda
              \sum _{v \in V \setminus \bigcup _i \lbrace V_{G_i}
              \rbrace }{\pi (v)} \end{equation}</span><br />
              <span class="equation-number">(1)</span>
            </div>
          </div>is minimized.
          <p></p>
        </div>
        <p>In the above definition, <em>λ</em> is a
        <em>normalization coefficient</em> that expresses our bias
        between the prizes and the costs. One can also think of
        <em>λ</em> as a way to convert the two quantities, which
        are defined in different scales, into the same units.</p>
        <p>We study the following two instantiations of the
        <em>k</em> <font style=
        "font-variant: small-caps">-PCSubgraphs</font> problem:
        when the subgraphs are required to be tours, we refer to
        this setting as the <em>k</em> <font style=
        "font-variant: small-caps">-PCTours</font> problem, and
        when the subgraphs are required to be paths as the
        <em>k</em> <font style=
        "font-variant: small-caps">-PCPaths</font> problem.</p>
        <p>The <em>k</em> <font style=
        "font-variant: small-caps">-PCTours</font> problem is
        NP-hard, as it was shown to be NP-hard already when
        <em>k</em> = 1 by a reduction from the Traveling Salesman
        Problem problem&nbsp;[<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0001">1</a>]. As a result, we can only hope to
        approximate this problem in polynomial time. The <em>k</em>
        <font style="font-variant: small-caps">-PCPaths</font>
        problem is also NP-hard by a reduction from the Min-Cost
        Hamiltonian Path problem&nbsp;[<a class="bib" data-trigger=
        "hover" data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0001">1</a>] and although it can be approximated
        for metric spaces it is inapproximable for general
        graphs&nbsp;[<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0001">1</a>]. Since we focus on general graphs,
        the algorithms we design for this problem cannot have
        bounded approximation factors.</p>
      </section>
      <section id="sec-9">
        <header>
          <div class="title-info">
            <h3><span class="section-number">2.3</span> The
            <em>k</em> <font style=
            "font-variant: small-caps">-PCSF</font> problem</h3>
          </div>
        </header>
        <p>A well known variant of Problem&nbsp;<a class="enc"
        href="#enc1">1</a>, restricts the subgraphs to be
        <em>trees</em>. When <em>k</em> = 1, this problem is known
        as the <em>Prize Collecting Steiner Tree</em> (<font style=
        "font-variant: small-caps">PCST</font>) problem. When
        <em>k</em> &gt; 1, we will refer to the problem as the
        <em>k</em> <font style=
        "font-variant: small-caps">-PCSF</font> problem. The
        <font style="font-variant: small-caps">PCST</font> problem
        admits a factor-2 approximation&nbsp;[<a class="bib"
        data-trigger="hover" data-toggle="popover" data-placement=
        "top" href="#BibPLXBIB0010">10</a>, <a class="bib"
        data-trigger="hover" data-toggle="popover" data-placement=
        "top" href="#BibPLXBIB0011">11</a>, <a class="bib"
        data-trigger="hover" data-toggle="popover" data-placement=
        "top" href="#BibPLXBIB0013">13</a>]. The most recent of
        these algorithms runs in time
        <em>O</em>(<em>dm</em>log <em>n</em>)&nbsp;[<a class="bib"
        data-trigger="hover" data-toggle="popover" data-placement=
        "top" href="#BibPLXBIB0011">11</a>], where <em>d</em> is
        the number of bits used to represent the cost and prize
        values. In a later paper, Hegde et al.&nbsp;[<a class="bib"
        data-trigger="hover" data-toggle="popover" data-placement=
        "top" href="#BibPLXBIB0012">12</a>] show that a small
        modification of the initial algorithm they provided
        in&nbsp;[<a class="bib" data-trigger="hover" data-toggle=
        "popover" data-placement="top" href=
        "#BibPLXBIB0011">11</a>] gives a factor-2 approximation for
        the <em>k</em> <font style=
        "font-variant: small-caps">-PCSF</font> problem. We refer
        to this algorithm as the <tt>kTrees</tt> algorithm and we
        use it as a building block for the rest of the paper.</p>
      </section>
    </section>
    <section id="sec-10">
      <header>
        <div class="title-info">
          <h2><span class="section-number">3</span> Algorithms</h2>
        </div>
      </header>
      <p>In this section, we describe our algorithms for the
      <em>k</em> <font style=
      "font-variant: small-caps">-PCTours</font> and the <em>k</em>
      <font style="font-variant: small-caps">-PCPaths</font>
      problems. Since all these problems are NP-hard our algorithms
      only aim to provide approximate solutions.</p>
      <section id="sec-11">
        <header>
          <div class="title-info">
            <h3><span class="section-number">3.1</span> Solving the
            <em>k</em> <font style=
            "font-variant: small-caps">-PCTours</font> problem</h3>
          </div>
        </header>
        <figure id="fig1">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3186112/images/www2018-121-fig1.jpg"
          class="img-responsive" alt="" longdesc="" />
        </figure>
        <p>Here, we introduce a 4-approximation algorithm for the
        solution of the <em>k</em> <font style=
        "font-variant: small-caps">-PCTours</font> problem. We
        refer to this algorithm as <tt>kTours</tt> and present its
        outline in Algorithm&nbsp;1.</p>
        <p><tt>kTours</tt> operates in two steps; first, it calls
        <tt>kTrees</tt> in order to find a set <span class=
        "inline-equation"><span class="tex">$\mathcal
        {F}$</span></span> of <em>k</em> trees in <em>G</em>. Then,
        for each of these trees <span class=
        "inline-equation"><span class="tex">$T_i \in \mathcal
        {F}$</span></span> , it isolates the subgraph of <em>G</em>
        that includes all edges induced by the nodes of
        <em>T<sub>i</sub></em> , i.e., <span class=
        "inline-equation"><span class=
        "tex">$G[V_{T_i}]$</span></span> , and finds a tour that
        visits all of <em>T<sub>i</sub></em> ’s nodes.</p>
        <p>We refer to the method that designs a tour on a
        connected graph as <tt>FindTour</tt>. First, the algorithm
        transforms the input graph into an <em>Eulerian</em> one by
        doubling all its edges. Now the graph <span class=
        "inline-equation"><span class=
        "tex">$G[V_{T_i}]$</span></span> has an Eulerian tour
        <em>τ</em>, which is drawn by picking an arbitrary node in
        the Eulerian graph and executing a <em>depth-first search
        while reporting the visited edges. Tour <em>τ</em> visits
        some of the nodes multiple times. The edges however are
        visited only once due to the edge doubling of the previous
        step. Whenever, a tour picks both an edge and its copy, the
        cost of the specific edge will contribute twice to the
        total cost of the tour.</em> The running time of
        <tt>kTours</tt> is <em>O</em>(<em>dm</em>log <em>n</em> +
        <em>m</em> + <em>n</em>).</p>
        <p>Our result for the approximation factor of
        <tt>kTours</tt> is based on the following lemma.</p>
        <div class="lemma" id="enc2">
          <label>Lemma 3.1.</label>
          <p>Given a graph <em>G</em> = (<em>V</em>, <em>E</em>,
          <em>c</em>, <em>π</em>), an integer <em>k</em> &gt; 0 and
          <em>λ</em> ∈ R<sup>+</sup>, the cost of the optimal
          solution of <em>k</em> <font style=
          "font-variant: small-caps">-PCSF</font> is less than or
          equal to the cost of the optimal solution of <em>k</em>
          <font style="font-variant: small-caps">-PCTours</font>.
          That is,</p>
          <div class="table-responsive" id="eq2">
            <div class="display-equation">
              <span class="tex mytex">\begin{eqnarray} {\rm
              O}{\rm\small PT}_{k{\rm\small -PCSF}} \le {\rm
              O}{\rm\small PT}_{k{\rm\small -PCTours}}
              \end{eqnarray}</span><br />
              <span class="equation-number">(2)</span>
            </div>
          </div>
          <p></p>
        </div>
        <div class="proof" id="proof1">
          <label>Proof.</label>
          <p>Let us denote with <span class=
          "inline-equation"><span class="tex">$\mathcal
          {R}^*=\lbrace \tau _1, \ldots , \tau
          _k\rbrace$</span></span> the optimal solution for
          <em>k</em> <font style=
          "font-variant: small-caps">-PCTours</font> on <em>G</em>.
          Now, let us generate a solution <span class=
          "inline-equation"><span class="tex">$\mathcal {F}=\lbrace
          T_1, \ldots , T_k\rbrace$</span></span> for <em>k</em>
          <font style="font-variant: small-caps">-PCSF</font> on
          <em>G</em> in the following way; for each connected
          component <span class="inline-equation"><span class=
          "tex">$\tau _i \in \mathcal {R}^*$</span></span> , let
          <em>T<sub>i</sub></em> be the <em>minimum spanning
          tree</em> on <em>τ<sub>i</sub></em> . Then,
          <em>π</em>(<em>T<sub>i</sub></em> ) =
          <em>π</em>(<em>τ<sub>i</sub></em> ), while
          <em>c</em>(<em>T<sub>i</sub></em> ) &lt;
          <em>c</em>(<em>τ<sub>i</sub></em> ). The cost of the
          optimal solution <span class=
          "inline-equation"><span class="tex">$\mathcal
          {F}^*$</span></span> for <em>k</em> <font style=
          "font-variant: small-caps">-PCSF</font> is <span class=
          "inline-equation"><span class="tex">${\it cost}(\mathcal
          {F}^*) \le {\it cost}(\mathcal {F}) {\lt} {\it
          cost}(\mathcal {R}^*)$</span></span> , where
          <em>cost</em>(·) corresponds to Equation&nbsp;(<a class=
          "eqn" href="#eq1">1</a>).</p>
        </div>
        <p>Given the above lemma, we have the following result:</p>
        <div class="theorem" id="enc3">
          <label>Theorem 3.2.</label>
          <p><tt>kTours</tt> is a 4-approximation algorithm for the
          <em>k</em> <font style=
          "font-variant: small-caps">-tours</font> problem.</p>
        </div>
        <div class="proof" id="proof2">
          <label>Proof.</label>
          <p>Given a graph <em>G</em> = (<em>V</em>, <em>E</em>,
          <em>c</em>, <em>π</em>), an integer <em>k</em> &gt; 0 and
          <em>λ</em> ∈ <em>R</em> <sup>+</sup>, let <span class=
          "inline-equation"><span class="tex">$\mathcal {F}=
          \lbrace T_1, \ldots , T_k \rbrace$</span></span> be the
          solution returned by the <tt>kTrees</tt> algorithm, and
          <span class="inline-equation"><span class="tex">$\mathcal
          {R}=\lbrace \tau _1, \ldots , \tau _k
          \rbrace$</span></span> be the tours returned by
          <tt>kTours</tt> on <em>G</em>. Notice that, by
          construction, <em>τ<sub>i</sub></em> is a tour visiting
          <span class="inline-equation"><span class=
          "tex">$V_{T_i}$</span></span> . Also,
          <em>c</em>(<em>τ<sub>i</sub></em> ) ≤
          2<em>c</em>(<em>T<sub>i</sub></em> ), for all
          <span class="inline-equation"><span class="tex">$T_i \in
          \mathcal {F}$</span></span> , because, in the worst case,
          <em>τ<sub>i</sub></em> traverses each edge in
          <span class="inline-equation"><span class=
          "tex">$E_{T_i}$</span></span> twice. Furthermore,
          <em>π</em>(<em>τ<sub>i</sub></em> ) =
          <em>π</em>(<em>T<sub>i</sub></em> ), because
          <em>τ<sub>i</sub></em> visits all the nodes of
          <em>T<sub>i</sub></em> . Consequently,</p>
          <div class="table-responsive" id="eq3">
            <div class="display-equation">
              <span class="tex mytex">\begin{eqnarray} {\it
              cost}(\mathcal {R}) = &amp;\lambda \pi (V) + \sum
              _{i=1}^k {c(\tau _i) - \lambda \pi (\tau _i)}
              \end{eqnarray}</span><br />
              <span class="equation-number">(3)</span>
            </div>
          </div>
          <div class="table-responsive" id="eq4">
            <div class="display-equation">
              <span class="tex mytex">\begin{eqnarray} &amp;\le
              \lambda \pi (V) + \sum _{i=1}^k {2 c(T_i) - \lambda
              \pi (T_i)} \end{eqnarray}</span><br />
              <span class="equation-number">(4)</span>
            </div>
          </div>
          <div class="table-responsive" id="eq5">
            <div class="display-equation">
              <span class="tex mytex">\begin{eqnarray} &amp;\le 2
              \left(\lambda \pi (V) + \sum _{i=1}^k {c(T_i) -
              \lambda \pi (T_i)} \right)\end{eqnarray}</span><br />
              <span class="equation-number">(5)</span>
            </div>
          </div>
          <div class="table-responsive" id="eq6">
            <div class="display-equation">
              <span class="tex mytex">\begin{eqnarray} &amp; \le 4
              \left(\lambda \pi (V) + \sum _{i=1}^k (c(T^*_i) -
              \lambda \pi (T^*_i)
              \right)\end{eqnarray}</span><br />
              <span class="equation-number">(6)</span>
            </div>
          </div>
          <div class="table-responsive" id="eq7">
            <div class="display-equation">
              <span class="tex mytex">\begin{eqnarray} &amp; = 4
              {{\rm O}{\rm\small PT}}_{{{\it k}{\rm\small -PCSF}}}
              \end{eqnarray}</span><br />
              <span class="equation-number">(7)</span>
            </div>
          </div>
          <div class="table-responsive" id="eq8">
            <div class="display-equation">
              <span class="tex mytex">\begin{eqnarray} &amp; \le 4
              {{\rm O}{\rm\small PT}}_{{{\it k}{\rm -PCT{\small
              OURS}}}} \end{eqnarray}</span><br />
              <span class="equation-number">(8)</span>
            </div>
          </div>where <span class="inline-equation"><span class=
          "tex">$\mathcal {F}^* =\lbrace T^*_1, \ldots , T^*_k
          \rbrace$</span></span> is the optimal solution for the
          <em>k</em> <font style=
          "font-variant: small-caps">-trees</font> on <em>G</em>.
          The last step above is due to Lemma&nbsp;<a class="enc"
          href="#enc2">3.1</a>. Notice also that
          Equation&nbsp;(<a class="eqn" href="#eq5">5</a>) holds
          because <span class="inline-equation"><span class=
          "tex">$\pi (V) - \sum _{i=1}^k {\pi (T_i)} \ge
          0$</span></span> , and Equation&nbsp;(<a class="eqn"
          href="#eq6">6</a>) is because <tt>kTrees</tt> is a
          <em>2-approximation</em> algorithm to <em>k</em>
          <font style=
          "font-variant: small-caps">-PCSF</font>&nbsp;[<a class=
          "bib" data-trigger="hover" data-toggle="popover"
          data-placement="top" href="#BibPLXBIB0012">12</a>].
          <p></p>
        </div>
      </section>
      <section id="sec-12">
        <header>
          <div class="title-info">
            <h3><span class="section-number">3.2</span> Solving the
            <em>k</em> <font style=
            "font-variant: small-caps">-PCPaths</font> problem</h3>
          </div>
        </header>
        <p>Our algorithm for the <em>k</em> <font style=
        "font-variant: small-caps">-PCPaths</font> problem,
        <tt>kPaths</tt>, can be broken down into two main
        components. It starts by using <tt>kTrees</tt> to build a
        collection <span class="inline-equation"><span class=
        "tex">$\mathcal {F}$</span></span> of trees. Then, it
        executes <tt>FindPaths</tt> (Algorithm&nbsp;3) on
        <span class="inline-equation"><span class="tex">$\mathcal
        {F}$</span></span> to select a set <span class=
        "inline-equation"><span class="tex">$\mathcal
        {P}$</span></span> of <em>k</em> paths. The total
        complexity of <tt>kPaths</tt> is
        <em>O</em>(<em>dm</em>log <em>n</em> + <em>kn</em> +
        <em>k</em> <sup>2</sup>). Before we discuss the details of
        this algorithm however, let us first present its building
        blocks.</p>
        <p><strong>Solving</strong> <em>k</em> <font style=
        "font-variant: small-caps">-PCPaths</font> <strong>on a
        binary tree:</strong> Let's assume that the <tt>kTrees</tt>
        algorithm returns a single <em>binary</em> tree <em>T</em>
        = (<em>V<sub>T</sub></em> , <em>E<sub>T</sub></em> ). We
        will later discuss how to relax the restrictions, both on
        the number as well as on the type of the trees. Here, we
        show how one can find the <em>k</em> best paths in
        <em>T</em>, i.e., the <em>k</em> paths which together
        minimize the cost presented in Equation&nbsp;(<a class=
        "eqn" href="#eq1">1</a>). To this end, we develop a
        <em>dynamic-programming</em> algorithm that runs in time
        <em>O</em>(<em>kn</em> + <em>k</em> <sup>2</sup>).</p>
        <p>As a first step, we arbitrarily pick a node <em>r</em> ∈
        <em>V<sub>T</sub></em> to be the <em>root</em> of
        <em>T</em>. We use the notation <em>T<sub>v</sub></em> to
        refer to the subtree of <em>T</em> that is rooted at a
        particular node <em>v</em> ∈ <em>V<sub>T</sub></em> . We
        also define the set
        <em>succ</em>(<em>v</em>)⊆<em>V<sub>T</sub></em> to be the
        set of nodes that are immediate successors of <em>v</em> in
        <em>T</em>. When <em>v</em> has only two children, we
        denote them as <em>v<sub>l</sub></em> and
        <em>v<sub>r</sub></em> .</p>
        <p>In general, paths in trees can be partitioned into two
        categories; those which use only
        <em>ancestor-to-descendant</em> edges and those that
        connect two siblings through their direct and common
        ancestor. We will call the former paths <em>vertical</em>
        and the latter <em>horizontal</em>. We illustrate examples
        of such paths using the tree in Figure&nbsp;<a class="fig"
        href="#fig4">1</a>. There, <span class=
        "inline-equation"><span class="tex">$\texttt
        {a-b-f}$</span></span> is a vertical path, while
        <span class="inline-equation"><span class="tex">$\texttt
        {c-a-e}$</span></span> is a horizontal path. Intuitively,
        our algorithm iteratively computes the cost of the best
        vertical and the best horizontal path in each subtree of
        <em>T</em>, starting from the leaves and moving towards the
        root.</p>
        <figure id="fig2">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3186112/images/www2018-121-fig2.jpg"
          class="img-responsive" alt="" longdesc="" />
        </figure>
        <figure id="fig3">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3186112/images/www2018-121-fig3.jpg"
          class="img-responsive" alt="" longdesc="" />
        </figure>
        <p></p>
        <p>For each node <em>v</em> ∈ <em>V<sub>T</sub></em> we
        define the following sub-problems:</p>
        <ul class="list-no-style">
          <li id="list4" label="•"><em>D</em>(<em>v</em>,
          <em>k</em>) is the minimum cost of picking <em>k</em>
          paths in <em>T<sub>v</sub></em> , given that a
          <em>vertical</em> path includes <em>v</em> as an
          endpoint.<br /></li>
          <li id="list5" label="•"><em>H</em>(<em>v</em>,
          <em>k</em>) is the minimum cost of picking <em>k</em>
          paths in <em>T<sub>v</sub></em> , given that <em>v</em>
          is included in a <em>horizontal</em> path.<br /></li>
          <li id="list6" label="•"><em>B</em>(<em>v</em>,
          <em>k</em>) is the minimum cost of picking <em>k</em>
          paths in <em>T<sub>v</sub></em> , given that <em>v</em>
          is not included in any path.<br /></li>
          <li id="list7" label="•"><em>L</em>(<em>v</em>,
          <em>k</em>) is the minimum cost of picking <em>k</em>
          paths in <em>T<sub>v</sub></em> .<br /></li>
        </ul>
        <p>Notice that the algorithm runs recursively in a
        bottom-up manner, i.e., examining the nodes from the leaves
        to the root. For all <em>v</em> ∈ <em>V</em> and <em>k</em>
        = 0, we initialize the cost of all sub-problems with
        <span class="inline-equation"><span class="tex">$\sum
        _{u\in T_v \setminus \lbrace v\rbrace }\pi
        (u)$</span></span> . For the leaf nodes we consider two
        cases; i) for <em>k</em> ≥ 1 and <em>k</em> &gt; 1,
        sub-problems <em>H</em> and <em>B</em>, and sub-problems
        <em>D</em> and <em>L</em>, respectively, are not defined so
        the cost at the leaf nodes is initialized to ∞, ii) for
        <em>k</em> = 1, the solution of sub-problems <em>D</em> and
        <em>L</em> is the node itself, so the cost is initialized
        to 0.</p>
        <p>When computing <em>D</em>(<em>v</em>, <em>k</em>), we
        need to compare between including <em>v</em> in a path on
        its own or connecting it with one of its successors, either
        to the left or to the right. That is,</p>
        <div class="table-responsive" id="eq9">
          <div class="display-equation">
            <span class="tex mytex">\begin{equation} D(v,k) = \min
            \left\lbrace \begin{array}{l}\min \limits _{k_l+k_r =
            k-1} L(v_l,k_l)+L(v_r,k_r) \\\\ \min \limits
            _{{{\scriptstyle {\begin{array}{*10c}k_l+k_r = k \\k_l
            {\gt} 0
            \end{array}}}}}D(v_l,k_l)+c(v,v_l)+L(v_r,k_r)\\\\ \min
            \limits _{{{\scriptstyle {\begin{array}{*10c}k_l+k_r =
            k \\k_r {\gt} 0
            \end{array}}}}}L(v_l,k_l)+c(v,v_r)+D(v_r,k_r)
            \end{array} \right\rbrace \end{equation}</span><br />
            <span class="equation-number">(9)</span>
          </div>
        </div>We use <em>k<sub>l</sub></em> and
        <em>k<sub>r</sub></em> to denote the budget that we
        allocate to the left and right child of <em>v</em>
        respectively.
        <figure id="fig4">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3186112/images/www2018-121-fig4.jpg"
          class="img-responsive" alt="Figure 4" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 1:</span>
            <span class="figure-title">A general tree to illustrate
            different types of paths.</span>
          </div>
        </figure>
        <p></p>
        <p>Next, <em>H</em>(<em>v</em>, <em>k</em>) considers
        <em>k</em> paths in the subtree <em>T<sub>v</sub></em> ,
        requiring that <em>v</em> participates in exactly one
        horizontal path. As a result, we need to pick how to split
        <em>k</em> between the left and right child of <em>v</em>.
        Using <em>D</em>(<em>v<sub>l</sub></em> ,
        <em>k<sub>l</sub></em> ) and
        <em>D</em>(<em>v<sub>r</sub></em> , <em>k<sub>r</sub></em>
        ), and constraining both <em>k<sub>l</sub></em> and
        <em>k<sub>r</sub></em> to be positive, we make sure that
        both <em>v<sub>l</sub></em> and <em>v<sub>r</sub></em>
        participate in exactly one vertical path. Otherwise, we
        would not be able to draw a horizontal path through
        <em>v</em>.</p>
        <div class="table-responsive" id="eq10">
          <div class="display-equation">
            <span class="tex mytex">\begin{equation} H(v,k) = \min
            \limits _{{{\scriptstyle {\begin{array}{*10c}k_l+k_r =
            k+1 \\k_r,k_l {\gt} 0
            \end{array}}}}}D(v_l,k_l)+D(v_r,k_r)+c(v,v_r)+c(v,v_l)
            \end{equation}</span><br />
            <span class="equation-number">(10)</span>
          </div>
        </div>Notice that we require <em>k<sub>l</sub></em> +
        <em>k<sub>r</sub></em> = <em>k</em> + 1. This is because,
        in order to have <em>k</em> paths in total with <em>v</em>
        being part of a horizontal path, we need the left and the
        right child of <em>v</em> to have <em>k</em> + 1 paths
        below them. This way, <em>v</em> will consume exactly two
        of them for a new horizontal path, which will bring the
        total number of paths down to <em>k</em>.
        <p></p>
        <p>When computing <em>B</em>(<em>v</em>, <em>k</em>), we
        restrict <em>v</em> from participating in any of the
        <em>k</em> paths in the subtree <em>T<sub>v</sub></em></p>
        <div class="table-responsive" id="eq11">
          <div class="display-equation">
            <span class="tex mytex">\begin{equation} B(v,k) = \pi
            (v) + \min \limits _{k_l+k_r=k}L(v_l,k_l) + L(v_r,k_r)
            \end{equation}</span><br />
            <span class="equation-number">(11)</span>
          </div>
        </div>
        <p></p>
        <p>Finally, <em>L</em>(<em>v</em>, <em>k</em>) reflects the
        cost of the best solution in <em>T<sub>v</sub></em> , by
        deciding between including <em>v</em> in one of the paths
        or not, independently of the type of the path.</p>
        <div class="table-responsive" id="eq12">
          <div class="display-equation">
            <span class="tex mytex">\begin{equation} L(v,k) = \min
            \left\lbrace \begin{array}{c}D(v,k)\\ H(v,k)\\ B(v,k)
            \end{array} \right\rbrace \end{equation}</span><br />
            <span class="equation-number">(12)</span>
          </div>
        </div>We will refer to the algorithm that computes these
        recursive formulas for all the nodes of <em>T</em> as
        <tt>FindPathsOnTree</tt>. To find the cost of the optimal
        selection of <em>k</em> paths on <em>T</em>, we execute
        <tt>FindPathsOnTree</tt> and report <em>L</em>(<em>r</em>,
        <em>k</em>). We can retrieve the solution that optimizes
        this cost in <em>O</em>(<em>k</em> <sup>2</sup> <em>n</em>)
        time.
        <p></p>
        <div class="lemma" id="enc4">
          <label>Lemma 3.3.</label>
          <p><tt>FindPathsOnTree</tt> finds the optimal solution
          for the <em>k</em> <font style=
          "font-variant: small-caps">-PCPaths</font> problem, when
          the input graph is a binary tree.</p>
        </div>
        <p><strong>Solving</strong> <em>k</em> <font style=
        "font-variant: small-caps">-PCPaths</font> <strong>on a
        general tree:</strong>We now show how to enable
        <tt>FindPathsOnTree</tt> to work for general trees. One
        could generalize the previous equations to work for any
        number of children per node. However, if this is
        implemented naively, it would result in an exponential
        running time. Instead, we choose to transform the tree to
        its <em>binary</em> equivalent, which is a common and
        relatively straightforward practice&nbsp;[<a class="bib"
        data-trigger="hover" data-toggle="popover" data-placement=
        "top" href="#BibPLXBIB0008">8</a>, <a class="bib"
        data-trigger="hover" data-toggle="popover" data-placement=
        "top" href="#BibPLXBIB0015">15</a>]. We omit the
        description of this procedure due to space constraints. The
        new tree has at most twice as many nodes as the original
        tree and thus the runtime complexity of
        <tt>FindPathsOnTree</tt> remains <em>O</em>(<em>k</em>
        <sup>2</sup> <em>n</em>).</p>
        <p>Notice that, we need to slightly modify our algorithm to
        ensure that, when run on the binarized version <em>B</em>
        of an arbitrary tree <em>T</em>, <tt>FindPathsOnTree</tt>
        will return the optimal valid paths of <em>T</em>. For
        space reasons, we omit the details of these
        modifications.</p>
        <p><strong>Solving</strong> <em>k</em> <font style=
        "font-variant: small-caps">-PCPaths</font> <strong>on a
        graph:</strong>So far, we have assumed that there is only a
        single tree on which we will select our <em>k</em> paths.
        This is equivalent to executing <tt>kPaths</tt> for
        <em>t</em> = 1. We consider this to be a distinct method,
        <span class="inline-equation"><span class="tex">${\texttt
        {kPaths}(t=1)}$</span></span> , whose purpose becomes clear
        in Section&nbsp;<a class="sec" href="#sec-13">4</a>.
        However, the <tt>kTrees</tt> algorithm may also return a
        set of trees <span class="inline-equation"><span class=
        "tex">$\mathcal {F}$</span></span> , with <span class=
        "inline-equation"><span class="tex">$t = |\mathcal {F}| \ge
        1$</span></span> , which allows us to be more flexible. In
        fact, we can ask <tt>kTrees</tt> to retrieve exactly
        <em>t</em> = <em>k</em> trees, because, in the extreme
        case, we will assign one path per tree. Here, we show how
        to optimally split our budget of <em>k</em> paths between
        the trees in <span class="inline-equation"><span class=
        "tex">$\mathcal {F}$</span></span> , so that we minimize
        the total cost of the solution. This can be achieved by
        another dynamic-programming recursion.</p>
        <p>After running <tt>FindPathsOnTree</tt> on each tree
        <span class="inline-equation"><span class="tex">$T_i \in
        \mathcal {F}$</span></span> for budget <em>k</em>, we know
        the optimal cost <em>L</em>(<em>T<sub>i</sub></em> ,
        <em>κ</em>) of assigning <em>κ</em> paths to
        <em>T<sub>i</sub></em> , for all 0 ≤ <em>κ</em> ≤
        <em>k</em>. The optimal allocation on <span class=
        "inline-equation"><span class="tex">$\mathcal
        {F}$</span></span> can now be calculated using dynamic
        programming: let <em>T</em> <sub>1</sub>, …,
        <em>T<sub>k</sub></em> be a random but fixed ordering on
        the trees in <span class="inline-equation"><span class=
        "tex">$\mathcal {F}$</span></span> , and <span class=
        "inline-equation"><span class="tex">${\rm O}{\rm\small
        PT}(\ell , b)$</span></span> be the optimal allocation of
        <em>b</em> ≤ <em>k</em> paths on the first ℓ trees
        <em>T</em> <sub>1</sub>, …, <em>T</em> <sub>ℓ</sub>. Then
        <span class="inline-equation"><span class="tex">${\rm
        O}{\rm\small PT}(k, k)$</span></span> is the optimal
        solution to our budget assignment problem. This can be
        recursively computed as follows:</p>
        <div class="table-responsive" id="Xeq1">
          <div class="display-equation">
            <span class="tex mytex">\begin{equation} {\rm
            O}{\rm\small PT}(\ell , b) = \min \limits _{0 \le
            b^{\prime } \le b} {\rm O}{\rm\small PT}(\ell - 1, b -
            b^{\prime }) + L(T_\ell , b^{\prime })
            \end{equation}</span><br />
            <span class="equation-number">(13)</span>
          </div>
        </div>We can compute <span class=
        "inline-equation"><span class="tex">${\rm O}{\rm\small
        PT}(k,k)$</span></span> in time <em>O</em>(<em>k</em>
        <sup>2</sup>). The initial conditions of this dynamic
        program are the following; <span class=
        "inline-equation"><span class="tex">${\rm O}{\rm\small
        PT}(T_i,0) = \pi (T_i)$</span></span> and <span class=
        "inline-equation"><span class="tex">${\rm O}{\rm\small
        PT}(T_1,i) = L(T_1, i)$</span></span> , for
        <em>i</em>=1,...,<em>k</em>. We call this algorithm
        <tt>SplitBudget</tt>.
        <p></p>
        <p><strong>Running time complexity of</strong>
        <tt><strong>kPaths</strong></tt> <strong>:</strong>The
        complexity of <tt>kPaths</tt> can be split into two main
        parts; initially it runs <tt>kTrees</tt> to produce a set
        <span class="inline-equation"><span class="tex">$\mathcal
        {F}$</span></span> of trees, which takes
        <em>O</em>(<em>dm</em>log <em>n</em>). Then, it runs
        <tt>FindPaths</tt> to find the paths on the trees. In
        <tt>FindPaths</tt> for each <span class=
        "inline-equation"><span class="tex">$T_i \in \mathcal
        {F}$</span></span> there is a call to <tt>Binarize</tt>,
        which takes <em>O</em>(<em>n</em>), and a call to
        <tt>FindPathsOnTree</tt>, which takes
        <em>O</em>(<em>kn</em>). The complexity of repeating this
        for all the trees is <em>O</em>(<em>k</em> <sup>2</sup>
        <em>n</em>). Finally, <tt>SplitBudget</tt> runs in
        <em>O</em>(<em>k</em> <sup>2</sup>), so the running time
        complexity of <tt>kPaths</tt> is
        <em>O</em>(<em>dm</em>log <em>n</em> + <em>k</em>
        <sup>2</sup> <em>n</em> + <em>k</em> <sup>2</sup>).</p>
        <p>We can reduce the complexity of <tt>kPaths</tt> to
        <em>O</em>(<em>dm</em>log <em>n</em> + <em>kn</em> +
        <em>k</em> <sup>2</sup>) as follows. Consider the
        computation of <em>D</em>(<em>v</em>, <em>i</em>), see
        Equation&nbsp;(<a class="eqn" href="#eq9">9</a>). Notice
        that, for a fixed node <em>v</em>, we can fill in all the
        entries <em>D</em>(<em>v</em>, <em>i</em>) for <em>i</em>
        ranging from 1 to <em>k</em> in <em>O</em>(<em>k</em>) time
        using the following observation. Consider the entry
        <em>D</em>(<em>v</em>, <em>i</em>) and let <span class=
        "inline-equation"><span class=
        "tex">$(i^{*}_{l},i^{*}_{r})$</span></span> be an optimal
        split for <em>i</em>. We claim that there is an optimal
        split <span class="inline-equation"><span class=
        "tex">$(j^{*}_{l},j^{*}_{r})$</span></span> for <em>j</em>
        = <em>i</em> + 1 satisfying <span class=
        "inline-equation"><span class=
        "tex">$j^{*}_{l}=i^{*}_{l}$</span></span> or <span class=
        "inline-equation"><span class=
        "tex">$j^{*}_{l}=i^{*}_{l}+1$</span></span> . In other
        words, the better of the two splits <span class=
        "inline-equation"><span class=
        "tex">$(i^{*}_{l}+1,i^{*}_{r})$</span></span> ,
        <span class="inline-equation"><span class=
        "tex">$(i^{*}_{l},i^{*}_{r}+1)$</span></span> is an optimal
        split for <em>i</em> + 1, so when going from <em>i</em> to
        <em>i</em> + 1 we add a path, either to the left or to the
        right child, but without removing any other paths. This can
        be extended to all the values used in the dynamic-program,
        whose computations require considering pairs of the form
        (<em>i<sub>l</sub></em> , <em>i<sub>r</sub></em> ). Thus,
        the new running time complexity of <tt>kPaths</tt> becomes
        <em>O</em>(<em>dm</em>log <em>n</em> + <em>kn</em> +
        <em>k</em> <sup>2</sup>). Intuitively, let us assume that,
        without loss of generality, instead of only adding a path
        to the left child, the algorithm also replaces an existing
        path <em>P</em> <sub>1</sub> with a new path <em>P</em>
        <sub>2</sub>. We claim that this solution is suboptimal.
        Indeed, the extra path <em>P</em> <sub>2</sub> increases
        the total cost more than <em>P</em> <sub>1</sub>, or else
        it would have been picked by the algorithm at a previous
        step. As a result, no paths are removed when moving from a
        solution with <em>i</em> paths to one with <em>i</em> +
        1.</p>
      </section>
    </section>
    <section id="sec-13">
      <header>
        <div class="title-info">
          <h2><span class="section-number">4</span>
          Experiments</h2>
        </div>
      </header>
      <div class="table-responsive" id="tab1">
        <div class="table-caption">
          <span class="table-number">Table 1:</span> <span class=
          "table-title">A summary of the dataset statistics.</span>
        </div>
        <table class="table">
          <thead>
            <tr>
              <th style="text-align:left;"></th>
              <th style="text-align:left;">#nodes</th>
              <th style="text-align:left;">#edges</th>
              <th style="text-align:left;">#tweets</th>
              <th style="text-align:left;">#photos</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align:left;">Boston</td>
              <td style="text-align:left;">10 101</td>
              <td style="text-align:left;">15 435</td>
              <td style="text-align:left;">222 474</td>
              <td style="text-align:left;">124 560</td>
            </tr>
            <tr>
              <td style="text-align:left;">San Francisco</td>
              <td style="text-align:left;">14 361</td>
              <td style="text-align:left;">22 055</td>
              <td style="text-align:left;">448 688</td>
              <td style="text-align:left;">282 263</td>
            </tr>
            <tr>
              <td style="text-align:left;">Austin</td>
              <td style="text-align:left;">53 772</td>
              <td style="text-align:left;">77 135</td>
              <td style="text-align:left;">243 811</td>
              <td style="text-align:left;">102 446</td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>The purpose of this section is to explore the practicality
      and efficiency of our algorithms on real datasets.
      Specifically, i) we evaluate the performance of our three
      methods, <tt>kTours</tt>, <span class=
      "inline-equation"><span class="tex">${\texttt
      {kPaths}(t=1)}$</span></span> <a class="fn" href="#fn1" id=
      "foot-fn1"><sup>1</sup></a> and <tt>kPaths</tt>, compared to
      a set of baseline methods for different values of <em>k</em>,
      ii) we present a break-down of the runtime of our algorithms,
      and iii) we showcase their impact by visualizing their
      solutions on a map.</p>
      <section id="sec-14">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.1</span>
            Datasets</h3>
          </div>
        </header>
        <p>We generate six real-world activity networks by
        combining the road networks of three major US cities
        (Boston, San Francisco and Austin), with geo-located user
        activity from two online social platforms (<em>Twitter</em>
        and <em>Flickr</em>). Table&nbsp;<a class="tbl" href=
        "#tab1">1</a> exhibits some statistics on the size and the
        activity levels of our datasets.</p>
        <p><strong>Road network:</strong>For each of the three
        cities of interest, we use OpenStreetMap<a class="fn" href=
        "#fn2" id="foot-fn2"><sup>2</sup></a> to retrieve the
        corresponding city road network. The nodes in these
        networks represent road intersections, while the edges are
        road segments. Each edge has a positive weight that
        represents its length in kilometers. Given that we only
        select nodes within the city limits, these networks might
        have more than one connected components, e.g., a
        neighborhood might be connected to other neighborhoods
        through a road that exceeds the city's limits. In this
        case, we only keep the largest connected component.</p>
        <p><strong>User activity:</strong>We use geo-located posts
        from <em>Twitter</em><a class="fn" href="#fn3" id=
        "foot-fn3"><sup>3</sup></a> (between October 2015 and
        January 2017) and geo-tagged photos from
        <em>Flickr</em><a class="fn" href="#fn4" id=
        "foot-fn4"><sup>4</sup></a> to capture the levels of
        activity at each node in our road networks. Specifically,
        we assign a post or a photo, respectively, to the node
        whose location is closest to the item. The node's
        <em>prize</em> is then the number of items assigned to it.
        We preprocess our data such that outlying users, who are
        responsible for a considerably larger volume of posts or
        photos than the rest, are filtered out. The number of items
        that we are left with in the end is summarized in
        Table&nbsp;<a class="tbl" href="#tab1">1</a>.</p>
      </section>
      <section id="sec-15">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.2</span> Baseline
            algorithms</h3>
          </div>
        </header>
        <p>In order to evaluate the performance of the algorithms
        introduced in Section&nbsp;<a class="sec" href=
        "#sec-10">3</a>, we propose a variety of baseline methods
        that are summarized in Table&nbsp;<a class="tbl" href=
        "#tab2">2</a>. The primary difference between our
        approaches and the baseline algorithms lies in the method
        used to produce the trees required for the extraction of
        tours and paths. Note that the second step of all baseline
        algorithms utilizes our own <tt>kTours</tt> and
        <tt>FindPaths</tt> algorithms. We follow this approach,
        because we have already shown that <tt>kTours</tt> is a
        constant factor approximation algorithm, when trees are
        produced by <tt>kTrees</tt>, and <tt>FindPaths</tt> is
        optimal for a set of given trees. Utilizing these high
        quality routines ensures that the baseline algorithms will
        not perform considerably worse than our solutions. The
        baseline methods that we consider are based on a
        greedy-based approach and a well-known density-based
        clustering algorithm, <tt>DBSCAN</tt>&nbsp;[<a class="bib"
        data-trigger="hover" data-toggle="popover" data-placement=
        "top" href="#BibPLXBIB0007">7</a>].</p>
        <p><tt>Greedy</tt> builds on top of the
        <tt>kTrees</tt>&nbsp;[<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0011">11</a>] algorithm. It iteratively extracts
        one tree from the input graph <em>G</em> using
        <tt>kTrees</tt> for <em>k</em> = 1, adds it to the solution
        and then removes its nodes from <em>G</em>. It repeats this
        process until the solution includes <em>k</em> trees.
        <tt>DBSCAN</tt> locates regions of high density separated
        by regions of low density by using a nearest neighbor
        approach. The algorithm takes as input a set of points in
        space and the parameters <em>MinPts</em> and <em>Eps</em>,
        and returns an arbitrary number of <em>dense</em> clusters.
        To identify the parameter values for which the solution
        retrieves exactly <em>k</em> clusters we perform a greedy
        search. Given that the output clusters are not necessarily
        connected, we impose connectivity by finding for each
        cluster the induced subgraphs, computing the minimum
        spanning tree for each of these subgraphs and selecting the
        cluster's representative to be the subgraph that improves
        the objective value. Following, we describe each of our
        proposed baselines.</p>
        <p><strong>{</strong> <tt><strong>Greedy</strong></tt>
        <strong>,</strong> <tt><strong>DBSCAN</strong></tt>
        <strong>}</strong> <tt><strong>+</strong></tt>
        <tt><strong>FindTours</strong></tt> <strong>:</strong>These
        two algorithms are extensions of <tt>Greedy</tt> and
        <tt>DBSCAN</tt>, respectively, followed by applying
        <tt>FindTours</tt>, a variation of the <tt>FindTour</tt>
        algorithm, to their solutions. <tt>FindTours</tt> simply
        takes as an input a set of <em>k</em> trees and runs
        <tt>FindTour</tt> on each of them, thus producing
        <em>k</em> tours.</p>
        <p><strong>{</strong> <tt><strong>Greedy</strong></tt>
        <strong>,</strong> <tt><strong>DBSCAN</strong></tt>
        <strong>}</strong> <tt><strong>+</strong></tt>
        <tt><strong>FindPaths</strong></tt> : These algorithms
        build <em>k</em> trees using <tt>Greedy</tt> and
        <tt>DBSCAN</tt>, respectively, on top of which we run our
        <tt>FindPaths</tt> algorithm (Algorithm&nbsp;3).</p>
        <div class="table-responsive" id="tab2">
          <div class="table-caption">
            <span class="table-number">Table 2:</span> <span class=
            "table-title">A summary of the baseline methods that we
            compare against.</span>
          </div>
          <table class="table">
            <thead>
              <tr>
                <th style="text-align:left;">Problems</th>
                <th style="text-align:left;">Baseline
                algorithms</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td style="text-align:left;"><em>k</em>
                <font style="font-variant: small-caps">-PCTours</font>:</td>
                <td style="text-align:left;">
                <tt>Greedy+FindTours</tt></td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">
                <tt>DBSCAN+FindTours</tt></td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td></td>
              </tr>
              <tr>
                <td style="text-align:left;"><em>k</em>
                <font style="font-variant: small-caps">-PCPaths</font>:</td>
                <td style="text-align:left;">
                <tt>Greedy+FindPaths</tt></td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">
                <tt>DBSCAN+FindPaths</tt></td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
      <section id="sec-16">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.3</span>
            Experimental setup</h3>
          </div>
        </header>
        <p>Here, we discuss the details regarding the setup of the
        experimental evaluation and our choice of <em>λ</em>.</p>
        <p><strong>Implementation details:</strong>A prerequisite
        for the algorithms presented in Section&nbsp;<a class="sec"
        href="#sec-10">3</a> is the <tt>kTrees</tt> algorithm. We
        use its <tt>C++</tt> implementation that is available
        online<a class="fn" href="#fn5" id=
        "foot-fn5"><sup>5</sup></a>. The rest of the algorithms are
        implemented in Python. Experiments were run on a 64-bit
        MacBook Pro with an Intel Core i7 CPU at 2.6GHz and 16 GB
        RAM. We make the code, the datasets and the chosen
        parameters available online for reproducibility
        purposes<a class="fn" href="#fn6" id=
        "foot-fn6"><sup>6</sup></a>.</p>
        <p><strong>Picking a fixed <em>λ</em>:</strong>Recall that
        the purpose of parameter <em>λ</em> in
        Equation&nbsp;(<a class="eqn" href="#eq1">1</a>) is to
        transform the prizes and the costs into comparable units.
        For instance, in our <em>Twitter</em> datasets, the
        distributions of the node prizes indicate that there are no
        more than 10 nodes with prize above 500 (number of tweets).
        The same cut-off for the edge cost histogram is 0.5 (km).
        As a result, we align the two quantities by picking
        <em>λ</em> = 10<sup>− 3</sup>. Similarly, for
        <em>Flickr</em>, we set <em>λ</em> = 2 × 10<sup>−
        3</sup>.</p>
        <div class="table-responsive" id="tab3">
          <div class="table-caption">
            <span class="table-number">Table 3:</span> <span class=
            "table-title">Total runtime per algorithmic function
            for different <em>k</em> on the <em>Twitter Austin</em>
            dataset. All times are reported in seconds.</span>
          </div>
          <table class="table">
            <thead>
              <tr>
                <th style="text-align:left;"><em>k</em></th>
                <th style="text-align:left;"><tt>kTrees</tt></th>
                <th style="text-align:left;"><tt>FindTour</tt></th>
                <th style="text-align:left;"><tt>kTours</tt></th>
                <th style="text-align:left;"><tt>Binarize</tt></th>
                <th style="text-align:left;">
                <tt>FindPathsOnTree</tt></th>
                <th style="text-align:left;">
                <tt>SplitBudget</tt></th>
                <th style="text-align:left;">
                <tt>RetrievePath</tt></th>
                <th><tt>kPaths</tt></th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td style="text-align:left;">1</td>
                <td style="text-align:left;">0.0791</td>
                <td style="text-align:left;">0.639</td>
                <td style="text-align:left;">0.7182</td>
                <td style="text-align:left;">0.0145</td>
                <td style="text-align:left;">0.0633</td>
                <td style="text-align:left;">0.0</td>
                <td style="text-align:left;">0.0015</td>
                <td>0.1586</td>
              </tr>
              <tr>
                <td style="text-align:left;">5</td>
                <td style="text-align:left;">0.0654</td>
                <td style="text-align:left;">2.0756</td>
                <td style="text-align:left;">2.141</td>
                <td style="text-align:left;">0.0753</td>
                <td style="text-align:left;">1.6741</td>
                <td style="text-align:left;">0.0002</td>
                <td style="text-align:left;">0.0182</td>
                <td>1.8334</td>
              </tr>
              <tr>
                <td style="text-align:left;">10</td>
                <td style="text-align:left;">0.0655</td>
                <td style="text-align:left;">3.9507</td>
                <td style="text-align:left;">4.0163</td>
                <td style="text-align:left;">0.1522</td>
                <td style="text-align:left;">7.1594</td>
                <td style="text-align:left;">0.001</td>
                <td style="text-align:left;">0.0886</td>
                <td>7.4668</td>
              </tr>
              <tr>
                <td style="text-align:left;">15</td>
                <td style="text-align:left;">0.0645</td>
                <td style="text-align:left;">5.4639</td>
                <td style="text-align:left;">5.5284</td>
                <td style="text-align:left;">0.2519</td>
                <td style="text-align:left;">18.4105</td>
                <td style="text-align:left;">0.0027</td>
                <td style="text-align:left;">0.0976</td>
                <td>18.8273</td>
              </tr>
              <tr>
                <td style="text-align:left;">20</td>
                <td style="text-align:left;">0.0641</td>
                <td style="text-align:left;">7.3068</td>
                <td style="text-align:left;">7.3709</td>
                <td style="text-align:left;">0.3631</td>
                <td style="text-align:left;">35.3417</td>
                <td style="text-align:left;">0.0054</td>
                <td style="text-align:left;">0.1454</td>
                <td>35.9198</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
      <section id="sec-17">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.4</span> Performance
            evaluation</h3>
          </div>
        </header>
        <figure id="fig5">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3186112/images/www2018-121-fig5.jpg"
          class="img-responsive" alt="Figure 5" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 2:</span>
            <span class="figure-title">Performance of different
            algorithms for the <em>k</em> <font style=
            "font-variant: small-caps">-tours</font> and <em>k</em>
            <font style="font-variant: small-caps">-paths</font>
            problems on the <em>Twitter</em> and <em>Flickr</em>
            datasets, for fixed weight multiplier <em>λ</em> =
            0.001 and <em>λ</em> = 0.002, respectively;
            <em>x</em>-axis: number of <em>k</em> subgraphs;
            <em>y</em>-axis: cost of the solution.</span>
          </div>
        </figure>
        <p>In this section, we showcase the performance of our
        algorithms compared to the baselines. To this end, we vary
        the parameter <em>k</em> to take values in {1, 2, 3, ...,
        20} and compute the cost of the solution. We present the
        results of this evaluation in Figure&nbsp;<a class="fig"
        href="#fig5">2</a>. The figure comprises 12 panels; each
        row corresponds to a dataset and each column corresponds to
        a problem from Section&nbsp;<a class="sec" href=
        "#sec-6">2</a>. Furthermore, the first three rows consider
        user activity from <em>Twitter</em>, while the rest are on
        pictures from <em>Flickr</em>. Finally, recall that smaller
        values of cost imply a better solution. Let us now examine
        the performance of the algorithms, one problem (column) at
        a time.</p>
        <p><strong>The</strong> <em>k</em> <font style=
        "font-variant: small-caps">-PCTours</font>
        <strong>problem:</strong>For this problem, we compare the
        performance of <tt>kTours</tt> to the baseline algorithms
        <tt>Greedy+FindTours</tt> and <tt>DBSCAN+FindTours</tt> for
        the <em>k</em> <font style=
        "font-variant: small-caps">-PCTours</font> problem, which
        is presented in the first column of Figure&nbsp;<a class=
        "fig" href="#fig5">2</a>. Here, in the majority of the
        panels <tt>kTours</tt> (which is the only algorithm with an
        approximation guarantee) clearly outperforms the other two
        algorithms. In addition, notice that for small values of
        <em>k</em>, the cost of <tt>Greedy+FindTours</tt> is
        comparable to <tt>kTours</tt> because their solutions are
        similar. As <em>k</em> increases however, <tt>kTours</tt>
        prefers splitting highly active subgraphs rather than
        introducing new, less active ones, which is what
        <tt>Greedy+FindTours</tt> does. For this reason, the
        difference in their performance is more pronounced for
        larger values of <em>k</em>. Furthermore, observe that the
        cost of the solutions of <tt>DBSCAN+FindTours</tt> is not
        decreasing monotonically with <em>k</em>, contrary to both
        <tt>kTours</tt> and <tt>Greedy+FindTours</tt>.
        Specifically, panels&nbsp;2(a) ,&nbsp;2(c) ,&nbsp;2(g)
        and&nbsp;2(i) illustrate that the cost, after reaching a
        minimum point for some value of <em>k</em>, starts
        increasing again.</p>
        <p>Although this may seem counter-intuitive, this behavior
        is attributed to the way each algorithm functions. In
        particular, as <em>k</em> grows, <tt>kTours</tt> and
        <tt>Greedy+FindTours</tt> “favor” single–node trees with a
        relatively large prize, since expanding the subgraphs to
        their neighbors is too expensive, i.e., the edge cost would
        be bigger than the cost of leaving the nodes out of the
        solution. On the contrary, <tt>DBSCAN</tt> is driven by its
        input parameters and is oblivious to such trade-offs.
        Initially, the subgraphs it picks have smaller edge cost
        than the prizes of their nodes. At this stage, the cost of
        <tt>DBSCAN+FindTours</tt> decreases with <em>k</em>, until
        it reaches a minimum point. After that point, the cost of
        keeping the subgraphs connected outweighs their node
        prizes, and the total cost increases.</p>
        <p><strong>The</strong> <em>k</em> <font style=
        "font-variant: small-caps">-PCPaths</font>
        <strong>problem:</strong>The second column of
        Figure&nbsp;<a class="fig" href="#fig5">2</a> shows the
        performance of our algorithms and the baselines for
        <em>k</em> <font style=
        "font-variant: small-caps">-PCPaths</font> over the
        multiple datasets that we consider. We observe that, as
        expected, <span class="inline-equation"><span class=
        "tex">${\texttt {kPaths}(t=1)}$</span></span> and
        <tt>kPaths</tt> outperform the baseline algorithms, and
        that <tt>Greedy+FindPaths</tt> has the worst performance.
        The <tt>DBSCAN</tt>-based baseline algorithm seems to
        perform better in the <em>k</em> <font style=
        "font-variant: small-caps">-PCPaths</font> problem compared
        to its previous performance for the <em>k</em> <font style=
        "font-variant: small-caps">-PCTours</font> problem.
        Furthermore, in the case of <em>Flickr Austin</em> at
        panel&nbsp;2(j), for <em>k</em> ≤ 10 it seems to provide
        the best solution.</p>
        <p><strong>Discussion:</strong>The performance of
        <tt>kTours</tt>, <span class="inline-equation"><span class=
        "tex">${\texttt {kPaths}(t=1)}$</span></span> and
        <tt>kPaths</tt> shows in all plots a sudden decrease in
        cost for some values of <em>k</em>. This usually happens
        because there exists a component with high enough prize
        that can pay for the cost to keep it connected, even if
        that cost might be unreasonable. However, at the next
        iteration, i.e., for <em>k</em> + 1, the algorithm decides
        to split this component in two. This way, the solution
        excludes some of the expensive edges, while it still
        maintains the high-prize nodes. At the same time, no other
        candidate component can decrease the cost of the solution
        as much as excluding these edges.</p>
      </section>
      <section id="sec-18">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.5</span> Runtime
            analysis</h3>
          </div>
        </header>
        <p>We now investigate the scalability of our proposed
        algorithms. To better evaluate the runtime performance of
        our algorithms, we use the largest road network that we
        have, which is the city of <em>Austin</em>. Recall that the
        running time complexity of <tt>kTrees</tt> and
        <tt>kTours</tt> is nearly-linear to the number of edges in
        the graph , while the complexity of <tt>kPaths</tt> is also
        linear to the number of nodes and quadratic to <em>k</em>.
        <a class="fn" href="#fn7" id="foot-fn7"><sup>7</sup></a>.
        We test different values of <em>k</em>, for each of which
        we repeat the experiment over 10 times and report the
        average runtime in seconds. We break each algorithm down to
        its components and report how the runtime is distributed
        among these components during the program execution.</p>
        <p>Table&nbsp;<a class="tbl" href="#tab3">3</a> summarizes
        the results for this experiment. Each row corresponds to a
        different value of <em>k</em>, while the columns represent
        the different components of our algorithms. For example,
        the running time for <tt>kTours</tt> at <em>k</em> = 10 is
        equal to the runtime of <tt>FindTour</tt> at that row, plus
        the runtime of <tt>kTrees</tt> at that row, plus the
        runtime of the code outside these two main components. Note
        that due to the overhead of some processing occurring
        outside of the main components, the summations do not add
        up exactly. Overall, column 1 corresponds to the
        <tt>kTrees</tt> algorithm, columns 1–3 correspond to
        <tt>kTours</tt>, and columns 1 and 4–8 correspond to
        <tt>kPaths</tt>. The values in the Table are clearly what
        one would expect, given the running time complexities. We
        observe that for the largest graph and input parameter
        <em>k</em> our methods require less than 36 seconds.</p>
        <p>We do not report the respective running times of the
        baseline algorithms, as their expected times can be derived
        from Table&nbsp;<a class="tbl" href="#tab3">3</a>. Notice,
        that <tt>Greedy+FindTours</tt> and
        <tt>Greedy+FindPaths</tt> require running <tt>kTrees</tt>
        <em>k</em> times and then perform <tt>FindTours</tt> and
        <tt>FindPaths</tt>, respectively, for the appropriate value
        of <em>k</em>. The same applies to
        <tt>DBSCAN+FindTours</tt> and <tt>DBSCAN+FindPaths</tt>,
        only now we need to run the <tt>DBSCAN</tt> algorithm at
        least once to produce <em>k</em> subgraphs, which takes
        <em>O</em>(<em>n</em>log <em>n</em>), where <em>n</em> is
        the number of the nodes in the graph, and then perform
        <tt>FindTours</tt> and <tt>FindPaths</tt>,
        respectively.</p>
      </section>
      <section id="sec-19">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.6</span> Qualitative
            comparisons</h3>
          </div>
        </header>
        <p>In this section, we aim to provide an intuition about
        how our algorithms behave in practice for the <em>k</em>
        <font style="font-variant: small-caps">-paths</font>
        problem, by examining their solutions on the map. Our focus
        is on three aspects; i) the qualitative differences between
        our proposed approaches and the baseline algorithms, ii)
        the purpose of suggesting the two methods <span class=
        "inline-equation"><span class="tex">${\texttt
        {kPaths}(t=1)}$</span></span> and <tt>kPaths</tt>, and iii)
        the interpretability of our algorithms.</p>
        <p>In Figure&nbsp;<a class="fig" href="#fig6">3</a>, we
        demonstrate how the solutions of our proposed algorithms,
        namely <span class="inline-equation"><span class=
        "tex">${\texttt {kPaths}(t=1)}$</span></span> and
        <tt>kPaths</tt>, differ qualitatively from the ones of the
        baseline algorithms <tt>DBSCAN+FindPaths</tt> and
        <tt>Greedy+FindPaths</tt>. Initially, we focus on the paths
        created by the baseline algorithms. On one hand, we observe
        in panels&nbsp;3(c) and&nbsp;3(g) that
        <tt>DBSCAN+FindPaths</tt> creates significantly shorter
        paths compared to the other algorithms, but these paths are
        high-valued with large prizes. On the other hand, for a
        smaller value of <em>k</em>, such as in panel&nbsp;3(d),
        <tt>Greedy+FindPaths</tt> tends to find some relatively
        larger paths, compared to the other algorithms, but as
        <em>k</em> increases it begins adding smaller paths to the
        solution, as shown in panel&nbsp;3(h) . For even larger
        values of <em>k</em> we expect the greedy-based algorithm
        to output paths of singleton nodes, because it lacks the
        ability of breaking large high-valued paths into smaller
        dense ones. Regarding the quality of the solutions of our
        algorithms, <span class="inline-equation"><span class=
        "tex">${\texttt {kPaths}(t=1)}$</span></span> and
        <tt>kPaths</tt>, we observe that both algorithms find very
        similar and high quality paths, so now we focus on their
        main difference in Figures&nbsp;<a class="fig" href=
        "#fig6">3</a> and&nbsp;<a class="fig" href=
        "#fig7">4</a>.</p>
        <p>The two algorithms follow a similar methodology and,
        consequently, result in solutions of similar cost. However,
        it becomes clear from Figures&nbsp;<a class="fig" href=
        "#fig6">3</a> and&nbsp;<a class="fig" href="#fig7">4</a>
        that the resulting paths can differ in practice, depending
        on the application. In particular, notice that in
        panel&nbsp;3(a), one of the paths that <span class=
        "inline-equation"><span class="tex">${\texttt
        {kPaths}(t=1)}$</span></span> returns reaches the Golden
        Gate bridge (top left corner). This is not the case for
        <tt>kPaths</tt> (panel&nbsp;3(b)). The reason for this
        behavior is that the aforementioned area is not covered by
        any of the <em>k</em> trees that <tt>kPaths</tt> provides
        to <tt>FindPaths</tt> as input. Yet in panel&nbsp;4(b), we
        see that <tt>kPaths</tt> finds a path within the
        Austin-Bergstrom International Airport (bottom right
        corner) that <span class="inline-equation"><span class=
        "tex">${\texttt {kPaths}(t=1)}$</span></span> cannot
        identify&nbsp;4(a) . That is because the airport is located
        far from the city of Austin, and therefore the input tree
        of <span class="inline-equation"><span class=
        "tex">${\texttt {kPaths}(t=1)}$</span></span> does not
        cover that area. These qualitative results are also
        reflected in the algorithms’ solution costs, as in the
        former case <span class="inline-equation"><span class=
        "tex">${\texttt {kPaths}(t=1)}$</span></span> has smaller
        cost, while in the latter case <tt>kPaths</tt> performs
        better.</p>
        <p>Regarding the paths’ locations in Figures&nbsp;<a class=
        "fig" href="#fig6">3</a> and&nbsp;<a class="fig" href=
        "#fig7">4</a>, we clearly see that these span popular spots
        (parks, seaside, downtown) that are heavily photographed,
        and whose nodes’ prizes stand out.</p>
        <figure id="fig6">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3186112/images/www2018-121-fig6.jpg"
          class="img-responsive" alt="Figure 6" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 3:</span>
            <span class="figure-title">Maps showing illustration of
            <em>k</em> = 5 (row 1) and <em>k</em> = 10 (row 2) path
            subgraphs outputted by the algorithms <span class=
            "inline-equation"><span class="tex">${\texttt
            {kPaths}(t=1)}$</span></span> , <tt>kPaths</tt>,
            <tt>DBSCAN+FindPaths</tt> and <tt>Greedy+FindPaths</tt>
            for the <em>k</em> <font style=
            "font-variant: small-caps">-PCPaths</font> problem
            (<em>λ</em> = 0.002). The results of <em>k</em>
            <font style="font-variant: small-caps">-PCPaths</font>
            are on the <em>Flickr SanFrancisco</em> dataset;
            different colors correspond to different trees in the
            solution.</span>
          </div>
        </figure>
        <figure id="fig7">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3186112/images/www2018-121-fig7.jpg"
          class="img-responsive" alt="Figure 7" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 4:</span>
            <span class="figure-title">Maps showing illustration of
            <em>k</em> = 5 path subgraphs outputted by the
            algorithms <span class="inline-equation"><span class=
            "tex">${\texttt {kPaths}(t=1)}$</span></span> and
            <tt>kPaths</tt> for the <em>k</em> <font style=
            "font-variant: small-caps">-PCPaths</font> problem
            (<em>λ</em> = 0.001). The results of <em>k</em>
            <font style="font-variant: small-caps">-PCPaths</font>
            are on the <em>Twitter Austin</em> dataset; different
            colors correspond to different trees in the
            solution.</span>
          </div>
        </figure>
        <p></p>
      </section>
    </section>
    <section id="sec-20">
      <header>
        <div class="title-info">
          <h2><span class="section-number">5</span> Related
          work</h2>
        </div>
      </header>
      <p>Our work is related to a lot of existing work in
      theoretical computer science, activity-network mining and
      spatial data analysis. Below, we review this work and comment
      on how it relates to ours.</p>
      <p><strong>Prize-collecting trees, tours and
      paths:</strong>There is a lot of work in theoretical computer
      science on prize-collecting problems. In these problems the
      input is a graph <em>G</em> = (<em>V</em>, <em>E</em>), where
      every node is associated with a prize and each edge with a
      weight. The goal is to identify one subgraph of <em>G</em>,
      say <em>G</em>′ = (<em>V</em>′, <em>E</em>′), such that
      <em>G</em>′ has a certain structure (e.g., it is a tree or a
      path) and the total weight of the edges in <em>E</em>′ plus
      the prices of the nodes in <em>V</em>∖<em>V</em>′ is
      minimized.</p>
      <p>The most well-known among these problems is the
      <em>prize-collecting Steiner Tree</em>, where <em>G</em>′ is
      required to be a tree. Using a primal-dual scheme, Goemans
      and Williamson&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0010">10</a>] designed a 2-approximation algorithm
      for PCST with time complexity <em>O</em>(<em>n</em>
      <sup>3</sup>log <em>n</em>). Later, the running time of this
      algorithm was reduced to <em>O</em>(<em>n</em>
      <sup>2</sup>log <em>n</em>) [<a class="bib" data-trigger=
      "hover" data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0013">13</a>] and more recently to
      <em>O</em>(<em>dm</em>log <em>n</em>)&nbsp;[<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0011">11</a>], where <em>d</em> is the
      number of bits used for the edge costs and node prizes. The
      idea of restricting <em>G</em>′ to being a tour or a path has
      also been considered in the past&nbsp;[<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0001">1</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0002">2</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0004">4</a>]. The key difference
      between all the above works and ours is that we focus on
      finding <em>k</em> instead of one subgraph in the given
      network. Although we use ideas from the above problems to
      solve ours, both our formulations and algorithmic techniques
      are new.</p>
      <p>The most relevant to ours is the work by Hegde et
      al.&nbsp;[<a class="bib" data-trigger="hover" data-toggle=
      "popover" data-placement="top" href="#BibPLXBIB0012">12</a>],
      which finds <em>k</em> trees instead of one. Hegde&nbsp;et
      al. modify their nearly-linear time algorithm for
      <font style="font-variant: small-caps">PCST</font>&nbsp;[<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0011">11</a>] to provide a
      2-approximation algorithm for this problem as well. In fact,
      our algorithms for <em>k</em> <font style=
      "font-variant: small-caps">-PCTours</font> and <em>k</em>
      <font style="font-variant: small-caps">-PCPaths</font> use
      their algorithm as a subroutine.</p>
      <p><strong>Applications of PCST:</strong>Recently,
      Rozenshtein et al.&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0020">20</a>] presented an optimization problem
      for event detection in activity networks, which reduces to
      the <font style="font-variant: small-caps">PCST</font>
      formulation. Although we also mine activity networks, our
      problem formulations are different. First, we detect
      <em>k</em> subgraphs (which can be routes and paths), while
      they only focus on detecting one single tree. Moreover, our
      algorithms run in time nearly-linear to <em>m</em>, while
      they use the algorithm by Johnson et al.&nbsp;[<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0013">13</a>], which runs in time
      <em>O</em>(<em>n</em> <sup>2</sup>log <em>n</em>).</p>
      <p><strong>Spatial Data Analysis:</strong>On a high level,
      our problem is also related to works on spatial scan
      statistics&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0006">6</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0014">14</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0016">16</a>]. These works assume that data points
      are distributed on the Euclidean space based on some
      distribution. The goal is to detect sub-areas (usually of
      pre-specified size or shape) that display significantly high
      density; this requirement is usually quantified in the form
      of a statistic. These works are clearly different from ours
      as we focus on activity networks rather than points on the
      2-dimensional Euclidean space.</p>
      <p>More recently, scan statistics have been extended to also
      work on graphs&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0003">3</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0005">5</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0009">9</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0021">21</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0024">24</a>], and thus output connected subgraphs
      of the input graph with high value of the scan statistic.
      Although some of these works impose constraints on the output
      graph (e.g., size, connectivity), none of them has the
      flexibility of asking for subgraphs of a particular
      structure. We believe that this is crucial when analyzing
      spatial data that correspond to routes taken by city
      dwellers. As a result, the algorithmic problems underlying
      this work are totally different from the ones we consider in
      this paper.</p>
      <p>Finally, one can view all density-based clustering
      methods&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0007">7</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0017">17</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0018">18</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0022">22</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0023">23</a>] as related to our work. After all,
      they identify areas of unusually high density of points.
      However, these methods do not consider an underlying graph
      structure and, as a result, one cannot impose any graph-based
      constraints on their output. Consequently, our algorithmic
      techniques are also different.</p>
    </section>
    <section id="sec-21">
      <header>
        <div class="title-info">
          <h2><span class="section-number">6</span>
          Conclusions</h2>
        </div>
      </header>
      <p>In this paper, we introduced the general <em>k</em>
      <font style="font-variant: small-caps">-PCSubgraphs</font>
      problem in activity networks, where the goal is to find a set
      of connected and non-overlapping subgraphs with nodes
      exhibiting high levels of activity. More specifically, we
      focused on two of its variants, namely the <em>k</em>
      <font style="font-variant: small-caps">-PCTours</font> and
      the <em>k</em> <font style=
      "font-variant: small-caps">-PCPaths</font> problems. Using
      existing ideas from theoretical computer science, we gave
      almost linear-time algorithms for solving all these problems
      and discussed their approximation guarantees. In our
      experimental evaluation, we used activity networks built on
      top of an underlying road network of three cities: Boston,
      San Francisco and Austin. Each node of the network, which
      corresponds to an intersection, is associated with the number
      of tweets or photo uploads made by social-network users in
      the vicinity of the intersection. By applying our algorithms
      to such datasets, we demonstrated their efficiency and their
      ability to extract interesting patterns of human activity in
      urban settings.</p>
    </section>
    <section id="sec-22">
      <header>
        <div class="title-info">
          <h2>Acknowledgments</h2>
        </div>
      </header>
      <p>This work was supported by NSF awards: CAREER 1253393 III
      1421759 and IIP 1430145. The authors also thank the anonymous
      reviewers for their helpful comments and Ben Lawson for his
      work on collecting and summarizing the data we used in our
      experiments.</p>
    </section>
  </section>
  <section class="back-matter">
    <section id="ref-001">
      <header>
        <div class="title-info">
          <h2 class="page-brake-head">REFERENCES</h2>
        </div>
      </header>
      <ul class="bibUl">
        <li id="BibPLXBIB0001" label="[1]">A. Archer, M.&nbsp;H.
        Bateni, M.&nbsp;T. Hajiaghayi, and H. Karloff. 2011.
        Improved approximation algorithms for prize-collecting
        Steiner tree and TSP. <em><em>Journal on
        Computing</em></em> (2011).</li>
        <li id="BibPLXBIB0002" label="[2]">M.&nbsp;H. Bateni, C.
        Chekuri, A. Ene, M.&nbsp;T. Hajiaghayi, N. Korula, and D.
        Marx. 2011. Prize-collecting Steiner problems on planar
        graphs. In <em><em>SODA</em></em> . SIAM.</li>
        <li id="BibPLXBIB0003" label="[3]">J. Cadena, F. Chen, and
        A. Vullikanti. 2017. Near-Optimal and Practical Algorithms
        for Graph Scan Statistics. In <em><em>SDM</em></em> .
        SIAM.</li>
        <li id="BibPLXBIB0004" label="[4]">K. Chaudhuri, B.
        Godfrey, S. Rao, and K. Talwar. 2003. Paths, trees, and
        minimum latency tours. In <em><em>FOCS</em></em> .
        IEEE.</li>
        <li id="BibPLXBIB0005" label="[5]">F. Chen and D.&nbsp;B.
        Neill. 2014. Non-parametric scan statistics for event
        detection and forecasting in heterogeneous social media
        graphs. In <em><em>SIGKDD</em></em> . ACM.</li>
        <li id="BibPLXBIB0006" label="[6]">L. Duczmal, M.
        Kulldorff, and L. Huang. 2006. Evaluation of spatial scan
        statistics for irregularly shaped clusters. <em><em>Journal
        of Computational and Graphical Statistics</em></em>
        (2006).</li>
        <li id="BibPLXBIB0007" label="[7]">M. Ester, H. Kriegel, J.
        Sander, and X. Xu. 1996. A density-based algorithm for
        discovering clusters in large spatial databases with noise.
        In <em><em>SIGKDD</em></em> . ACM.</li>
        <li id="BibPLXBIB0008" label="[8]">R. Fagin, R. Guha, R.
        Kumar, J. Novak, D. Sivakumar, and A. Tomkins. 2005.
        Multi-structural databases. In <em><em>SIGMOD</em></em> .
        ACM.</li>
        <li id="BibPLXBIB0009" label="[9]">A. Gionis, M.
        Mathioudakis, and A. Ukkonen. 2017. Bump hunting in the
        dark: Local discrepancy maximization on graphs.
        <em><em>TKDE</em></em> (2017).</li>
        <li id="BibPLXBIB0010" label="[10]">M.&nbsp;X. Goemans and
        D.&nbsp;P. Williamson. 1995. A general approximation
        technique for constrained forest problems. <em><em>Journal
        on Computing</em></em> (1995).</li>
        <li id="BibPLXBIB0011" label="[11]">C. Hegde, P. Indyk, and
        L. Schmidt. 2014. A fast, adaptive variant of the
        Goemans-Williamson scheme for the prize-collecting Steiner
        tree problem. In <em><em>11th DIMACS Challenge
        Workshop</em></em> .</li>
        <li id="BibPLXBIB0012" label="[12]">C. Hegde, P. Indyk, and
        L. Schmidt. 2015. A nearly-linear time framework for
        graph-structured sparsity. In <em><em>ICML</em></em> .</li>
        <li id="BibPLXBIB0013" label="[13]">D.&nbsp;S Johnson, M.
        Minkoff, and S. Phillips. 2000. The prize collecting
        steiner tree problem: theory and practice. In
        <em><em>SODA</em></em> . SIAM.</li>
        <li id="BibPLXBIB0014" label="[14]">M. Kulldorff. 1997. A
        spatial scan statistic. <em><em>Communications in
        Statistics-Theory and methods</em></em> (1997).</li>
        <li id="BibPLXBIB0015" label="[15]">T. Lappas, E. Terzi, D.
        Gunopulos, and H. Mannila. 2010. Finding effectors in
        social networks. In <em><em>SIGKDD</em></em> . ACM.</li>
        <li id="BibPLXBIB0016" label="[16]">T. Lappas, M.&nbsp;R.
        Vieira, D. Gunopulos, and V.&nbsp;J. Tsotras. 2012. On the
        spatiotemporal burstiness of terms. <em><em>PVLDB</em></em>
        (2012).</li>
        <li id="BibPLXBIB0017" label="[17]">A. Lulli, M.
        Dell'Amico, P. Michiardi, and L. Ricci. 2016. NG-DBSCAN:
        scalable density-based clustering for arbitrary data.
        <em><em>PVLDB</em></em> (2016).</li>
        <li id="BibPLXBIB0018" label="[18]">S.&nbsp;T. Mai, I.
        Assent, and M. Storgaard. 2016. AnyDBC: an efficient
        anytime density-based clustering algorithm for very large
        complex datasets. In <em><em>SIGKDD</em></em> . ACM.</li>
        <li id="BibPLXBIB0019" label="[19]">D. Quercia, R.
        Schifanella, and L.&nbsp;M. Aiello. 2014. The shortest path
        to happiness: Recommending beautiful, quiet, and happy
        routes in the city. In <em><em>HT</em></em> . ACM.</li>
        <li id="BibPLXBIB0020" label="[20]">A. Rozenshtein,
        P.and&nbsp;Anagnostopoulos, A. Gionis, and N. Tatti. 2014.
        Event detection in activity networks. In
        <em><em>SIGKDD</em></em> . ACM.</li>
        <li id="BibPLXBIB0021" label="[21]">S. Seufert, S.
        Bedathur, J. Mestre, and G. Weikum. 2010. Bonsai: Growing
        interesting small trees. In <em><em>ICDM</em></em> .
        IEEE.</li>
        <li id="BibPLXBIB0022" label="[22]">G. Sheikholeslami, S.
        Chatterjee, and A. Zhang. 1998. Wavecluster: A
        multi-resolution clustering approach for very large spatial
        databases. In <em><em>VLDB</em></em> .</li>
        <li id="BibPLXBIB0023" label="[23]">J. Shi, N. Mamoulis, D.
        Wu, and D.&nbsp;W. Cheung. 2014. Density-based place
        clustering in geo-social networks. In
        <em><em>SIGMOD</em></em> . ACM.</li>
        <li id="BibPLXBIB0024" label="[24]">S. Speakman, Y. Zhang,
        and D.&nbsp;B. Neill. 2013. Dynamic pattern detection with
        temporal consistency and connectivity constraints. In
        <em><em>ICDM</em></em> . IEEE.</li>
      </ul>
    </section>
  </section>
  <section id="foot-001" class="footnote">
    <header>
      <div class="title-info">
        <h2>FOOTNOTE</h2>
      </div>
    </header>
    <p id="fn1"><a href="#foot-fn1"><sup>1</sup></a>Executes the
    <tt>kPaths</tt> algorithm for a single tree, produced by
    <tt>kTrees</tt> for <em>k</em> = 1.</p>
    <p id="fn2"><a href="#foot-fn2"><sup>2</sup></a><a class=
    "link-inline force-break" href=
    "https://wiki.openstreetmap.org/wiki">https://wiki.openstreetmap.org/wiki</a></p>
    <p id="fn3"><a href="#foot-fn3"><sup>3</sup></a><a class=
    "link-inline force-break" href=
    "https://dev.twitter.com/rest/public">https://dev.twitter.com/rest/public</a></p>
    <p id="fn4"><a href="#foot-fn4"><sup>4</sup></a><a class=
    "link-inline force-break" href=
    "https://webscope.sandbox.yahoo.com">https://webscope.sandbox.yahoo.com</a></p>
    <p id="fn5"><a href="#foot-fn5"><sup>5</sup></a><a class=
    "link-inline force-break" href=
    "https://github.com/ludwigschmidt/cluster_approx">https://github.com/ludwigschmidt/cluster_approx</a></p>
    <p id="fn6"><a href="#foot-fn6"><sup>6</sup></a><a class=
    "link-inline force-break" href=
    "https://github.com/smnikolakaki/activity_networks">https://github.com/smnikolakaki/activity_networks</a></p>
    <p id="fn7"><a href="#foot-fn7"><sup>7</sup></a>Note that the
    running time reported for <tt>kTrees</tt> cannot be directly
    compared to the rest of the entries, since it is implemented in
    <tt>C++</tt> while the rest of the codebase is written in
    Python.</p>
    <div class="bibStrip">
      <p>This paper is published under the Creative Commons
      Attribution 4.0 International (CC-BY&nbsp;4.0) license.
      Authors reserve their rights to disseminate the work on their
      personal and corporate Web sites with the appropriate
      attribution.</p>
      <p><em>WWW '18, April 23-27, 2018, Lyon, France</em></p>
      <p>© 2018; IW3C2 (International World Wide Web Conference
      Committee), published under Creative Commons CC-BY&nbsp;4.0
      License. ACM ISBN 978-1-4503-5639-8/18/04.<br />
      DOI: <a class="link-inline force-break" target="_blank" href=
      "https://doi.org/10.1145/3178876.3186112">https://doi.org/10.1145/3178876.3186112</a></p>
    </div>
  </section>
  <div class="pubHistory">
    <p></p>
  </div>
</body>
</html>
