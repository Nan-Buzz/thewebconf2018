<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta name="generator" content=
  "HTML Tidy for HTML5 for Linux version 5.7.16" />
  <title>Fast Exact CoSimRank Search on Evolving and Static
  Graphs</title><!-- Copyright (c) 2010-2015 The MathJax Consortium -->
  <meta http-equiv="Content-Type" content=
  "text/html; charset=utf-8" />
  <meta name="viewport" content=
  "width=device-width; initial-scale=1.0;" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="screen, print" rel="stylesheet" href=
  "../../../data/dl.acm.org/pubs/lib/css/bootstrap.min.css" />
  <link media="screen, print" rel="stylesheet" href=
  "../../../data/dl.acm.org/pubs/lib/css/bootstrap-theme.min.css" />
  <link media="screen, print" rel="stylesheet" href=
  "../../../data/dl.acm.org/pubs/lib/css/main.css" />
  <script src="../../../data/dl.acm.org/pubs/lib/js/jquery.min.js" type=
  "text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/bootstrap.min.js"
  type="text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/bibCit.js" type=
  "text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/divTab.js" type=
  "text/javascript"></script>
  <script type="text/javascript" src=
  "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>
  <script type="text/x-mathjax-config">
  <![CDATA[
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  ]]>
  </script>
</head>
<body id="main">
<div>
<p style='font-size: 75%; color #444'>
This is a web copy of <a href='https://doi.org/10.1145/3178876.3186126'>https://doi.org/10.1145/3178876.3186126</a> 
 Published in WWW2018 Proceedings © 2018 International World Wide Web Conference Committee, published under 
 <a rel='license' property='license' href='https://creativecommons.org/licenses/by/4.0/'>
 Creative Commons CC By 4.0 License</a>.
The <a href='https://github.com/usable-oa/thewebconf2018/tree/master/scripts'>modifications</a> 
from the original are solely to improve HTML aiming to make it Findable, Accessible, Interoperable and Reusable. 
augmenting HTML metadata and avoiding ACM trademark.
To reference this HTML version, use:
</p><p>
<strong>Permalink:</strong>
<a href='https://w3id.org/oa/10.1145/3178876.3186126'>https://w3id.org/oa/10.1145/3178876.3186126</a>
</p></div>
<hr>


  <section class="front-matter">
    <section>
      <header class="title-info">
        <div class="journal-title">
          <h1><span class="title">Fast Exact CoSimRank Search on
          Evolving and Static Graphs</span><br />
          <span class="subTitle"></span></h1>
        </div>
      </header>
      <div class="authorGroup">
        <div class="author">
          <span class="givenName">Weiren</span> <span class=
          "surName">Yu</span>, Aston University, Birmingham, B4
          7ET, UK, <a href=
          "mailto:w.yu3@aston.ac.uk">w.yu3@aston.ac.uk</a>
        </div>
        <div class="author">
          <span class="givenName">Fan</span> <span class=
          "surName">Wang</span>, Aston University, Birmingham, B4
          7ET, UK, <a href=
          "mailto:wangf7@aston.ac.uk">wangf7@aston.ac.uk</a>
        </div>
      </div><br />
      <div class="pubInfo">
        <p>DOI: <a href="https://doi.org/10.1145/3178876.3186126"
        target=
        "_blank">https://doi.org/10.1145/3178876.3186126</a><br />
        WWW '18: <a href="https://doi.org/10.1145/3178876" target=
        "_blank">Proceedings of The Web Conference 2018</a>, Lyon,
        France, April 2018</p>
      </div>
      <div class="abstract">
        <p><small>In real Web applications, CoSimRank has been
        proposed as a powerful measure of node-pair similarity
        based on graph topologies. However, existing work on
        CoSimRank is restricted to static graphs. When the graph is
        updated with new edges arriving over time, it is
        cost-inhibitive to recompute all CoSimRank scores from
        scratch, which is impractical. In this study, we propose a
        fast dynamic scheme, D-CoSim, for accurate CoSimRank search
        over evolving graphs. Based on D-CoSim, we also propose a
        fast scheme, F-CoSim, that greatly accelerates CoSimRank
        search over static graphs. Our theoretical analysis shows
        that D-CoSim and F-CoSim guarantee the exactness of
        CoSimRank scores. On the static graph <em>G</em>, to
        efficiently retrieve CoSimRank scores <strong>S</strong>,
        F-CoSim is based on three ideas: (i) It first finds a
        “spanning polytree” <em>T</em> over <em>G</em>. (ii) On
        <em>T</em>, a fast algorithm is designed to compute the
        CoSimRank scores <strong>S</strong>(<em>T</em>) over the
        “spanning polytree” <em>T</em>. (iii) On <em>G</em>,
        D-CoSim is employed to compute the changes of
        <strong>S</strong>(<em>T</em>) in response to the delta
        graph (<em>G</em>⊖<em>T</em>). Experimental evaluations
        verify the superiority of D-CoSim over evolving graphs, and
        the fast speedup of F-CoSim on large-scale static graphs
        against its competitors, without any loss of
        accuracy.</small></p>
      </div>
      <div class="classifications">
        <div class="AcmReferenceFormat">
          <p><small><span style="font-weight:bold;">ACM Reference
          Format:</span><br />
          Weiren Yu and Fan Wang. 2018. Fast Exact CoSimRank Search
          on Evolving and Static Graphs. In <em>WWW 2018: The 2018
          Web Conference,</em> <em>April 23–27, 2018,</em>
          <em>Lyon, France. ACM, New York, NY, USA</em> 10 Pages.
          <a href="https://doi.org/10.1145/3178876.3186126" class=
          "link-inline force-break" target=
          "_blank">https://doi.org/10.1145/3178876.3186126</a></small></p>
        </div>
      </div>
    </section>
  </section>
  <section class="body">
    <section id="sec-3">
      <header>
        <div class="title-info">
          <h2><span class="section-number">1</span>
          Introduction</h2>
        </div>
      </header>
      <p>Graphs are widely used to model complex objects
      (<em>e.g.,&nbsp;</em>web pages) and their relationships
      (<em>e.g.,&nbsp;</em>hyperlinks). CoSimRank, proposed by
      Rothe and Schütze&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0018">18</a>], is a powerful similarity measure
      between two objects based on graph topologies. It recursively
      follows the SimRank-like philosophy that “two nodes are
      considered as similar if their in-neighbours are similar”.
      CoSimRank is a <em>node-pair</em> similarity measure, which
      is different from PageRank that ranks <em>nodes</em> only.
      Intuitively, a CoSimRank score <em>s</em>(<em>a</em>,
      <em>b</em>) between nodes <em>a</em> and <em>b</em>
      aggregates <em>all</em> the meeting time of two random
      surfers starting at <em>a</em> and <em>b</em>, in contrast to
      SimRank [<a class="bib" data-trigger="hover" data-toggle=
      "popover" data-placement="top" href="#BibPLXBIB0008">8</a>]
      that counts their <em>first</em> meeting time only. Thus,
      CoSimRank has been shown [<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0018">18</a>] to be more accurate and effective
      than SimRank in many applications.</p>
      <p><strong>Application 1 (Synonym Expansion).</strong>
      Synonym expansion is a useful tool in search engine query
      rewriting [<a class="bib" data-trigger="hover" data-toggle=
      "popover" data-placement="top" href="#BibPLXBIB0002">2</a>,
      <a class="bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0005">5</a>] and text
      simplification [<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0004">4</a>] that replaces a target word in a
      sentence with another more appropriate word. The CoSimRank
      measure was utilised to measure the similarity of words based
      on the intuition that “two words that are synonyms of each
      other should have similar lexical neighbors”, where nodes are
      nouns, adjective and verbs occurring in Wikipedia, and edges
      denote types of syntactic configurations extracted from the
      parsed Wikipedias (<em>e.g.,&nbsp;</em>adjective-noun,
      verb-object, and noun-noun coordination). They evaluated the
      CoSimRank similarities of words (synonyms), whose results are
      superior to the cosine similarity of two Personalised
      PageRank vectors to identify effective synonyms.</p>
      <p><strong>Application 2 (Lexicon Extraction).</strong>
      Automatically building bilingual lexicons from corpora is an
      important task in natural language processing. Rothe and
      Schütze have applied CoSimRank to lexicon extraction, and
      represented an English and a German text corpus as two
      graphs, where nodes represent words, and edges denote
      grammatical relationships between words. Their central
      intuition is that “a node in the English graph and a node in
      the German graph are similar (<em>i.e.,&nbsp;</em>are likely
      to be translations of each other) if their neighbouring nodes
      are similar”. They initialised the CoSimRank scores using an
      English-German “seed” dictionary whose entries correspond to
      known pairs of equivalent nodes (words). Their approach
      produces more reliable similarity results than SimRank-based
      approaches [<a class="bib" data-trigger="hover" data-toggle=
      "popover" data-placement="top" href="#BibPLXBIB0011">11</a>,
      <a class="bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0022">22</a>].</p>
      <p>Despite its effectiveness, existing work on CoSimRank is
      restricted to static graphs. However, when the graph is
      updated with new edges arriving over time, it is difficult
      for this approach to handle quick response over dynamical
      graphs, due to its cost-inhibitive overheads for recomputing
      CoSimRank scores from scratch. This highlights our need to
      consider the problem of fast accurate dynamic CoSimRank
      search:</p>
      <p><strong>Problem 1 (Dynamic CoSimRank on Evolving
      Graphs).</strong></p>
      <ul class="list-no-style">
        <li id="list2" label="Given:">a graph <em>G</em>, a
        collection of edge updates <em>ΔG</em> to <em>G</em>, and a
        query set <em>Q</em> = {<em>q</em> <sub>1</sub>, <em>q</em>
        <sub>2</sub>, ⋅⋅⋅}.</li>
        <li id="list2" label="Retrieve:">the changes to the
        CoSimRank scores <em>w.r.t.&nbsp;Q</em> on
        (<em>G</em>⊕<em>ΔG</em>) quickly and accurately.</li>
      </ul>
      <p>To address this issue, we propose a fast accurate dynamic
      scheme, D-CoSim, for CoSimRank search over evolving graphs.
      Moreover, as an important application of D-CoSim, we show
      that our dynamic D-CoSim is also applicable to static graphs
      to achieve a huge speedup for large-scale CoSimRank search.
      Thus, based on D-CoSim, we also design a fast accurate static
      scheme, F-CoSim, to solve the following problem:</p>
      <p><strong>Problem 2 (Static CoSimRank on Large
      Graphs).</strong></p>
      <ul class="list-no-style">
        <li id="list2" label="Given:">a graph <em>G</em>, and a
        query set <em>Q</em> = {<em>q</em> <sub>1</sub>, <em>q</em>
        <sub>2</sub>, ⋅⋅⋅}</li>
        <li id="list2" label="Retrieve:">the CoSimRank scores
        <em>w.r.t.&nbsp;Q</em> on <em>G</em> quickly and
        accurately.</li>
      </ul>
      <p>To speed up the computation of CoSimRank scores
      <strong>S</strong> over the static graph <em>G</em>, (i)
      F-CoSim first finds a “spanning polytree” <em>T</em> over
      <em>G</em>; (ii) on the “spanning polytree” <em>T</em>, we
      devise a fast approach to compute the CoSimRank scores
      <strong>S</strong>(<em>T</em>) of <em>T</em>; (iii) on
      (<em>G</em>⊖<em>T</em>), we employ D-CoSim to compute the
      changes of <strong>S</strong>(<em>T</em>)
      <em>w.r.t.&nbsp;</em>the delta graph (<em>G</em>⊖<em>T</em>).
      With these ideas, F-CoSim and D-CoSim have the following
      salient features:</p>
      <ul class="list-no-style">
        <li id="list1" label="•"><strong>Fast.</strong> F-CoSim and
        D-CoSim are orders of magnitude faster than the best-known
        competitors on static and dynamic graphs, respectively,
        with no loss of accuracy.<br /></li>
        <li id="list2" label="•"><strong>Dynamic.</strong> D-CoSim
        quickly and accurately answers ad-hoc CoSimRank search on
        evolving graphs, with no need to recompute CoSimRank scores
        from scratch.<br /></li>
        <li id="list3" label="•"><strong>Accurate.</strong> F-CoSim
        and D-CoSim do not compromise any accuracy for huge
        speedup.<br /></li>
        <li id="list4" label="•"><strong>Scalable.</strong> Our
        schemes require only linear memory space, and scales well
        on million-node graphs.<br /></li>
      </ul>
      <p>In a nutshell, both dynamic D-CoSim and static F-CoSim
      allow myriads of SimRank-based applications [<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0006">6</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0014">14</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0021">21</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0030">30</a>] being handled more
      efficiently and accurately.</p>
    </section>
    <section id="sec-4">
      <header>
        <div class="title-info">
          <h2><span class="section-number">2</span> Related
          Work</h2>
        </div>
      </header>
      <p>Previous work on CoSimRank search focuses on static
      graphs. The pioneering research of [<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0018">18</a>] proposed an efficient
      local algorithm that computes each CoSimRank score from the
      sum of the dot product of two Personalised PageRank vectors.
      It entails <em>O</em>(<em>Kdn</em>) time and
      <em>O</em>(<em>dn</em>) memory to compute a single-pair
      CoSimRank score over a static graph with <em>n</em> nodes and
      <em>d</em> average degree after <em>K</em> iterations.
      However, when the graph is slightly updated, all CoSimRank
      scores have to be recomputed from scratch. Recently, Yu and
      McCann [<a class="bib" data-trigger="hover" data-toggle=
      "popover" data-placement="top" href="#BibPLXBIB0027">27</a>]
      have suggested an optimisation technique, namely CoSimMate,
      that leverages repeated squaring memoisation to cut down the
      number of iterations from <em>K</em> to ⌈log <sub>2</sub>
      <em>K</em>⌉ for all-pairs CoSimRank scores retrieval, but
      this approach requires extra <em>O</em>(<em>n</em>
      <sup>2</sup>) memory to store repeated squaring results,
      which is impractical on large-scale graphs. Worse still, the
      approach of [<a class="bib" data-trigger="hover" data-toggle=
      "popover" data-placement="top" href="#BibPLXBIB0027">27</a>]
      is a non-local algorithm on static graphs, meaning that, even
      if one wishes to compute a single-pair score, all-pairs
      scores have to be computed simultaneously.</p>
      <p>Regarding dynamic updating, there is no work on CoSimRank
      except a relatively little work on updating of SimRank, a
      variant of SimRank, in dynamic graphs [<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0009">9</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0013">13</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0020">20</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0025">25</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0026">26</a>]. However, when extended
      to CoSimRank, these work would become inefficient, due to the
      following reasons: First, the two state-of-art studies
      [<a class="bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0009">9</a>, <a class=
      "bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0020">20</a>] are based
      on random walk sampling, whose optimisation techniques
      heavily hinge on aggregating “only the <em>first</em> meeting
      time” of two random surfers for SimRank. If applied to
      aggregate “<em>all</em> the meeting time” of two random
      surfers for CoSimRank, their approaches will become slow, due
      to the expensive cost to sample more additional meeting paths
      of two coalescing random walks. Second, some work [<a class=
      "bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0013">13</a>, <a class=
      "bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0025">25</a>] devised
      low-rank decomposition methods to update all-pairs SimRank
      scores, leading to <em>O</em>(<em>n</em> <sup>2</sup>) memory
      to store the decomposed matrices, which is not scalable on
      large graphs. Worse still, these methods rest on an
      assumption that <em>all pairs</em> of old SimRank scores
      should be given in advance even if only a few pairs of scores
      need updating, which is unrealistic in practice.</p>
      <p>There is also a growing body of research on SimRank (the
      variant of CoSimRank) on static graphs [<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0006">6</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0007">7</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0008">8</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0010">10</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0013">13</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0015">15</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0016">16</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0019">19</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0023">23</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0029">29</a>]. Their optimisation
      techniques can be classified into three broad categories:
      Monte Carlo sampling [<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0006">6</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0010">10</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0019">19</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0023">23</a>], matrix-based methods [<a class=
      "bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0007">7</a>, <a class=
      "bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0013">13</a>], and
      iterative schemes [<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0008">8</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0015">15</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0029">29</a>]. Among them, the sampling approach,
      SLING [<a class="bib" data-trigger="hover" data-toggle=
      "popover" data-placement="top" href="#BibPLXBIB0023">23</a>],
      is the best-of-breed SimRank algorithm on static graphs.
      However, their techniques, if applied to CoSimRank, are not
      fast as the performance gain of SLING relies on aggregating
      only the <em>first</em> meeting time of two coalescing walks,
      as opposed to CoSimRank that aggregates <em>all</em> their
      meeting time.</p>
      <p>There has also been much work on computing incremental
      Personalised PageRank (PPR) vectors [<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0003">3</a>], and dynamic Random Walk
      with Restart (RWR) proximities [<a class="bib" data-trigger=
      "hover" data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0028">28</a>]. However, it is not efficient to
      directly apply these techniques to dynamic CoSimRank
      updating. This is because the CoSimRank score at iteration
      <em>k</em> is the sum of <em>k</em> inner products between
      two Personalised PageRank vectors at every iteration
      <em>i</em> = 1, 2, ⋅⋅⋅, <em>k</em>. Thus, to update the
      <em>k</em>-th iterative CoSimRank score, existing incremental
      PPR (RWR) algorithms will be repeatedly applied 2<em>k</em>
      times to update two PPR (RWR) vectors at every iteration
      <em>i</em> = 1, 2, ⋅⋅⋅, <em>k</em>, respectively, before
      summing up the <em>k</em> dot products of every two PPR (RWR)
      vectors at each iteration, which would become rather
      expensive.</p>
      <div class="table-responsive" id="tab1">
        <div class="table-caption">
          <span class="table-number">Table 1:</span> <span class=
          "table-title">Description of Main Symbols</span>
        </div>
        <table class="table">
          <thead>
            <tr>
              <th style="text-align:center;">
              <strong>Symbol</strong></th>
              <th><strong>Description</strong></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align:center;"><em>G</em></td>
              <td>given (old) graph <em>G</em></td>
            </tr>
            <tr>
              <td style="text-align:center;"><em>ΔG</em></td>
              <td>update graph to (old) graph <em>G</em></td>
            </tr>
            <tr>
              <td style="text-align:center;"><span class=
              "inline-equation"><span class="tex">$n /
              \tilde{n}$</span></span></td>
              <td>number of nodes in old/new graph</td>
            </tr>
            <tr>
              <td style="text-align:center;"><span class=
              "inline-equation"><span class="tex">$m /
              \tilde{m}$</span></span></td>
              <td>number of edges in old/new graph</td>
            </tr>
            <tr>
              <td style="text-align:center;"><span class=
              "inline-equation"><span class="tex">$\deg
              ^{-}_i$</span></span></td>
              <td>in-degree of node <em>i</em> in (old) graph
              <em>G</em></td>
            </tr>
            <tr>
              <td style="text-align:center;"><em>C</em></td>
              <td>damping factor (0 &lt; <em>C</em> &lt; 1)</td>
            </tr>
            <tr>
              <td style="text-align:center;"><em>K</em></td>
              <td>number of iterations</td>
            </tr>
            <tr>
              <td style="text-align:center;"><span class=
              "inline-equation"><span class="tex">$\mathbf {A} /
              \tilde{\mathbf {A}}$</span></span></td>
              <td>old/new column-normalised adjacency matrix</td>
            </tr>
            <tr>
              <td style="text-align:center;"><span class=
              "inline-equation"><span class="tex">$\mathbf {S} /
              \tilde{\mathbf {S}}$</span></span></td>
              <td>old/new SimRank matrix</td>
            </tr>
            <tr>
              <td style="text-align:center;">
              <strong>I</strong></td>
              <td><em>n</em> × <em>n</em> identity matrix</td>
            </tr>
            <tr>
              <td style="text-align:center;"><strong>e</strong>
              <sub><em>i</em></sub></td>
              <td><em>n</em> × 1 unit vector with only a 1 in
              <em>i</em>-th entry</td>
            </tr>
            <tr>
              <td style="text-align:center;"><strong>X</strong>
              <sup><em>T</em></sup></td>
              <td>transpose of matrix <strong>X</strong></td>
            </tr>
            <tr>
              <td style="text-align:center;">
              <strong>X</strong>[<em>i</em>, : ]</td>
              <td><em>i</em>-th row of matrix
              <strong>X</strong></td>
            </tr>
            <tr>
              <td style="text-align:center;"><strong>X</strong>[:,
              <em>j</em>]</td>
              <td><em>j</em>-th column of matrix
              <strong>X</strong></td>
            </tr>
            <tr>
              <td style="text-align:center;">
              <strong>X</strong>[<em>i</em>, <em>j</em>]</td>
              <td>(<em>i</em>, <em>j</em>)-th entry of matrix
              <strong>X</strong></td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section id="sec-5">
      <header>
        <div class="title-info">
          <h2><span class="section-number">3</span>
          Preliminaries</h2>
        </div>
      </header>
      <p>Let us formally revisit the CoSimRank definition.
      Table&nbsp;<a class="tbl" href="#tab1">1</a> lists the main
      notations used throughout this paper. CoSimRank, proposed by
      [<a class="bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0018">18</a>], is an
      attractive node-pair similarity measure based on graph
      topologies. It is based on a recursive philosophy that “two
      nodes are considered as similar if their in-neighbours are
      similar”. Unlike SimRank [<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0008">8</a>], the CoSimRank score of each node
      with itself is not constantly&nbsp;1. Mathematically,
      CoSimRank is formulated as follows:<a class="fn" href="#fn1"
      id="foot-fn1"><sup>1</sup></a></p>
      <div class="table-responsive" id="eq1">
        <div class="display-equation">
          <span class="tex mytex">\begin{equation} \mathbf {S} = C
          \mathbf {A}^T \mathbf {S} \mathbf {A} + \mathbf {I}
          \end{equation}</span><br />
          <span class="equation-number">(1)</span>
        </div>
      </div>where <strong>S</strong> is a (symmetric) CoSimRank
      matrix, whose element <strong>S</strong>[<em>i</em>,
      <em>j</em>] is the similarity score between nodes <em>i</em>
      and <em>j</em> in the graph <em>G</em>; <em>C</em> is a
      constant decay factor between 0 and 1; <strong>A</strong> is
      the column-normalised adjacency matrix; <strong>I</strong> is
      the identity matrix; and (*) <sup><em>T</em></sup> is matrix
      transpose. The upper bound of each element of
      <strong>S</strong> in Eq.(<a class="eqn" href="#eq1">1</a>)
      is 1/(1 − <em>C</em>).
      <p></p>
      <p>To evaluate one single-pair CoSimRank score, Rothe and
      Schütze <a class="bib" data-trigger="hover" data-toggle=
      "popover" data-placement="top" href="#BibPLXBIB0018">18</a>
      adopted a novel method to compute
      <strong>S</strong>[<em>i</em>, <em>j</em>]:</p>
      <div class="table-responsive" id="eq2">
        <div class="display-equation">
          <span class="tex mytex">\begin{equation} \textstyle
          \mathbf {S}[i,j] = \sum \nolimits _{k=0}^{\infty } {C^k
          (\mathbf {p}_{i}^{(k)})^T \mathbf {p}_{j}^{(k)} }
          \end{equation}</span><br />
          <span class="equation-number">(2)</span>
        </div>
      </div>where <span class="inline-equation"><span class=
      "tex">$\mathbf {p}_{j}^{(k)}$</span></span> is the
      Personalised PageRank vector with respect to the seed node
      <em>j</em>, which can be iteratively obtained from
      <div class="table-responsive" id="eq3">
        <div class="display-equation">
          <span class="tex mytex">\begin{equation} \mathbf
          {p}_{j}^{(k)} = \mathbf {A} \mathbf {p}_{j}^{(k-1)} \ \
          \textrm { with } \ \ \mathbf {p}_{j}^{(0)} = \mathbf
          {e}_j \end{equation}</span><br />
          <span class="equation-number">(3)</span>
        </div>
      </div>It requires <em>O</em>(<em>K</em>(<em>m</em> +
      <em>n</em>)) time and <em>O</em>(<em>m</em> + <em>Kn</em>)
      memory to compute a single-pair score
      <strong>S</strong>[<em>i</em>, <em>j</em>] via Eqs.(<a class=
      "eqn" href="#eq2">2</a>) and (<a class="eqn" href=
      "#eq3">3</a>) on the static graph <em>G</em> with <em>n</em>
      nodes and <em>m</em> edges after <em>K</em> iterations. When
      the graph is dynamically updated, it will incur expensive
      cost to recompute all CoSimRank scores from scratch.
      <p></p>
    </section>
    <section id="sec-6">
      <header>
        <div class="title-info">
          <h2><span class="section-number">4</span> Proposed
          Schemes</h2>
        </div>
      </header>
      <p>We first present our efficient dynamic scheme, D-CoSim,
      that can quickly and accurately retrieve CoSimRank scores
      over large evolving graphs. Next, we will show that our
      dynamic D-CoSim is applicable to greatly speed up CoSimRank
      search over static graphs, and propose our static scheme,
      F-CoSim.</p>
      <section id="sec-7">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.1</span> D-CoSim
            over Evolving Graphs</h3>
          </div>
        </header>
        <p>Given an old graph <em>G</em>, and a set of new edges
        updated to <em>G</em>:</p>
        <div class="table-responsive">
          <div class="display-equation">
            <span class="tex mytex">\[ \Delta G=\{ ({{v}_{1}}
            \rightarrow {{u}_{1}}),({{v}_{2}} \rightarrow
            {{u}_{2}}), ({{v}_{3}} \rightarrow {{u}_{3}}),\cdots \}
            \]</span><br />
          </div>
        </div>According to the end point <em>u<sub>i</sub></em> of
        each edge (<em>v<sub>i</sub></em> → <em>u<sub>i</sub></em>
        ) in <em>ΔG</em>, we first bunch all edges in <em>ΔG</em>
        into pieces:
        <div class="table-responsive">
          <div class="display-equation">
            <span class="tex mytex">\[ \Delta G=\Delta
            {{G}_{{{u}_{1}}}}\cup \Delta {{G}_{{{u}_{2}}}}\cup
            \cdots \cup \Delta {{G}_{{{u}_{p}}}} \]</span><br />
          </div>
        </div>such that all edges in each piece <span class=
        "inline-equation"><span class="tex">$\Delta
        {{G}_{{{u}_{i}}}}$</span></span> share a common end point
        <em>u<sub>i</sub></em> . Thus, each piece <span class=
        "inline-equation"><span class="tex">$\Delta
        {{G}_{{{u}_{i}}}}$</span></span> takes the following form:
        <div class="table-responsive">
          <div class="display-equation">
            <span class="tex mytex">\[ \Delta {{G}_{{{u}_{i}}}}=\{
            ({{v}_{{{i}_{1}}}} \rightarrow
            {{u}_{i}}),({{v}_{{{i}_{2}}}} \rightarrow
            {{u}_{i}}),\cdots ,({{v}_{{{i}_{\delta }}}} \rightarrow
            {{u}_{i}})\} \]</span><br />
          </div>
        </div>which is abbreviated as <span class=
        "inline-equation"><span class="tex">$\Delta
        {{G}_{{{u}_{i}}}}\triangleq
        \left([{{v}_{{{i}_{1}}}},{{v}_{{{i}_{2}}}},\cdots
        ,{{v}_{{{i}_{\delta }}}}] \rightarrow {{u}_{i}}
        \right).$</span></span>
        <figure id="fig1">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3186126/images/www2018-135-fig1.jpg"
          class="img-responsive" alt="Figure 1" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 1:</span>
            <span class="figure-title">Example of old web graph
            <em>G</em> (solid arrows) updated by Δ<em>G</em> (six
            new edges in dashed arrows)</span>
          </div>
        </figure>
        <p></p>
        <div class="example" id="enc1">
          <label>Example 4.1.</label>
          <p>Figure&nbsp;<a class="fig" href="#fig1">1</a> depicts
          old graph <em>G</em> (solid arrows), and an update graph
          <em>ΔG</em> (dashed arrows) to <em>G</em>:</p>
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \Delta G=\{ (a \rightarrow
              f),(c \rightarrow e),(d \rightarrow g),(f \rightarrow
              e),(b \rightarrow f),(g \rightarrow e)\} .
              \]</span><br />
            </div>
          </div>We lump edges of <em>ΔG</em> into 3 pieces:
          <em>ΔG</em> = <em>ΔG<sub>e</sub></em>
          ∪<em>ΔG<sub>f</sub></em> ∪<em>ΔG<sub>g</sub></em> , where
          <em>ΔG<sub>e</sub></em> = {(<em>c</em> → <em>e</em>),
          (<em>f</em> → <em>e</em>), (<em>g</em> →
          <em>e</em>)}≜([<em>c</em>, <em>f</em>, <em>g</em>] →
          <em>e</em>),
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \Delta {{G}_{f}}=\{ (a
              \rightarrow f),(b \rightarrow f)\} \triangleq ([a,b]
              \rightarrow f), \ \ \Delta {{G}_{g}}=([d] \rightarrow
              g).\qquad \Box \]</span><br />
            </div>
          </div>
          <p></p>
        </div>
        <p>The way we chunk edges of <em>ΔG</em> has two
        advantages: First, we can efficiently characterise the
        changes to <strong>A</strong> in answer to <span class=
        "inline-equation"><span class="tex">$\Delta
        {{G}_{{{u}_{i}}}}$</span></span> as a linear transformation
        of the <em>u<sub>i</sub></em> -th column of the old
        <strong>A</strong>. This characterisation allows us to
        dynamically capture only the “refreshed areas” of CoSimRank
        scores in answer to the update <span class=
        "inline-equation"><span class="tex">$\Delta
        {{G}_{{{u}_{i}}}}$</span></span> . Second, bunching edges
        of <em>ΔG</em> facilitates sharing and reuse of common
        information among all the edge updates over each piece
        <span class="inline-equation"><span class="tex">$\Delta
        {{G}_{{{u}_{i}}}}$</span></span> , thus discarding many
        unnecessary repeated computations on evolving graphs. For
        instance, to efficiently update CoSimRank similarities in
        response to each piece <span class=
        "inline-equation"><span class="tex">$\Delta
        {{G}_{{{u}_{i}}}}\triangleq
        ([{{v}_{{{i}_{1}}}},{{v}_{{{i}_{2}}}},\cdots
        ,{{v}_{{{i}_{\delta }}}}] \rightarrow
        {{u}_{i}})$</span></span> , the intermediate results to
        update the edge <span class="inline-equation"><span class=
        "tex">$({{v}_{{{i}_{1}}}} \rightarrow
        {{u}_{i}})$</span></span> , once computed, can be maximally
        reused to update all the other edges (<em>e.g.,&nbsp;</em>
        <span class="inline-equation"><span class=
        "tex">$({{v}_{{{i}_{2}}}} \rightarrow
        {{u}_{i}}),({{v}_{{{i}_{3}}}} \rightarrow
        {{u}_{i}}),\cdots$</span></span> ) in <span class=
        "inline-equation"><span class="tex">$\Delta
        {{G}_{{{u}_{i}}}}$</span></span> . Therefore, D-CoSim is
        highly efficient over evolving graphs.</p>
        <p>Having bunched all edges of <em>ΔG</em> into chunks, we
        propose an efficient approach that dynamically computes the
        changes to the CoSimRank scores in response to each update
        piece <em>ΔG<sub>u</sub></em> .<a class="fn" href="#fn2"
        id="foot-fn2"><sup>2</sup></a> We observe that each update
        piece <em>ΔG<sub>u</sub></em> changes only one column of
        <strong>A</strong>. Specifically, we show the following
        lemma.</p>
        <div class="lemma" id="enc2">
          <label>Lemma 4.2.</label>
          <p>Given old graph <em>G</em>, and an update piece to
          <em>G</em>: <span class="inline-equation"><span class=
          "tex">$\Delta {{G}_{u}} = ([{{v}_{1}},{{v}_{2}},\cdots
          ,{{v}_{\delta _u }}] \rightarrow u)$</span></span> , the
          new column-normalised adjacency matrix <span class=
          "inline-equation"><span class="tex">$\mathbf
          {\tilde{A}}$</span></span> of the graph
          (<em>G</em>⊕<em>ΔG<sub>u</sub></em> ) can be dynamically
          updated from old <strong>A</strong> by replacing its
          <em>u</em>-th column with</p>
          <div class="table-responsive" id="eq4">
            <div class="display-equation">
              <span class="tex mytex">\begin{equation} \mathbf
              {\tilde{A}}[:,u]=\tfrac{1}{\delta _u + {{\deg
              }^{-}_u} }\left({{\deg }^{-}_u} \mathbf
              {A}[:,u]+{{\mathbf {1}}_{\{
              {{v}_{1}},{{v}_{2}},\cdots ,{{v}_{\delta _u }}\} }}
              \right) \end{equation}</span><br />
              <span class="equation-number">(4)</span>
            </div>
          </div>where <span class="inline-equation"><span class=
          "tex">${{\deg }^{-}_u}$</span></span> is the in-degree of
          node <em>u</em> in old graph <em>G</em>;
          <em>δ<sub>u</sub></em> is the number of edge updates in
          <em>ΔG<sub>u</sub></em> ; and <span class=
          "inline-equation"><span class="tex">${{\mathbf {1}}_{\{
          {{v}_{1}},{{v}_{2}},\cdots ,{{v}_{\delta _u }}\}
          }}$</span></span> is a column vector (its length is the
          number of rows in new <span class=
          "inline-equation"><span class="tex">$\mathbf
          {\tilde{A}}$</span></span> ) with 1s in the <span class=
          "inline-equation"><span class=
          "tex">$({{v}_{1}},{{v}_{2}},\cdots ,{{v}_{\delta _u
          }})$</span></span> -th entries, and 0s elsewhere.
          <p></p>
        </div>
        <p>Note that if the new <span class=
        "inline-equation"><span class="tex">$\mathbf
        {\tilde{A}}$</span></span> and old <strong>A</strong> are
        not of the same size (this case will happen when there are
        new nodes in <em>ΔG<sub>u</sub></em> ), then prior to using
        Eq.(<a class="eqn" href="#eq4">4</a>), we should first
        border <strong>A</strong> with new zero-columns on the
        right and new zero-rows on the bottom to make it the same
        size of new <span class="inline-equation"><span class=
        "tex">$\mathbf {\tilde{A}}$</span></span> .</p>
        <div class="example" id="enc3">
          <label>Example 4.3.</label>
          <p>In Figure&nbsp;<a class="fig" href="#fig1">1</a>, old
          graph <em>G</em> has 5 nodes, so the old
          <strong>A</strong> is of size 5 × 5. In
          <em>ΔG<sub>e</sub></em> = ([<em>c</em>, <em>f</em>,
          <em>g</em>] → <em>e</em>) there are two new nodes
          <em>f</em> and <em>g</em>. Thus, to update
          <strong>A</strong> in answer to <em>ΔG<sub>e</sub></em> ,
          we first border <strong>A</strong> to 7 × 7 with two zero
          columns and rows:</p>
          <figure id="fig2">
            <img src=
            "../../../data/deliveryimages.acm.org/10.1145/3190000/3186126/images/www2018-135-fig2.jpg"
            class="img-responsive" alt="" longdesc="" />
          </figure>
          <p></p>
          <p>Then, since <span class="inline-equation"><span class=
          "tex">${{\deg }^{-}_e}=2$</span></span> and
          <em>δ<sub>e</sub></em> = 3, in light of Eq.(<a class=
          "eqn" href="#eq3">3</a>), the <em>e</em>-th column of
          <strong>A</strong> in answer to <em>ΔG<sub>e</sub></em>
          is updated to</p>
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \mathbf
              {\tilde{A}}[:,e]=\tfrac{1}{3+2}\left(2 \mathbf
              {A}[:,e] +{{\mathbf {1}}_{\{ c,f,g\} }} \right) = [0,
              \tfrac{1}{5}, \tfrac{1}{5}, \tfrac{1}{5}, 0,
              \tfrac{1}{5}, \tfrac{1}{5}]^T. \Box \]</span><br />
            </div>
          </div>
          <p></p>
        </div>
        <p>Leveraging Lemma&nbsp;<a class="enc" href=
        "#enc2">4.2</a>, we next show how to dynamically update
        CoSimRank scores in answer to each piece
        <em>ΔG<sub>u</sub></em> .</p>
        <div class="theorem" id="enc4">
          <label>Theorem 4.4.</label>
          <p>Given an old graph <em>G</em>, an update piece to
          <em>G</em>: <span class="inline-equation"><span class=
          "tex">$\Delta {{G}_{u}} = ([{{v}_{1}},\cdots
          ,{{v}_{\delta _u}}] \rightarrow u)$</span></span> , and a
          query node <em>q</em> ∈
          (<em>G</em>⊕<em>ΔG<sub>u</sub></em> ), the changes
          <strong><em>Δ</em>S</strong>[:, <em>q</em>] to CoSimRank
          scores with respect to <em>q</em> are dynamically
          computed as</p>
          <div class="table-responsive" id="eq5">
            <div class="display-equation">
              <span class="tex mytex">\begin{equation} \textstyle
              \mathbf {\Delta S}[:,q]= \sum \limits _{k=0}^{\infty
              }{{{C}^{k}}\left({{\mathbf {t}}^{(k)}}[q]\cdot
              {{\mathbf {p}}^{(k)}} + {{\mathbf {p}}^{(k)}}[q]\cdot
              {{\mathbf {t}}^{(k)}} \right)}
              \end{equation}</span><br />
              <span class="equation-number">(5)</span>
            </div>
          </div>where <strong>p</strong>
          <sup>(<em>k</em>)</sup>[<em>q</em>] and
          <strong>t</strong> <sup>(<em>k</em>)</sup>[<em>q</em>]
          denote the <em>q</em>-th entry of the vectors
          <strong>p</strong> <sup>(<em>k</em>)</sup> and
          <strong>t</strong> <sup>(<em>k</em>)</sup>, respectively,
          which are iteratively obtained by
          <div class="table-responsive" id="eq6">
            <div class="display-equation">
              <span class="tex mytex">\begin{equation} \! \left\{
              \!\! \begin{array}{ll}{\mathbf {p}}^{(0)}={{\mathbf
              {e}}_{u}} \\ {{\mathbf {p}}^{(k)}}={{{\mathbf
              {\tilde{A}}}}^{T}}{{\mathbf {p}}^{(k-1)}} \end{array}
              \right. \! \left\{ \!\! \begin{array}{ll}{\mathbf
              {t}}^{(0)}=\tfrac{C}{2({{\delta }_{u}}+\deg
              _{u}^{-})}{{(\mathbf {A}+\mathbf {\tilde{A}})^T}}
              {{\mathbf {r}}} \\ {{\mathbf {t}}^{(k)}}=\mathbf
              {\tilde{A}}^T{{\mathbf {t}}^{(k-1)}} \end{array}
              \right. \!\!\!\!\! \end{equation}</span><br />
              <span class="equation-number">(6)</span>
            </div>
          </div>and <strong>r</strong> = lim <sub><em>K</em> →
          ∞</sub> <strong>r</strong> <sup>(<em>K</em>)</sup>, which
          can be iteratively derived as
          <div class="table-responsive" id="eq7">
            <div class="display-equation">
              <span class="tex mytex">\begin{equation} \ \ \
              \left\{ \!\! \begin{array}{ll}{\mathbf
              {r}}^{(0)}={{\mathbf {w}}^{(K)}} \\ {{\mathbf
              {r}}^{(k)}}=C{{\mathbf {A}}^{T}}{{\mathbf
              {r}}^{(k-1)}}+{{\mathbf {w}}^{(K-k)}} \end{array}
              \right. \ \quad (1 \le k \le K)
              \end{equation}</span><br />
              <span class="equation-number">(7)</span>
            </div>
          </div>
          <div class="table-responsive" id="eq8">
            <div class="display-equation">
              <span class="tex mytex">\begin{equation}
              \!\!\!\!\!\!\textrm {with }\left\{ \!\!
              \begin{array}{ll}{\mathbf {w}}^{(0)}= {{\mathbf
              {1}}_{\{ {{v}_{1}},\cdots ,{{v}_{{{\delta }_{u}}}}\}
              }}-\delta _u \mathbf {A}[:,u] \\ {{\mathbf
              {w}}^{(k)}}=\mathbf {A}{{\mathbf {w}}^{(k-1)}}
              \end{array} \right. \ \ (1 \le k \le K)
              \end{equation}</span><br />
              <span class="equation-number">(8)</span>
            </div>
          </div>
          <p></p>
        </div>
        <div class="proof" id="proof1">
          <label>Proof.</label>
          <p>After <em>ΔG<sub>u</sub></em> is updated to
          <em>G</em>, by definition in Eq.(<a class="eqn" href=
          "#eq1">1</a>), the new CoSimRank scores
          (<strong>S</strong> + <strong><em>Δ</em>S</strong>) in
          <em>G</em>⊕<em>ΔG<sub>u</sub></em> satisfy</p>
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \mathbf {S}+\mathbf
              {\Delta S}=C{{\mathbf {\tilde{A}}}^{T}}\left(\mathbf
              {S}+\mathbf {\Delta S} \right)\mathbf
              {\tilde{A}}+\mathbf {I} \]</span><br />
            </div>
          </div>Rearranging the terms in the above equation yields
          <div class="table-responsive" id="eq9">
            <div class="display-equation">
              <span class="tex mytex">\begin{equation} \mathbf
              {\Delta S}=C{{\mathbf {\tilde{A}}}^{T}}\mathbf
              {\Delta S\tilde{A}}+\mathbf {E} \ \ \textrm { with }
              \ \ \mathbf {E}=C{{\mathbf {\tilde{A}}}^{T}}\mathbf
              {S\tilde{A}}+\mathbf {I}-\mathbf {S}
              \end{equation}</span><br />
              <span class="equation-number">(9)</span>
            </div>
          </div>Let <span class="inline-equation"><span class=
          "tex">$\mathbf {\Delta A} = \mathbf {\tilde{A}} - \mathbf
          {A}$</span></span> . From Eq.(<a class="eqn" href=
          "#eq4">4</a>) in Lemma&nbsp;<a class="enc" href=
          "#enc2">4.2</a>, we have
          <div class="table-responsive" id="eq10">
            <div class="display-equation">
              <span class="tex mytex">\begin{equation} \mathbf
              {\Delta A}[:,u] =\tfrac{1}{{{\delta }_{u}}+\deg
              _{u}^{-}}\left({{\mathbf {1}}_{\{ {{v}_{1}},\cdots
              ,{{v}_{{{\delta }_{u}}}}\} }}-\delta _u \mathbf
              {A}[:,u] \right) \end{equation}</span><br />
              <span class="equation-number">(10)</span>
            </div>
          </div>To simplify <strong>E</strong> in Eq.(<a class=
          "eqn" href="#eq9">9</a>), we plug <span class=
          "inline-equation"><span class="tex">$\mathbf
          {\tilde{A}}=\mathbf {A}+\mathbf {\Delta A}[:,u]{{\mathbf
          {e}}_{u}^{T}}$</span></span> and <strong>S</strong> =
          <em>C</em> <strong>A</strong> <sup><em>T</em></sup>
          <strong>S</strong> <strong>A</strong> +
          <strong>I</strong>, and let <strong>f</strong>
          <sub><em>u</em></sub> ≜<strong>S<em>Δ</em>A</strong>[:,
          <em>u</em>], which produces
          <div class="table-responsive" id="eq11">
            <div class="display-equation">
              <span class="tex mytex">\begin{align} \mathbf {E}
              \nonumber &amp; =C({{\mathbf {e}}_{u}}({{\mathbf
              {f}}_{u}^{T}}\mathbf {A})+({{\mathbf
              {A}}^{T}}{{\mathbf {f}}_{u}}){{\mathbf
              {e}}_{u}^{T}}+(\mathbf {\Delta
              A}{{[:,u]}^{T}}{{\mathbf {f}}_{u}}){{\mathbf
              {e}}_{u}}{{\mathbf {e}}_{u}^{T}})\\ &amp; ={{\mathbf
              {e}}_{u}}{{\mathbf {x}^{T}}}+\mathbf {x}{{\mathbf
              {e}}_{u}^{T}} \ \ \textrm { where }
              \end{align}</span><br />
              <span class="equation-number">(11)</span>
            </div>
          </div>
          <div class="table-responsive" id="eq12">
            <div class="display-equation">
              <span class="tex mytex">\begin{align} \nonumber
              \mathbf {x} &amp; =C{{\mathbf {A}}^{T}}{{\mathbf
              {f}}_{u}}+\tfrac{C}{2}(\mathbf {\Delta
              A}{{[:,u]}^{T}}{{\mathbf {f}}_{u}}){{\mathbf
              {e}}_{u}} \\\nonumber &amp; =C({{\mathbf
              {A}}^{T}}+\tfrac{1}{2}{{\mathbf {e}}_{u}}\mathbf
              {\Delta A}{{[:,u]}^{T}}){{\mathbf {f}}_{u}} \qquad
              \textrm {\{ using Eq.(10)\} } \\ &amp;
              =\tfrac{C}{2}({{\mathbf {A}}^{T}}+{{{\mathbf
              {\tilde{A}}}}^{T}}){{\mathbf {f}}_{u}}
              \end{align}</span><br />
              <span class="equation-number">(12)</span>
            </div>
          </div>Thus, combining Eqs.(<a class="eqn" href=
          "#eq9">9</a>) and (<a class="eqn" href="#eq11">11</a>),
          we obtain
          <div class="table-responsive" id="eq13">
            <div class="display-equation">
              <span class="tex mytex">\begin{align} \nonumber
              \mathbf {\Delta S} &amp; \textstyle =\sum \limits
              _{k=0}^{\infty }{{{C}^{k}}{{({{{\mathbf
              {\tilde{A}}}}^{T}})}^{k}}\mathbf {E}{{{\mathbf
              {\tilde{A}}}}^{k}}} \qquad \textrm {\{ using
              Eq.(11)\} } \\ &amp; \textstyle =\sum \limits
              _{k=0}^{\infty } { {{C}^{k}} \left({ {{({{{\mathbf
              {\tilde{A}}}}^{T}})}^{k}}{{\mathbf {e}}_{u}}{{\mathbf
              {x}}^{T}}{{{\mathbf
              {\tilde{A}}}}^{k}}}+{{{({{{\mathbf
              {\tilde{A}}}}^{T}})}^{k}}\mathbf {x}{{\mathbf
              {e}}_{u}^{T}}{{{\mathbf {\tilde{A}}}}^{k}}} \right) }
              \end{align}</span><br />
              <span class="equation-number">(13)</span>
            </div>
          </div>By direct iteration, it follows from Eqs.(<a class=
          "eqn" href="#eq6">6</a>) and (<a class="eqn" href=
          "#eq8">8</a>) that
          <div class="table-responsive" id="eq14">
            <div class="display-equation">
              <span class="tex mytex">\begin{equation} {
              \!\!\!\!\!\!\!{{\mathbf {p}}^{(k)}} ={{({{{\mathbf
              {\tilde{A}}}}^{T}})^{k}}}{{\mathbf {e}}_{u}}, \quad
              {{\mathbf {w}}^{(k)}} ={{\mathbf {A}}^{k}}({{\mathbf
              {1}}_{\{ {{v}_{1}},\cdots ,{{v}_{{{\delta }_{u}}}}\}
              }}-\delta _u \mathbf {A}[:,u])}
              \end{equation}</span><br />
              <span class="equation-number">(14)</span>
            </div>
          </div>To express <strong>r</strong> in <strong>t</strong>
          <sup>(0)</sup> of Eq.(<a class="eqn" href="#eq6">6</a>),
          by iteration, Eq.(<a class="eqn" href="#eq7">7</a>)
          implies
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ {{\mathbf
              {r}}^{(K)}}={{\left(C{{\mathbf {A}}^{T}}
              \right)}^{K}}{{\mathbf {w}}^{(K)}}+{{\left(C{{\mathbf
              {A}}^{T}} \right)}^{K-1}}{{\mathbf
              {w}}^{(K-1)}}+\cdots +{{\mathbf {w}}^{(0)}}
              \]</span><br />
            </div>
          </div>
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ { =\underbrace{\big
              ({{(C{{\mathbf {A}}^{T}})}^{K}}{{\mathbf
              {A}}^{K}}+{{(C{{\mathbf {A}}^{T}})}^{K-1}}{{\mathbf
              {A}}^{K-1}}+\cdots +\mathbf {I} \big)}_{=\text{\{ the
              first $K$ terms of $\mathbf {S}=\sum _{k=0}^{\infty
              }{C^k (\mathbf {A}^T)^k \mathbf {A}^k}$\} }} \!
              \underbrace{\big ({{\mathbf {1}}_{\{ {{v}_{1}},\cdots
              ,{{v}_{{{\delta }_{u}}}}\} }}-\delta _u \mathbf
              {A}[:,u] \big)}_{\textrm {\{ By Eq.(10)\} }=({{\delta
              }_{u}}+\deg _{u}^{-})\mathbf {\Delta A}[:,u]} }
              \]</span><br />
            </div>
          </div>By taking limits on both sides, we have
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \mathbf {r}\triangleq
              \underset{K\rightarrow \infty }{\mathop {\lim
              }}\,{{\mathbf {r}}^{(K)}}=\left({{\delta }_{u}}+\deg
              _{u}^{-} \right)\mathbf {S\Delta
              A}[:,u]=\left({{\delta }_{u}}+\deg _{u}^{-}
              \right){{\mathbf {f}}_{u}} \]</span><br />
            </div>
          </div>Thus, by plugging <span class=
          "inline-equation"><span class="tex">$\mathbf {r}
          =\left({{\delta }_{u}}+\deg _{u}^{-} \right){{\mathbf
          {f}}_{u}}$</span></span> into Eq.(<a class="eqn" href=
          "#eq6">6</a>), we get
          <div class="table-responsive" id="eq15">
            <div class="display-equation">
              <span class="tex mytex">\begin{equation}
              \!\!\!\!\!\!\! {{{\mathbf
              {t}}^{(0)}}=\tfrac{C}{2}({{\mathbf {A}}}+{{{\mathbf
              {\tilde{A}}}}})^{T}{{\mathbf {f}}_{u}}=\textrm {\{ By
              Eq.(12)\} }=\mathbf {x}, \quad {{\mathbf
              {t}}^{(k)}}={({{\mathbf {\tilde{A}}}}^{k})^T}\mathbf
              {x}} \end{equation}</span><br />
              <span class="equation-number">(15)</span>
            </div>
          </div>Substituting Eqs.(<a class="eqn" href=
          "#eq14">14</a>) and (<a class="eqn" href="#eq15">15</a>)
          into Eq.(<a class="eqn" href="#eq13">13</a>) produces
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \textstyle \mathbf {\Delta
              S}=\sum \limits _{k=0}^{\infty
              }{{{C}^{k}}\left({{\mathbf
              {p}}^{(k)}}{{\left({{\mathbf {t}}^{(k)}}
              \right)}^{T}}+{{\mathbf {t}}^{(k)}}{{\left({{\mathbf
              {p}}^{(k)}} \right)}^{T}} \right)} \]</span><br />
            </div>
          </div>Finally, post-multiplying both sides by
          <strong>e</strong> <sub><em>q</em></sub> yields
          Eq.(<a class="eqn" href="#eq5">5</a>).
          <p></p>
        </div>
        <p>Example 3. <em>Recall the old <em>G</em> (solid arrows)
        in Figure&nbsp;<a class="fig" href="#fig1">1</a>, and
        update piece <em>ΔG<sub>e</sub></em> = ([<em>c</em>,
        <em>f</em>, <em>g</em>] → <em>e</em>) to <em>G</em> (dashed
        arrows). Given query <em>q</em> = <em>e</em>, number of
        iterations <em>K</em> = 3, and decay factor <em>C</em> =
        0.6, Theorem&nbsp;<a class="enc" href="#enc4">4.4</a>
        retrieves <strong><em>Δ</em>S</strong>[:, <em>e</em>] as
        follows:</em></p>
        <p><em>First, we compute {<strong>w</strong>
        <sup>(<em>k</em>)</sup>} and {<strong>r</strong>
        <sup>(<em>k</em>)</sup>} via Eqs.(<a class="eqn" href=
        "#eq8">8</a>) and (<a class="eqn" href=
        "#eq7">7</a>):</em></p>
        <div class="table-responsive" id="inltbl3">
          <table class="table">
            <thead>
              <tr>
                <th style="text-align:left;"><em>k</em></th>
                <th style="text-align:left;"><strong>w</strong>
                <sup>(<em>k</em>)</sup></th>
                <th><strong>r</strong> <sup>(<em>k</em>)</sup></th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td style="text-align:left;">0</td>
                <td style="text-align:left;">[0, −1.5, 1, −1.5, 0,
                1, 1] <sup><em>T</em></sup></td>
                <td>[0, 0, 0, 0, 0, 0, 0]
                <sup><em>T</em></sup></td>
              </tr>
              <tr>
                <td style="text-align:left;">1</td>
                <td style="text-align:left;">[ − .25, 0, −.75, .5,
                0, 0, 0] <sup><em>T</em></sup></td>
                <td>[ − .375, 0, 0, −.375, 0, 0, 0]
                <sup><em>T</em></sup></td>
              </tr>
              <tr>
                <td style="text-align:left;">2</td>
                <td style="text-align:left;">[ − .375, 0, 0, −.375,
                0, 0, 0] <sup><em>T</em></sup></td>
                <td>[ − .25, −.113, −.975, .5, −.113, 0, 0]
                <sup><em>T</em></sup></td>
              </tr>
              <tr>
                <td style="text-align:left;">3</td>
                <td style="text-align:left;">[0, 0, 0, 0, 0, 0, 0]
                <sup><em>T</em></sup></td>
                <td>[0, −1.868, 1.075, −1.5, .116, 1, 1]
                <sup><em>T</em></sup></td>
              </tr>
            </tbody>
          </table>
        </div>
        <p><em>Next, we obtain {<strong>p</strong>
        <sup>(<em>k</em>)</sup>} and {<strong>t</strong>
        <sup>(<em>k</em>)</sup>} via Eq.(<a class="eqn" href=
        "#eq6">6</a>) with <strong>r</strong> = <strong>r</strong>
        <sup>(3)</sup>:</em></p>
        <div class="table-responsive" id="inltbl4">
          <table class="table">
            <thead>
              <tr>
                <th style="text-align:left;"><em>k</em></th>
                <th style="text-align:left;"><strong>p</strong>
                <sup>(<em>k</em>)</sup></th>
                <th><strong>t</strong> <sup>(<em>k</em>)</sup></th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td style="text-align:left;">0</td>
                <td style="text-align:left;">[0, 0, 0, 0, 1, 0, 0]
                <sup><em>T</em></sup></td>
                <td>[0, .065, −.09, 0, −.105, 0, 0]
                <sup><em>T</em></sup></td>
              </tr>
              <tr>
                <td style="text-align:left;">1</td>
                <td style="text-align:left;">[0, 0, 0, 0, 0, 0, 0]
                <sup><em>T</em></sup></td>
                <td>[0, −.045, 0, 0, −.005, 0, 0]
                <sup><em>T</em></sup></td>
              </tr>
              <tr>
                <td style="text-align:left;">2</td>
                <td style="text-align:left;">[0, 0, 0, 0, 0, 0, 0]
                <sup><em>T</em></sup></td>
                <td>[0, 0, 0, 0, −.009, 0, 0]
                <sup><em>T</em></sup></td>
              </tr>
              <tr>
                <td style="text-align:left;">3</td>
                <td style="text-align:left;">[0, 0, 0, 0, 0, 0, 0]
                <sup><em>T</em></sup></td>
                <td>[0, 0, 0, 0, 0, 0, 0]
                <sup><em>T</em></sup></td>
              </tr>
            </tbody>
          </table>
        </div>
        <p><em>Finally, we use Eq.(<a class="eqn" href=
        "#eq5">5</a>) to derive <strong><em>Δ</em>S</strong>[:,
        <em>e</em>] in answer to <em>ΔG<sub>e</sub></em> :</em></p>
        <div class="table-responsive">
          <div class="display-equation">
            <span class="tex mytex">\begin{align*} \mathbf {\Delta
            S}[:,e] &amp;= \textstyle \sum \nolimits _{k=0}^{3
            }{{{0.6}^{k}}\left({{\mathbf {t}}^{(k)}}[e]\cdot
            {{\mathbf {p}}^{(k)}} + {{\mathbf {p}}^{(k)}}[e]\cdot
            {{\mathbf {t}}^{(k)}} \right)} \\ &amp;=[0, .0645,
            -.09, 0, -.2091, 0, 0]^T \Box\end{align*}</span><br />
          </div>
        </div>
        <p></p>
        <p>Theorem&nbsp;<a class="enc" href="#enc4">4.4</a> implies
        an efficient dynamic method, D-CoSim, to retrieve the
        changes to CoSimRank scores (Algorithm&nbsp;1).</p>
        <p><img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3186126/images/www2018-135-graphic3.jpg"
        class="img-responsive" alt="" longdesc="" /></p>
        <p><strong>Correctness.</strong> While
        Theorem&nbsp;<a class="enc" href="#enc4">4.4</a> guarantees
        the correctness of <strong><em>Δ</em>S</strong>
        <em>w.r.t.&nbsp;one piece</em> update
        <em>ΔG<sub>u</sub></em> only, the following theorem
        guarantees further that, after one piece update
        <em>ΔG<sub>u</sub></em> is processed, other pieces being
        processed will not distort the correct CoSimRank results
        <strong><em>Δ</em>S</strong>[:, <em>Q</em>].</p>
        <div class="theorem" id="enc5">
          <label>Theorem 4.5.</label>
          <p>Let <em>ΔG</em>≜{<em>ΔG</em> <sub>1</sub>, <em>ΔG</em>
          <sub>2</sub>, ⋅⋅⋅, <em>ΔG<sub>p</sub></em> } be a set of
          edges bunched into pieces updated to the old graph
          <em>G</em> (line&nbsp;1). The CoSimRank changes
          <strong><em>Δ</em>S</strong> (line&nbsp;20) returned by
          D-CoSim are the correct answers in response to the update
          graph <em>ΔG</em>.</p>
        </div>
        <div class="proof" id="proof2">
          <label>Proof.</label>
          <p>Let <strong><em>Δ</em></strong> <strong>A</strong>,
          <strong><em>Δ</em></strong>
          <strong>A<sub>1</sub></strong> ,
          <strong><em>Δ</em></strong>
          <strong>A<sub>2</sub></strong> , ⋅⋅⋅,
          <strong><em>Δ</em></strong>
          <strong>A<sub>p</sub></strong> be the changes to the
          column-normalised adjacency matrices
          <em>w.r.t.&nbsp;</em>the graph updates <em>ΔG</em>,
          <em>ΔG</em> <sub>1</sub>, <em>ΔG</em> <sub>2</sub>, ⋅⋅⋅,
          <em>ΔG<sub>p</sub></em> , respectively.</p>
          <p>In the 1st round of for-loop (lines 4–19): D-CoSim
          starts by viewing <em>G</em> <sub>0</sub> (≜<em>G</em>)
          as the old graph, and <strong>S<sub>0</sub></strong>
           (≜<strong>S</strong>) as the old CoSimRank scores, and
          update the 1st chunk <em>ΔG</em> <sub>1</sub> to
          <em>G</em> <sub>0</sub>. Theorem&nbsp;<a class="enc"
          href="#enc4">4.4</a> ensures that <strong>s</strong>
          (line&nbsp;18) at the 1st round, denoted by
          <strong><em>Δ</em>S<sub>1</sub></strong> , is the
          CoSimRank changes <em>w.r.t.&nbsp;</em>the update
          <em>ΔG</em> <sub>1</sub> to <em>G</em> <sub>0</sub>,
          <em>i.e.,&nbsp;</em>
          <strong><em>Δ</em>S<sub>1</sub></strong> satisfies</p>
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \mathbf {S_0} + \mathbf
              {\Delta S_1} = C (\mathbf {A_0}+ \mathbf {\Delta
              A_1})^T (\mathbf {S_0} + \mathbf {\Delta S_1})
              (\mathbf {A_0}+ \mathbf {\Delta A_1}) + \mathbf {I}
              \]</span><br />
            </div>
          </div>Then, D-CoSim updates <strong><em>Δ</em>S</strong>
          (line&nbsp;18) by adding <strong>s</strong> (=
          <strong><em>Δ</em>S<sub>1</sub></strong> ), and updates
          the current graph from <em>G</em> <sub>0</sub> to
          <em>G</em> <sub>1</sub> (line&nbsp;19):
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \mathbf {\Delta S} =
              \mathbf {0} + \mathbf {\Delta S_1} = \mathbf {\Delta
              S_1}, \qquad \mathbf {A_1} = \mathbf {A_0} + \mathbf
              {\Delta A_1} \]</span><br />
            </div>
          </div>
          <p></p>
          <p>The for-loop (lines 4–19) continues till the last
          chunk <em>ΔG<sub>p</sub></em> is updated. In the
          <em>p</em>-th (last) round of for-loop (lines 4–18):
          D-CoSim regards <em>G</em> <sub><em>p</em> − 1</sub> (=
          <em>G</em> <sub><em>p</em> − 2</sub> + <em>ΔG</em>
          <sub><em>p</em> − 1</sub>) as the old graph, and
          <strong>S<sub>p − 1</sub></strong> (= <strong>S<sub>p −
          2</sub></strong> + <strong><em>Δ</em>S<sub>p −
          1</sub></strong> ) as the old CoSimRank scores, and
          updates the <em>p</em>-th chunk <em>ΔG<sub>p</sub></em>
          to <em>G</em> <sub><em>p</em> − 1</sub>.
          Theorem&nbsp;<a class="enc" href="#enc4">4.4</a> ensures
          that <strong>s</strong> (line&nbsp;18) at the
          <em>p</em>-th round, denoted by
          <strong><em>Δ</em>S<sub>p</sub></strong> , is the
          CoSimRank changes <em>w.r.t.&nbsp;</em>the update
          <em>ΔG<sub>p</sub></em> to <em>G</em> <sub><em>p</em> −
          1</sub>, <em>i.e.,&nbsp;</em>
          <strong><em>Δ</em>S<sub>p</sub></strong> satisfies</p>
          <div class="table-responsive" id="eq16">
            <div class="display-equation">
              <span class="tex mytex">\begin{equation}
              \begin{split} \mathbf {S_{p-1}} + \mathbf {\Delta
              S_p} = C &amp; (\mathbf {A_{p-1}}+ \mathbf {\Delta
              A_p})^T \cdot (\mathbf {S_{p-1}} + \mathbf {\Delta
              S_p}) \cdot \\ &amp; \qquad \cdot (\mathbf {A_{p-1}}+
              \mathbf {\Delta A_p}) + \mathbf {I} \end{split}
              \end{equation}</span><br />
              <span class="equation-number">(16)</span>
            </div>
          </div>Then, D-CoSim updates <strong><em>Δ</em>S</strong>
          (line&nbsp;18) by adding <strong>s</strong> (=
          <strong><em>Δ</em>S<sub>p</sub></strong> ), and updates
          the current graph from <em>G</em> <sub><em>p</em> −
          1</sub> to <em>G<sub>p</sub></em> (line&nbsp;19):
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \mathbf {\Delta S} =
              (\mathbf {\Delta S_1} + \cdots + \mathbf {\Delta
              S_{p-1}})+ \mathbf {\Delta S_{p}}, \quad \mathbf
              {A_p} = \mathbf {A_{p-1}} + \mathbf {\Delta A_p}
              \]</span><br />
            </div>
          </div>
          <p></p>
          <p>Finally, we check if <strong><em>Δ</em>S</strong> (=
          <strong><em>Δ</em>S<sub>1</sub></strong> +
          <strong><em>Δ</em>S<sub>2</sub></strong> + ⋅⋅⋅ +
          <strong><em>Δ</em>S<sub>p</sub></strong> ) is the correct
          CoSimRank changes <em>w.r.t.&nbsp;</em>the update
          <em>ΔG</em> to <em>G</em>. Our above analysis for each
          round of the for-loop implies</p>
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \mathbf {S_i} = \mathbf
              {S_{i-1}} + \mathbf {\Delta S_i}, \qquad \mathbf
              {A_i} = \mathbf {A_{i-1}} + \mathbf {\Delta A_i}
              \qquad (\forall i=1, \cdots , p-1) \]</span><br />
            </div>
          </div>Repeatedly applying the above iterations produces
          <div class="table-responsive" id="eq17">
            <div class="display-equation">
              <span class="tex mytex">\begin{align} \nonumber &amp;
              \mathbf {A_{p-1}} + \mathbf {\Delta A_p} = (\mathbf
              {A_{p-2}} + \mathbf {\Delta A_{p-1}}) + \mathbf
              {\Delta A_p} = \cdots = \\\nonumber = &amp; (\mathbf
              {A_0} + \mathbf {\Delta A_1}) + \mathbf {\Delta A_2}
              + \cdots + \mathbf {\Delta A_{p-1}} + \mathbf {\Delta
              A_p} \\ = &amp; \mathbf {A_0} + \mathbf {\Delta A} \
              \ \textrm { with } \ \ \mathbf {\Delta A} \triangleq
              \mathbf {\Delta A_1} + \cdots + \mathbf {\Delta A_p}
              \end{align}</span><br />
              <span class="equation-number">(17)</span>
            </div>
          </div>Similarly,
          <div class="table-responsive" id="eq18">
            <div class="display-equation">
              <span class="tex mytex">\begin{equation} {\mathbf
              {S_{p-1}} + \mathbf {\Delta S_p} = \mathbf {S_0} +
              \mathbf {\Delta S} \ \textrm { with } \ \mathbf
              {\Delta S} \triangleq \mathbf {\Delta S_1} + \cdots +
              \mathbf {\Delta S_p}} \end{equation}</span><br />
              <span class="equation-number">(18)</span>
            </div>
          </div>Plugging Eqs.(<a class="eqn" href="#eq17">17</a>)
          and (<a class="eqn" href="#eq18">18</a>) into
          Eq.(<a class="eqn" href="#eq16">16</a>) produces
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \mathbf {S_0} + \mathbf
              {\Delta S} = C (\mathbf {A_0}+ \mathbf {\Delta A})^T
              (\mathbf {S_0} + \mathbf {\Delta S}) (\mathbf {A_0}+
              \mathbf {\Delta A}) + \mathbf {I} \]</span><br />
            </div>
          </div>Thus, <strong><em>Δ</em>S</strong> satisfies the
          CoSimRank definition, which implies that
          <strong><em>Δ</em>S</strong> (=
          <strong><em>Δ</em>S<sub>1</sub></strong> +
          <strong><em>Δ</em>S<sub>2</sub></strong> + ⋅⋅⋅ +
          <strong><em>Δ</em>S<sub>p</sub></strong> ) returned by
          D-CoSim is exactly the CoSimRank changes
          <em>w.r.t.&nbsp;</em>the graph update <em>ΔG</em> (=
          <em>ΔG</em> <sub>1</sub> + ⋅⋅⋅ + <em>ΔG<sub>p</sub></em>
          ) to <em>G</em> <sub>0</sub> (≜<em>G</em>).
          <p></p>
        </div>
        <div class="example" id="enc6">
          <label>Example 4.6.</label>
          <p>Recall old graph <em>G</em> (solid arrows) and update
          graph <em>ΔG</em> to <em>G</em> (dashed arrows) in
          Figure&nbsp;<a class="fig" href="#fig1">1</a>. Given the
          query <em>q</em> = <em>e</em>, number of iterations
          <em>K</em> = 3, and decay factor <em>C</em> = 0.6,
          D-CoSim computes <strong><em>Δ</em>S</strong> in answer
          to <em>ΔG</em> as follows:</p>
          <p>First, D-CoSim chunks all edges of <em>ΔG</em> into
          three pieces: <em>ΔG</em> = <em>ΔG<sub>e</sub></em>
          ∪<em>ΔG<sub>f</sub></em> ∪<em>ΔG<sub>g</sub></em> ,
          according to Example&nbsp;<a class="enc" href=
          "#enc1">4.1</a>.</p>
          <p>Then, after CoSimRank changes
          <strong><em>Δ</em>S<sub>1</sub></strong> [:, <em>e</em>]
          <em>w.r.t.&nbsp;</em>1st piece update
          <em>ΔG<sub>e</sub></em> to <em>G</em> <sub>0</sub> (=
          <em>G</em>) are derived (see Example&nbsp;3):</p>
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \mathbf {\Delta S_1}[:,e]
              =[0, .0645, -.09, 0, -.2091, 0, 0]^T, \]</span><br />
            </div>
          </div>D-CoSim views <em>G</em> <sub>1</sub>(= <em>G</em>
          <sub>0</sub>⊕<em>ΔG<sub>e</sub></em> ) as the old graph,
          and computes changes
          <strong><em>Δ</em>S<sub>2</sub></strong> [:, <em>e</em>]
          <em>w.r.t.&nbsp;</em>2nd piece update
          <em>ΔG<sub>f</sub></em> to <em>G</em> <sub>1</sub>:
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \mathbf {\Delta S_2}[:,e]
              =[0, .009, 0, 0, .0239, .1, 0]^T. \]</span><br />
            </div>
          </div>Next, it views <em>G</em> <sub>2</sub>(= <em>G</em>
          <sub>1</sub>⊕<em>ΔG<sub>g</sub></em> ) as the old graph,
          and computes changes
          <strong><em>Δ</em>S<sub>3</sub></strong> [:, <em>e</em>]
          <em>w.r.t.&nbsp;</em>3rd piece update
          <em>ΔG<sub>g</sub></em> to <em>G</em> <sub>2</sub>:
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \mathbf {\Delta S_3}[:,e]
              =[0, .018, 0, 0, .0288, 0, .12]^T. \]</span><br />
            </div>
          </div>
          <p></p>
          <p>Finally, the CoSimRank changes
          <strong><em>Δ</em>S</strong>[:, <em>e</em>]
          <em>w.r.t.&nbsp;</em>the graph update <em>ΔG</em> (=
          <em>ΔG<sub>e</sub></em> ⊕<em>ΔG<sub>f</sub></em>
          ⊕<em>ΔG<sub>g</sub></em> ) are</p>
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\begin{align*} \mathbf
              {\Delta S}[:,e] &amp;= \mathbf {\Delta S_1}[:,e] +
              \mathbf {\Delta S_2}[:,e] + \mathbf {\Delta S_3}[:,e]
              \\ &amp;= [0, .0915, -.09, 0, -.1564, .1, .12]^T
              \quad \Box\end{align*}</span><br />
            </div>
          </div>
          <p></p>
        </div>
        <p><strong>Complexity.</strong> We analyse the
        computational cost of D-CoSim. Let <span class=
        "inline-equation"><span class=
        "tex">$\tilde{n}$</span></span> and <span class=
        "inline-equation"><span class=
        "tex">$\tilde{m}$</span></span> denote the number of nodes
        and edges in new <em>G</em>⊕<em>ΔG</em>, respectively. Let
        <em>δ</em> be the number of edges in <em>ΔG</em>, and
        <em>p</em> be the number of update pieces
        {<em>ΔG<sub>u</sub></em> } in <em>ΔG</em>. Clearly,
        <em>p</em> ≤ <em>δ</em>. D-CoSim has the following
        complexity bound:</p>
        <div class="theorem" id="enc7">
          <label>Theorem 4.7.</label>
          <p>D-CoSim requires <span class=
          "inline-equation"><span class=
          "tex">$O(K(\tilde{m}+\tilde{n}p|Q|))$</span></span> time
          and <span class="inline-equation"><span class=
          "tex">$O(\tilde{m}+K\tilde{n})$</span></span> memory to
          dynamically compute <strong><em>Δ</em>S</strong>[:,
          <em>Q</em>] after <em>K</em> iterations, where
          |<em>Q</em>| is the number of queries in <em>Q</em>.</p>
        </div>
        <div class="proof" id="proof3">
          <label>Proof.</label>
          <p>D-CoSim runs in three phases: (1) bunching edges of
          <em>ΔG</em> (line 1), (2) {<strong>p</strong>
          <sup>(<em>k</em>)</sup>} and {<strong>t</strong>
          <sup>(<em>k</em>)</sup>} iterating (lines 4–13), and (3)
          online query (lines 14–18). Specifically, bunching edges
          of <em>ΔG</em> requires <em>O</em>(<em>δ</em>) time and
          <em>O</em>(<em>δ</em>) memory for a linear scan of all
          edges in <em>ΔG</em>. To iteratively compute
          {<strong>p</strong> <sup>(<em>k</em>)</sup>} and
          {<strong>t</strong> <sup>(<em>k</em>)</sup>}, for each
          query <em>q</em> ∈ <em>Q</em> and each piece update
          <em>ΔG<sub>u</sub></em> , it entails <span class=
          "inline-equation"><span class=
          "tex">$O(K\tilde{m})$</span></span> time and <span class=
          "inline-equation"><span class=
          "tex">$O(\tilde{m}+K\tilde{n})$</span></span> memory for
          Eqs.(<a class="eqn" href="#eq6">6</a>)–(<a class="eqn"
          href="#eq8">8</a>). The <span class=
          "inline-equation"><span class=
          "tex">$O(K\tilde{m})$</span></span> time is dominated by
          5 matrix-vector products: <strong>A</strong>
          <strong>w</strong> <sup>(<em>k</em> − 1)</sup>
          (line&nbsp;5), <strong>A</strong> <sup><em>T</em></sup>
          <strong>r</strong> <sup>(<em>k</em> − 1)</sup>
          (line&nbsp;7), <span class="inline-equation"><span class=
          "tex">${{{\mathbf {\tilde{A}}}}^{T}}{{\mathbf
          {p}}^{(k-1)}}$</span></span> (line&nbsp;11), <span class=
          "inline-equation"><span class="tex">${{(\mathbf
          {A}+\mathbf {\tilde{A}})^T}} {{\mathbf
          {r}}}$</span></span> (line&nbsp;12), and <span class=
          "inline-equation"><span class="tex">$\mathbf
          {\tilde{A}}{{\mathbf {t}}^{(k-1)}}$</span></span>
          (line&nbsp;13). The memory <span class=
          "inline-equation"><span class=
          "tex">$O(\tilde{m}+K\tilde{n})$</span></span> is
          dominated by the storage of matrix <strong>A</strong>,
          and resulting iterative vectors. For online query, once
          {<strong>p</strong> <sup>(<em>k</em>)</sup>} and
          {<strong>t</strong> <sup>(<em>k</em>)</sup>} are
          computed, they are memoised and reused to compute
          <strong><em>Δ</em>S</strong>[:, <em>q</em>] for every
          query in <em>Q</em>. After
          <strong><em>Δ</em>S</strong>[:, <em>q</em>] is updated in
          answer to each piece <em>ΔG<sub>u</sub></em> , all the
          vectors {<strong>p</strong> <sup>(<em>k</em>)</sup>} and
          {<strong>t</strong> <sup>(<em>k</em>)</sup>} are freed
          for the next piece update. Thus, for |<em>Q</em>| queries
          and <em>p</em> update pieces, it entails <span class=
          "inline-equation"><span class=
          "tex">$O(K(\tilde{m}+\tilde{n}p|Q|))$</span></span> time
          and <span class="inline-equation"><span class=
          "tex">$O(\tilde{m}+K\tilde{n})$</span></span> memory in
          total.</p>
        </div>
        <p>Theorem&nbsp;<a class="enc" href="#enc7">4.7</a>
        guarantees the high efficiency of D-CoSim for dynamic
        CoSimRank search, whose speedup is achieved by (a) our
        characterisation of the “refreshed areas”
        <strong><em>Δ</em>S</strong>[:, <em>q</em>] in terms of
        only the linear combination of {<strong>p</strong>
        <sup>(<em>k</em>)</sup>} and {<strong>t</strong>
        <sup>(<em>k</em>)</sup>}, and (b) maximally reusing and
        sharing common intermediate results in answer to the edge
        updates on each piece <em>ΔG<sub>u</sub></em> . In
        comparison, the existing approach by [<a class="bib"
        data-trigger="hover" data-toggle="popover" data-placement=
        "top" href="#BibPLXBIB0018">18</a>] requires <span class=
        "inline-equation"><span class=
        "tex">$O(K(\tilde{m}+\tilde{n}))$</span></span> time to
        compute only a single-pair <span class=
        "inline-equation"><span class="tex">$\mathbf
        {\tilde{S}}[i,j]$</span></span> per edge update via
        Eqs.(<a class="eqn" href="#eq2">2</a>) and (<a class="eqn"
        href="#eq3">3</a>) from scratch, leading to <span class=
        "inline-equation"><span class=
        "tex">$O(K(\tilde{m}+\tilde{n}|Q|)\tilde{n}\delta)$</span></span>
        total time to compute <span class=
        "inline-equation"><span class="tex">$\mathbf
        {\tilde{S}}[:,Q]$</span></span> (<span class=
        "inline-equation"><span class="tex">$\tilde{n} \times
        |Q|$</span></span> pairs) for <em>δ</em> edge updates,
        which is rather expensive.</p>
      </section>
      <section id="sec-8">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.2</span> F-CoSim
            over Static Graphs</h3>
          </div>
        </header>
        <p>Apart from supporting quick dynamic CoSimRank retrieval
        on evolving graphs, D-CoSim can also be applied to static
        graphs for accelerating CoSimRank search. Based on D-CoSim,
        we next propose an efficient scheme, F-CoSim, that greatly
        speeds up CoSimRank search over static graphs. Given a
        static graph <em>G</em> and a query set <em>Q</em>, F-CoSim
        retrieves the CoSimRank scores <strong>S</strong>[:,
        <em>Q</em>] over <em>G</em> based on three ideas: First, we
        propose a fast method to find a “spanning polytree”
        <em>T</em> of <em>G</em> so that <em>G</em> is decomposed
        into <em>G</em> = <em>T</em>⊕(<em>G</em>⊖<em>T</em>), which
        can be viewed as the old <em>T</em> plus its update
        (<em>G</em>⊖<em>T</em>). Next, on <em>T</em>, due to its
        special “polytree” structure, we notice that the CoSimRank
        scores are relatively easier to compute, and we propose a
        novel fast algorithm to retrieve the CoSimRank scores
        <strong>S</strong>(<em>T</em>)[:, <em>Q</em>] over the
        “spanning polytree”. Finally, we apply our dynamic D-CoSim
        to compute <strong>S</strong>(<em>T</em>) changes in
        response to the graph update (<em>G</em>⊖<em>T</em>). With
        the above ideas, F-CoSim enables a notable speedup in
        CoSimRank search over static graphs, which is achieved by
        our efficient method to retrieve
        <strong>S</strong>(<em>T</em>)[:, <em>Q</em>] over the
        “spanning polytree” and our fast D-CoSim to compute the
        changes to <strong>S</strong>(<em>T</em>)
        <em>w.r.t.&nbsp;</em>(<em>G</em>⊖<em>T</em>).</p>
        <p>In the following, we shall elaborate on these ideas.</p>
        <div class="definition" id="enc8">
          <label>Definition 4.8 (Spanning Polytree).</label>
          <p>A spanning polytree <em>T</em> of a connected graph
          <em>G</em> is a subgraph of <em>G</em> that includes
          every node of <em>G</em> (<em>i.e.,&nbsp;</em>spans
          <em>G</em>), with a maximal set of edges of <em>G</em>
          that contains no undirected cycles if we replace all the
          directed edges of <em>T</em> with undirected edges.</p>
        </div>
        <p>Intuitively, in contrast with the traditional definition
        of the spanning tree in which each node has only one parent
        node, our spanning polytree is a generalised notion of the
        spanning tree from undirected graphs to directed ones, in
        which each node may have more than one parent nodes. The
        reason we introduce the spanning polytree is that, when
        <em>G</em> is a directed graph, its traditional spanning
        tree does not always exist, but there always exists a
        spanning polytree of <em>G</em>. For instance in
        Figure&nbsp;<a class="fig" href="#fig3">2</a>, there are no
        conventional trees that span <em>G</em>, but one can find a
        polytree <em>T</em> that spans <em>G</em>. If <em>G</em> is
        an undirected graph, the spanning polytree in
        Definition&nbsp;<a class="enc" href="#enc8">4.8</a> reduces
        to the traditional spanning tree.</p>
        <figure id="fig3">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3186126/images/www2018-135-fig4.jpg"
          class="img-responsive" alt="Figure 2" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 2:</span>
            <span class="figure-title">Decompose <em>G</em> into a
            spanning polytree <em>T</em> and <em>ΔG</em> (=
            <em>G</em>⊖<em>T</em>)</span>
          </div>
        </figure>
        <p></p>
        <p>To identify a spanning polytree <em>T</em> over a given
        graph <em>G</em>, we devise a fast heuristic approach based
        on breadth first search (BFS) in Procedure&nbsp;2 . The
        complexity of Procedure&nbsp;2 is dominated by the BFS
        search, which is <em>O</em>(<em>n</em> + <em>m</em>) time
        and <em>O</em>(<em>n</em> + <em>m</em>) memory on a graph
        with <em>n</em> nodes and <em>m</em> edges.</p>
        <p><img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3186126/images/www2018-135-fig5.jpg"
        class="img-responsive" alt="" longdesc="" /></p>
        <p>Having identified the spanning polytree <em>T</em> of
        the graph <em>G</em>, we can decompose <em>G</em> into two
        parts: <em>G</em> = <em>T</em>⊕(<em>G</em>⊖<em>T</em>). Due
        to the special acyclic structure of <em>T</em>, there is a
        more efficient way to retrieve CoSimRank scores of the
        spanning polytree <em>T</em>. Our key observation is that,
        if the nodes of <em>T</em> are organised in level order,
        the adjacency matrix <strong>A</strong> of <em>T</em> will
        exhibit a block superdiagonal structure, leading to the
        CoSimRank scores of <em>T</em>,
        <strong>S</strong>(<em>T</em>), displaying a block diagonal
        structure. Consequently, any two nodes at different levels
        of <em>T</em> have zero CoSimRank scores. Moreover, the
        CoSimRank scores of the nodes at the same level of
        <em>T</em> can be immediately derived from those at the
        previous level, based on the following theorem:</p>
        <div class="theorem" id="enc9">
          <label>Theorem 4.9 (CoSimRank on Polytree T).</label>
          <p>Given a polytree <em>T</em> with nodes organised in
          level order, let <em>n<sub>l</sub></em> be the number of
          nodes at level <em>l</em> (<em>l</em> = 1, ⋅⋅⋅,
          <em>L</em>), the CoSimRank scores of <em>T</em>,
          <strong>S</strong>(<em>T</em>), is computed level by
          level:</p>
          <div class="table-responsive" id="eq19">
            <div class="display-equation">
              <span class="tex mytex">\begin{equation}
              \begin{split} &amp; \mathbf {S}(T) = diag(\mathbf
              {S}_{1}, \mathbf {S}_{2}, \cdots , \mathbf {S}_{L}) \
              \ \textrm {with} \ \ {{\mathbf {S}}_{1}}={{\mathbf
              {I}}_{n_1}} \ \textrm { and } \\ &amp; \quad
              {{\mathbf {S}}_{l}}=C\mathbf {A}_{l-1,l}^{T}{{\mathbf
              {S}}_{l-1}}{{\mathbf {A}}_{l-1,l}}+{{\mathbf
              {I}}_{n_l}} \ \ \ (l=2, \cdots , L) \end{split}
              \end{equation}</span><br />
              <span class="equation-number">(19)</span>
            </div>
          </div>where <em>L</em> is the number of levels in
          <em>T</em>; <strong>S</strong>(<em>T</em>) is a diagonal
          block matrix with each block <strong>S</strong>
          <sub><em>l</em></sub> being the CoSimRank scores of
          <span class="inline-equation"><span class=
          "tex">$n_l^2$</span></span> pairs of nodes at level
          <em>l</em>; <strong>A</strong> <sub><em>l</em> − 1,
          <em>l</em></sub> is the (<em>n</em> <sub><em>l</em> −
          1</sub> × <em>n<sub>l</sub></em> ) column-normalised
          adjacency matrix of the subgraph between level
          (<em>l</em> − 1) and level <em>l</em> of <em>T</em>; and
          <span class="inline-equation"><span class="tex">${\mathbf
          {I}}_{n_l}$</span></span> is the <em>n<sub>l</sub></em> ×
          <em>n<sub>l</sub></em> identity matrix.
          <p></p>
        </div>
        <div class="proof" id="proof4">
          <label>Proof.</label>
          <p>Since <em>T</em> is a polytree, two surfers starting
          at different levels cannot meet at a common node via
          equal-length steps. Thus, only node-pairs at the same
          level have nonzero scores, leading to the block diagonal
          structure of <strong>S</strong>(<em>T</em>).</p>
          <p>To compute <em>l</em>-th diagonal block
          <strong>S</strong> <sub><em>l</em></sub> , by
          Eq.(<a class="eqn" href="#eq1">1</a>), we have</p>
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ { C{{\left[
              {\begin{array}{*10c}\mathbf {0} &amp; {{\mathbf
              {A}}_{1,2}} &amp; \cdots &amp; \mathbf {0} \\[-5pt]
              \mathbf {0} &amp; \mathbf {0} &amp; \ddots &amp;
              \vdots \\[-5pt] \vdots &amp; \vdots &amp; \ddots
              &amp; {{\mathbf {A}}_{L-1,L}} \\ \mathbf {0} &amp;
              \mathbf {0} &amp; \cdots &amp; \mathbf {0} \\
              \end{array}} \right]}^{T}}\left[
              {\begin{array}{*10c}{\mathbf {S}}_{1} &amp; \mathbf
              {0} &amp; \cdots &amp; \mathbf {0} \\ \mathbf {0}
              &amp; {{\mathbf {S}}_{2}} &amp; \cdots &amp; \mathbf
              {0} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots
              \\ \mathbf {0} &amp; \mathbf {0} &amp; \cdots &amp;
              {{\mathbf {S}}_{L}} \\ \end{array}} \right]\left[
              {\begin{array}{*10c}\mathbf {0} &amp; {{\mathbf
              {A}}_{1,2}} &amp; \cdots &amp; \mathbf {0} \\[-5pt]
              \mathbf {0} &amp; \mathbf {0} &amp; \ddots &amp;
              \vdots \\[-5pt] \vdots &amp; \vdots &amp; \ddots
              &amp; {{\mathbf {A}}_{L-1,L}} \\ \mathbf {0} &amp;
              \mathbf {0} &amp; \cdots &amp; \mathbf {0} \\
              \end{array}} \right]+\left[
              {\begin{array}{*10c}{\mathbf {I}}_{{{n}_{1}}} &amp;
              \mathbf {0} &amp; \cdots &amp; \mathbf {0} \\ \mathbf
              {0} &amp; {{\mathbf {I}}_{{{n}_{2}}}} &amp; \cdots
              &amp; \mathbf {0} \\ \vdots &amp; \vdots &amp; \ddots
              &amp; \vdots \\ \mathbf {0} &amp; \mathbf {0} &amp;
              \cdots &amp; {{\mathbf {I}}_{{{n}_{L}}}} \\
              \end{array}} \right] } \]</span><br />
            </div>
          </div>
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \!\! { =\left[
              {\begin{array}{*10c}\mathbf {I}_{n_1} &amp; \mathbf
              {0} &amp; \cdots &amp; \mathbf {0} \\ \mathbf {0}
              &amp; C\mathbf {A}_{1,2}^{T}{{\mathbf
              {S}}_{1}}{{\mathbf {A}}_{1,2}}+\mathbf {I}_{n_2}
              &amp; \cdots &amp; \mathbf {0} \\[-5pt] \vdots &amp;
              \ddots &amp; \ddots &amp; \vdots \\ \mathbf {0} &amp;
              \mathbf {0} &amp; \cdots &amp; C\mathbf
              {A}_{L-1,L}^{T}{{\mathbf {S}}_{L-1}}{{\mathbf
              {A}}_{L-1,L}}+\mathbf {I}_{n_L} \\ \end{array}}
              \right] = \left[ {\begin{array}{*10c}{\mathbf
              {S}}_{1} &amp; \mathbf {0} &amp; \cdots &amp; \mathbf
              {0} \\ \mathbf {0} &amp; {{\mathbf {S}}_{2}} &amp;
              \cdots &amp; \mathbf {0} \\ \vdots &amp; \vdots &amp;
              \ddots &amp; \vdots \\ \mathbf {0} &amp; \mathbf {0}
              &amp; \cdots &amp; {{\mathbf {S}}_{L}} \\
              \end{array}} \right] } \]</span><br />
            </div>
          </div>In the last equality, since the corresponding
          diagonal blocks are equal, Eq.(<a class="eqn" href=
          "#eq19">19</a>) holds.
          <p></p>
        </div>
        <p>Theorem&nbsp;<a class="enc" href="#enc9">4.9</a> gives a
        fast and accurate approach for CoSimRank search on a
        spanning polytree in a level-by-level style. The CoSimRank
        scores at level <em>l</em> are immediately computed from
        those at level (<em>l</em> − 1). To retrieve each block
        <strong>S</strong> <sub><em>l</em></sub> at level
        <em>l</em> via Eq.(<a class="eqn" href="#eq19">19</a>), it
        requires only <em>O</em>(<em>n<sub>l</sub></em> (<em>n</em>
        <sub><em>l</em> − 1</sub> + <em>n<sub>l</sub></em> )) time
        and <span class="inline-equation"><span class=
        "tex">$O(n_l^2)$</span></span> memory, as opposed to the
        original method entailing <em>O</em>(<em>K</em>(<em>m</em>
        + <em>n</em>)<em>n<sub>l</sub></em> ) time and
        <em>O</em>(<em>m</em> + <em>n</em>) memory to retrieve
        <span class="inline-equation"><span class=
        "tex">$n_l^2$</span></span> pairs of <strong>S</strong>
        <sub><em>l</em></sub> scores. Since <em>n<sub>l</sub></em>
        ≪ <em>n</em> = <em>n</em> <sub>1</sub> + <em>n</em>
        <sub>2</sub> + ⋅⋅⋅ + <em>n<sub>L</sub></em> , the
        complexity improvement of our approach is significant.</p>
        <div class="example" id="enc10">
          <label>Example 4.10.</label>
          <p>Consider the spanning polytree <em>T</em> in
          Figure&nbsp;<a class="fig" href="#fig3">2</a>.
          Theorem&nbsp;<a class="enc" href="#enc9">4.9</a> computes
          the CoSimRank <strong>S</strong>(<em>T</em>) of
          <em>T</em> as follows:</p>
          <p>As Level 1 of <em>T</em> has two nodes {<em>a</em>,
          <em>b</em>}, Eq.(<a class="eqn" href="#eq19">19</a>)
          initialises</p>
          <p><img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3186126/images/www2018-135-img1.svg"
          class="img-responsive" alt="" longdesc="" /><br />
          Since <span class="inline-equation"><span class=
          "tex">${{\mathbf {A}}_{1,2}}=\left[
          {{\begin{array}{*10c}.5 &amp; 0 \\ .5 &amp; 0
          \\\end{array}}} \right]$</span></span> and <span class=
          "inline-equation"><span class="tex">$ {{\mathbf
          {A}}_{2,3}}=\left[ {{\begin{array}{*10c}1 &amp; .5 &amp;
          1 \\ 0 &amp; .5 &amp; 0 \\\end{array}}}
          \right]$</span></span> , the CoSimRank similarity of
          nodes {<em>c</em>, <em>d</em>} at Level 2 is computed
          from <strong>S</strong> <sub>1</sub>:</p>
          <div class="table-responsive">
            <div class="display-equation">
              \begin{align} \!\!(c)\quad (d)\\
              {S}_{2}=0.6{A}_{1,2}^{T} {S}_{1}{A}_{1,2}+{I}_{2} =
              \begin{array}{c}(c)\\(d)\\\end{array}\left[\begin{array}{cc}
              1.3 &amp; 0 \\ 0 &amp; 1 \\
              \end{array}\right]\end{align}
            </div>
          </div>
          <p></p>
          <p>Next, the CoSimRank similarity of nodes {<em>e</em>,
          <em>f</em>, <em>g</em>} at Level&nbsp;3 is computed from
          <strong>S</strong> <sub>2</sub>:</p>
          <div class="table-responsive">
            <div class="display-equation">
              \begin{align} (e)\quad\,\, (f)\quad (g)\,\,\quad \\
              \mathbf {S}_{3}=0.6\mathbf {A}_{2,3}^{T}\mathbf
              {S}_{2}\mathbf {A}_{2,3}+\mathbf {I}_{3} =
              \begin{array}{c}(e)\\(f)\\(g)\\\end{array}
              \left[\begin{array}{ccc} 1.78 &amp; 0.39 &amp; 0.78
              \\ 0.39 &amp; 1.34 &amp; 0.39 \\ 0.78 &amp; 0.39
              &amp; 1.78 \\ \end{array}\right]\end{align}
            </div>
          </div>Thus, the CoSimRank scores
          <strong>S</strong>(<em>T</em>) =
          <em>diag</em>(<strong>S</strong> <sub>1</sub>,
          <strong>S</strong> <sub>2</sub>, <strong>S</strong>
          <sub>3</sub>). &nbsp;&nbsp;&nbsp;<span class=
          "inline-equation"><span class="tex">$\Box$</span></span>
          <p></p>
        </div>
        <p><strong>CoSimRank on Static Graph <em>G</em>.</strong>
        After the CoSimRank <strong>S</strong>(<em>T</em>) of the
        polytree <em>T</em> is computed, F-CoSim next computes the
        CoSimRank changes <strong><em>Δ</em>S</strong>
        <em>w.r.t.&nbsp;</em>the graph <em>ΔG</em> (=
        <em>G</em>⊖<em>T</em>), by utilising our dynamical D-CoSim
        algorithm in Section&nbsp;<a class="sec" href=
        "#sec-7">4.1</a>. Finally, the two parts
        (<strong>S</strong>(<em>T</em>) and
        <strong><em>Δ</em>S</strong>) are added together, which
        produces the CoSimRank <strong>S</strong> of the original
        graph, <em>i.e.,&nbsp;</em></p>
        <div class="table-responsive">
          <div class="display-equation">
            <span class="tex mytex">\[ \mathbf {S} = \mathbf {S}(T)
            + \mathbf {\Delta S} \]</span><br />
          </div>
        </div>
        <p></p>
        <p>Based on the above ideas, Algorithm&nbsp;3 provides our
        complete static scheme, F-CoSim, which incorporates
        Theorem&nbsp;<a class="enc" href="#enc9">4.9</a> and our
        dynamic D-CoSim scheme. F-CoSim consists of three phases:
        (i) finding a spanning polytree <em>T</em> over <em>G</em>
        (line&nbsp;), (ii) retrieving CoSimRank
        <strong>S</strong>(<em>T</em>) on <em>T</em>
        (lines&nbsp;–), (iii) computing CoSimRank changes
        <strong><em>Δ</em>S</strong> in answer to
        (<em>G</em>⊖<em>T</em>) (lines&nbsp;–).</p>
        <p><img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3186126/images/www2018-135-fig6.jpg"
        class="img-responsive" alt="" longdesc="" /></p>
        <div class="example" id="enc11">
          <label>Example 4.11.</label>
          <p>Recall <em>G</em> in Figure&nbsp;<a class="fig" href=
          "#fig3">2</a>. To retrieve <strong>S</strong>[:,
          <em>c</em>] on <em>G</em>, F-CoSim first decomposes
          <em>G</em> = <em>T</em>⊕(<em>G</em>⊖<em>T</em>). Then, it
          computes the CoSimRank <strong>S</strong>(<em>T</em>)[:,
          <em>c</em>] of <em>T</em>, as shown in
          Example&nbsp;<a class="enc" href="#enc10">4.10</a>:</p>
          <p></p>
          <div class="table-responsive">
            <div class="display-equation">
              \begin{align} (a)\quad (b)\quad (c)\quad (d)\quad
              (e)\quad (f)\quad (g)\,\,\, \\ \mathbf {S}(T)[:,c]=
              (c)\left[\begin{array}{ccccccc} 0\,\,\, &amp; 0\,\,\,
              &amp; 1.3\,\,\, &amp; 0\,\,\,\, &amp; 0\,\,\,\, &amp;
              0\,\,\,\, &amp; 0 \end{array}\right]^T
              \end{align}<br />
            </div>
          </div>
          <p></p>
          <p>Next, F-CoSim invokes D-CoSim (Line&nbsp;) to compute
          the CoSimRank increment <strong><em>Δ</em>S</strong>[:,
          <em>c</em>] <em>w.r.t.&nbsp;</em>delta graph
          (<em>G</em>⊖<em>T</em>):</p>
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \mathbf {\Delta S}[:,c]=[
              0, .15, .045, 0, .03, .0225, .045]^T. \]</span><br />
            </div>
          </div>
          <p></p>
          <p>Finally, the CoSimRank score <strong>S</strong>[:,
          <em>c</em>] of <em>G</em> (Line&nbsp;) is</p>
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \mathbf {S}[:,c]=\mathbf
              {S}(T)[:,c]+\mathbf {\Delta S}[:,c]=[0, .15, 1.345,
              0, .03, .0225, .045]^T \;\Box \]</span><br />
            </div>
          </div>
          <p></p>
        </div>
        <p><strong>Correctness.</strong> We next show that F-CoSim
        <em>correctly</em> returns the CoSimRank scores
        <strong>S</strong>[:, <em>Q</em>] on <em>G</em>.</p>
        <div class="theorem" id="enc12">
          <label>Theorem 4.12.</label>
          <p>Given graph <em>G</em>, the resulting
          <strong>S</strong> returned by Line&nbsp; of F-CoSim is
          the correct CoSimRank scores over <em>G</em>.</p>
        </div>
        <div class="proof" id="proof5">
          <label>Proof.</label>
          <p>Let <strong>S</strong>(<em>T</em>) be the CoSimRank of
          the polytree <em>T</em>, and
          <strong>A</strong>(<em>T</em>) be the column-normalised
          adjacency matrix of <em>T</em>. According to Line&nbsp;
          of F-CoSim, after <em>T</em> is retrieved from
          <em>G</em>, the column-normalised adjacency matrix
          <strong>A</strong> of <em>G</em> is decomposed into two
          parts (<strong>A</strong>(<em>T</em>) and
          <strong><em>Δ</em>A</strong>):</p>
          <div class="table-responsive" id="eq20">
            <div class="display-equation">
              <span class="tex mytex">\begin{equation} \mathbf
              {A}=\mathbf {A}(T)+\mathbf {\Delta A} \ \ \textrm {
              where } \ \ \mathbf {\Delta A}\triangleq \mathbf {A}
              -\mathbf {A}(T) \end{equation}</span><br />
              <span class="equation-number">(20)</span>
            </div>
          </div>Theorem&nbsp;<a class="enc" href="#enc5">4.5</a>
          guarantees that the CoSimRank of <em>T</em>, denoted as
          <strong>S</strong>(<em>T</em>) (≜<em>diag</em>(<strong>S</strong>
          <sub>1</sub>, ⋅⋅⋅, <strong>S</strong>
          <sub><em>L</em></sub> )), that is obtained by Lines 2–7
          of F-CoSim, is the correct CoSimRank of <em>T</em>,
          <em>i.e.,&nbsp;</em> <strong>S</strong>(<em>T</em>)
          satisfies the CoSimRank definition:
          <div class="table-responsive" id="eq21">
            <div class="display-equation">
              <span class="tex mytex">\begin{equation} \mathbf
              {S}(T) = C \mathbf {A}(T)^{T}\mathbf {S}(T)\mathbf
              {A}(T)+\mathbf {I} \end{equation}</span><br />
              <span class="equation-number">(21)</span>
            </div>
          </div>
          <p></p>
          <p>Moreover, our correctness proof of D-CoSim in
          Theorem&nbsp;<a class="enc" href="#enc5">4.5</a>
          guarantees that, by viewing <em>T</em> as the old graph,
          and (<em>G</em>⊖<em>T</em>) as the graph update to
          <em>T</em>, the value of <strong><em>Δ</em>S</strong>,
          from calling D-CoSim (Line 8 of F-CoSim), is the correct
          CoSimRank increments <em>w.r.t.&nbsp;</em>the update
          (<em>G</em>⊖<em>T</em>) to <em>T</em>. That is,
          <strong><em>Δ</em>S</strong> satisfies CoSimRank
          definition:</p>
          <div class="table-responsive" id="eq22">
            <div class="display-equation">
              <span class="tex mytex">\begin{align} \nonumber
              \mathbf {S}(T) + \mathbf {\Delta S} = &amp; \ C \cdot
              (\mathbf {A}(T) + \mathbf {\Delta A})^{T} \cdot
              (\mathbf {S}(T) + \mathbf {\Delta S}) \cdot \\ &amp;
              \qquad \cdot (\mathbf {A}(T) + \mathbf {\Delta A}) +
              \mathbf {I} \end{align}</span><br />
              <span class="equation-number">(22)</span>
            </div>
          </div>According to Line 9, CoSimRank returned by F-CoSim
          is:
          <div class="table-responsive" id="eq23">
            <div class="display-equation">
              <span class="tex mytex">\begin{equation} \mathbf
              {S}=diag(\mathbf {S}_1,\cdots ,\mathbf {S}_L)+\mathbf
              {\Delta S}=\mathbf {S}(T)+\mathbf {\Delta S}
              \end{equation}</span><br />
              <span class="equation-number">(23)</span>
            </div>
          </div>Plugging Eqs.(<a class="eqn" href="#eq21">21</a>)
          and (<a class="eqn" href="#eq22">22</a>) into (<a class=
          "eqn" href="#eq23">23</a>) produces
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \mathbf {S}=C\mathbf
              {A}^{T}\mathbf {SA}+\mathbf {I}. \]</span><br />
            </div>
          </div>Thus, <strong>S</strong> satisfies the CoSimRank
          definition, <em>i.e.,&nbsp;</em> <strong>S</strong>,
          returned by F-CoSim, is the correct CoSimRank of
          <em>G</em>.
          <p></p>
        </div>
        <p><strong>Complexity.</strong> Given <em>Q</em>, the time
        of F-CoSim in each phase is <em>O</em>(<em>n</em> +
        <em>m</em>), <span class="inline-equation"><span class=
        "tex">$O(\sum
        _{l=2}^{L_Q}{n_l(n_{l-1}+n_l)})$</span></span> ,
        <em>O</em>(<em>K</em>(<em>m</em> + <em>np</em>
        <sub>⊖</sub>|<em>Q</em>|)), respectively, where
        <em>L<sub>Q</sub></em> is the maximum level of the query
        node of <em>Q</em> in <em>T</em>, and <em>p</em>
        <sub>⊖</sub> is number of update pieces in <em>ΔG</em>.
        Since <em>L<sub>Q</sub></em> ≤ <em>L</em> ≪ <em>n</em>,
        <em>n</em> <sub><em>l</em> − 1</sub> +
        <em>n<sub>l</sub></em> ≪ <em>n</em>, and <em>p</em>
        <sub>⊖</sub> ≪ <em>m</em> − <em>n</em> in practice, it
        requires <span class="inline-equation"><span class=
        "tex">$O(n\max \nolimits _{2 \le l \le L_Q}\{ n_{l-1}+n_l\}
        + K(m+np_{\ominus } |Q|))$</span></span> time in total, as
        opposed to the <em>O</em>(<em>Kn</em>(<em>m</em> +
        |<em>Q</em>|<em>n</em>)) time of the original method to
        assess <em>n</em> × |<em>Q</em>| pairs of scores
        <strong>S</strong>[:, <em>Q</em>].</p>
        <p>The memory space of F-CoSim in each phase is
        <em>O</em>(<em>m</em> + <em>n</em>), <span class=
        "inline-equation"><span class="tex">$O(m+\sum
        _{l=1}^{L_Q}{{n_l}^2})$</span></span> ,
        <em>O</em>(<em>m</em> + <em>Kn</em>), respectively. Thus,
        the total memory is bounded by <span class=
        "inline-equation"><span class="tex">$O({m}+(K+\max
        \nolimits _{1 \le l \le L_Q}\{ n_l\}){n})$</span></span>
        .</p>
        <figure id="fig4">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3186126/images/www2018-135-fig7.jpg"
          class="img-responsive" alt="Figure 4" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 3:</span>
            <span class="figure-title">Time Efficiency on Dynamic
            Graphs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Figure
            4: Time Efficiency on Static Graphs</span>
          </div>
        </figure>
        <p></p>
      </section>
    </section>
    <section id="sec-9">
      <header>
        <div class="title-info">
          <h2><span class="section-number">5</span> Experimental
          Evaluation</h2>
        </div>
      </header>
      <p>Our evaluations on various datasets verify the superiority
      of D-CoSim in dynamic graphs and F-CoSim in static
      graphs.</p>
      <p>The performance efficiency is evaluated by three
      metrics:</p>
      <p><strong>(a) Running Time.</strong> On dynamic graphs,
      D-CoSim quickly answers CoSimRank search. On static graphs,
      F-CoSim is much faster than the best-known CoSimRank
      approaches.</p>
      <p><strong>(b) Memory Space.</strong> Both D-CoSim and
      F-CoSim require only linear memory, and scale well on
      million-node graphs.</p>
      <p><strong>(c) Accuracy.</strong> D-CoSim and F-CoSim do not
      compromise any accuracy for speedup.</p>
      <section id="sec-10">
        <header>
          <div class="title-info">
            <h3><span class="section-number">5.1</span>
            Experimental Settings</h3>
          </div>
        </header>
        <p><strong>Datasets.</strong> We adopt the following public
        datasets:</p>
        <div class="table-responsive" id="inltbl5">
          <table class="table">
            <thead>
              <tr>
                <th style="text-align:left;">
                <strong>Datasets</strong></th>
                <th style="text-align:left;"></th>
                <th style="text-align:right;">
                <strong>#-Nodes</strong></th>
                <th style="text-align:left;">
                <strong>#-Edges</strong> </th>
                <th><strong>Type</strong></th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td style="text-align:left;">as-735</td>
                <td style="text-align:left;">(AS)</td>
                <td style="text-align:right;">7,716</td>
                <td style="text-align:left;">26,467</td>
                <td>Undirected</td>
              </tr>
              <tr>
                <td style="text-align:left;">ca-HepPh</td>
                <td style="text-align:left;">(HP)</td>
                <td style="text-align:right;">12,008</td>
                <td style="text-align:left;">237,010</td>
                <td>Undirected</td>
              </tr>
              <tr>
                <td style="text-align:left;">email-EuAll</td>
                <td style="text-align:left;">(EE)</td>
                <td style="text-align:right;">265,214</td>
                <td style="text-align:left;">420,045</td>
                <td>Directed</td>
              </tr>
              <tr>
                <td style="text-align:left;">web-Google</td>
                <td style="text-align:left;">(WG)</td>
                <td style="text-align:right;">916,428</td>
                <td style="text-align:left;">5,105,039</td>
                <td>Directed</td>
              </tr>
              <tr>
                <td style="text-align:left;">wiki-Talk</td>
                <td style="text-align:left;">(WT)</td>
                <td style="text-align:right;">2,394,385</td>
                <td style="text-align:left;">5,021,410</td>
                <td>Directed</td>
              </tr>
              <tr>
                <td style="text-align:left;">soc-LiveJournal</td>
                <td style="text-align:left;">(LJ)</td>
                <td style="text-align:right;">18,520,486</td>
                <td style="text-align:left;">298,113,762</td>
                <td>Directed</td>
              </tr>
            </tbody>
          </table>
        </div>
        <ul class="list-no-style">
          <li id="list5" label="•">as-735 (AS). It is a
          communication graph of autonomous systems, taken from the
          Border Gateway Protocol logs, where an edge is a
          who-talks-to-whom relationship.<br /></li>
          <li id="list6" label="•">ca-HepPh (HP). It is a
          collaboration graph taken from the arXiv High Energy
          Physics. If two authors (nodes) co-authored a paper,
          there is an edge between them.<br /></li>
          <li id="list7" label="•">email-EuAll (EE). It is an EU
          email contact graph. Each node is an email address. If
          node <em>i</em> sent at least one message to <em>j</em>,
          there is an edge <em>i</em> → <em>j</em> in the
          network.<br /></li>
          <li id="list8" label="•">web-Google (WG). It is a Google
          web graph, where each node is a web page, and an edge is
          a hyperlink.<br /></li>
          <li id="list9" label="•">wiki-Talk (WT). In Wikipedia,
          each user (node) has a talk page that other users can
          edit for discussion. In this graph, an edge <em>i</em> →
          <em>j</em> means that user <em>i</em> edited user
          <em>j</em>’s talk page.<br /></li>
          <li id="list10" label="•">soc-LiveJournal (LJ). It is a
          social community network, where edge <em>i</em> →
          <em>j</em> is a friendship link from user <em>i</em> to
          <em>j</em>.<br /></li>
        </ul>
        <p>To simulate real evolution on dynamic graphs, we use RTG
        (Random Typing Generator) [<a class="bib" data-trigger=
        "hover" data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0001">1</a>] to generate |<em>ΔG</em>| dynamic
        updates following linkage generation models [<a class="bib"
        data-trigger="hover" data-toggle="popover" data-placement=
        "top" href="#BibPLXBIB0012">12</a>, <a class="bib"
        data-trigger="hover" data-toggle="popover" data-placement=
        "top" href="#BibPLXBIB0017">17</a>].</p>
        <p>All experiments are conducted on a PC with Intel Core
        i7-6700 3.40GHz CPU and 64GB memory compiled by VC++.</p>
        <p><strong>Compared Algorithms.</strong> We implemented our
        D-CoSim (dynamic) and F-CoSim (static), and compared them
        with two state-of-art CoSimRank competitors: (a) CSR, a
        method by [<a class="bib" data-trigger="hover" data-toggle=
        "popover" data-placement="top" href=
        "#BibPLXBIB0018">18</a>] that retrieves a CoSimRank score
        from the sum of the dot product of two Personalised
        PageRank vectors; (b) CSM, a repeated-squaring method by
        [<a class="bib" data-trigger="hover" data-toggle="popover"
        data-placement="top" href="#BibPLXBIB0027">27</a>] that
        cuts down the number of CoSimRank iterations.</p>
        <p><strong>Parameters.</strong> We chose the following
        parameters by default: (a) the decay factor <em>C</em> =
        0.8 and (b) the number of iterations <em>K</em> = 5, as
        previously used in [<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0018">18</a>].</p>
        <figure id="fig5">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3186126/images/www2018-135-fig8.jpg"
          class="img-responsive" alt="Figure 8" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 5:</span>
            <span class="figure-title">Memory Efficiency &amp;
            Scalability&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Figure
            6: Exactness</span>
          </div>
        </figure>
        <p></p>
      </section>
      <section id="sec-11">
        <header>
          <div class="title-info">
            <h3><span class="section-number">5.2</span>
            Experimental Results</h3>
          </div>
        </header>
        <section id="sec-12">
          <p><em>5.2.1 Time Efficiency.</em> Figure&nbsp;3 depicts
          the time efficiency of D-CoSim on several dynamic graphs.
          On each dataset, we randomly select |<em>Q</em>| = 500
          queries, and build |<em>ΔG</em>| = 1000 new edge updates.
          Figure&nbsp;3a compares the time of D-CoSim against CSR
          and CSM to compute CoSimRank changes per update for each
          query. We see that D-CoSim is consistently 3-5
          order-of-magnitude faster than CSR (<em>resp.</em>118x
          faster than CSM). This is because D-CoSim leverages
          Theorem&nbsp;<a class="enc" href="#enc4">4.4</a> that
          evaluates only the refreshed areas of CoSimRank scores in
          response to graph updates, without the need to recompute
          all scores from scratch. Moreover, unlike CSM crashes on
          large datasets (<em>e.g.,&nbsp;</em>WT, LJ) due to
          insufficient memory for repeated squaring memoisation,
          D-CoSim can update their scores within one second.
          Figure&nbsp;3b further depicts the time of D-CoSim
          <em>w.r.t.&nbsp;</em>|<em>ΔG</em>|. As |<em>ΔG</em>|
          grows from 500 to 3000 on each dataset, the time of
          D-CoSim is increasing mildly, highlighting its
          scalability <em>w.r.t.&nbsp;</em>the number of edge
          updates. It is consistent with the time complexity in
          Theorem&nbsp;<a class="enc" href="#enc7">4.7</a> where
          D-CoSim is linear to the number of update pieces
          <em>p</em> (≤ <em>δ</em>).</p>
          <p>Figure&nbsp;<a class="fig" href="#fig4">4</a> shows
          the time efficiency of F-CoSim on static graphs. Due to
          space limitations, we only report the results on three
          datasets, and the trends on other datasets are similar.
          Figure&nbsp;4a compares the time of F-CoSim with CSR and
          CSM on each dataset. We discern that F-CoSim always
          outperforms CSR with a speedup up to 9.8x (on EE). Thus,
          the use of our spanning polytree for fast CoSimRank
          search is effective (Theorem&nbsp;<a class="enc" href=
          "#enc9">4.9</a>). On HP dataset, CSM is the fastest, but
          this method only survives on small-scale graphs, due to
          its high memory storage for repeated squaring. In
          contrast, F-CoSim scales well on million-edge graphs
          (<em>e.g.,&nbsp;</em>WT, LJ).</p>
          <p>Since F-CoSim encompasses three phases
          (Algorithm&nbsp;3), Figure&nbsp;4b details the time
          allocated in each phase per dataset. We see that, among
          these phases, Phase 2 (computing
          <strong>S</strong>(<em>T</em>) on spanning polytree
          <em>T</em>) takes the smallest portion; Phase 1 (finding
          <em>T</em> from <em>G</em>) the second smallest; Phase 3
          (computing <strong><em>Δ</em>S</strong>
          <em>w.r.t.&nbsp;G</em>⊖<em>T</em>) the largest. This
          agrees well with our complexity analysis of
          Algorithm&nbsp;3, where the time of Phase 2, <span class=
          "inline-equation"><span class="tex">$O(\sum
          _{l=2}^{L_Q}{n_l(n_{l-1}+n_l)})$</span></span> , is
          independent of the graph size <em>n</em>, unlike Phases 1
          and 3 that hinge on <em>n</em> (≫ <em>n<sub>l</sub></em>
          ).</p>
        </section>
        <section id="sec-13">
          <p><em>5.2.2 Memory Efficiency &amp; Scalability.</em>
          Figure&nbsp;5 depicts the memory efficiency of D-CoSim
          and F-CoSim on six real datasets as compared with CSR and
          CSM. On each dataset, we randomly select |<em>Q</em>| =
          500 queries. For dynamic graphs, we generate
          |<em>ΔG</em>| = 1000 new edge updates to each dataset.
          Figure&nbsp;5a reports the memory of D-CoSim for
          <em>ΔG</em> updates to each dataset
          <em>w.r.t.&nbsp;</em>the query set <em>Q</em>. We see
          that D-CoSim and CSR have comparable memory; both
          increase linearly with the growing size of graphs,
          highlighting the scalability. On small datasets
          (<em>e.g.,&nbsp;</em>AS, HP) when CSM does not fail, the
          memory of D-CoSim is almost 2.5 orders of magnitude
          smaller than CSM. This is because D-CoSim requires only
          linear memory to store auxiliary vectors, as opposed to
          the <em>O</em>(<em>n</em> <sup>2</sup>) memory of CSM for
          repeated squaring. In Figure&nbsp;5b, the memory of
          F-CoSim on static graphs shows the similar tendency.
          Figure&nbsp;5c shows the memory usage at each phase of
          F-CoSim on each dataset. We see that Phase 1 (finding
          <em>T</em>) has the lowest memory as it is based on
          linear BFS search. Phase 2 (computing
          <strong>S</strong>(<em>T</em>) on <em>T</em>) requires
          larger memory than Phase 1, due to its overheads to store
          the resulting <strong>S</strong>(<em>T</em>)[:,
          <em>Q</em>]. These agree with our memory analysis in
          Algorithm&nbsp;3 .</p>
        </section>
        <section id="sec-14">
          <p><em>5.2.3 Accuracy.</em> We evaluate the accuracy of
          D-CoSim and F-CoSim, relative to the original CSR, on
          real datasets. We randomly pick up various query sets
          with its size |<em>Q</em>| varying from 1000 to 3000. For
          each query set <em>Q</em>, based on the CoSimRank scores
          <strong>S</strong>[:, <em>Q</em>] from D-CoSim
          (<em>resp.</em>F-CoSim), we measure their similarity
          ranking results via NDCG (Normalised Discounted
          Cumulative Gain) [<a class="bib" data-trigger="hover"
          data-toggle="popover" data-placement="top" href=
          "#BibPLXBIB0024">24</a>]:</p>
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \textstyle \textrm
              {NDCG}_Q@k = \frac{1}{|Q|} \sum _{q=1}^{|Q|} { \big
              (Z_{k,j} \sum _{x=1}^k {\frac{2^{\mathbf
              {S}[x,q]}-1}{\log _2(1+x)}} \big) } \]</span><br />
            </div>
          </div>where <em>Z</em> <sub><em>k</em>, <em>j</em></sub>
          is a normalization factor that is the DCG ranking results
          by the original method CSR. Thus, NDCG = 1 implies that
          the CoSimRank ranking of the compared algorithm perfectly
          matches that of CSR, with no accuracy loss.
          Figure&nbsp;<a class="fig" href="#fig5">6</a> shows the
          accuracy of D-CoSim and F-CoSim via NDCG for top
          <em>k</em> = 1000 CoSimRank ranking scores on AS. The
          trends on other datasets are similar. We omit them here.
          From the results, we notice that, for each query set
          <em>Q</em>, both NDCGs of D-CoSim and F-CoSim are 1s,
          implying that D-CoSim and F-CoSim do not sacrifice any
          accuracy for their speedup. This verifies the correctness
          of Theorems&nbsp;<a class="enc" href="#enc5">4.5</a> and
          <a class="enc" href="#enc12">4.12</a>.
          <p></p>
        </section>
      </section>
    </section>
    <section id="sec-15">
      <header>
        <div class="title-info">
          <h2><span class="section-number">6</span>
          Conclusions</h2>
        </div>
      </header>
      <p>This paper presents a dynamic scheme, D-CoSim, for fast
      accurate CoSimRank retrieval on evolving graphs. We also
      apply D-CoSim to static graphs, by proposing F-CoSim to speed
      up large-scale static CoSimRank retrieval. On dynamic graphs,
      we devise a novel approach that (a) bunches all edges of
      <em>ΔG</em> into pieces {<em>ΔG<sub>i</sub></em> } and (b)
      characterises only the CoSimRank changes in answer to each
      piece update <em>ΔG<sub>i</sub></em> as the linear
      combination of vectors, thus discarding unnecessary
      computations. D-CoSim retrieves CoSimRank quickly and
      accurately on dynamic graphs, with no need to reassess them
      from scratch. On static graphs, our fast accurate algorithm,
      F-CoSim, greatly speeds up CoSimRank retrieval based on three
      ideas: Given graph <em>G</em>, we (a) find a “spanning
      polytree” <em>T</em> of <em>G</em>; (b) design an efficient
      algorithm to retrieve CoSimRank scores
      <strong>S</strong>(<em>T</em>) over <em>T</em>; and (c) apply
      D-CoSim to evaluate the changes to
      <strong>S</strong>(<em>T</em>) in answer to delta graph
      (<em>G</em>⊖<em>T</em>). Our empirical studies on various
      real datasets demonstrate that (a) D-CoSim is 3–5 orders of
      magnitude faster than the best-known competitors on large
      dynamic graphs; (b) F-CoSim outperforms the state-of-the-art
      approaches on static graphs with a speedup up to 9.8 times;
      (c) D-CoSim and F-CoSim retain comparable linear memory, and
      scale on million-node graphs, with no compromise of any
      accuracy for speedup.</p>
    </section>
  </section>
  <section class="back-matter">
    <section id="ref-001">
      <header>
        <div class="title-info">
          <h2 class="page-brake-head">REFERENCES</h2>
        </div>
      </header>
      <ul class="bibUl">
        <li id="BibPLXBIB0001" label="[1]">Leman Akoglu and
        Christos Faloutsos. 2009. RTG: a recursive realistic graph
        generator using random typing. <em><em>Data Min. Knowl.
        Discov.</em></em> 19, 2 (2009), 194–209. <a class=
        "link-inline force-break" href=
        "https://doi.org/10.1007/s10618-009-0140-7" target=
        "_blank">https://doi.org/10.1007/s10618-009-0140-7</a>
        </li>
        <li id="BibPLXBIB0002" label="[2]">Ioannis Antonellis,
        Hector Garcia-Molina, and Chi-Chao Chang. 2008. SimRank++:
        Query rewriting through link analysis of the click graph.
        In <em><em>WWW</em></em> . 1177–1178. <a class=
        "link-inline force-break" href=
        "https://doi.org/10.1145/1367497.1367714" target="_blank">
          https://doi.org/10.1145/1367497.1367714</a>
        </li>
        <li id="BibPLXBIB0003" label="[3]">Bahman Bahmani, Abdur
        Chowdhury, and Ashish Goel. 2010. Fast Incremental and
        Personalized PageRank. <em><em>PVLDB</em></em> 4, 3
        (2010).</li>
        <li id="BibPLXBIB0004" label="[4]">Orkut Buyukkokten,
        Hector Garcia-Molina, and Andreas Paepcke. 2001. Seeing the
        whole in parts: Text summarization for web browsing on
        handheld devices. In <em><em>WWW</em></em> . 652–662.
        <a class="link-inline force-break" href=
        "https://doi.org/10.1145/371920.372178" target=
        "_blank">https://doi.org/10.1145/371920.372178</a>
        </li>
        <li id="BibPLXBIB0005" label="[5]">Surajit Chaudhuri,
        Venkatesh Ganti, and Dong Xin. 2009. Exploiting web search
        to generate synonyms for entities. In <em><em>WWW</em></em>
        . 151–160. <a class="link-inline force-break" href=
        "https://doi.org/10.1145/1526709.1526731" target="_blank">
          https://doi.org/10.1145/1526709.1526731</a>
        </li>
        <li id="BibPLXBIB0006" label="[6]">Dániel Fogaras and
        Balázs Rácz. 2005. Scaling link-based similarity search. In
        <em><em>WWW</em></em> . 641–650. <a class=
        "link-inline force-break" href=
        "https://doi.org/10.1145/1060745.1060839" target="_blank">
          https://doi.org/10.1145/1060745.1060839</a>
        </li>
        <li id="BibPLXBIB0007" label="[7]">Yasuhiro Fujiwara,
        Makoto Nakatsuji, Hiroaki Shiokawa, and Makoto Onizuka.
        2013. Efficient search algorithm for SimRank. In
        <em><em>ICDE</em></em> . 589–600. <a class=
        "link-inline force-break" href=
        "https://doi.org/10.1109/ICDE.2013.6544858" target=
        "_blank">https://doi.org/10.1109/ICDE.2013.6544858</a>
        </li>
        <li id="BibPLXBIB0008" label="[8]">Glen Jeh and Jennifer
        Widom. 2002. SimRank: A measure of structural-context
        similarity. In <em><em>SIGKDD</em></em> . 538–543.
          <a class="link-inline force-break" href=
          "https://doi.org/10.1145/775047.775126" target=
          "_blank">https://doi.org/10.1145/775047.775126</a>
        </li>
        <li id="BibPLXBIB0009" label="[9]">Minhao Jiang,
        Ada&nbsp;Wai-Chee Fu, Raymond&nbsp;Chi-Wing Wong, and Ke
        Wang. 2017. READS: A Random Walk Approach for Efficient and
        Accurate Dynamic SimRank. <em><em>PVLDB</em></em> 10, 9
        (2017), 937–948. <a class="link-inline force-break" href=
        "http://www.vldb.org/pvldb/vol10/p937-jiang.pdf" target=
        "_blank">http://www.vldb.org/pvldb/vol10/p937-jiang.pdf</a>
        </li>
        <li id="BibPLXBIB0010" label="[10]">Mitsuru Kusumoto,
        Takanori Maehara, and Ken-ichi Kawarabayashi. 2014.
        Scalable similarity search for SimRank. In
        <em><em>SIGMOD</em></em> . 325–336. <a class=
        "link-inline force-break" href=
        "https://doi.org/10.1145/2588555.2610526" target="_blank">
          https://doi.org/10.1145/2588555.2610526</a>
        </li>
        <li id="BibPLXBIB0011" label="[11]">Florian Laws, Lukas
        Michelbacher, Beate Dorow, Christian Scheible, Ulrich Heid,
        and Hinrich Schütze. 2010. A Linguistically Grounded Graph
        Model for Bilingual Lexicon Extraction. In
        <em><em>COLING</em></em> . 614–622. <a class=
        "link-inline force-break" href=
        "http://aclweb.org/anthology/C/C10/C10-2070.pdf" target=
        "_blank">http://aclweb.org/anthology/C/C10/C10-2070.pdf</a>
        </li>
        <li id="BibPLXBIB0012" label="[12]">Jure Leskovec,
        Jon&nbsp;M. Kleinberg, and Christos Faloutsos. 2007. Graph
        evolution: Densification and shrinking diameters. <em><em>
          TKDD</em></em> 1, 1 (2007), 2. <a class=
          "link-inline force-break" href=
          "https://doi.org/10.1145/1217299.1217301" target=
          "_blank">https://doi.org/10.1145/1217299.1217301</a>
        </li>
        <li id="BibPLXBIB0013" label="[13]">Cuiping Li, Jiawei Han,
        Guoming He, Xin Jin, Yizhou Sun, Yintao Yu, and Tianyi Wu.
        2010. Fast computation of SimRank for static and dynamic
        information networks. In <em><em>EDBT</em></em> . 465–476.
        <a class="link-inline force-break" href=
        "https://doi.org/10.1145/1739041.1739098" target="_blank">
          https://doi.org/10.1145/1739041.1739098</a>
        </li>
        <li id="BibPLXBIB0014" label="[14]">Zhenjiang Lin,
        Michael&nbsp;R. Lyu, and Irwin King. 2006. PageSim: A novel
        link-based measure of web page similarity. In
        <em><em>WWW</em></em> . 1019–1020. <a class=
        "link-inline force-break" href=
        "https://doi.org/10.1145/1135777.1135994" target="_blank">
          https://doi.org/10.1145/1135777.1135994</a>
        </li>
        <li id="BibPLXBIB0015" label="[15]">Dmitry Lizorkin, Pavel
        Velikhov, Maxim&nbsp;N. Grinev, and Denis Turdakov. 2010.
        Accuracy estimate and optimization techniques for SimRank
        computation. <em><em>VLDB J.</em></em> 19, 1 (2010), 45–66.
        <a class="link-inline force-break" href=
        "https://doi.org/10.1007/s00778-009-0168-8" target=
        "_blank">https://doi.org/10.1007/s00778-009-0168-8</a>
        </li>
        <li id="BibPLXBIB0016" label="[16]">Phuong Nguyen, Paolo
        Tomeo, Tommaso&nbsp;Di Noia, and Eugenio&nbsp;Di Sciascio.
        2015. An evaluation of SimRank and Personalized PageRank to
        build a recommender system for the Web of Data. In <em><em>
          WWW</em></em> . 1477–1482. <a class=
          "link-inline force-break" href=
          "https://doi.org/10.1145/2740908.2742141" target=
          "_blank">https://doi.org/10.1145/2740908.2742141</a>
        </li>
        <li id="BibPLXBIB0017" label="[17]">Alexandros Ntoulas,
        Junghoo Cho, and Christopher Olston. 2004. What's new on
        the web? The evolution of the web from a search engine
        perspective. In <em><em>WWW</em></em> . 1–12. <a class=
        "link-inline force-break" href=
        "https://doi.org/10.1145/988672.988674" target=
        "_blank">https://doi.org/10.1145/988672.988674</a>
        </li>
        <li id="BibPLXBIB0018" label="[18]">Sascha Rothe and
        Hinrich Schütze. 2014. CoSimRank: A Flexible &amp;
        Efficient Graph-Theoretic Similarity Measure. In
        <em><em>ACL</em></em> . 1392–1402. <a class=
        "link-inline force-break" href=
        "http://aclweb.org/anthology/P/P14/P14-1131.pdf" target=
        "_blank">http://aclweb.org/anthology/P/P14/P14-1131.pdf</a>
        </li>
        <li id="BibPLXBIB0019" label="[19]">Tamás Sarlós,
        András&nbsp;A. Benczúr, Károly Csalogány, Dániel Fogaras,
        and Balázs Rácz. 2006. To randomize or not to randomize:
        Space optimal summaries for hyperlink analysis. In <em><em>
          WWW</em></em> . 297–306. <a class=
          "link-inline force-break" href=
          "https://doi.org/10.1145/1135777.1135823" target=
          "_blank">https://doi.org/10.1145/1135777.1135823</a>
        </li>
        <li id="BibPLXBIB0020" label="[20]">Yingxia Shao, Bin Cui,
        Lei Chen, Mingming Liu, and Xing Xie. 2015. An Efficient
        Similarity Search Framework for SimRank over Large Dynamic
        Graphs. <em><em>PVLDB</em></em> 8, 8 (2015), 838–849.
        <a class="link-inline force-break" href=
        "http://www.vldb.org/pvldb/vol8/p838-shao.pdf" target=
        "_blank">http://www.vldb.org/pvldb/vol8/p838-shao.pdf</a>
        </li>
        <li id="BibPLXBIB0021" label="[21]">Yizhou Sun, Jiawei Han,
        Xifeng Yan, Philip&nbsp;S. Yu, and Tianyi Wu. 2011.
        PathSim: Meta path-based top-<em>K</em> similarity search
        in heterogeneous information networks.
        <em><em>PVLDB</em></em> 4, 11 (2011), 992–1003. <a class=
        "link-inline force-break" href=
        "http://www.vldb.org/pvldb/vol4/p992-sun.pdf" target=
        "_blank">http://www.vldb.org/pvldb/vol4/p992-sun.pdf</a>
        </li>
        <li id="BibPLXBIB0022" label="[22]">Akihiro Tamura, Taro
        Watanabe, and Eiichiro Sumita. 2012. Bilingual Lexicon
        Extraction from Comparable Corpora Using Label Propagation.
        In <em><em>EMNLP-CoNLL</em></em> . 24–36. <a class=
        "link-inline force-break" href=
        "http://www.aclweb.org/anthology/D12-1003" target="_blank">
          http://www.aclweb.org/anthology/D12-1003</a>
        </li>
        <li id="BibPLXBIB0023" label="[23]">Boyu Tian and Xiaokui
        Xiao. 2016. SLING: A Near-Optimal Index Structure for
        SimRank. In <em><em>SIGMOD</em></em> . 1859–1874.
          <a class="link-inline force-break" href=
          "https://doi.org/10.1145/2882903.2915243" target=
          "_blank">https://doi.org/10.1145/2882903.2915243</a>
        </li>
        <li id="BibPLXBIB0024" label="[24]">Yining Wang, Liwei
        Wang, Yuanzhi Li, Di He, and Tie-Yan Liu. 2013. A
        Theoretical Analysis of NDCG Type Ranking Measures. In <em>
          <em>COLT</em></em> . 25–54. <a class=
          "link-inline force-break" href=
          "http://jmlr.org/proceedings/papers/v30/Wang13.html"
          target=
          "_blank">http://jmlr.org/proceedings/papers/v30/Wang13.html</a>
        </li>
        <li id="BibPLXBIB0025" label="[25]">Weiren Yu, Xuemin Lin,
        and Wenjie Zhang. 2014. Fast incremental SimRank on
        link-evolving graphs. In <em><em>ICDE</em></em> . 304–315.
        <a class="link-inline force-break" href=
        "https://doi.org/10.1109/ICDE.2014.6816660" target=
        "_blank">https://doi.org/10.1109/ICDE.2014.6816660</a>
        </li>
        <li id="BibPLXBIB0026" label="[26]">Weiren Yu, Xuemin Lin,
        Wenjie Zhang, and Julie&nbsp;A. McCann. 2018. Dynamical
        SimRank search on time-varying networks. <em><em>VLDB
        J.</em></em> 27, 1 (2018), 79–104. <a class=
        "link-inline force-break" href=
        "https://doi.org/10.1007/s00778-017-0488-z" target=
        "_blank">https://doi.org/10.1007/s00778-017-0488-z</a>
        </li>
        <li id="BibPLXBIB0027" label="[27]">Weiren Yu and
        Julie&nbsp;A. McCann. 2015. Co-Simmate: Quick Retrieving
        All Pairwise Co-Simrank Scores. In <em><em>ACL</em></em> .
        327–333. <a class="link-inline force-break" href=
        "http://aclweb.org/anthology/P/P15/P15-2054.pdf" target=
        "_blank">http://aclweb.org/anthology/P/P15/P15-2054.pdf</a>
        </li>
        <li id="BibPLXBIB0028" label="[28]">Weiren Yu and
        Julie&nbsp;A. McCann. 2016. Random Walk with Restart over
        Dynamic Graphs. In <em><em>ICDM</em></em> . 589–598.
        <a class="link-inline force-break" href=
        "https://doi.org/10.1109/ICDM.2016.0070" target=
        "_blank">https://doi.org/10.1109/ICDM.2016.0070</a>
        </li>
        <li id="BibPLXBIB0029" label="[29]">Weiren Yu, Wenjie
        Zhang, Xuemin Lin, Qing Zhang, and Jiajin Le. 2012. A space
        and time efficient algorithm for SimRank computation. <em>
          <em>World Wide Web</em></em> 15, 3 (2012), 327–353.
          <a class="link-inline force-break" href=
          "https://doi.org/10.1007/s11280-010-0100-6" target=
          "_blank">https://doi.org/10.1007/s11280-010-0100-6</a>
        </li>
        <li id="BibPLXBIB0030" label="[30]">Peixiang Zhao, Jiawei
        Han, and Yizhou Sun. 2009. P-Rank: A comprehensive
        structural similarity measure over information networks. In
        <em><em>CIKM</em></em> . 553–562. <a class=
        "link-inline force-break" href=
        "https://doi.org/10.1145/1645953.1646025" target="_blank">
          https://doi.org/10.1145/1645953.1646025</a>
        </li>
      </ul>
    </section>
  </section>
  <section id="foot-001" class="footnote">
    <header>
      <div class="title-info">
        <h2>FOOTNOTE</h2>
      </div>
    </header>
    <p id="fn1"><a href="#foot-fn1"><sup>1</sup></a>In comparison,
    SimRank [<a class="bib" data-trigger="hover" data-toggle=
    "popover" data-placement="top" href="#BibPLXBIB0008">8</a>] is
    defined as: <strong>S</strong> = max {<em>C</em>
    <strong>A</strong> <sup><em>T</em></sup> <strong>S</strong>
    <strong>A</strong>, <strong>I</strong>}.</p>
    <p id="fn2"><a href="#foot-fn2"><sup>2</sup></a>In the
    following, <span class="inline-equation"><span class=
    "tex">$\Delta {{G}_{{{u}_{i}}}} =
    ([{{v}_{{{i}_{1}}}},{{v}_{{{i}_{2}}}},\cdots
    ,{{v}_{{{i}_{\delta }}}}] \rightarrow {{u}_{i}})$</span></span>
    is abbreviated to <span class="inline-equation"><span class=
    "tex">$\Delta {{G}_{u}} = ([{{v}_{1}},{{v}_{2}},\cdots
    ,{{v}_{\delta _u}}] \rightarrow u)$</span></span> for
    simplicity.</p>
    <div class="bibStrip">
      <p>This paper is published under the Creative Commons
      Attribution 4.0 International (CC-BY&nbsp;4.0) license.
      Authors reserve their rights to disseminate the work on their
      personal and corporate Web sites with the appropriate
      attribution.</p>
      <p><em>WWW '18, April 23-27, 2018, Lyon, France</em></p>
      <p>© 2018; IW3C2 (International World Wide Web Conference
      Committee), published under Creative Commons CC-BY&nbsp;4.0
      License. ACM ISBN 978-1-4503-5639-8/18/04.<br />
      DOI: <a class="link-inline force-break" target="_blank" href=
      "https://doi.org/10.1145/3178876.3186126">https://doi.org/10.1145/3178876.3186126</a></p>
    </div>
  </section>
  <div class="pubHistory">
    <p></p>
  </div>
</body>
</html>
