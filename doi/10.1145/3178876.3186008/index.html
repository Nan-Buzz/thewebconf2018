<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">  <head>  <title>Browserless Web Data Extraction: Challenges and Opportunities</title>  <!-- Copyright (c) 2010-2015 The MathJax Consortium --><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>  <meta name="viewport" content="width=device-width; initial-scale=1.0;"></meta>  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>  <link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/bootstrap.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/bootstrap-theme.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/main.css"/><script src="../../../data/dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script>  <script type="text/javascript"    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>  <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>  <link rel="cite-as" href="https://doi.org/10.1145/3178876.3186008"/></head>  <body id="main">
<div>
<p style='font-size: 75%; color #444'>
This is a web copy of <a href='https://doi.org/10.1145/3178876.3186008'>https://doi.org/10.1145/3178876.3186008</a>.
 Published in WWW2018 Proceedings Â© 2018 International World Wide Web Conference Committee, published under 
 <a rel='license' property='license' href='https://creativecommons.org/licenses/by/4.0/'>
 Creative Commons CC By 4.0 License</a>.
The <a href='https://github.com/usable-oa/thewebconf2018/tree/master/scripts'>modifications</a> 
from the original are solely to improve HTML aiming to make it Findable, Accessible, Interoperable and Reusable. 
augmenting HTML metadata and avoiding ACM trademark.
To reference this HTML version, use:
</p><p>
<strong>Permalink:</strong>
<a href='https://w3id.org/oa/10.1145/3178876.3186008'>https://w3id.org/oa/10.1145/3178876.3186008</a>
</p></div>
<hr>

  <section class="front-matter">   <section>    <header class="title-info">     <div class="journal-title">     <h1>      <span class="title">Browserless Web Data Extraction: Challenges and Opportunities<a class="fn" href="#fn1" id="foot-fn1a"><sup>&#x002A;</sup></a></span>      <br/>      <span class="subTitle"/>     </h1>     </div>    </header>    <div class="authorGroup">     <div class="author">     <span class="givenName">Ruslan R.</span>      <span class="surName">Fayzrakhmanov</span>,     Department of Computer Science, University of Oxford, Wolfson Building, Parks RoadOxford, UKOX1 3QD     </div>     <div class="author">     <span class="givenName">Emanuel</span>      <span class="surName">Sallinger</span>,     Department of Computer Science, University of Oxford, Wolfson Building, Parks RoadOxford, UKOX1 3QD     </div>     <div class="author">     <span class="givenName">Ben</span>      <span class="surName">Spencer</span>,     Department of Computer Science, University of Oxford, Wolfson Building, Parks RoadOxford, UKOX1 3QD     </div>     <div class="author">     <span class="givenName">Tim</span>      <span class="surName">Furche</span>,     Department of Computer Science, University of Oxford, Wolfson Building, Parks RoadOxford, UKOX1 3QD     </div>     <div class="author">     <span class="givenName">Georg</span>      <span class="surName">Gottlob</span>,     Department of Computer Science, University of Oxford, Wolfson Building, Parks RoadOxford, UKOX1 3QD, <a href="mailto:name.surname@cs.ox.ac.uk">name.surname@cs.ox.ac.uk</a>     </div>        </div>    <br/>    <div class="pubInfo">     <p>DOI: <a href="https://doi.org/10.1145/3178876.3186008" target="_blank">https://doi.org/10.1145/3178876.3186008</a>     <br/>WWW '18: <a href="https://doi.org/10.1145/3178876" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p>    </div>    <div class="abstract">     <p>     <small>Most modern web scrapers use an embedded browser to render web pages and to simulate user actions. Such scrapers (or wrappers) are therefore expensive to execute, in terms of time and network traffic. In contrast, it is magnitudes more resource-efficient to use a &#x201C;browserless&#x201D; wrapper which directly accesses a web server through HTTP requests, and takes the desired data directly from the raw replies. However, creating and maintaining browserless wrappers of high precision requires specialists, and is prohibitively labor-intensive at scale. In this paper, we demonstrate the principal feasibility of automatically translating browser-based wrappers into &#x201C;browserless&#x201D; wrappers. We present the first algorithm and system performing such an automated translation on suitably restricted types of web sites. This system works in the vast majority of test cases and produces very fast and extremely resource-efficient wrappers. We discuss research challenges for extending our approach to a general method applicable to a yet larger number of cases.</small>     </p>    </div>    <div class="CCSconcepts">     <p> <small> <span style="font-weight:bold;">CCS Concepts:</span> &#x2022;<strong> Information systems </strong>&#x2192; <strong>Site wrapping;</strong> <strong>Deep web;</strong> <em>Information extraction;</em></small> </p>    </div>    <div class="classifications">     <div class="author">     <span style="font-weight:bold;">      <small>Keywords:</small>     </span>     <span class="keyword">      <small>web data extraction; scraping; deep web; HTTP; AJAX</small>     </span>     </div>     <br/>     <div class="AcmReferenceFormat">     <p>      <small>       <span style="font-weight:bold;">ACM Reference Format:</span>       <br/>       Ruslan R. Fayzrakhmanov, Emanuel Sallinger, Ben Spencer, Tim Furche, and Georg Gottlob. 2018. Browserless Web Data Extraction: Challenges and Opportunities. In <em>WWW 2018: The 2018 Web Conference,</em>       <em>April 23&#x2013;27, 2018 (WWW 2018),</em>       <em> Lyon, France. ACM, New York, NY, USA</em> 10 Pages. <a href="https://doi.org/10.1145/3178876.3186008" class="link-inline force-break"        target="_blank">https://doi.org/10.1145/3178876.3186008</a></small>     </p>     </div>    </div>   </section>  </section>  <section class="body">   <section id="sec-2">    <header>     <div class="title-info">     <h2>      <span class="section-number">1</span> Introduction</h2>     </div>    </header>    <p>&#x201C;The Web is the largest database&#x201D; is a sentence one sometimes hears. This statement is, of course, wrong: Web data relevant to most applications is distributed over heterogeneously structured websites, usually does not come with a schema, and cannot be directly queried, except by manual keyword search. Given that many companies and institutions need to access outside data for better decision making [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0033">33</a>], they have to rely on automated Web data extraction programs, also known as<em>wrappers</em>. They use wrapper generators that produce wrappers which continuously or periodically extract information from relevant websites and store this information in a highly structured format in a local database. In fact, Web data extraction is nowadays heavily and proficuously used by various branches of industry. Electronics retailers, for example, are interested in the daily prices offered by their competitors, as are hotels and supermarket chains. International construction firms automatically extract tenders from hundreds of websites. Other sectors have adopted Web data extraction as part of their core business. Among those are flight search engines and media intelligence companies.</p>    <p>Since around the year 2000, sophisticated semi-automated visual and interactive tools have been developed, which allow users to define wrappers via visual point-and-click actions. Examples are tools such as <em>STALKER</em> &#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0036">36</a>] and <em>Lixto</em>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0003">3</a>]. Other advanced semi-automatic tools are, for example, <em>import.io</em>, Mozenda&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0035">35</a>] , FMiner&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0015">15</a>] , iMacros&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0021">21</a>] , Visual Web Ripper&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0046">46</a>]&#x00A0; , and the BODE system&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0045">45</a>]. The OXPath data extraction language&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0018">18</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0025">25</a>] enriches XPath with simulated user interaction, and node and form field selection based on visual features. OXPath is the target language of the fully automated high-precision visual-clue based wrapper generator DIADEM&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0016">16</a>]. In DIADEM the knowledge for extracting data from websites belonging to an application domain (e.g., real-estate) is provided in form of Datalog rules. Using such rules and a set of URLs as input, the DIADEM system autonomously extracts data from sites belonging to this domain.</p>    <p>     <strong>Advantages of visual-clue based data extraction</strong>. Most modern data extraction tools, including those mentioned, use visual clues and visual interaction in the wrapper generation process and rely on graphical and geometric concepts such as the <em>distance</em> between two rendered elements&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0024">24</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0026">26</a>]. For example, there is a rule in the DIADEM knowledge base which, in simplified form, says the following: <em>The closest text chunk below or above an input field on a Web page is (with high probability and in absence of better information) the explanatory label of this field</em>. The use of visual clues and &#x201C;page geography&#x201D; often leads to more precise and more robust wrappers&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0013">13</a>]. The possibility of defining, modifying, and testing wrappers in a visual fashion has relieved wrapper designers from the tedious task of having to decipher the HTML code of each target web page, and of writing sequential programs that act on it. The semi-automatic wrapper generation process for complex websites, inclusive of testing, now typically takes a couple of hours at most, rather than a couple of days using traditional methods.</p>    <p>     <strong>Drawbacks of visual-clue based data extraction</strong>. While infinitely beneficial for <em>wrapper design</em>, visual-clue based wrappers, referred to as <strong>visual wrappers</strong>, come with an awful drawback at execution time: The natural approach, which is currently in use, is to render the page internally via an embedded browser. This <em>rendering</em> tasks consists of (a) parsing the web page and building a DOM tree (b) applying the CSS rules and (c) executing JavaScript, which is typically the most computationally expensive part, often having wide-ranging effects on the page&#x0027;s DOM.</p>    <p>A coarse analysis of the relative computational cost for visual wrappers in OXPath shows that the browser initialization phase takes about 13% of the runtime, the rendering phase about 85%, and the actual extraction about 2%&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0018">18</a>]. Initialization and rendering jointly require approximately 50 times more time than the actual data extraction. For visual-clue based wrappers written in other programming languages than OXPath, this disproportion is similar or even worse. Companies engaged in massive data extraction suffer sorely under this huge runtime overhead. For example, financial companies, flight search companies or news services have hundreds of wrappers working continually, both in their own data centers and on rented cloud resources. A factor of 50 runtime overhead leads to huge additional costs. Moreover, the implied slow-down of real-time extraction tasks, such as extracting the current price of a flight, often leads to user dissatisfaction. For these and other critical real-time scraping tasks, such as data access in automated option trading, visual wrappers are simply too slow.</p>    <p>     <strong>HTTP wrappers</strong>. To mitigate such runtime problems, many companies resort to replacing their most heavily used wrappers by alternative hand-programmed wrappers which we refer to as <strong>HTTP wrappers</strong>. An HTTP wrapper is a browserless wrapper that interacts directly with a remote web server by sending HTTP requests (similar to those a browser would issue) and by analyzing the received replies without rendering them, picking the desired data directly from the raw content. In our experiments, we observed that HTTP wrappers are on average 23.8 times faster than the original visual wrappers, even excluding browser initialisation (see Tab.&#x00A0;<a class="tbl" href="#tab1">1</a>). Another advantage of HTTP wrappers is that they usually make only those server requests that are really necessary for obtaining the desired data, and skip a large number of requests that a browser would usually make to load irrelevant images, fonts, CSS style sheets, JavaScript code, text, and ads. Around 96.8% of the Internet traffic generated by visual wrappers (already ignoring images) is totally useless for obtaining the desired data and can be elided in a corresponding HTTP wrapper.</p>    <p>In order to build such HTTP wrappers, highly-qualified specialists initially perform the typical user interaction through a browser and analyze the HTTP traffic between the browser and the server. Once they have understood the browser-server interaction, which usually consists of a series of back-and-forth data exchange steps, and after they have identified the precise flow of the relevant data items, they write a parametrized HTTP wrapper that simulates the browser-server interaction obtaining, for each set of input parameters, the desired output data from the remote server without any rendering. Note that writing HTTP wrappers by hand is an extremely complicated task. Even specialists typically require several days to develop and test a new HTTP wrapper. Moreover, HTTP wrappers are usually less robust than visual-clue based wrappers and require more maintenance in case of structural website changes.</p>    <p>     <strong>Key idea underlying this work</strong>. It is frustrating that for many scraping applications one has to go back to old-fashioned manual programming, and the data extraction community is in sore need of new methods which avoid the drawbacks of the above two types of wrappers altogether. As the authors have learnt from multiple contacts with scraping-intensive industries, the dichotomy of wrapper types and the implied necessity of choosing between one or another set of drawbacks is a major pain point. It would be fantastic if there were a method which combined all the advantages of both visual wrapping and HTTP wrapping, without sharing the disadvantages of either method. As will be reported in this paper, we discovered that this is indeed possible, and we will provide evidence of this. Our key innovative idea is very simple to formulate, but, as we will see later, represents a great technical challenge:</p>    <p style="border-style: solid;">     <strong>Key idea</strong>: Transform modern visual-clue based wrappers automatically into browserless HTTP wrappers. Use the former at wrapper design time and the latter at runtime.</p>    <p>Of course such an automated transformation should be &#x201C;intelligent&#x201D; and produce HTTP wrappers which perform only the necessary steps and suppress useless requests that load pictures, ads, and other irrelevant data. This approach would then combine the advantages of relatively simple visual wrapper generation with the fast execution time, real-time wrapping suitability, low cost, and reduced Internet traffic of HTTP wrappers. Clearly, with the proposed new approach, wrapper maintenance, too, is simpler than with hand-made HTTP wrappers. We observed, that the transformation approach achieves a level of wrapper robustness that is not worse than the robustness level of visual wrappers. The &#x201C;compilation&#x201D; approach thus combines all advantages of visual-clue wrapping and HTTP wrapping. It follows that the proposed HTTP wrapper generation approach, when successful, has none of the disadvantages mentioned for either of the wrapping paradigms. This assumes of course that the transformation itself is robust, which is a key research challenge.</p>    <p>To our knowledge, nobody has ever attempted to construct an automatic transformation from visual wrappers into HTTP wrappers. This is not astonishing, given that it is a difficult endeavor which combines several hard research challenges. The main contributions of this work and its structure are detailed as follows:</p>    <ul class="list-no-style">     <li id="list1" label="&#x2022;"><strong>Problem definition, challenges, and limitations</strong> (Section&#x00A0;<a class="sec" href="#sec-3">2</a>). We open up the new area of automated HTTP wrapper generation from visual-clue based wrappers. We present a number of pitfalls that induce interesting research challenges, and set the limitations we assume in this paper.<br/></li>     <li id="list2" label="&#x2022;"><strong>The</strong>      <SmallCap>      <strong>FastWrap</strong>     </SmallCap>     <strong>approach</strong> (Section&#x00A0;<a class="sec" href="#sec-4">3</a>). We present the first approach for automatically generating HTTP wrappers from visual-clue based wrappers. This includes novel techniques for identifying dependencies between browser-server interactions through the concept of &#x201C;dependency graph&#x201D;. This graph is obtained by new methods of generalizing browser-server interactions based on their similarity, and a number of other technical tools. We present both the high-level approach, as well as a concrete algorithm. Complex analysis tasks are performed in relatively little time: The translation process takes less than one minute on average.<br/></li>     <li id="list3" label="&#x2022;"><strong>Evaluation</strong> (Section&#x00A0;<a class="sec" href="#sec-9">4</a>). We present a comprehensive evaluation of the implementation of our approach, proving the principal feasibility of automatically generating HTTP wrappers. Encouragingly, even considering the limitations on the scope of the approach, the results are rather promising: The system successfully generates an HTTP wrapper in 79.2% of the test cases. Our evaluation shows that these HTTP wrappers are on average 23.8 times faster, use 31.3 times less network traffic, and send 71.4 times fewer requests than the original interactive wrappers executed through Firefox with images disabled.<br/></li>     <li id="list4" label="&#x2022;"><strong>Related work and research directions</strong> (Sections&#x00A0;<a class="sec" href="#sec-14">5</a> and <a class="sec" href="#sec-15">6</a>). After discussing related work, we identify research directions arising from the challenges and limitations described in Section&#x00A0;<a class="sec" href="#sec-3">2</a>, as well as from our evaluation in Section&#x00A0;<a class="sec" href="#sec-9">4</a>.<br/></li>    </ul>   </section>   <section id="sec-3">    <header>     <div class="title-info">     <h2>      <span class="section-number">2</span> Problem Definition, Challenges, and Limitations</h2>     </div>    </header>    <p>Visual wrappers targeting complex Web applications require the simulation of specific sequences of user interactions either to get to a certain state of a current Web page (e.g., to get detailed information about a product loaded by AJAX requests) or to reach a page with relevant data (e.g., sending a filled in Web form or navigating to a specific page). These interactions are enriched with input and output instructions, parametrizing such interactive wrappers, e.g., to define that a certain form field should receive a location as input and that a particular part of the search result page to be extracted is a phone number. The parametrization is necessary for an intensive large-scale data extraction.</p> <figure id="fig1">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186008/images/www2018-17-fig1.jpg" class="img-responsive" alt="Figure 1"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 1:</span>      <span class="figure-title">The four-step interaction for extraction from Vauxhall with the user input, &#x201C;Preston&#x201D;.</span>     </div>     </figure>    <p>Visual wrappers mimic user actions by firing DOM events such as <span class="inline-equation"><span class="tex">$\mathtt {click}$</span>     </span> or <span class="inline-equation"><span class="tex">$\mathtt {keypress}$</span>     </span> in the integrated Web page rendering engine. In Fig.&#x00A0;<a class="fig" href="#fig1">1</a>, we see an example of a visual wrapper used for extracting details of car dealerships. This scenario is represented by a sequence of four user interactions: <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineUserActionOne.jpg" align="middle"/> entering search keywords (an input parameter), <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineUserActionTwo.jpg" class="img-responsive" alt="" longdesc=""/> &#x00A0;selecting a relevant suggestion from the autocomplete list, <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineUserActionThree.jpg" class="img-responsive" alt="" longdesc=""/> &#x00A0;clicking the search button, which displays a list of corresponding car dealers, and <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineUserActionFour.jpg" class="img-responsive" alt="" longdesc=""/> &#x00A0;clicking a link to a more detailed view which shows the target output data.</p>    <p>We can observe two levels of interaction: the <em>user-browser interaction</em> and the HTTP-based <em>browser-server communication</em>. On the first level, the data extraction scenario is defined by a sequence of interactions with the rendered graphical interface. Simulated user actions (e.g., <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineUserActionOne.jpg" class="img-responsive" alt="" longdesc=""/>&#x2013;<img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineUserActionFour.jpg" class="img-responsive" alt="" longdesc=""/> illustrated in Fig.&#x00A0;<a class="fig" href="#fig1">1</a>) trigger the invocation of HTTP request-response exchanges (<em>HTTP interactions</em>) as well as the execution of the JavaScript code parsing and modifying the data obtained from the server. In our example in Fig.&#x00A0;<a class="fig" href="#fig1">1</a>, the visual wrapper execution will produce a sequence of <em>HTTP traces</em> as schematically illustrated in Fig.&#x00A0;<a class="fig" href="#fig2">2</a> (and which will be explained in Sec.&#x00A0;<a class="sec" href="#sec-4">3</a>). For example, the user action <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineUserActionOne.jpg" class="img-responsive" alt="" longdesc=""/> , entering input string into the search form, generates an autocomplete list by triggering the HTTP request-response <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionTwo.jpg" class="img-responsive" alt="" longdesc=""/>. The latter is an AJAX request returning a JSON object from the server, which is converted by client&#x0027;s JavaScript into a snippet of HTML code and integrated into the rendered web page.</p>    <p>The <strong>main goal and problem</strong> that we target in this paper is how to eliminate the first level of interaction (along with the browser) and conduct web data extraction exclusively using HTTP interactions, corresponding to the second level. As a <strong>second goal and problem</strong>, we also want to minimize the number of HTTP interactions by eliminating those of them which do not lead to HTTP responses with desired data.</p>    <p>     <strong>Limitations</strong>. We now describe the limitations that we deliberately set on the wrappers and websites we consider. Two are on the visual wrappers, and two are on the websites our approach applies to. All four are important limitations, giving rise to interesting research challenges, and are discussed in Sec.&#x00A0;<a class="sec" href="#sec-15">6</a>.</p>    <p>     <strong>Single target page</strong>. While the considered visual wrapper may visit arbitrarily many pages during execution (and the navigation may be arbitrarily complex), we only consider visual wrappers where the final extracted data is contained in a single Web page, which we call the target page. This limitation is not essential, as it does not touch upon the major critical points in browserless web data extraction. In fact, it is conceptually not hard to generalize the method to wrappers that take data from multiple pages. Moreover, note that overwhelming number of wrappers used in various industrial applications are single-target page wrappers (for example, in application areas that we have considered so far, these are more than 80%). Most wrappers that extract data from multiple pages do this because of next-page links, which are simple to recognize and handle automatically, but are not considered here for the avoidance of irrelevant overhead and to concentrate on the essential.</p>    <p>     <strong>Flat records</strong>. For simplicity we only consider visual wrappers which extract flat data records as output. That is, we allow no nesting of records, no optional fields, and no compound data values. We believe that this restriction can be easily lifted by state-of-the-art structure identification techniques.</p>    <p>     <strong>Service with reproducible interactions</strong>. We also here exclude unstable servers, i.e., web servers that reply to the same request with considerably different content in the response. This limitation is mitigated by the fact that according to our observations the vast majority are related to dynamically generated session-ids: When repeating the request with the same session-id, the server can return an error message. For session-ids, special approaches are possible, as will be discussed in Sec.&#x00A0;<a class="sec" href="#sec-15">6</a>. In some web domains the content can change frequently according to the data in the backend database (e.g., products in a shop, or flight details). In our approach we assume that the content does not change during the HTTP wrapper generation process.</p>    <p>     <strong>No Google Maps Geocoding API</strong>. We do not support websites which use the Google Maps API. More specifically, we disallow websites that use the Google Maps API as a necessary part of the wrapper&#x0027;s execution. The deeper reason for this is that corresponding requests may use different parameters in different traces. In fact, this API encodes query values into the parameter names. However, there is an obvious solution to the problem: To carefully analyze the code to generate a bespoke, generic HTTP wrapper for interacting with the Google Maps service.</p>    <p>A wrapper is called <strong>compliant</strong> if it satisfies the four wrapper limitations given above.</p>   </section>   <section id="sec-4">    <header>     <div class="title-info">     <h2>      <span class="section-number">3</span> The <SmallCap>FastWrap</SmallCap> Method</h2>     </div>    </header>    <p>In this section, we introduce <SmallCap>FastWrap</SmallCap>, our approach and algorithm for automatically generating HTTP wrappers. The algorithm takes as input a visual wrapper, referred to as the <em>input wrapper</em>, along with its input parameters, and produces as output a corresponding browserless HTTP wrapper, referred to as the <em>output wrapper</em>. The output wrapper extracts the same data as the input wrapper by directly interacting with the website&#x0027;s servers and does not require loading and rendering the web page.</p>    <p>The <SmallCap>FastWrap</SmallCap> system implementing our approach works by executing the input wrapper with its input parameters to collect and analyze the sequence of request-response exchanges (referred to as <em>HTTP traces</em> or simply <em>traces</em>) between the input wrapper and the web server. Specifically these exchanges stem from a rendering engine (as used in, e.g. Lixto&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0019">19</a>]), whether or not it is part of a browser (as used in, e.g. Mozenda&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0035">35</a>] or OXPath&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0018">18</a>]). HTTP traces also include data extracted by the input wrapper (so-called <em>output records</em>). This data is used to identify <em>target HTTP interactions</em> (or <em>target interactions</em>) with the desired output records in their responses. Furthermore, the provided records are used to generate <em>data selectors</em> to extract the data from the content and transform them into a structured representation. If <em>input parameters</em> are necessary (e.g., for web form filling), HTTP traces also include these. They are used to correctly induce the output wrapper which extracts the same data as the input wrapper. Wrapper creation is thus solely based on the direct analysis of these HTTP traces. This makes our approach applicable to a wide range of visual wrappers and avoids tying it to any particular system.</p>    <section id="sec-5">     <header>     <div class="title-info">      <h3>       <span class="section-number">3.1</span> Overview of the Approach</h3>     </div>     </header>     <figure id="fig2">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186008/images/www2018-17-fig2.jpg" class="img-responsive" alt="Figure 2"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 2:</span>      <span class="figure-title">A schematic representation of an HTTP trace for the Vauxhall example with the user input, &#x201C;Preston&#x201D;. HTTP interactions are ordered chronologically. It also illustrates parameter matches and the relations between user actions and triggered HTTP interactions.</span>     </div>     </figure>     <p>The overall <SmallCap>FastWrap</SmallCap> approach can be intuitively explained via the following four main steps. A more formal definition of some of the terms used will be given in Sec.&#x00A0;<a class="sec" href="#sec-6">3.2</a>. The core algorithm is given in Sec.&#x00A0;3.3 and some further technical details in Sec.&#x00A0;3.4.</p>     <ul class="list-no-style">     <li id="uid9" label="Step&#x00A0;1:">Execute the input wrapper on sample input parameters and collect the corresponding HTTP trace for each run, along with the input parameters and output records. In the special case where input wrapper has no input parameter execute the input wrapper a single time.<br/></li>     </ul>     <p>In Step&#x00A0;1, the input wrapper is executed several times with different input parameters (e.g., &#x201C;Preston&#x201D;, &#x201C;Southampton&#x201D;, and &#x201C;Walton&#x201D; for the input parameter <tt>city</tt>), producing a corresponding number of HTTP traces. A graphical representation of a trace with user input &#x201C;Preston&#x201D; is illustrated in Fig.&#x00A0;<a class="fig" href="#fig2">2</a>. The actual trace seen by our algorithm is a log of HTTP request-response messages (in this case obtained from the OXPath wrapper execution engine), where each response may contain HTML, JSON, XML or other formats.</p>     <ul class="list-no-style">     <li id="uid10" label="Step&#x00A0;2:">Analyze the traces in order to identify those HTTP interactions that contain the target records. Initially, the target records are the output records, while for subsequent recursive invocations, they are provided by Step&#x00A0;4.7.<br/></li>     </ul>     <p>In our example, interaction <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionSix.jpg" class="img-responsive" alt="" longdesc=""/> is one of the interactions that carries the required output data. In subsequent invocations, Step&#x00A0;2 will analyze interactions <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionOne.jpg" class="img-responsive" alt="" longdesc=""/>, <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionTwo.jpg" class="img-responsive" alt="" longdesc=""/>, <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionThree.jpg" class="img-responsive" alt="" longdesc=""/>, <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionFour.jpg" class="img-responsive" alt="" longdesc=""/>, and <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionFive.jpg" class="img-responsive" alt="" longdesc=""/>. This way the traces are analyzed staring from the output records and leading back towards the input parameters. The advantage of this approach is that only interactions which are causally relevant to the output will be considered, while other, irrelevant interactions (e.g., downloading ads) are disregarded. In our example, all interactions <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteraction.jpg" class="img-responsive" alt="" longdesc=""/> (represented by rectangles) without numbers are such irrelevant interactions.</p>     <ul class="list-no-style">     <li id="uid11" label="Step&#x00A0;3:">Group similar HTTP interactions containing the target records from different traces into the same <em>equivalence class</em>. Two interactions are equivalent if they share exactly the same parameter names (possibly with different parameter values).<br/></li>     </ul>     <p>In our example, recall that Fig.&#x00A0;<a class="fig" href="#fig3">3</a> shows only a single trace for one possible input parameter, namely for Preston. Other such traces exist for other input parameters, such as &#x201C;Southampton&#x201D;, &#x201C;Walton&#x201D;, etc., where, for instance, instead of interaction <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionOne.jpg" class="img-responsive" alt="" longdesc=""/>, <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionTwo.jpg" class="img-responsive" alt="" longdesc=""/>, <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionThree.jpg" class="img-responsive" alt="" longdesc=""/>, we will have interactions <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionOne.jpg" class="img-responsive" alt="" longdesc=""/>&#x2032;, <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionTwo.jpg" class="img-responsive" alt="" longdesc=""/>&#x2032;, <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionThree.jpg" class="img-responsive" alt="" longdesc=""/>&#x2032; (for Southampton) and <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionOne.jpg" class="img-responsive" alt="" longdesc=""/>&#x2032;&#x2032;, <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionTwo.jpg" class="img-responsive" alt="" longdesc=""/>&#x2032;&#x2032;, <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionThree.jpg" class="img-responsive" alt="" longdesc=""/>&#x2032;&#x2032;, (for Walton). Step 3 now groups <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionOne.jpg" class="img-responsive" alt="" longdesc=""/>, <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionOne.jpg" class="img-responsive" alt="" longdesc=""/>&#x2032; and <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionOne.jpg" class="img-responsive" alt="" longdesc=""/>&#x2032;&#x2032; into the same equivalence class, and does the same for the other interactions.</p>     <p>Note that in our simple example, the grouping looks rather trivial. In more complex cases, the traces for different inputs may of course differ, and the exact notion of equivalence that induces the equivalence classes is important, which we shall discuss later.</p>     <ul class="list-no-style">     <li id="uid12" label="Step&#x00A0;4:">For each equivalence class <em>c</em> do:<br/></li>     <li id="uid13" label="Step&#x00A0;4.1:">Generate a <em>data selector</em> able to extract the required records (which were identified in Step&#x00A0;2). That is, generate a single data selector that, for each interaction <em>e</em> of equivalence class <em>c</em>, extracts the required record from the HTTP response of interaction <em>e</em>. If a data selector cannot be generated, skip Steps&#x00A0;4.2&#x2013;4.8 and return to Step&#x00A0;4.<br/></li>     </ul>     <p>It is very often the case that extractors for the same parameter can be found in multiple equivalence classes. For example, interaction <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionSix.jpg" class="img-responsive" alt="" longdesc=""/> needs the parameters <tt>CADC</tt> and <tt>UPSC</tt>. These are in fact obtainable from four different classes of interactions, namely <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionOne.jpg" class="img-responsive" alt="" longdesc=""/>, <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionThree.jpg" class="img-responsive" alt="" longdesc=""/>, <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionFour.jpg" class="img-responsive" alt="" longdesc=""/> and <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionFive.jpg" class="img-responsive" alt="" longdesc=""/>. Yet, interactions <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionOne.jpg" class="img-responsive" alt="" longdesc=""/> and <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionFive.jpg" class="img-responsive" alt="" longdesc=""/> contain all possible <tt>CADC</tt>&#x2019;s, and it is not possible for a selector to &#x201C;magically&#x201D; guess the right one. Thus, the selector generation fails for (the equivalence class of) interactions <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionOne.jpg" class="img-responsive" alt="" longdesc=""/> and <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionFive.jpg" class="img-responsive" alt="" longdesc=""/>, respectively. However, the selector can be easily built from interaction <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionThree.jpg" class="img-responsive" alt="" longdesc=""/> or <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionFour.jpg" class="img-responsive" alt="" longdesc=""/>, for which the selector generation succeeds. Note that for interaction <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionSix.jpg" class="img-responsive" alt="" longdesc=""/>, the algorithm generates an XPath-based data selector, as the response is HTML. In other cases, the responses are, for example, JSON-formatted, in which case it would generate JSONPath. Sometimes transformations of the extracted data are required, in which case they are recognized by our algorithm and applied.</p>     <ul class="list-no-style">     <li id="uid14" label="Step&#x00A0;4.2:">Ensure that all HTTP interactions from the equivalence class are repeatable. That is, re-execute each of the requests, and check whether the selector still selects the same data. Otherwise, skip Steps&#x00A0;4.3&#x2013;4.8 and return to Step 4.<br/></li>     <li id="uid15" label="Step&#x00A0;4.3:">For the equivalence class <em>c</em>, classify the parameters into constant and variable parameters. A constant parameter has the same value over all interactions in <em>c</em>; a variable parameter has two or more such values.<br/></li>     </ul>     <p>In our example, parameters <tt>CADC</tt> and <tt>UPSC</tt> (from the body of the HTTP POST requests) are variables, as they occur with different values in different traces (such as <tt>GBW3C1</tt>, <tt>GBW771</tt>, <tt>GBC678</tt> for <tt>CADC</tt>). At the same time there are also constant parameters, such as <tt>x-brand</tt> which is always <tt>vauxhall</tt> and <tt>x-language</tt> which is always <tt>en</tt> (from the URL&#x0027;s query string).</p>     <ul class="list-no-style">     <li id="uid16" label="Step&#x00A0;4.4:">With query probing techniques, eliminate superfluous variable parameters: those which can be omitted without affecting the data extracted from the HTTP response by the data selectors derived in Step&#x00A0;4.1.<br/></li>     </ul>     <p>In principle, the algorithm could also remove constant parameters when they are unnecessary. However, removing variable parameters is most important; this reduces the number of dependencies to be satisfied and therefore the algorithm&#x0027;s search space.</p>     <ul class="list-no-style">     <li id="uid17" label="Step&#x00A0;4.5:">Synthesize an abstract HTTP interaction, that is, an HTTP request which contains placeholders, which are to be instantiated with the values of the variable parameters. These will be the nodes of the dependency graph.<br/></li>     </ul>     <p>For our example, Fig.&#x00A0;<a class="fig" href="#fig3">3</a> shows the abstract HTTP interactions generated from the (concrete) HTTP interactions in Fig.&#x00A0;<a class="fig" href="#fig2">2</a>. For instance, the equivalence class of <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionSix.jpg" class="img-responsive" alt="" longdesc=""/> corresponds to <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineGenHttpInteractionSix.jpg" class="img-responsive" alt="" longdesc=""/>.</p>     <ul class="list-no-style">     <li id="uid18" label="Step&#x00A0;4.6:">Find variable parameters in <em>c</em> whose values come directly from the input parameters.<br/></li>     </ul>     <p>For example, the parameter city in interaction <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionTwo.jpg" class="img-responsive" alt="" longdesc=""/> can be obtained from the input. Note that in this case the parameter literally occurs in the input (i.e., we have the string &#x201C;Preston&#x201D; as a parameter value, and the exact same string &#x201C;Preston&#x201D; as the input), but in other cases transformations may be required, as in Step&#x00A0;4.1.</p>     <ul class="list-no-style">     <li id="uid19" label="Step&#x00A0;4.7:">For each variable parameter <em>v</em> that cannot be obtained from the input, go to Step&#x00A0;2 recursively. Let the target records be all parameter values of <em>v</em>. To avoid recursive loops, remove all interactions from the equivalence class of <em>c</em> from the trace. From the recursive call, we get one dependency graph <em>D<sub>v</sub>      </em> for each such variable parameter <em>v</em>, or find that no such dependency graph can be obtained for <em>v</em>.<br/></li>     </ul>     <p>For example, for abstract interaction <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineGenHttpInteractionSix.jpg" class="img-responsive" alt="" longdesc=""/>, the variable parameter <tt>CADC</tt> cannot be obtained from the input parameters. Therefore, we recursively go to Step&#x00A0;2, using the values of <tt>CADC</tt> as the target records, i.e., the set {<tt>GBW3C1</tt>, <tt>GBW771</tt>, <tt>GBC678</tt>}.</p>     <p>For this recursive call, all interactions in the equivalence class of <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionSix.jpg" class="img-responsive" alt="" longdesc=""/> are no longer considered. This recursive call returns a &#x201C;local&#x201D; dependency graph <span class="inline-equation"><span class="tex">$D_\texttt {CADC}$</span>     </span> (which will ultimately become a subgraph of the overall dependency graph constructed by the algorithm). For the variable parameter <tt>UPSC</tt>, it yields a dependency graph <span class="inline-equation"><span class="tex">$D_\texttt {UPSC}$</span>     </span>. In fact, these two graphs both have the form: <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineGenHttpInteractionTwoNOSPLIT.jpg" class="img-responsive" alt="" longdesc=""/> &#x2190; <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineGenHttpInteractionThree.jpg" class="img-responsive" alt="" longdesc=""/>.</p>     <p>Note that, through this recursion, the final wrapper is not required to keep the HTTP requests in chronological order but may rearrange them to obtain a more efficient wrapper.</p>     <ul class="list-no-style">     <li id="uid20" label="Step&#x00A0;4.8:">If for some variable parameter <em>v</em> a dependency graph <em>D<sub>v</sub>      </em> could not be computed, skip this step. Otherwise, create a new dependency graph <em>D</em> by merging all &#x201C;local&#x201D; dependency graphs <em>D<sub>v</sub>      </em>. Add to <em>D</em> the abstract interaction of <em>c</em> as well as edges from <em>c</em> to each <em>D<sub>v</sub>      </em> and <em>c</em>. Return <em>D</em>.<br/></li>     </ul>     <p>In our example, for abstract interaction <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineGenHttpInteractionSix.jpg" class="img-responsive" alt="" longdesc=""/>, we obtained the graphs <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineGenHttpInteractionTwoNOSPLIT.jpg" class="img-responsive" alt="" longdesc=""/> &#x2190; <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineGenHttpInteractionThree.jpg" class="img-responsive" alt="" longdesc=""/> in the previous step, thus the result of merging is exactly the graph <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineGenHttpInteractionTwoNOSPLIT.jpg" class="img-responsive" alt="" longdesc=""/> &#x2190; <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineGenHttpInteractionThree.jpg" class="img-responsive" alt="" longdesc=""/>. The algorithm adds to it the abstract interaction <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineGenHttpInteractionSix.jpg" class="img-responsive" alt="" longdesc=""/>, as well as two edges, from <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineGenHttpInteractionSix.jpg" class="img-responsive" alt="" longdesc=""/> to <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineGenHttpInteractionThree.jpg" class="img-responsive" alt="" longdesc=""/>, one labeled with the variable <tt>CADC</tt>, the other with <tt>UPSC</tt>. This is illustrated in Fig.&#x00A0;<a class="fig" href="#fig3">3</a>. <figure id="fig3">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186008/images/www2018-17-fig3.jpg" class="img-responsive" alt="Figure 3"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 3:</span>       <span class="figure-title">The overall dependency graph of generalised HTTP interactions for the Vauxhall example (with disconnected nodes omitted) and corresponding HTTP wrapper.</span>      </div>     </figure>     </p>     <p>This was a simplified explanation of the algorithm. As can be seen in Fig.&#x00A0;<a class="fig" href="#fig3">3</a>, other parts of the HTTP wrapper are generated apart from those discussed. However, it highlights the central concepts.</p>    </section>    <section id="sec-6">     <header>     <div class="title-info">      <h3>       <span class="section-number">3.2</span> Formal Definition of Main Concepts</h3>     </div>     </header>     <p>We now give formal definitions of some of the concepts we have informally introduced in Sec.&#x00A0;<a class="sec" href="#sec-5">3.1</a>, and which are used by the <SmallCap>FastWrap</SmallCap> algorithm. For space reasons, we cannot give a detailed description of all the data structures used.</p>     <div class="definition" id="enc1">     <Label>Definition 3.1.</Label>     <p> An <em>HTTP interaction</em> (or simply an <em>interaction</em>) represents an HTTP request-response exchange as a tuple <span class="inline-equation"><span class="tex">$(U, V, \mathcal {P}, B)$</span>      </span>, where <em>U</em> is a parametrized URL (a URL without its query part and with values of segments split by &#x201C;<tt>/</tt>&#x201D;, removed); <em>V</em> is an HTTP verb; and <span class="inline-equation"><span class="tex">$\mathcal {P}= \lbrace \rho _1, \rho _2, \dots \rbrace$</span>      </span> is a set of HTTP request parameters, each of which are pairs <em>&#x03C1;<sub>i</sub>      </em> = (<em>n<sub>i</sub>      </em>, <em>v<sub>i</sub>      </em>) specifying parameter names and values. A <em>parameter name</em> is a pair (<em>o</em>, <em>s</em>) of an <em>origin</em> and <em>origin-specific name</em>. Origin is one of &#x201C;header&#x201D;, &#x201C;path&#x201D;, &#x201C;query&#x201D;, or &#x201C;post&#x201D;. &#x00A0;&#x00A0;&#x00A0;&#x25A1;</p>     </div>     <p>An <strong>HTTP trace</strong> is a sequence of HTTP interactions observed during a single execution of a visual wrapper. It can either be collected by a proxy server or directly from the input wrapper&#x0027;s interpreter. A trace additionally contains the visual wrapper&#x0027;s input data (e.g. used for form filling) and the extracted output data. If an interaction of an HTTP trace contains all the extracted output data in its response, it is called a <em>target interaction</em>.</p>     <div class="definition" id="enc2">     <Label>Definition 3.2.</Label>     <p> An <strong>abstract HTTP interaction</strong> is an equivalence class of HTTP interactions. Two interactions are <em>equivalent</em> if they have the same <em>signatures</em> and the same <em>response content type</em>. The <em>signature</em> of an HTTP interaction is the set of parameter names of the HTTP interactions (i.e., ignoring the parameters&#x2019; values). The response content type is the MIME-type of the response (e.g., <tt>text/html</tt> or <tt>application/json</tt>).</p>     <p>A parameter name (or simply, a parameter) in an abstract HTTP interaction is either <em>constant</em> or <em>variable</em>. Let <em>V</em> be the set of all values for a parameter in the original HTTP interactions. If this set <em>V</em> contains a single element, the parameter is called <em>constant</em>, otherwise, it is called <em>variable</em>.&#x00A0;&#x00A0;&#x00A0;&#x25A1;</p>     </div>     <p>Conceptually, an abstract HTTP interaction represents an equivalence class as defined above. In the implementation, it is an HTTP interaction <em>template</em>      <span class="inline-equation"><span class="tex">$(U,V,\mathcal {P},B)$</span>     </span> with empty response body <em>B</em> and where values for variable parameters are removed from <span class="inline-equation"><span class="tex">$\mathcal {P}$</span>     </span>.</p>     <div class="definition" id="enc3">     <Label>Definition 3.3.</Label>     <p> A <strong>dependency graph</strong> is a DAG whose nodes are abstract HTTP interactions, where each edge is annotated by the tuple (<em>n</em>, <em>s</em>, <em>t</em>) where <em>n</em> is a parameter name, <em>s</em> is a <em>data selector</em> and <em>t</em> is a <em>value transformer</em>. A <em>data selector</em> is an expression (e.g., XPath, JSONPath, or regular expression) for extracting data from the HTTP response content. A <em>value transformer</em> is a function which converts the data extracted from the response of one interaction into the format required by the dependent interaction. Nodes may be labeled as <em>target interactions</em>. In addition, the graph contains special nodes <em>input</em> and <em>output</em>, each annotated with parameter names.&#x00A0;&#x00A0;&#x00A0;&#x25A1;</p>     </div>     <p>Fig.&#x00A0;<a class="fig" href="#fig3">3</a> shows a dependency graph for the Vauxhall example. It contains all abstract interactions from all available sets of traces, along with their dependencies. Some matches from Fig.&#x00A0;<a class="fig" href="#fig2">2</a> do not give rise to corresponding abstract dependencies; in particular, there are no edges between <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionSix.jpg" class="img-responsive" alt="" longdesc=""/> and <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionFive.jpg" class="img-responsive" alt="" longdesc=""/>, or <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionSix.jpg" class="img-responsive" alt="" longdesc=""/> and <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionOne.jpg" class="img-responsive" alt="" longdesc=""/>. This is due to the fact that <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionFive.jpg" class="img-responsive" alt="" longdesc=""/> and <img style="display: inline" src="http://delivery.acm.org/10.1145/3190000/3186008/images/inlineHttpInteractionOne.jpg" class="img-responsive" alt="" longdesc=""/> contain all possible values for certain parameters, and it is impossible to generate a data selector which can precisely extract only the relevant data corresponding to the given user input.</p>     <div class="definition" id="enc4">     <Label>Definition 3.4.</Label>     <p> An <strong>HTTP wrapper</strong> is a dependency graph with the following properties:</p>     <p>      <ul class="list-no-style">       <li id="list5" label="&#x2022;">It always contains a single node labeled as the target interaction.<br/></li>       <li id="list6" label="&#x2022;">All parameter dependencies are resolved. That is, for each abstract interaction in the graph, if it contains a parameter named <em>n</em>, there is an outgoing edge labeled with <em>n</em>.&#x00A0;&#x00A0;&#x00A0;&#x25A1;<br/></li>      </ul>     </p>     </div>     <p>The HTTP wrapper can be executed straightforwardly by a depth-first traversal rooted at the single target interaction which provides the output data. Each interaction is initiated after obtaining values for all its variable parameters either from the user input or from other HTTP interactions.</p>    </section>    <section id="sec-7">     <header>     <div class="title-info">      <h3>       <span class="section-number">3.3</span> The <SmallCap>FastWrap</SmallCap> Algorithm</h3>     </div>     </header>     <p>Starting by identifying the final interactions, <SmallCap>FastWrap</SmallCap> recursively constructs abstract HTTP interactions and sets their corresponding dependency arcs. This exploration of each potential dependency corresponds to a search through the implicit dependency graph for a suitable wrapper. Once a valid wrapper is found, the search terminates. Assuming one exists, one wrapper is generated for each target node. The user or external system can then select one of those according to its own objective function, based on criteria such as precision, recall, number of interactions, or runtime.</p>     <p>Alg.&#x00A0;1 shows the core algorithm at the heart of <SmallCap>FastWrap</SmallCap>, starting at Step&#x00A0;2, after having generated the traces. Given the set of recorded HTTP traces <span class="inline-equation"><span class="tex">$\mathbb {T}$</span>     </span>, the algorithm is invoked by calling <SmallCap>FindWrappers</SmallCap>(<span class="inline-equation"><span class="tex">$\mathbb {T}$</span>     </span>, <em>output</em>(<span class="inline-equation"><span class="tex">$\mathbb {T}$</span>     </span>), <em>true</em>), where <em>output</em>(<span class="inline-equation"><span class="tex">$\mathbb {T}$</span>     </span>) represents the output data for each trace. <figure id="fig4">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186008/images/www2018-17-fig4.jpg" class="img-responsive" alt="" longdesc=""/>     </figure>     </p>     <p>The <SmallCap>FastWrap</SmallCap> algorithm consists of two functions: <SmallCap>FindWrappers</SmallCap> and <SmallCap>ResolveDependencies</SmallCap>. The former finds a)&#x00A0;the final abstract interactions containing all required data (see line&#x00A0;3), executing <SmallCap>ResolveDependencies</SmallCap> in mode 1 (<em>init</em> = <em>true</em>), and b)&#x00A0;the intermediate abstract interactions (with their dependency subgraphs), each of which provides the value for a specific variable parameter (see line&#x00A0;5&#x2013;9), executing <SmallCap>ResolveDependencies</SmallCap> in mode 2 (<em>init</em> = <em>false</em>). Given a set of parameters (in mode 2, the set consists of a single parameter), <SmallCap>ResolveDependencies</SmallCap>, in turn, recursively builds an HTTP wrapper, identifying corresponding interactions with desired data in their responses and adding the appropriate dependency edges.</p>    </section>    <section id="sec-8">     <header>     <div class="title-info">      <h3>       <span class="section-number">3.4</span> Implementation Details</h3>     </div>     </header>     <p>     <SmallCap>FastWrap</SmallCap> is implemented in Python. For data and parameter value extraction, <SmallCap>FastWrap</SmallCap> implements two types of data selectors: XPath and JSONPath. It currently supports a subset of XPath&#x00A0;1.0 for extracting from HTML and XML content. This subset includes node tests, position predicates, attribute, child and descendant axes. JSONPath is an analogous query language for JSON data<a class="fn" href="#fn1" id="foot-fn1"><sup>1</sup></a>, which is used to select data from JSON and JSONP documents. All data selectors can also select sub-structures (i.e., subtrees in the case of XPath, and nested objects in the case of JSONPath) and substrings (either by position or by splitting on a specific symbol).</p>     <p>     <SmallCap>FastWrap</SmallCap> supports six basic types of value transformations, which were introduced based on the analysis of various real-world sites, independent from the dataset evaluated in this experiment.</p>     <ul class="list-no-style">     <li id="list7" label="&#x2022;">Removal of double, leading, and trailing spaces.<br/></li>     <li id="list8" label="&#x2022;">Extracting substrings and concatenation with constant strings.<br/></li>     <li id="list9" label="&#x2022;">Space conversions such as space-to-plus/minus symbols.<br/></li>     <li id="list10" label="&#x2022;">URL en-(de-)coding with newer&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"       href="#BibPLXBIB0005">5</a>] and older&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"       href="#BibPLXBIB0006">6</a>] standards.<br/></li>     <li id="list11" label="&#x2022;">Replacing HTML escape symbols.<br/></li>     <li id="list12" label="&#x2022;">Changing the precision of real numbers.<br/></li>     </ul>     <p>We also support two specific composite transformations:</p>     <ul class="list-no-style">     <li id="list13" label="&#x2022;">Space-to-plus followed by URL encoding.<br/></li>     <li id="list14" label="&#x2022;">URL encoding, followed by string concatenation.<br/></li>     </ul>    </section>   </section>   <section id="sec-9">    <header>     <div class="title-info">     <h2>      <span class="section-number">4</span> Evaluation</h2>     </div>    </header>    <p>In this section, we conduct an extensive evaluation of the <SmallCap>FastWrap</SmallCap> approach on different types of websites. For the experiments we implemented the <SmallCap>FastWrap</SmallCap> system in Python. It executes visual wrappers and analyses HTTP traces to build corresponding HTTP wrappers. We selected OXPath, a state-of-the-art web data extraction system, as a visual wrapper system for our experiments.</p>    <section id="sec-10">     <header>     <div class="title-info">      <h3>       <span class="section-number">4.1</span> Choice of Test Cases</h3>     </div>     </header>     <p>In total, we considered 130 wrappers, out of which 101 (78%) were compliant (according to the definition from Sec.&#x00A0;<a class="sec" href="#sec-3">2</a>). 45% of the 29 rejected wrappers had unreproducible interactions carrying relevant data, and the other 55% invoked the Google Maps API to obtain necessary data (in particular, to obtain geographic coordinates for the location provided as user input). The compliant wrappers (78% of the original 130) span a variety of application domains and feature various degrees of difficulty. In particular, we consider (A) more complex examples involving web form interaction and (B) simpler cases without web form interaction.</p>     <p>     <strong>Type A test cases</strong>. Type (A)&#x00A0;is used to test the success rate of our approach in converting wrappers interacting with web forms with different input parameters (which is necessary for Deep Web data extraction) into their HTTP wrapper counterparts. For this class of test cases, we tested (1)&#x00A0;12 OXPath wrappers for US restaurant chains from the DIADEM dataset&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0017">17</a>]; (2)&#x00A0;11 OXPath wrappers for well-known car dealership websites; (3)&#x00A0;12 OXPath wrappers for popular websites, mostly from the retail domain, with two or three simulated user interactions (e.g., <tt>click</tt> and <tt>type</tt>), each of which triggers HTTP requests (often via AJAX calls) to deliver the content necessary for subsequent interactions (we call this category A-multisteppers); (4)&#x00A0;25 OXPath wrappers for randomly chosen web pages with web forms (referred to as A-RND). The random sites were chosen by randomly sampling URLs from the Common Crawl&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0010">10</a>] search index dataset, which includes around 3 billion web pages. As there were no existing wrappers for classes (2), (3) and (4), new OXPath wrappers were manually written. Wrappers from category (A) are typical search-based wrappers, which fill web forms and extract data from the first result page (which may involve AJAX requests to load additional data). Interestingly, test set (iv), i.e., random URLs turned out to be much simpler and easier to deal with than categories (i)&#x2013;(iii), which showed rather homogeneous behavior. We thus group (i), (ii) and (iii) into the single class A-RCM (restaurants, cars, and multisteppers). Hence class (A) consists of two subclasses: A-RCM and A-RND.</p>     <p>     <strong>Type B test cases</strong>. Type&#x00A0;(B) comprises 41 additional OXPath wrappers for US restaurant chains from the DIADEM dataset. In contrast to the restaurant wrappers from set (i), these wrappers do not require filling web forms and do not take input parameters from a user. Thus, for this class of test cases it is enough to analyze a single HTTP trace to identify any target HTTP interactions. This approach is applicable to any wrapper which uses a single, linear navigation and does not depend on input data, even if that navigation requires multiple steps or page downloads.</p>    </section>    <section id="sec-11">     <header>     <div class="title-info">      <h3>       <span class="section-number">4.2</span> Experimental Setup</h3>     </div>     </header>     <p>Each experiment consists of two phases: (1) execution of the visual wrapper and (2) generation of the HTTP wrapper.</p>     <p>For phase 1, OXPath was executed with images disabled. It was extended with a proxy server module to listen to HTTP request-response exchanges and record them as HTTP traces, including input parameters and extracted data. Each wrapper of type (A) (i.e., A-RCM and A-RND) was executed eight times with different input parameters selected manually. Wrappers of type (B) do not require input and were executed once each.</p>     <p>In phase 2, the stored HTTP traces from phase 1 were used to induce an HTTP wrapper and test it. Wrappers of type (A) used five of the eight traces for induction (i.e., building an HTTP wrapper). The three remaining traces are used to evaluate the correctness and performance of the generated HTTP wrapper. Wrappers of type (B) were induced and evaluated on a single trace from phase 1.</p>    </section>    <section id="sec-12">     <header>     <div class="title-info">      <h3>       <span class="section-number">4.3</span> Experimental Results</h3>     </div>     </header>     <p>In this section, we will first discuss the overall success rate (lower part of Fig.&#x00A0;<a class="fig" href="#fig5">4</a>) of the <SmallCap>FastWrap</SmallCap> approach. Then we compare the performance of the generated output wrappers to the performance of the original input wrappers (Tab.&#x00A0;<a class="tbl" href="#tab1">1</a>). Finally, we discuss the characteristics of the generated wrappers in more detail (Tab.&#x00A0;<a class="tbl" href="#tab2">2</a>). Sec.&#x00A0;<a class="sec" href="#sec-13">4.4</a> presents a detailed failure analysis which allows us to draw important conclusions for necessary future research to bring this approach to industrial strength (upper part of Fig.&#x00A0;<a class="fig" href="#fig5">4</a>).</p>     <div class="table-responsive" id="tab1">     <div class="table-caption">      <span class="table-number">Table 1:</span>      <span class="table-title">Comparative analysis of OXPath and HTTP wrappers.</span>     </div>     <table class="table">      <thead>       <tr>        <th style="text-align:left;"/>        <th style="text-align:center;" colspan="3">OXPath wrappers<hr/>        </th>        <th style="text-align:center;" colspan="3">HTTP wrappers<hr/>        </th>        <th style="text-align:center;" colspan="3">Comparison<hr/>        </th>       </tr>       <tr>        <th style="text-align:left;">Wrappers</th>        <th style="text-align:center;">Time&#x2020; (ms)</th>        <th style="text-align:center;">Data&#x2021; (KB)</th>        <th style="text-align:center;">Interactions</th>        <th style="text-align:center;">Time (ms)</th>        <th style="text-align:center;">Data (KB)</th>        <th style="text-align:center;">Interactions</th>        <th style="text-align:center;">Time (%)</th>        <th style="text-align:center;">Data (%)</th>        <th style="text-align:center;">Interactions (%)</th>       </tr>      </thead>      <tbody>       <tr>        <td style="text-align:left;">A-RCM</td>        <td style="text-align:center;">33780</td>        <td style="text-align:center;">4151</td>        <td style="text-align:center;">90.0</td>        <td style="text-align:center;">1145</td>        <td style="text-align:center;">134</td>        <td style="text-align:center;">1.5</td>        <td style="text-align:center;">3.4</td>        <td style="text-align:center;">3.2</td>        <td style="text-align:center;">1.7</td>       </tr>       <tr>        <td style="text-align:left;">A-RND</td>        <td style="text-align:center;">22299</td>        <td style="text-align:center;">2839</td>        <td style="text-align:center;">79.7</td>        <td style="text-align:center;">1314</td>        <td style="text-align:center;">76</td>        <td style="text-align:center;">1.0</td>        <td style="text-align:center;">5.9</td>        <td style="text-align:center;">2.7</td>        <td style="text-align:center;">1.3</td>       </tr>       <tr>        <td style="text-align:left;">B-type</td>        <td style="text-align:center;">23879</td>        <td style="text-align:center;">1523</td>        <td style="text-align:center;">38.6</td>        <td style="text-align:center;">837</td>        <td style="text-align:center;">69</td>        <td style="text-align:center;">1.0</td>        <td style="text-align:center;">3.5</td>        <td style="text-align:center;">4.6</td>        <td style="text-align:center;">2.6</td>       </tr>       <tr>        <td style="text-align:left;">All</td>        <td style="text-align:center;">26917</td>        <td style="text-align:center;">3013</td>        <td style="text-align:center;">76.9</td>        <td style="text-align:center;">1139</td>        <td style="text-align:center;">96</td>        <td style="text-align:center;">1.1</td>        <td style="text-align:center;">4.2</td>        <td style="text-align:center;">3.2</td>        <td style="text-align:center;">1.4</td>       </tr>      </tbody>      <tfoot>       <tr>        <td colspan="10">&#x2020; without browser initialization without loading images</td>       </tr>      </tfoot>     </table>     </div>     <div class="table-responsive" id="tab2">     <div class="table-caption">      <span class="table-number">Table 2:</span>      <span class="table-title">Characteristics of generated HTTP wrappers.</span>     </div>     <table class="table">      <thead>       <tr>        <th style="text-align:left;">Wrappers</th>        <th style="text-align:center;">Gener-ation<sup>1</sup> (s)</th>        <th style="text-align:center;">Content formats (%)</th>        <th style="text-align:center;">Value transformers<sup>2</sup> (%)</th>        <th style="text-align:center;">Ignored variable parameters (%)</th>        <th style="text-align:center;">Stably correct models (%)</th>        <th style="text-align:center;">Successful evaluations (%)</th>       </tr>      </thead>      <tbody>       <tr>        <td style="text-align:left;">A-RCM</td>        <td style="text-align:center;">137.9</td>        <td style="text-align:center;">JSON: 52; HTML: 45; XML: 3</td>        <td style="text-align:center;">        <strong>n</strong>: 77; <strong>u</strong>: 14; <strong>p</strong>: 6; <strong>s</strong>: 3</td>        <td style="text-align:center;">16.7</td>        <td style="text-align:center;">100.0</td>        <td style="text-align:center;">100.0</td>       </tr>       <tr>        <td style="text-align:left;">A-RND</td>        <td style="text-align:center;">33.1</td>        <td style="text-align:center;">HTML: 91; JSON: 9</td>        <td style="text-align:center;">        <strong>n</strong>: 52; <strong>u</strong>: 33; <strong>s</strong>: 10; <strong>c</strong>: 5</td>        <td style="text-align:center;">8.7</td>        <td style="text-align:center;">90.9</td>        <td style="text-align:center;">97.0</td>       </tr>       <tr>        <td style="text-align:left;">B-type</td>        <td style="text-align:center;">2.1</td>        <td style="text-align:center;">HTML: 92; JSON: 5; XML: 3</td>        <td style="text-align:center;">[c]&#x2014;</td>        <td style="text-align:center;">0.0</td>        <td style="text-align:center;">100.0</td>        <td style="text-align:center;">100.0</td>       </tr>       <tr>        <td style="text-align:left;">All</td>        <td style="text-align:center;">44.9</td>        <td style="text-align:center;">HTML: 76; JSON: 22 XML: 2</td>        <td style="text-align:center;">        <strong>n</strong>: 68; <strong>u</strong>: 21; <strong>s</strong>: 5; <strong>p</strong>: 4; <strong>c</strong>: 2</td>        <td style="text-align:center;">13.8</td>        <td style="text-align:center;">94.9</td>        <td style="text-align:center;">98.2</td>       </tr>      </tbody>      <tfoot>       <tr>        <td colspan="7">        <sup>1</sup> HTTP wrapper generation from HTTP traces        </td>       </tr>       <tr>        <td colspan="7">        <sup>2</sup>         <strong>n</strong> &#x2013; no transformation, <strong>u</strong> &#x2013; URL en-(de-)code, <strong>p</strong> &#x2013; precision, <strong>s</strong> &#x2013; substring, <strong>c</strong> &#x2013; composite        </td>       </tr>      </tfoot>     </table>     </div>     <p>     <strong>Overall results</strong>. Overall, our experimental evaluation showed a high success rate of 79.2%. However, interestingly, it demonstrated quite different performance on the test sets. In particular, HTTP wrappers were successfully generated for 48.6% of A-RCM wrappers, 96.0% for A-RND, and 95.1% for B-type (lower part of Fig.&#x00A0;<a class="fig" href="#fig5">4</a>, the rest of the figure will be discussed later). The average time required by <SmallCap>FastWrap</SmallCap> to generate a wrapper is 44.9 seconds. For the B-type wrappers, which is the simpler category, the average is 2.1 seconds. Due to the larger number of interactions, and in particular more complex data structures in the HTTP responses (and thus in the traces), together with a somewhat larger data volume, the average generation time is 137.9 seconds for A-RCM. The wrapper generation time is shown in Tab.&#x00A0;2, whose other columns will be discussed further below.</p> <figure id="fig5">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186008/images/www2018-17-fig5.jpg" class="img-responsive" alt="Figure 4"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 4:</span>       <span class="figure-title">Overall results.</span>      </div>     </figure>     <p>     <strong>Performance comparison</strong>. As can be seen in Tab.&#x00A0;<a class="tbl" href="#tab1">1</a>, all generated HTTP wrappers considerably outperform the respective OXPath wrappers on all test sets. The resource usage of the generated wrappers was orders of magnitude lower, which confirms our initial expectation that &#x201C;cutting off&#x201D; the browser would lead to a significant benefit. The average runtime of the HTTP wrappers is only 4.2% of the runtime of their visual wrapper counterparts. The generated HTTP wrappers use only 3.2% of the data traffic, and perform just 1.4% of the HTTP interactions. Interestingly, while the number of HTTP interactions in the test cases A-RND and B-type is always 1 (which is 1.3% resp. 2.6% of the original number of interactions), for test cases A-RCM it is 1.5 (1.7%) on average. This mainly stems from the subclass A-multisteppers, and in particular eight wrappers, seven of which require two interactions in our HTTP wrapper, and one which requires three (namely our running example, Vauxhall). In these cases, multiple interactions are required due to additional transformations that are not computed on the client side, because they need data from the server or require server-side functionality, such as a database lookup. This is, for example, the case for lexus.fr, where it is necessary to transform input postcodes to geographic coordinates. For our running example Vauxhall, the wrapper needs to transform location names to the variables <tt>CADC</tt> and <tt>UPSC</tt> (as mentioned before) representing car dealerships.</p>     <p>     <strong>Detailed analysis of relevant wrapper features</strong>. In Tab.&#x00A0;<a class="tbl" href="#tab2">2</a> we analyze interesting features of the generated HTTP wrappers. We classify a specific evaluation test as <em>successful</em> if both precision and recall are 100%, i.e., the data extracted by the HTTP wrapper is identical to the data extracted by the input wrapper. We say that a wrapper is <strong>stably correct</strong>, if it successfully passes all tests of phase 2 (see Sec.&#x00A0;<a class="sec" href="#sec-11">4.2</a>). As we see, all wrappers in class A-RCM and B-type are stably correct. For A-RND, we see that 90.9% are stably correct and in total 97% of individual tests are passed. The reason for this is related to deviations in HTML structures, which require either richer test sets or more powerful data selectors. According to our evaluation, 13.8% of variable parameters of HTTP interactions can be omitted without affecting the quality of data extraction. Interestingly, many web applications actively use such parameters (16.7% for A-RCM), which indicates the importance of query probing for identifying an irrelevant set of parameters to reduce the dependency graph and increase the chance of resolving all dependencies. It is also worth noting that A-RCM&#x0027;s web applications use JSON (52% of content processed by the HTTP wrappers) to deliver relevant data considerably more often than web applications from other categories which, in turn, more often use HTML snippets (91% for A-RND and 92% for B-type). In Tab.&#x00A0;<a class="tbl" href="#tab2">2</a>, we omit value transformations applied to the output data as they are always related to removing redundant spaces. For input and intermediate parameters for HTTP interactions, frequently no transformation (68%), or only URL encoding-decoding (21%) are required for transforming values between requests.</p>    </section>    <section id="sec-13">     <header>     <div class="title-info">      <h3>       <span class="section-number">4.4</span> Discussion and Lessons Learned</h3>     </div>     </header>     <p>Our experiments confirm that our approach is feasible. Beyond the criteria mentioned in Sec.&#x00A0;<a class="sec" href="#sec-3">2</a> for compliant wrappers, we can identify further critical points where future research is needed. The overall numbers are an indicator that the approach presented in this paper is principally feasible. Still, it is useful to try to understand what the reasons for the 20.8% failure rate are (see the fourth bar in Figure&#x00A0;<a class="fig" href="#fig5">4</a>). As illustrated in Fig.&#x00A0;<a class="fig" href="#fig5">4</a>, most of the issues are encountered in A-RCM with wrappers written for more complex web applications (51.4% of the A-RCM wrappers could not be translated). There are three main causes for the failures: 1)&#x00A0;composite parameters, 2)&#x00A0;more data extracted, 3)&#x00A0;heterogeneous content.</p>     <p>     <strong>Composite parameters.</strong> This problem covers 8.9% of All test cases and 25.7% of A-RCM. A variable parameter (i.e., a parameter of the abstract HTTP request) can be a string-serialization of multiple values. It can represent a tuple (as in &#x201C;<tt>lat|long|locality</tt>&#x201D;), an array (e.g. &#x201C;<tt>lat-long,lat-long,...</tt>&#x201D; representing a set of geometric points), or a complex structure (such as a GET parameter containing a URL-encoded XML document). Furthermore, the structure of the value may not be obvious from its string serialization without domain knowledge; for example if the value is an address constructed from different attributes, such as &#x201C;72-353 Highway 111&#x201D;. Thus, composite parameters might require the analysis of regularities in the string-serialized representation, and application of domain specific methods, or generic techniques such as NLP.</p>     <p>     <strong>More data extracted.</strong> The second common cause of failure (6.9% of All test cases or 20% of A-RCM) is related to extracting a superset of the data extracted by the original wrapper. For example, a car search website may return car models from all production years, while a client-side JavaScript filter may restrict the models shown to a user to those of the current year. Another example is that for design reasons (so as not to overwhelm the user with too many results), a website may choose to display only a limited number of results, while the data received by the client actually contains much more data. Another example we encountered is from the flight search domain, in which JavaScript filters some results returned from the server before displaying them on a web page. The filter analyses attributes of the search result to eliminate those with lower scores, reflecting their trustworthiness or relevance. This also motivates further research into the identification of such JavaScript filters and methods to mimic them. Both machine learning and program analysis may be promising approaches. Note that for certain applications, returning more data is in fact a benefit.</p>     <p>     <strong>Heterogeneous content.</strong> Multiple levels of embedding of different content types were regularly encountered in our test cases, i.e., in 5% of All, 5.7% of A-RCM, 4% of A-RND, and 4.9% of B-type. For example, a typical website will return an HTML, JSON, or XML document, which is no problem for our approach; whereas some sites use a single response which is a snippet of HTML, where the desired data is embedded within a serialized JSON object embedded within JavaScript source code within the HTML. Desired data can also be encoded into a string-serialized snippet of HTML represented as a value in a JSON object.</p>     <p>We believe that these problems can be largely overcome by further targeted research and will give further details in Sec.&#x00A0;<a class="sec" href="#sec-15">6</a>. Note that interestingly, if we had excluded composite parameters a priori, then the success rate would grow to 87% of the compliant cases. This shows the huge potential of improvements further research could bring here.</p>    </section>   </section>   <section id="sec-14">    <header>     <div class="title-info">     <h2>      <span class="section-number">5</span> Related Work</h2>     </div>    </header>    <p>To the best of our knowledge, this is the first work that specifically addresses the problem of automatically transforming visual wrappers into HTTP wrappers, other than a different prototype tool described in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0039">39</a>]. However, there are some closely related areas that serve to inform our approach or delimit its goals.</p>    <p>Most supervised web data extraction tools provide visual interfaces for the definition of visual wrappers ([<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0015">15</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0019">19</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0021">21</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0025">25</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0035">35</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0045">45</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0046">46</a>]). Such wrappers are then executed typically using a live browser. For this work, we focus on visual wrappers written in OXPath, as it outperforms previous commercial and open source systems in both time and memory&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0018">18</a>].</p>    <p>Web automation and some AJAX crawlers share the simulation of user interaction with visual wrappers. In many web automation systems, this simulation is to test the correct behavior of a web application&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0002">2</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0008">8</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0028">28</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0031">31</a>]. Our approach would be applicable to &#x201C;test scripts&#x201D; produced by such systems and could be used to verify that the backend produces the intended results. This can be achieved by converting tests into their HTTP counterparts. However, as our intent is to <em>avoid</em> interaction with the application&#x0027;s frontend, it is obviously not suited to test that part of the application. In contrast, when considering crawling of heavily scripted AJAX sites, our approach could be used for finding shortcuts to specific nodes in the state-flow graphs as produced by such AJAX crawlers [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0011">11</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0012">12</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0034">34</a>].</p>    <p>The techniques and aims presented in this paper share some similarity with techniques for the analysis of HTTP logs&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0047">47</a>] or click streams&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0032">32</a>]. However, that similarity is only on the surface, as we focus on observing one or more interactions with a single backend, without any control over that backend. In contrast, HTTP log analysis usually assumes many users accessing a single, instrumented backend. Also, as far as we are aware, none of the works on HTTP log analysis have considered the problem of discovering the underlying backend API (as it is usually assumed to be known).</p>   </section>   <section id="sec-15">    <header>     <div class="title-info">     <h2>      <span class="section-number">6</span> Directions for Further Research</h2>     </div>    </header>    <p>The main goal of future work is certainly to increase the number of cases where a visual wrapper can be automatically transformed into an HTTP wrapper. Through our analysis we now know better what needs to be done to achieve this goal. We now re-examine the cases that we excluded upfront in Sec.&#x00A0;<a class="sec" href="#sec-3">2</a> as well as those failures observed in Sec.&#x00A0;<a class="sec" href="#sec-13">4.4</a> to formulate directions for future research.</p>    <p>     <strong>Shallow JavaScript analysis</strong>. Value transformations of parameters transferred between HTTP interactions may vary from simple text transformations (e.g., merging two strings into one) to complex functions. In the case of complex transformations, which go beyond basic numerical or string-based changes, shallow JavaScript analysis is required (e.g., knowledge-based, heuristic methods for variable and value tracing). These transformations can often be automatically induced, however in certain cases partial execution of relevant pieces of JavaScript code is actually necessary. To identify relevant pieces of JavaScript code transforming values, approaches from the field of concolic testing (e.g., Jalangi&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0043">43</a>]) can be used.</p>    <p>     <strong>Composite parameter handling</strong>. Our evaluation in Sec.&#x00A0;<a class="sec" href="#sec-9">4</a> demonstrated the importance of being able to analyze composite parameters of HTTP requests. One approach to handle them is to parse their structures directly. Another is to identify the atomic values contained in complex parameters by the analysis of discrepancies between HTTP interactions of the same equivalence class. Techniques from data matching&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0007">7</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0022">22</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0023">23</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0044">44</a>] may apply.</p>    <p>     <strong>Heterogeneous content</strong> (e.g., mixtures of HTML, XML, JSON). This poses yet another extraction problem related to locating identified parameters within HTTP replies. There are various existing approaches from the web data extraction and information extraction areas. However, they target specific formats, such as XML, HTML&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0009">9</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0014">14</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0020">20</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0029">29</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0037">37</a>] and plain or formatted texts&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0027">27</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0041">41</a>]. Thus, a development of a hybrid approach is necessary for dealing with multiple formats at once, creating appropriate <em>heterogeneous data extractors</em>. Moreover, in some cases, data is actually contained inside of JavaScript code. This needs further research.</p>    <p>     <strong>Non-reproducible interactions.</strong> Sometimes interactions cannot be reproduced due to the session-ids or access tokens being required. Apart from shallow JavaScript analysis&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0038">38</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0040">40</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0042">42</a>], research in the area of web automation may contribute to automatically obtain such tokens on behalf of a user&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0002">2</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0031">31</a>].</p>    <p>     <strong>HTTP interactions with varying sets of parameters.</strong> Sometimes, alike HTTP interactions from different executions of a visual wrapper can have different sets of variable parameters. We frequently faced this problem with the Google Maps service. This requires more advanced approaches to identifying similar HTTP requests that are able to deal with such a high degree of variability.</p>    <p>     <strong>Multiple target pages and complex navigation scenarios.</strong> Allowing extraction from different web pages might require the analysis of linear navigation paths through the result pages or more complex navigation patterns. Examples of such difficult cases are conditional navigation, as well as unbounded loops in navigation for which more research is needed.</p>    <p>     <strong>Wrapper optimization.</strong> Identification of the most efficient and robust wrapper can also be represented as an optimization problem, minimizing the overall cost of the wrapper generation and execution processes. This has potential connections to web service composition&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0004">4</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0030">30</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0048">48</a>].</p>   </section>  </section>  <section class="back-matter">   <section id="ref-001">    <header>     <div class="title-info">     <h2 class="page-brake-head">REFERENCES</h2>     </div>    </header>    <ul class="bibUl">     <li id="BibPLXBIB0001" label="[1]">Shaon Barman, Sarah Chasins, Rastislav Bod&#x00ED;k, and Sumit Gulwani. 2016. Ringer: web automation by demonstration. In <em>      <em>Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications, OOPSLA 2016, part of SPLASH 2016, Amsterdam, The Netherlands, October 30 - November 4, 2016</em>     </em>. 748&#x2013;764.</li>     <li id="BibPLXBIB0002" label="[2]">Alberto Bartoli, Eric Medvet, and Marco Mauri. 2012. Recording and replaying navigations on AJAX web sites. In <em>      <em>International Conference on Web Engineering</em>     </em>. Springer, 370&#x2013;377.</li>     <li id="BibPLXBIB0003" label="[3]">Robert Baumgartner, Oliver Fr&#x00F6;lich, and Georg Gottlob. 2007. The Lixto Systems Applications in Business Intelligence and Semantic Web. In <em>      <em>The Semantic Web: Research and Applications, 4th European Semantic Web Conference, ESWC 2007, Innsbruck, Austria, June 3-7, 2007, Proceedings</em>     </em>. 16&#x2013;26.</li>     <li id="BibPLXBIB0004" label="[4]">Amina Bekkouche, Sidi Mohammed, Benslimane Marianne, Chouki Tibermacine, Fethallah Hadjila, and Mohammed Merzoug. 2017. QoS-aware optimal and automated semantic web service composition with user&#x0027;s constraints. <em>      <em>Service Oriented Computing and Applications</em>     </em>(2017), 1&#x2013;19.</li>     <li id="BibPLXBIB0005" label="[5]">Tim Berners-Lee, Roy Fielding, and Larry Masinter. 2005. <em>      <em>Uniform Resource Identifier (URI): Generic Syntax</em>     </em>. StandardRFC 3986. The Internet Society (ISOC) / Internet Engineering Task Force (IETF).</li>     <li id="BibPLXBIB0006" label="[6]">Tim Berners-Lee, Larry Masinter, and M. McCahill. 1994. <em>      <em>Uniform Resource Identifier (URI)</em>     </em>. StandardRFC 1738. Network Working Group.</li>     <li id="BibPLXBIB0007" label="[7]">Philip&#x00A0;A. Bernstein, Jayant Madhavan, and Erhard Rahm. 2011. Generic Schema Matching, Ten Years Later. <em>      <em>PVLDB</em>     </em>4, 11 (2011), 695&#x2013;701.</li>     <li id="BibPLXBIB0008" label="[8]">Jeffrey&#x00A0;P. Bigham, T. Lau, and J. Nichols. 2009. Trailblazer: enabling blind users to blaze trails through the web. In <em>      <em>Proceedings of the 13th international conference on Intelligent user interfaces</em>     </em>, Vol.&#x00A0;09. ACM, 177&#x2013;186.</li>     <li id="BibPLXBIB0009" label="[9]">Michal Ceresna. 2005. <em>Supervised Learning of Wrappers from Structured Data Sources</em>. PhD Thesis. Vienna University of Technology.</li>     <li id="BibPLXBIB0010" label="[10]">CommonCrawl2018. Common Crawl. (2018). <a class="link-inline force-break" href="http://commoncrawl.org/" target="_blank">http://commoncrawl.org/</a> Retrieved Feb 14, 2018 from</li>     <li id="BibPLXBIB0011" label="[11]">Mustafa&#x00A0;Emre Dincturk, Suryakant Choudhary, Gregor von Bochmann, Guy-Vincent Jourdan, and Iosif&#x00A0;Viorel Onut. 2012. A statistical approach for efficient crawling of rich internet applications. In <em>      <em>Web Engineering</em>     </em>, Marco Brambilla, Takehiro Tokuda, and Robert Tolksdorf (Eds.). Springer, Berlin, Heidelberg, 362&#x2013;369.</li>     <li id="BibPLXBIB0012" label="[12]">Cristian Duda, Gianni Frey, Donald Kossmann, Reto Matter, and Chong Zhou. 2009. AJAX Crawl: Making AJAX applications searchable. In <em>      <em>Proceeding of the IEEE 25th International Conference on Data Engineering (ICDE &#x2019;09)</em>     </em>. IEEE, Washington, DC, USA, 78&#x2013;89.</li>     <li id="BibPLXBIB0013" label="[13]">Ruslan&#x00A0;R. Fayzrakhmanov. 2015. Models and Approaches for Web Information Extraction and Web Page Understanding. In <em>      <em>The Evolution of the Internet in the Business Sector: Web 1.0 to Web 3.0</em>     </em>, Pedro Isa&#x00ED;as, Piet Kommers, and Tomayess Issa (Eds.). IGI Global, Chapter&#x00A0;2, 25&#x2013;50.</li>     <li id="BibPLXBIB0014" label="[14]">Emilio Ferrara, Pasquale De Meo, Giacomo Fiumara, and Robert Baumgartner. 2014. Web data extraction, applications and techniques: A survey. <em>      <em>Knowledge-Based Systems</em>     </em>70 (2014), 301&#x2013;323.</li>     <li id="BibPLXBIB0015" label="[15]">FMiner2018. FMiner. (2018). <a class="link-inline force-break" href="http://www.fminer.com" target="_blank">http://www.fminer.com</a> Retrieved Feb 14, 2018 from</li>     <li id="BibPLXBIB0016" label="[16]">Tim Furche, Georg Gottlob, Giovanni Grasso, Omer Gunes, Xiaonan Guo, Andrey Kravchenko, Giorgio Orsi, Christian Schallhart, Andrew Sellers, and Cheng Wang. 2012. DIADEM: domain-centric, intelligent, automated data extraction methodology. In <em>      <em>Proceedings of the 21st International Conference Companion on World Wide Web (WWW &#x2019;12 Companion)</em>     </em>. ACM, New York, NY, USA, 267&#x2013;270.</li>     <li id="BibPLXBIB0017" label="[17]">Tim Furche, Georg Gottlob, Giovanni Grasso, Xiaonan Guo, Giorgio Orsi, Christian Schallhart, and Cheng Wang. 2014. DIADEM: Thousands of Websites to a Single Database. <em>      <em>PVLDB</em>     </em>7, 14 (2014), 1845&#x2013;1856.</li>     <li id="BibPLXBIB0018" label="[18]">Tim Furche, Georg Gottlob, Giovanni Grasso, Christian Schallhart, and Andrew Sellers. 2013. OXPath: A language for scalable data extraction, automation, and crawling on the deep web. <em>      <em>VLDB Journal</em>     </em>22, 1 (2013), 47&#x2013;72.</li>     <li id="BibPLXBIB0019" label="[19]">Georg Gottlob, Christoph Koch, Robert Baumgartner, Marcus Herzog, and Sergio Flesca. 2004. The Lixto Data Extraction Project: Back and Forth Between Theory and Practice. In <em>      <em>Proceedings of the Twenty-third ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems</em>     </em>(PODS &#x2019;04). ACM, New York, NY, USA, 1&#x2013;12.</li>     <li id="BibPLXBIB0020" label="[20]">Andrew&#x00A0;W. Hogue and David&#x00A0;R. Karger. 2005. Thresher: automating the unwrapping of semantic content from the World Wide Web. In <em>      <em>Proceedings of the 14th international conference on World Wide Web, WWW 2005, Chiba, Japan, May 10-14, 2005</em>     </em>. 86&#x2013;95.</li>     <li id="BibPLXBIB0021" label="[21]">iMacros2018. iMacros. (2018). <a class="link-inline force-break" href="http://imacros.net" target="_blank">http://imacros.net</a> Retrieved Feb 14, 2018 from</li>     <li id="BibPLXBIB0022" label="[22]">Ekaterini Ioannou, Nataliya Rassadko, and Yannis Velegrakis. 2013. On Generating Benchmark Data for Entity Matching. <em>      <em>J. Data Semantics</em>     </em>2, 1 (2013), 37&#x2013;56.</li>     <li id="BibPLXBIB0023" label="[23]">Hanna K&#x00F6;pcke and Erhard Rahm. 2010. Frameworks for entity matching: A comparison. <em>      <em>Data and Knowledge Engineering</em>     </em>69, 2 (2010), 197&#x2013;210.</li>     <li id="BibPLXBIB0024" label="[24]">Iraklis Kordomatis, Christoph Herzog, Ruslan&#x00A0;R. Fayzrakhmanov, Bernhard Kr&#x00FC;pl-Sypien, Wolfgang Holzinger, and Robert Baumgartner. 2013. Web object identification for web automation and meta-search. In <em>      <em>3rd International Conference on Web Intelligence, Mining and Semantics, WIMS &#x2019;13, Madrid, Spain, June 12-14, 2013</em>     </em>. 13.</li>     <li id="BibPLXBIB0025" label="[25]">Jochen Kranzdorf, Andrew Sellers, Giovanni Grasso, Christian Schallhart, and Tim Furche. 2012. Visual OXPath: Robust Wrapping by Example. In <em>      <em>Proc. of WWW</em>     </em>. 369&#x2013;372.</li>     <li id="BibPLXBIB0026" label="[26]">Bernhard Kr&#x00FC;pl-Sypien, Ruslan&#x00A0;R. Fayzrakhmanov, Wolfgang Holzinger, Mathias Panzenb&#x00F6;ck, and Robert Baumgartner. 2011. A versatile model for web page representation, information extraction and content re-packaging. In <em>      <em>Proceedings of the 2011 ACM Symposium on Document Engineering, Mountain View, CA, USA, September 19-22, 2011</em>     </em>. 129&#x2013;138.</li>     <li id="BibPLXBIB0027" label="[27]">Nicholas Kushmerick. 2003. Finite-State Approaches to Web Information Extraction. <em>      <em>Information Extraction in the Web Era</em>     </em>2700 (2003), 77&#x2013;91.</li>     <li id="BibPLXBIB0028" label="[28]">Tessa Lau, Juli&#x00E1;n Cerruti, Guillermo Manzato, Mateo Bengualid, Jeffrey Bigham, and Jeffrey Nichols. 2010. A conversational interface to web automation. <em>      <em>Proceedings of the 23nd annual ACM symposium on User interface software and technology</em>     </em> (2010), 229&#x2013;238.</li>     <li id="BibPLXBIB0029" label="[29]">A. Lemay, J. Niehren, and R. Gilleron. 2006. Learning n-Ary Node Selecting Tree Transducers from Completely Annotated Examples. <em>      <em>International Colloquium on Grammatical Inference (ICGI 2006)</em>     </em>4201 (2006), 253&#x2013;267.</li>     <li id="BibPLXBIB0030" label="[30]">Angel&#x00A0;Lagares Lemos, Florian Daniel, and Boualem Benatallah. 2016. Web Service Composition: A Survey of Techniques and Tools. <em>      <em>ACM Comput. Surv.</em>     </em>48, 3 (2016), 33:1&#x2013;33:41.</li>     <li id="BibPLXBIB0031" label="[31]">Gilly Leshed, Eben&#x00A0;M. Haber, Tara Matthews, and Tessa&#x00A0;A. Lau. 2008. CoScripter: automating &#x0026; sharing how-to knowledge in the enterprise. In <em>      <em>Proceedings of the 2008 Conference on Human Factors in Computing Systems, CHI 2008, 2008, Florence, Italy, April 5-10, 2008</em>     </em>. 1719&#x2013;1728.</li>     <li id="BibPLXBIB0032" label="[32]">Jun Liu, Cheng Fang, and Nirwan Ansari. 2014. Identifying user clicks based on dependency graph. <em>      <em>2014 23rd Wireless and Optical Communication Conference, WOCC 2014</em>     </em> (2014).</li>     <li id="BibPLXBIB0033" label="[33]">Jorn Lyseggen. 2017. <em>      <em>Outside Insight: Navigating a World Drowning in Data</em>     </em>. Penguin Books Limited. 336.</li>     <li id="BibPLXBIB0034" label="[34]">Ali Mesbah, Arie van Deursen, and Stefan Lenselink. 2012. Crawling Ajax-based Web applications through dynamic analysis of user interface state changes. <em>      <em>ACM Transactions on the Web (TWEB)</em>     </em>6, 1 (2012), 1&#x2013;30.</li>     <li id="BibPLXBIB0035" label="[35]">Mozenda2018. Mozenda. (2018). <a class="link-inline force-break" href="http://www.mozenda.com" target="_blank">http://www.mozenda.com</a> Retrieved Feb 14, 2018 from</li>     <li id="BibPLXBIB0036" label="[36]">Ion Muslea, Steven Minton, and Craig&#x00A0;A. Knoblock. 1999. A Hierarchical Approach to Wrapper Induction. In <em>      <em>Agents</em>     </em>. 190&#x2013;197.</li>     <li id="BibPLXBIB0037" label="[37]">Adi Omari, Sharon Shoham, and Eran Yahav. 2017. Synthesis of forgiving data extractors. In <em>      <em>Proceedings of the Tenth ACM International Conference on Web Search and Data Mining (WSDM &#x2019;17)</em>     </em>. ACM, New York, 385&#x2013;394.</li>     <li id="BibPLXBIB0038" label="[38]">Changhee Park and Sukyoung Ryu. 2015. Scalable and Precise Static Analysis of JavaScript Applications via Loop-Sensitivity. In <em>      <em>29th European Conference on Object-Oriented Programming, ECOOP 2015, July 5-10, 2015, Prague, Czech Republic</em>     </em>. 735&#x2013;756.</li>     <li id="BibPLXBIB0039" label="[39]">Richard Penman. 2016. <em>Web Data Extraction Optimization: From User Interaction To Web Server Communication</em>. MSc Thesis. University of Oxford.</li>     <li id="BibPLXBIB0040" label="[40]">Gregor Richards, Sylvain Lebresne, Brian Burg, and Jan Vitek. 2010. An analysis of the dynamic behavior of JavaScript programs. In <em>      <em>Proceedings of the 2010 ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI 2010, Toronto, Ontario, Canada, June 5-10, 2010</em>     </em>. 1&#x2013;12.</li>     <li id="BibPLXBIB0041" label="[41]">Sunita Sarawagi. 2008. Information extraction. <em>      <em>Foundations and Trends in Databases</em>     </em>1, 3 (2008), 261&#x2013;377.</li>     <li id="BibPLXBIB0042" label="[42]">Prateek Saxena, Devdatta Akhawe, Steve Hanna, Feng Mao, Stephen McCamant, and Dawn Song. 2010. A Symbolic Execution Framework for JavaScript. In <em>      <em>31st IEEE Symposium on Security and Privacy, S&#x0026;P 2010, 16-19 May 2010, Berleley/Oakland, California, USA</em>     </em>. 513&#x2013;528.</li>     <li id="BibPLXBIB0043" label="[43]">Koushik Sen, Swaroop Kalasapur, Tasneem Brutch, and Simon Gibbs. 2013. Jalangi: A selective record-replay and dynamic analysis framework for JavaScript. In <em>      <em>Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering</em>     </em>. 488&#x2013;498.</li>     <li id="BibPLXBIB0044" label="[44]">Wei Shen, Jianyong Wang, and Jiawei Han. 2015. Entity linking with a knowledge base: Issues, techniques, and solutions. <em>      <em>IEEE Transactions on Knowledge and Data Engineering</em>     </em>27, 2(2015), 443&#x2013;460.</li>     <li id="BibPLXBIB0045" label="[45]">Jui&#x00A0;Yuan Su, Der&#x00A0;Johng Sun, I.&#x00A0;Chen Wu, and Lung&#x00A0;Pin Chen. 2010. On design of browser-oriented data extraction system and the plug-ins. <em>      <em>Journal of Marine Science and Technology</em>     </em>18, 2 (2010), 189&#x2013;200.</li>     <li id="BibPLXBIB0046" label="[46]">Visual Web Ripper2018. Visual Web Ripper. (2018). <a class="link-inline force-break" href="http://visualwebripper.com"      target="_blank">http://visualwebripper.com</a> Retrieved Feb 14, 2018 from</li>     <li id="BibPLXBIB0047" label="[47]">Guowu Xie, Marios Iliofotou, Thomas Karagiannis, Michalis Faloutsos, and Yaohui Jin. 2013. ReSurf: Reconstructing Web-Surfing Activity From Network Traffic. <em>      <em>Proc. IFIP Networking Conference</em>     </em>(2013), 1&#x2013;9.</li>     <li id="BibPLXBIB0048" label="[48]">Yuhong Yan and Min Chen. 2013. Anytime QoS-aware service composition over the GraphPlan. <em>      <em>Service Oriented Computing and Applications</em>     </em>9, 1 (2013), 1&#x2013;19.</li>    </ul>   </section>  </section>  <section id="foot-001" class="footnote">   <header>    <div class="title-info">     <h2>FOOTNOTE</h2>    </div>   </header> <p id="fn1a"><a href="#foot-fn1"><sup>&#x002A;</sup></a>This work is supported by the EPSRC programme grant VADA: Value Added Data Systems - Principles and Architecture, no. EP/M025268/1. Georg Gottlob is also employed at TU Wien. Tim Furche is also with Wrapidity &#x0026; Meltwater, London, UK.</p>   <p id="fn1"><a href="#foot-fn1"><sup>1</sup></a>Our JSONPath notation is similar to <a class="link-inline force-break" href="http://goessner.net/articles/JsonPath/">http://goessner.net/articles/JsonPath/</a>   </p>   <div class="bibStrip">    <p>This paper is published under the Creative Commons Attribution 4.0 International (CC-BY&#x00A0;4.0) license. Authors reserve their rights to disseminate the work on their personal and corporate Web sites with the appropriate attribution.</p>    <p>     <em>WWW '18, April 23-27, 2018, Lyon, France</em>    </p>    <p>&#x00A9; 2018; IW3C2 (International World Wide Web Conference Committee), published under Creative Commons CC-BY&#x00A0;4.0 License. ACM ISBN 978-1-4503-5639-8/18/04.<br/>DOI: <a class="link-inline force-break" target="_blank"     href="https://doi.org/10.1145/3178876.3186008">https://doi.org/10.1145/3178876.3186008</a>    </p>   </div>  </section>  <div class="pubHistory">   <p/>  </div>  </body> </html> 
