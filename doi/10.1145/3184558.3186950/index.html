<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">  <head>  <title>FORank: Fast ObjectRank for Large Heterogeneous Graphs</title>  <!-- Copyright (c) 2010-2015 The MathJax Consortium --><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>  <meta name="viewport" content="width=device-width; initial-scale=1.0;"></meta>  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>  <link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/bootstrap.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/bootstrap-theme.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/main.css"/><script src="../../../data/dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script>  <script type="text/javascript"    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>  <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>  </head>  <body id="main">
<div>
<p style='font-size: 75%; color #444'>
This is a web copy of <a href='https://doi.org/10.1145/3184558.3186950'>https://doi.org/10.1145/3184558.3186950</a> 
 Published in WWW2018 Proceedings Â© 2018 International World Wide Web Conference Committee, published under 
 <a rel='license' property='license' href='https://creativecommons.org/licenses/by/4.0/'>
 Creative Commons CC By 4.0 License</a>.
The <a href='https://github.com/usable-oa/thewebconf2018/tree/master/scripts'>modifications</a> 
from the original are solely to improve HTML aiming to make it Findable, Accessible, Interoperable and Reusable. 
augmenting HTML metadata and avoiding ACM trademark.
To reference this HTML version, use:
</p><p>
<strong>Permalink:</strong>
<a href='https://w3id.org/oa/10.1145/3184558.3186950'>https://w3id.org/oa/10.1145/3184558.3186950</a>
</p></div>
<hr>

  <section class="front-matter">   <section>    <header class="title-info">     <div class="journal-title">     <h1>      <span class="title">FORank: Fast ObjectRank for Large Heterogeneous Graphs</span>      <br/>      <span class="subTitle"/>     </h1>     </div>    </header>    <div class="authorGroup">     <div class="author">     <span class="givenName">Tomoki</span>      <span class="surName">Sato</span>     University of Tsukuba, <a href="mailto:t.sato@kde.cs.tsukuba.ac.jp">t.sato@kde.cs.tsukuba.ac.jp</a>     </div>     <div class="author">     <span class="givenName">Hiroaki</span>      <span class="surName">Shiokawa</span>     University of Tsukuba, <a href="mailto:shiokawa@cs.tsukuba.ac.jp">shiokawa@cs.tsukuba.ac.jp</a>     </div>     <div class="author">     <span class="givenName">Yuto</span>      <span class="surName">Yamaguchi</span>     Indeed Japan, <a href="mailto:yyamaguchi@indeed.com">yyamaguchi@indeed.com</a>     </div>     <div class="author">     <span class="givenName">Hiroyuki</span>      <span class="surName">Kitagawa</span>     University of Tsukuba, <a href="mailto:kitagawa@cs.tsukuba.ac.jp">kitagawa@cs.tsukuba.ac.jp</a>     </div>             <Affiliation id="aff3">Both authors contributed equally to the paper</Affiliation>            </div>    <br/>    <div class="pubInfo">     <p>DOI: <a href="https://doi.org/10.1145/3184558.3186950" target="_blank">https://doi.org/10.1145/3184558.3186950</a>     <br/>WWW '18: <a href="https://doi.org/10.1145/3184558" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p>    </div>    <div class="abstract">     <p>     <small>ObjectRank is one of the popular graph mining methods that enables us to evaluate the importance of each vertex on heterogeneous graphs. However, it is computationally expensive to apply it to large graphs since ObjectRank needs to compute the importance of all vertices iteratively. In this work, we present a fast ObjectRank algorithm, <em>FORank</em>, that accurately approximates the keyword search results. FORank iteratively prunes vertices whose convergence score likely has less impact on the results during iterative computation. The experiments showed that FORank runs 7 times faster than ObjectRank computation with over 90% accuracy approximation.</small>     </p>    </div>    <div class="CCSconcepts">     <p> <small> <span style="font-weight:bold;">CCS Concepts:</span> &#x2022;<strong> Information systems </strong>&#x2192; <strong>Graph-based database models;</strong></small> </p>    </div>    <div class="classifications">     <div class="author">     <span style="font-weight:bold;">      <small>Keywords:</small>     </span>     <span class="keyword">      <small>ObjectRank; Graph data mining; Link structure analysis</small>     </span>     </div>     <br/>     <div class="AcmReferenceFormat">     <p>      <small>       <span style="font-weight:bold;">ACM Reference Format:</span>       <br/>       Tomoki Sato, Hiroaki Shiokawa, Yuto Yamaguchi, and Hiroyuki Kitagawa. 2018. FORank: Fast ObjectRank for Large Heterogeneous Graphs. In <em>WWW '18 Companion: The 2018 Web Conference Companion,</em>       <em>April 23&#x2013;27, 2018,</em>       <em> Lyon, France. ACM, New York, NY, USA</em> 3 Pages. <a href="https://doi.org/10.1145/3184558.3186950" class="link-inline force-break"        target="_blank">https://doi.org/10.1145/3184558.3186950</a></small>     </p>     </div>    </div>   </section>  </section>  <section class="body">   <section id="sec-6">    <header>     <div class="title-info">     <h2>      <span class="section-number">1</span> Introduction</h2>     </div>    </header>    <p>ObjectRank&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>] is a random walk-based graph analysis method that evaluates the importance of each vertex on the heterogeneous graphs where there are <em>multiple types</em> of vertices and edges. Although it is used in various applications, ObjectRank is computationally expensive since it requires iterative multiplications of matrix and vector to perform random walk. To address this problem, there is a line of works in the literature to accelerate ObjectRank computation&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0002">2</a>]. However, these methods still require much computation time on large heterogeneous graphs since they need to run precomputations.</p>    <p>In this paper, we propose <em>FORank</em>, a fast ObjectRank algorithm that accurately approximates the keyword search results without any precomputations. Our basic idea is that we exclude the vertices from the further computation if they do not have much impact on the ObjectRank scores of other vertices. In order to find which vertex to exclude, we theoretically derive the lower and upper bounds of the ObjectRank score. Our experiments showed that FORank runs 7 times faster than original ObjectRank computation while keeping the accuracy at over 90%.</p>   </section>   <section id="sec-7">    <header>     <div class="title-info">     <h2>      <span class="section-number">2</span> Preliminary: ObjectRank</h2>     </div>    </header>    <p>ObjectRank first transforms records in the database into a heterogeneous graph. The graph is twofold: <em>Authority Transfer Schema Graph</em> and <em>Authority Transfer Data Graph</em> (<em>Schema Graph</em> and <em>Data Graph</em> for short). Schema Graph is a labeled directed graph that defines relationships of attributes in the database schema: a vertex and an edge represent an attribute and a relationship between attributes, respectively. Each edge takes a weight value from 0 to 1 that indicates the fraction of the importance among attributes.</p>    <p>Data Graph is a labeled directed graph that materializes all records in the database based on the Schema Graph. Each vertex indicates an attribute value in the database, and it has a set of keywords corresponding to the attribute. Edges in the Data Graph have a weight value that is calculated by dividing the weight defined in Schema Graph by the outgoing degree of the source vertex.</p>    <p>Given a keyword <em>t</em> and a Data Graph <em>G</em> = (<em>V</em>, <em>E</em>), the ObjectRank score of each vertex <em>r<sub>t</sub>     </em>(<em>v</em>) can be obtained by recursively applying the following equation until convergence: <div class="table-responsive" id="eq1">     <div class="display-equation">      <span class="tex mytex">\begin{equation} \textstyle {r}_t = d {A} {r}_t + (1-d) {q}_t. \end{equation} </span>      <br/>      <span class="equation-number">(1)</span>     </div>     </div>    </p>    <p>A is a <em>N</em> &#x00D7; <em>N</em> transition matrix of <em>G</em>, and q<sub>     <em>t</em>     </sub> is the <em>N</em>-dimensional vector <em>s.t.</em>     <span class="inline-equation"><span class="tex">$q_t(v_i)=\frac{1}{|BS(t)|}$</span>     </span> for <em>v<sub>i</sub>     </em> &#x2208; <em>BS</em>(<em>t</em>), otherwise <em>q<sub>t</sub>     </em>(<em>v<sub>i</sub>     </em>) = 0, where |<em>BS</em>(<em>t</em>)| is the set of vertices that contains keyword <em>t</em>. As shown in Equation&#x00A0;<a class="eqn" href="#eq1">1</a>, ObjectRank consumes <em>O</em>((<em>N</em> + <em>M</em>)<em>T</em>) times for each keyword, where <em>N</em>, <em>M</em> and <em>T</em> are the number of vertices, edges, and iteration steps until convergence. This incurs high computational cost for large heterogeneous graphs. <figure id="fig1">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186950/images/www18companion-190-fig1.jpg" class="img-responsive" alt="Figure 1"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 1:</span>      <span class="figure-title">Query processing time varying threshold <em>&#x03B8;</em>      </span>     </div>     </figure>     <figure id="fig2">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186950/images/www18companion-190-fig2.jpg" class="img-responsive" alt="Figure 2"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 2:</span>      <span class="figure-title">The size of graph <em>G<sub>i</sub>       </em> in <em>i</em>-th iteration</span>     </div>     </figure>     <figure id="fig3">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186950/images/www18companion-190-fig3.jpg" class="img-responsive" alt="Figure 3"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 3:</span>      <span class="figure-title">Precomputation time in BinRank</span>     </div>     </figure>     <figure id="fig4">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186950/images/www18companion-190-fig4.jpg" class="img-responsive" alt="Figure 4"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 4:</span>      <span class="figure-title">Precision@k varying threshold <em>&#x03B8;</em>      </span>     </div>     </figure>    </p>   </section>   <section id="sec-8">    <header>     <div class="title-info">     <h2>      <span class="section-number">3</span> Proposed Method: <SmallCap>FORank</SmallCap>     </h2>     </div>    </header>    <figure id="fig5">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186950/images/www18companion-190-fig5.jpg" class="img-responsive" alt=""      longdesc=""/>    </figure>    <p>FORank reduces the number of vertices to be calculated by eliminating the ones with <em>small impact</em> on the final result. Thus, FORank identifies such vertices and prunes them iteratively from the further computations. In order to identify vertices to be pruned in the iterative computations, we theoretically derive upper bound <span class="inline-equation"><span class="tex">$\overline{ {r}}_t^{(i)}$</span>     </span> and lower bound <span class="inline-equation"><span class="tex">$\underline{ {r}}_t^{(i)}$</span>     </span> of the ObjectRank score r<sub>     <em>t</em>     </sub>. Since the upper bound <span class="inline-equation"><span class="tex">$\overline{ {r}}_t^{(i)}$</span>     </span> always holds <span class="inline-equation"><span class="tex">$\overline{ {r}}_t^{(i)} \ge {r}_t$</span>     </span> (Lemma&#x00A0;<a class="enc" href="#enc3">3.3</a>), we can prune vertex <em>v</em> if its upper bound <span class="inline-equation"><span class="tex">$\overline{r}_t^{(i)}(v)$</span>     </span> becomes smaller than the user-specified threshold <em>&#x03B8;</em> at the <em>i</em>-th iteration, <em>i.e.</em>     <span class="inline-equation"><span class="tex">$\overline{r}_t^{(i)}(v) {\lt} \theta$</span>     </span>.</p>    <p>     <div class="definition" id="enc1">     <Label>Definition 3.1 (Lower bound).</Label>     <p> The lower bound <span class="inline-equation"><span class="tex">$\underline{r}_t^{(i)}(v)$</span>      </span> of vertex <em>v</em> in the i-th iteration is defined as <div class="table-responsive" id="Xeq1">       <div class="display-equation">        <span class="tex mytex">\begin{equation} \underline{r}_t^{(i)}(v) = (1-d)\Sigma ^{i}_{j=0}d^{j}p_t^{(j)}(v), \end{equation} </span>        <br/>        <span class="equation-number">(2)</span>       </div>      </div> where <span class="inline-equation"><span class="tex">$ {p}_t^{(i)} = {q}_t$</span>      </span> if <em>i</em> = 0; otherwise, <span class="inline-equation"><span class="tex">$ {p}_t^{(i)} = {A}^{i} {q}_t$</span>      </span>.</p>     </div>    </p>    <p>     <div class="definition" id="enc2">     <Label>Definition 3.2 (Upper bound).</Label>     <p> The upper bound <span class="inline-equation"><span class="tex">$\overline{r}_t^{(i)}(v)$</span>      </span> of vertex <em>v</em> in the i-th iteration is given as <div class="table-responsive" id="Xeq2">       <div class="display-equation">        <span class="tex mytex">\begin{equation} \overline{r}_t^{(i)}(v) = \underline{r}_t^{(i)}(v) + d^{i+1}p_t^{(i)}(v) + (d^{i+1}/1-d)\Delta _t^{(i)}\overline{A}(v), \end{equation} </span>        <br/>        <span class="equation-number">(3)</span>       </div>      </div> where <span class="inline-equation"><span class="tex">$\overline{A}(v) = \max \lbrace A(v, u):u \in V\rbrace$</span>      </span>; <span class="inline-equation"><span class="tex">$\Delta _t^{(i)} = 1$</span>      </span> if <em>i</em> = 0, otherwise, <span class="inline-equation"><span class="tex">$\Delta _t^{(i)}=\sum _{u\in V_0}\Delta _t^{(i)}(u)$</span>      </span>, where <span class="inline-equation"><span class="tex">$\Delta _t^{(i)}(u) = \max \lbrace p_t^{(i)}(u)-p_t^{(i-1)}(u), 0\rbrace$</span>      </span>.</p>     </div>    </p>    <p>     <div class="lemma" id="enc3">     <Label>Lemma 3.3 (Lower and upper estimation).</Label>     <p> In the i-th iteration, lower/upper bounds <span class="inline-equation"><span class="tex">$\underline{r}_t^{(i)}(v)$</span>      </span>, <span class="inline-equation"><span class="tex">$\overline{r}_t^{(i)}(v)$</span>      </span> satisfy <span class="inline-equation"><span class="tex">$\underline{r}_t^{(i)}(v) \le r_t(v) \le \overline{r}_t^{(i)}(v)$</span>      </span>.</p>     </div>    </p>    <div class="proof" id="proof1">     <Label>Proof.</Label>     <p> Omitted due to the space limitation.</p>    </div>    <p>Based on Lemma&#x00A0;<a class="enc" href="#enc3">3.3</a>, FORank can estimate the upper bound of the final score. FORank prunes vertices whose upper bounds are smaller than the user-specified threshold <em>&#x03B8;</em> in each iteration. The pseudo-code of our proposal, FORank, is shown in Algorithm&#x00A0;1.</p>   </section>   <section id="sec-9">    <header>     <div class="title-info">     <h2>      <span class="section-number">4</span> Experiments</h2>     </div>    </header>    <p>We compared three algorithms, FORank, ObjectRank&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>] and the state-of-the-art algorithm, BinRank&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0002">2</a>]. BinRank approximates ObjectRank by using <em>subgraph construction</em>. As a precomputation, BinRank runs the ObjectRank and keeps a subgraph by pruning vertices whose ObjectRank scores are smaller than the user-specified threshold for each clustered keywords. When query keyword <em>t</em> is given, BinRank <em>re</em>-computes the ObjectRank scores on the subgraph generated from the cluster that has keyword <em>t</em>. All experiments were conducted on a Linux server with 3.5GHz CPU and 128GB RAM. We used DBLP bibliographic dataset published by AMiner&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0003">3</a>], which has 1,238,266 vertices and 5,149,294 edges.</p>    <p>     <strong>Efficiency:</strong>Figure&#x00A0;<a class="fig" href="#fig1">1</a> indicates that FORank is much faster than ObjectRank and BinRank except for the significantly small threshold values. Specifically, FORank cuts the execution time by up to 86% from ObjectRank. ObjectRank iteratively computes all vertices and edges until convergence. On the other hand, FORank computes only the key vertices and edges by incrementally pruning low impact vertices during iterative computations. Figure&#x00A0;<a class="fig" href="#fig2">2</a> shows how many vertices remain in the subgraph <em>G<sub>i</sub>     </em> in the <em>i</em>-th iteration. As shown in Figure&#x00A0;<a class="fig" href="#fig2">2</a>, FORank successfully reduces the number of vertices to be computed as the iteration number increases. Specifically, FORank removes from 98% to 99% of vertices in <em>G</em>     <sub>0</sub> through only 6 to 11 iterations. Although FORank is also more efficient than the state-of-the-art algorithm BinRank when <em>&#x03B8;</em> &#x2265; 0.1, its improvement is moderated compared with ObjectRank. However, BinRank requires the subgraph construction before querying a keyword. Figure&#x00A0;<a class="fig" href="#fig3">3</a> shows the precomputation time of BinRank varying the inner-parameter <em>maxBinSize</em>, which controls the size of subgraphs. Since BinRank consumes more than 10 hours under the all settings we examined, thus FORank is also faster than BinRank.</p>    <p>     <strong>Accuracy:</strong>We evaluated the top-<em>k</em> approximation accuracy using <em>Prec</em>(<em>t</em>, <em>k</em>) = |<em>CompSet</em>(<em>t</em>, <em>k</em>)&#x2229;<em>ORSet</em>(<em>t</em>, <em>k</em>)|/<em>k</em>, where <em>CompSet</em>(<em>t</em>, <em>k</em>) is the set of top-<em>k</em> vertices for keyword <em>t</em> obtained by FORank or BinRank, and <em>ORSet</em>(<em>t</em>, <em>k</em>) is those by ObjectRank. Figure&#x00A0;<a class="fig" href="#fig4">4</a> indicates that FORank showed better accuracy than BinRank: it achieved almost 90% accuracy compared with the results of ObjectRank.</p>   </section>   <section id="sec-10">    <header>     <div class="title-info">     <h2>      <span class="section-number">5</span> Summary</h2>     </div>    </header>    <p>We propose FORank, a fast algorithm that approximates the keyword search results. FORank iteratively prunes vertices whose convergence score likely has less impact on the results during iterative computations using upper and lower bounds. Our experiments using real dataset showed that FORank can obtain results about 7 times faster than ObjectRank while keeping the accuracy at 90%.</p>   </section>  </section>  <section class="back-matter">   <section id="sec-11">    <header>     <div class="title-info">     <h2>ACKNOWLEDGMENTS</h2>     </div>    </header>    <p>This work was supported by JSPS KAKENHI Grant Number JP16H06650, JST ACT-I, and Interdisciplinary Computational Science Program in CCS, University of Tsukuba.</p>   </section>   <section id="ref-001">    <header>     <div class="title-info">     <h2 class="page-brake-head">REFERENCES</h2>     </div>    </header>    <ul class="bibUl">     <li id="BibPLXBIB0001" label="[1]">Andrey Balmin, Vagelis Hristidis, and Yannis Papakonstantinou. 2004. ObjectRank: Authority-Based Keyword Search in Databases. <em>      <em>In Proc. VLDB</em>     </em>. 564&#x2013;575.</li>     <li id="BibPLXBIB0002" label="[2]">Heasoo Hwang, Andrey Balmin, Berthold Reinwald, and Erik Nijkamp. 2009. BinRank: Scaling Dynamic Authority-Based Search Using Materialized SubGraphs. <em>      <em>In Proc. ICDE</em>     </em>. 66&#x2013;77.</li>     <li id="BibPLXBIB0003" label="[3]">Jie Tang, Jing Zhang, Limin Yao, Juanzi Li, Li Zhang, and Zhong Su. 2008. ArnetMiner: Extraction and Mining of Academic Social Networks. <em>      <em>In Proc. KDD</em>     </em>.</li>    </ul>   </section>  </section>  <section id="foot-001" class="footnote">   <header>    <div class="title-info">     <h2>FOOTNOTE</h2>    </div>   </header>   <div class="bibStrip">    <p>This paper is published under the Creative Commons Attribution 4.0 International (CC-BY&#x00A0;4.0) license. Authors reserve their rights to disseminate the work on their personal and corporate Web sites with the appropriate attribution.</p>    <p>     <em>WWW '18, April 23-27, 2018, Lyon, France</em>    </p>    <p>&#x00A9; 2018; IW3C2 (International World Wide Web Conference Committee), published under Creative Commons CC-BY&#x00A0;4.0 License. ACM ISBN 978-1-4503-5640-4/18/04.<br/>DOI: <a class="link-inline force-break" target="_blank"     href="https://doi.org/10.1145/3184558.3186950">https://doi.org/10.1145/3184558.3186950</a>    </p>   </div>  </section>  <div class="pubHistory">   <p/>  </div>  </body> </html> 
