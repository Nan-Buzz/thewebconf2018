<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.7.16" />
  <title>Any-k: Anytime Top-k Tree Pattern Retrieval in Labeled Graphs</title><!-- Copyright (c) 2010-2015 The MathJax Consortium -->
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width; initial-scale=1.0;" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="screen, print" rel="stylesheet" href="../../../data/dl.acm.org/pubs/lib/css/bootstrap.min.css" />
  <link media="screen, print" rel="stylesheet" href="../../../data/dl.acm.org/pubs/lib/css/bootstrap-theme.min.css" />
  <link media="screen, print" rel="stylesheet" href="../../../data/dl.acm.org/pubs/lib/css/main.css" />
  <script src="../../../data/dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>
  <script type="text/x-mathjax-config">
  <![CDATA[
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  ]]>
  </script>
  <link rel="cite-as" href="https://doi.org/10.1145/3178876.3186115"/>
</head>
<body id="main">
<div>
<p style='font-size: 75%; color #444'>
This is a web copy of <a href='https://doi.org/10.1145/3178876.3186115'>https://doi.org/10.1145/3178876.3186115</a>.
 Published in WWW2018 Proceedings © 2018 International World Wide Web Conference Committee, published under 
 <a rel='license' property='license' href='https://creativecommons.org/licenses/by/4.0/'>
 Creative Commons CC By 4.0 License</a>.
The <a href='https://github.com/usable-oa/thewebconf2018/tree/master/scripts'>modifications</a> 
from the original are solely to improve HTML aiming to make it Findable, Accessible, Interoperable and Reusable. 
augmenting HTML metadata and avoiding ACM trademark.
To reference this HTML version, use:
</p><p>
<strong>Permalink:</strong>
<a href='https://w3id.org/oa/10.1145/3178876.3186115'>https://w3id.org/oa/10.1145/3178876.3186115</a>
</p></div>
<hr>


  <section class="front-matter">
    <section>
      <header class="title-info">
        <div class="journal-title">
          <h1><span class="title">Any-k: Anytime Top-k Tree Pattern Retrieval in Labeled Graphs</span><br />
          <span class="subTitle"></span></h1>
        </div>
      </header>
      <div class="authorGroup">
        <div class="author">
          <span class="givenName">Xiaofeng</span> <span class="surName">Yang</span>, Northeastern University, Boston, MA, <a href="mailto:xiaofeng@ccs.neu.edu">xiaofeng@ccs.neu.edu</a>
        </div>
        <div class="author">
          <span class="givenName">Deepak</span> <span class="surName">Ajwani</span>, Nokia Bell Labs, Dublin, Ireland, <a href="mailto:deepak.ajwani@nokia-bell-labs.com">deepak.ajwani@nokia-bell-labs.com</a>
        </div>
        <div class="author">
          <span class="givenName">Wolfgang</span> <span class="surName">Gatterbauer</span>, Northeastern University, Boston, MA, <a href="mailto:wolfgang@ccs.neu.edu">wolfgang@ccs.neu.edu</a>
        </div>
        <div class="author">
          <span class="givenName">Patrick K.</span> <span class="surName">Nicholson</span>, Nokia Bell Labs, Dublin, Ireland, <a href="mailto:pat.nicholson@nokia-bell-labs.com">pat.nicholson@nokia-bell-labs.com</a>
        </div>
        <div class="author">
          <span class="givenName">Mirek</span> <span class="surName">Riedewald</span>, Northeastern University, Boston, MA, <a href="mailto:mirek@ccs.neu.edu">mirek@ccs.neu.edu</a>
        </div>
        <div class="author">
          <span class="givenName">Alessandra</span> <span class="surName">Sala</span>, Nokia Bell Labs, Dublin, Ireland, <a href="mailto:alessandra.sala@nokia-bell-labs.com">alessandra.sala@nokia-bell-labs.com</a>
        </div>
      </div><br />
      <div class="pubInfo">
        <p>DOI: <a href="https://doi.org/10.1145/3178876.3186115" target="_blank">https://doi.org/10.1145/3178876.3186115</a><br />
        WWW 2018: <a href="https://doi.org/10.1145/3178876" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p>
      </div>
      <div class="abstract">
        <p><small>Many problems in areas as diverse as recommendation systems, social network analysis, semantic search, and distributed root cause analysis can be modeled as pattern search on labeled graphs (also called “heterogeneous information networks” or HINs). Given a large graph and a query pattern with node and edge label constraints, a fundamental challenge is to find the top-<em>k</em> matches according to a ranking function over edge and node weights. For users, it is difficult to select value <em>k</em>. We therefore propose the novel notion of an <em>any-</em>k</small> ranking algorithm: for a given time budget, return as many of the top-ranked results as possible. Then, given additional time, produce the next lower-ranked results quickly as well. It can be stopped anytime, but may have to continue until all results are returned. This paper focuses on acyclic patterns over arbitrary labeled graphs. We are interested in practical algorithms that effectively exploit (1) properties of heterogeneous networks, in particular selective constraints on labels, and (2) that the users often explore only a fraction of the top-ranked results. Our solution, KARPET, carefully integrates aggressive pruning that leverages the acyclic nature of the query, and incremental guided search. It enables us to prove strong non-trivial time and space guarantees, which is generally considered very hard for this type of graph search problem. Through experimental studies we show that KARPET achieves running times in the order of milliseconds for tree patterns on large networks with millions of nodes and edges.</p>
      </div>
      <div class="classifications">
        <div class="AcmReferenceFormat">
          <p><small><span style="font-weight:bold;">ACM Reference Format:</span><br />
          Xiaofeng Yang, Deepak Ajwani, Wolfgang Gatterbauer, Patrick K. Nicholson, Mirek Riedewald, and Alessandra Sala. 2018. Any-k: Anytime Top-k Tree Pattern Retrieval in Labeled Graphs. In <em>WWW 2018: The 2018 Web Conference,</em> <em>April 23–27, 2018,</em> <em>Lyon, France. ACM, New York, NY, USA</em> 10 Pages. <a href="https://doi.org/10.1145/3178876.3186115" class="link-inline force-break" target="_blank">https://doi.org/10.1145/3178876.3186115</a></small></p>
        </div>
      </div>
    </section>
  </section>
  <section class="body">
    <section id="sec-7">
      <header>
        <div class="title-info">
          <h2><span class="section-number">1</span> Introduction</h2>
        </div>
      </header>
      <p>Heterogeneous information networks (HIN)&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0016">16</a>], i.e., graphs with node and/or edge labels, have recently attracted a lot of attention for their ability to model many complex real-world relationships, thereby enabling rich queries. Often labels are used to represent types of nodes and their relationships:</p>
      <p></p>
      <div class="example" id="enc1">
        <label>Example 1.1 (Photo-sharing network).</label>
        <p>Consider a photo-sharing social network with three vertex type labels: user, photo, and group. Users are connected to the photos they upload, and photos are connected to groups when they are posted there. Finally, users can connect to groups by joining them. To maintain a vibrant community and alert users about potentially interesting photos, the social network might run queries of the type shown in Figure&nbsp;<a class="fig" href="#fig1">1</a>: given <em>photo1</em> and two users, <em>user1</em> and <em>user2</em>, find alternative groups (matching nodes for <em>group2</em>) to post the photo in order to reach <em>user2</em> without spamming her directly. This is achieved by identifying a user belonging to both groups (<em>user3</em>), who can post the photo in the other group. There might be hundreds of matching triples (<em>group1</em>, <em>user3</em>, <em>group2</em>), and there would be many more if <em>user2</em> was not given in advance. Under these circumstances, the goal often is not to find <em>all</em> results, but only the <em>most important</em> ones. Importance can be determined based on node and edge weights, e.g., weights representing distances (or similarities). Then the query should return the lightest (or heaviest) pattern instances. For example, the weight of a group may be based on its number of members, the weight of a user on how active s/he is, and the weight of a link on the timestamp when it was established (to give preference to long-term relationships or more recent photo posts), or the sum of the PageRanks of its endpoints.</p>
      </div>
      <p></p>
      <figure id="fig1">
        <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186115/images/www2018-124-fig1.png" class="img-responsive" alt="Figure 1" longdesc="" />
        <div class="figure-caption">
          <span class="figure-number">Figure 1:</span> <span class="figure-title">Example query on a photo-sharing network: find the most important nodes of types (user3, group1, group2) for a given triple of specified nodes of types (photo1, user1, user2).</span>
        </div>
      </figure>
      <p>These types of rich query semantics also appears in other contexts, e.g., root-cause analysis in distributed systems. The Vitrage service for OpenStack&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0004">4</a>] makes use of path and tree patterns to specify rules for automatic root cause deduction of alarms raised by virtual machines and hardware. Large OpenStack deployments—involving thousands of hosts and tens of thousands of virtual machines and hardware components—necessitate pattern matching algorithms to deduce the root cause of such patterns in near real-time.</p>
      <p>We focus on efficient solutions for acyclic pattern queries on general labeled graphs. To this end, we propose the notion of <em>any-</em>k algorithms, a novel variant of top-<em>k</em> algorithms. A top-<em>k</em> algorithm exploits knowledge about the given <em>k</em> to produce the top-<em>k</em> lightest patterns faster than the “full enumeration” algorithm (which first produces all results and then ranks them by weight). In practice, it is difficult for users to know the value of <em>k</em> upfront (“when will I have seen enough?”). An any-<em>k</em> algorithm addresses this issue by not requiring a pre-set value for <em>k</em>. Instead, an any-<em>k</em> algorithm</p>
      <ol class="list-no-style">
        <li id="list1" label="(1)">returns the top-ranked result as quickly as possible,<br /></li>
        <li id="list2" label="(2)">then returns the second-ranked result next, followed by the third-ranked, and so on,<br /></li>
        <li id="list3" label="(3)">until the user is satisfied and terminates the process.<br /></li>
      </ol>
      <p>In other words, the ranked enumeration can be stopped <em>anytime</em> and should then return as many top results as possible.</p>
      <p>The queries we are interested in correspond to <em>subgraph isomorphism</em>, which is known to be hard in general. In particular, subgraph isomorphism on homogeneous graphs is already NP-complete in the size of the query (even for the path case as Hamiltonian path is a special case). And labeled graphs contain unlabeled graphs as a special case. On the other hand, labels provide more opportunities for achieving better performance <em>in practice</em> by exploiting heterogeneity where present. Note that a key reason for hardness of isomorphism lies in the “non-repetition constraint,” i.e., the same graph node cannot occur more than once in an answer. Without this constraint, pattern search would correspond to the easier <em>subgraph homomorphism</em> problem which can be solved in PTIME.</p>
      <p>Our approach is based on three key insights: (1) Constraints on node or edge labels can dramatically reduce the number of matching results; (2) Mutually exclusive type labels “narrow the gap” in cardinality between the set of isomorphic subgraphs and the set of homomorphic subgraphs (which includes all isomorphic ones). The reason is that query pattern nodes of different types cannot be mapped to the same graph node, even when the algorithm is only searching for homomorphism. In the example photo-sharing network, users and photos cannot stand in for a group node. In the extreme, if all nodes in the query pattern have different types, then any solution for subgraph homomorphism also satisfies isomorphism. This suggests an approach that aggressively prunes for the homomorphism case and then filters based on node repetitions in the result patterns; and (3) In many real-world cases, output size is small relative to the combinatorial size of the pattern search space. Hence algorithm complexity bounds based on output size promise to deliver practically meaningful performance guarantees.</p>
      <p><strong>Overview of the Solution.</strong> Our approach combines three conceptually separate steps into a two-phase algorithm.</p>
      <p>1) The search space of possible homomorphic patterns is pruned to the provably smallest representation of the original graph. We use insights from the well-known Yannakakis algorithm&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0039">39</a>] for evaluating answers to acyclic conjunctive queries to create this representation in just one bottom-up and a subsequent top-down sweep through the query tree.</p>
      <p>2) We devise a novel any-<em>k</em> algorithm for enumerating homomorphic tree patterns. It uses dynamic programming to perform a bottom-up cost calculation, followed by a top-down guided search.</p>
      <p>3) A final pruning step removes those homomorphic patterns that do not satisfy the isomorphism requirement.</p>
      <p>We show how to combine the first two steps into just one bottom-up and one top-down phase. We then integrate the third step into the combined top-down phase. Our experiments show that even on graphs with millions of nodes and tens of millions of edges, we can return the top-ranked results in just a few milliseconds, whereas alternative approaches would take orders of magnitude longer. Our implementation can be downloaded from&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0002">2</a>].</p>
      <p><strong>Main contributions.</strong> We devise KARPET (<span style="text-decoration: underline;">K</span>ernelization<a class="fn" href="#fn1" id="foot-fn1"><sup>1</sup></a> <span style="text-decoration: underline;">A</span>nd <span style="text-decoration: underline;">R</span>apid <span style="text-decoration: underline;">P</span>runing-based <span style="text-decoration: underline;">E</span>xploration for <span style="text-decoration: underline;">T</span>ree patterns), a novel and highly performant any-<em>k</em> algorithm that can quickly identify top-ranked tree patterns in large graphs, then return the next lower-ranked ones when given extra time.</p>
      <p>1) KARPET is designed as an <em>anytime</em> ranking algorithm that enumerates homomorphic subtrees in order of total edge weight with strong theoretic guarantees: We show that our worst-case time complexity for returning all homomorphism results is identical to full enumeration. In addition, KARPET provides strong upper bound guarantees for the time to return the top-ranked homomorphism result, as well as the time between returning a homomorphism result and the next. For cases with “small gap” between homomorphism and isomorphism, i.e., when “sufficiently many” homomorphic patterns are also isomorphic patterns, these guarantees carry over to subgraph isomorphism.</p>
      <p>2) We propose fast and effective <em>local</em> pruning operations that exploit the heterogeneity of labeled graphs, proving that they also guarantee strong <em>global</em> pruning properties. Intuitively, for subgraph homomorphism, we show that inexpensive pruning based on 1-node neighborhoods efficiently removes all candidate nodes that are not part of any result pattern.</p>
      <p>3) In contrast to a lot of theoretical work on subgraph isomorphism algorithms, our algorithm is output-sensitive—its worst case complexity depends on the output size, which is smaller when the graph and the query are more heterogeneous, rather than being exponential in the size of the query pattern.</p>
      <p>4) We show how to speed up the search for top-ranked isomorphic answers by pushing the pruning for non-repeating nodes into the incremental result enumeration algorithm.</p>
    </section>
    <section id="sec-8">
      <header>
        <div class="title-info">
          <h2><span class="section-number">2</span> Problem Definition and Hardness</h2>
        </div>
      </header>
      <p><em>Our goal is to find the lightest subgraphs of a labeled graph <em>G</em> that are isomorphic to a given tree pattern <em>Q</em></em> . Instead of returning all results at once after a long wait time, we set out to devise an <em>anytime algorithm</em>, which returns the top-ranked match as quickly as possible and then incrementally returns the remaining results over time.</p>
      <p></p>
      <div class="definition" id="enc2">
        <label>Definition 2.1 (Any-k algorithm).</label>
        <p>An any-<em>k</em> algorithm is a variant of a top-<em>k</em> algorithm in which <em>k</em> is not known at the start of the algorithm. The algorithm can be interrupted <em>anytime</em>, returning the top-<em>k</em> results with <em>k</em> being as large as possible.</p>
      </div>
      <p></p>
      <p>We define the weight of a pattern as the <em>sum</em> of edge weights. This also supports search for the “most reliable” pattern based on probabilities assigned to edges. Finding the pattern with the greatest probability of being connected, assuming independence, is equivalent to maximizing the sum of the logarithms of the edge probabilities. For our problem with a fixed query pattern, lightest and heaviest pattern search can be easily converted into each other. It is also straightforward to modify our approach to support pattern weight defined as minimum or maximum of edge weights. We present the formal definitions next. Table&nbsp;<a class="tbl" href="#tab1">1</a> summarizes important notation.</p>
      <div class="table-responsive" id="tab1">
        <div class="table-caption">
          <span class="table-number">Table 1:</span> <span class="table-title">Notation used in this paper.</span>
        </div>
        <table class="table">
          <thead>
            <tr>
              <th style="text-align:left;">Symbol</th>
              <th style="text-align:left;">Definition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align:left;">G(V, E)</td>
              <td style="text-align:left;">A labeled graph with node set <em>V</em> and edge set <em>E</em></td>
            </tr>
            <tr>
              <td style="text-align:left;">L</td>
              <td style="text-align:left;">Set of node labels</td>
            </tr>
            <tr>
              <td style="text-align:left;">ϕ()</td>
              <td style="text-align:left;">Function mapping nodes to labels</td>
            </tr>
            <tr>
              <td style="text-align:left;"><em>w</em>()</td>
              <td style="text-align:left;">Function mapping edges to weights</td>
            </tr>
            <tr>
              <td style="text-align:left;"><em>Q</em>(<em>V<sub>Q</sub></em> , <em>E<sub>Q</sub></em> )</td>
              <td style="text-align:left;">Tree pattern with node set <em>V<sub>Q</sub></em> and edge set <em>E<sub>Q</sub></em></td>
            </tr>
            <tr>
              <td style="text-align:left;"><em>ψ</em>()</td>
              <td style="text-align:left;">Required labels for a graph node matched to a query node</td>
            </tr>
            <tr>
              <td style="text-align:left;">⊥(<em>Q</em>)</td>
              <td style="text-align:left;">Set of leaf nodes (or terminals) in <em>Q</em></td>
            </tr>
            <tr>
              <td style="text-align:left;">⊤(<em>Q</em>)</td>
              <td style="text-align:left;">Chosen root node in <em>Q</em></td>
            </tr>
            <tr>
              <td style="text-align:left;"><em>N</em>(<em>v</em>, ℓ)</td>
              <td style="text-align:left;">Set of neighbors of <em>v</em> in <em>G</em> with label ℓ</td>
            </tr>
            <tr>
              <td style="text-align:left;"><em>λ</em>()</td>
              <td style="text-align:left;">Function mapping query nodes <em>V<sub>Q</sub></em> to graph nodes <em>V</em></td>
            </tr>
          </tbody>
        </table>
      </div>
      <p></p>
      <div class="definition" id="enc3">
        <label>Definition 2.2 (HIN, labeled graph).</label>
        <p>A <em>Weighted Heterogeneous Information Network</em> (HIN) is a labeled undirected graph <em>G</em> = (<em>V</em>, <em>E</em>, ϕ, <em>w</em>), where <em>V</em> is a set of vertices, <em>E</em> is a set of edges, ϕ is a node labeling function ϕ: <em>V</em> → <em>L</em>, and <em>w</em> is an edge weight function <span class="inline-equation"><span class="tex">$w: E\rightarrow \mathbb {R}$</span></span> .</p>
      </div>
      <p></p>
      <p>In many HINs, a node has at least two different kinds of labels: a unique <em>node ID</em> and a <em>type</em> (or <em>class</em>). In the photo-sharing network example (see Example&nbsp;<a class="enc" href="#enc1">1.1</a>), the labeling function assigns types such as “user” or “photo” to each node. Our approach can be easily extended to include multiple labels per node, as well as (multiple) edge labels, node weights, and directed edges. We omit these straightforward generalizations in order to simplify the exposition.</p>
      <p>Given a vertex <em>v</em> ∈ <em>V</em> and label ℓ ∈ <em>L</em>, we use <em>N</em>(<em>v</em>, ℓ) to denote the set of all <em>neighbors</em> of <em>v</em> with label ℓ, i.e., <em>N</em>(<em>v</em>, ℓ){<em>u</em>: (<em>v</em>, <em>u</em>) ∈ <em>E</em>∧ϕ(<em>u</em>) = ℓ}.</p>
      <p></p>
      <div class="definition" id="enc4">
        <label>Definition 2.3 (Tree pattern or query Q).</label>
        <p>Given a labeled graph <em>G</em> = (<em>V</em>, <em>E</em>, ϕ, <em>w</em>), a <em>tree pattern</em> is a rooted tree <em>Q</em> = (<em>V<sub>Q</sub></em> , <em>E<sub>Q</sub></em> , <em>ψ</em>) in which each node <em>v</em> ∈ <em>V<sub>Q</sub></em> has a label constraint <em>ψ</em>: <em>V<sub>Q</sub></em> → <em>L</em>. We use ⊤(<em>Q</em>) ∈ <em>V<sub>Q</sub></em> to denote the root of the tree and ⊥(<em>Q</em>) to denote the set of its leaves (or terminals, i.e. nodes of degree one).</p>
      </div>
      <p></p>
      <p>The labeling constraint can encode the selection of specific nodes or node types. For example, in the photo-sharing network scenario, setting <em>ψ</em> for <em>user1</em> to be the ID of a specific user node limits the candidate set for <em>user1</em> to just this one graph node. Similarly, setting <em>ψ</em> to the label encoding the type “group” will enforce that only graph nodes representing groups, but not users or photos, will be considered.</p>
      <p>Notice that <em>Q</em> being rooted is not a restriction: any node in a tree can be chosen to be the root. We merely make use of the fact that the tree pattern is rooted in order to more easily describe our algorithms.</p>
      <p></p>
      <div class="definition" id="enc5">
        <label>Definition 2.4 (homomorphic match or result pattern).</label>
        <p>A <em>homomorphic result pattern</em> (or <em>homomorphic match</em>) of query <em>Q</em> is a graph (<em>V</em>′⊆<em>V</em>, <em>E</em>′⊆<em>E</em>) such that there exists a function <em>λ</em>: <em>V<sub>Q</sub></em> → <em>V</em>′ with the following properties: (1) ∀<em>u</em> ∈ <em>V<sub>Q</sub></em> : <em>ψ</em>(<em>u</em>) = ϕ(<em>λ</em>(<em>u</em>)), and (2) ∀(<em>u</em>, <em>v</em>) ∈ <em>E<sub>Q</sub></em> : (<em>λ</em>(<em>u</em>), <em>λ</em>(<em>v</em>)) ∈ <em>E</em>′. The weight of a result pattern is defined as <span class="inline-equation"><span class="tex">$\sum _{(u,v) \in E^{\prime }}w(u,v)$</span></span> .</p>
      </div>
      <p></p>
      <p></p>
      <div class="definition" id="enc6">
        <label>Definition 2.5 (match or result pattern).</label>
        <p>An (isomorphic) <em>result pattern</em> (or <em>match</em>) of query <em>Q</em> is a homomorphic result pattern (<em>V</em>′⊆<em>V</em>, <em>E</em>′⊆<em>E</em>) with a bijective mapping function <span class="inline-equation"><span class="tex">$\lambda : V_Q\xrightarrow []{\text{1:1}} V^{\prime }$</span></span> .</p>
      </div>
      <p></p>
      <p>The above definitions make it clear that the set of isomorphic matches is a subset of the homomorphic matches; and can be obtained by removing all those homomorphic matches where multiple query nodes are mapped to the same graph node.</p>
      <p>In the discussion below we will also refer to <em>partial patterns</em> (or <em>partial matches</em>) for intermediate results of the computation. These are incomplete instances where some of the query nodes are mapped to NIL by <em>λ</em>. The <em>direct successor</em> of a partial match is one where exactly one of the NIL targets is replaced by a graph node, growing the pattern by one additional node. With <em>successor</em> we refer to any partial or complete match in the transitive closure of direct successor.</p>
      <p>For fast access to <em>N</em>(<em>v</em>, ℓ), we rely on <tt>GraphEdge</tt>, a <em>two-level hash index</em> constructed offline for <em>G</em>. It maps a given node ID <em>v</em> to another hash table, which in turn maps a given label ℓ to the set <em>N</em>(<em>v</em>, ℓ) of neighbors of <em>v</em> with label ℓ. If no label is specified, all nodes and corresponding edge weights in the secondary hash table for <em>v</em> are returned. This index can be bulk-created from scratch in time linear in the graph size, and updated in time linear in the size of the changes.</p>
      <p><strong>Hardness.</strong> In general, even the decision version of sub-graph isomorphism, i.e., to determine if a given query graph is isomorphic to a sub-graph of <em>G</em>, is NP-complete. When the sub-graph is connected acyclic (i.e., a tree), the best worst-case time bound for the decision problem is a parameterized algorithm of Koutis and Williams&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0024">24</a>] that requires <span class="inline-equation"><span class="tex">$O(2^{|V_Q|}\texttt {poly}(|V|))$</span></span> time. Their algorithm also has matching conditional lower bounds&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0025">25</a>]: achieving a bound of <span class="inline-equation"><span class="tex">$O(2^{(1-\varepsilon)|V_Q|}\texttt {poly}(|V|))$</span></span> time, for any constant ɛ &gt; 0, would falsify a longstanding conjecture. Note that, since the decision problem is hard, the any-<em>k</em> problem discussed here is at least as hard.</p>
      <figure id="fig2">
        <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186115/images/www2018-124-fig2.png" class="img-responsive" alt="Figure 2" longdesc="" />
        <div class="figure-caption">
          <span class="figure-number">Figure 2:</span> <span class="figure-title">Candidate instances for matching the example query in Figure&nbsp;<a class="fig" href="#fig1">1</a>. Edge sets are named based on the corresponding pairs of adjacent nodes in the query pattern.</span>
        </div>
      </figure>
      <p></p>
      <p>In practice we often know specific node instances such as <em>a</em> for <em>user1</em> in the photo-sharing network example, and can dramatically reduce the pattern search space by exploring <em>G</em> starting from these nodes. Still, as fig:joinGraph illustrates, one cannot tell from the immediate neighborhood of node <em>a</em>, if edge (<em>a</em>, <em>c</em> <sub>1</sub>) will belong to top-ranked results, or any results at all. Worse yet, not even the 3-hop neighborhood of <em>a</em> will answer this question. Hence a pattern search algorithm might suffer from expensive backtracking or the inability to determine, without extensive graph traversal, when the top-<em>k</em> lowest-weight patterns have been found.</p>
      <p>To the best of our knowledge, KARPET is the first algorithm for ranked retrieval of graph query patterns that performs pruning and exploration based on “local” information, while <em>provably guaranteeing</em> to make the right decisions “globally.”</p>
    </section>
    <section id="sec-9">
      <header>
        <div class="title-info">
          <h2><span class="section-number">3</span> Any-k Algorithm</h2>
        </div>
      </header>
      <p>We next present an approach for sub-graph <em>homomorphism</em>; this is a relaxation of sub-graph isomorphism in that we do not require the mapping <em>λ</em> from query nodes to tree-pattern nodes to be bijective (in other words, a node can be repeated in the result pattern). Section&nbsp;<a class="sec" href="#sec-16">5</a> extends the approach for isomorphism.</p>
      <p>KARPET consists of two phases: 1) a bottom-up sweep from leaves to the root of <em>Q</em>, and 2) a top-down depth-first traversal from root to leaves. The first phase prunes some of the spurious candidates and creates a “<em>candidate graph</em>” (discussed below) with “<em>minimum subtree weights</em>.” The second phase prunes the remaining spurious candidates and performs a search guided by the subtree weights. Here the term <em>spurious candidate</em> refers to a node or edge of the input graph that does not appear in any of the query results.</p>
      <section id="sec-10">
        <header>
          <div class="title-info">
            <h3><span class="section-number">3.1</span> Bottom-Up Phase</h3>
          </div>
        </header>
        <p><img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186115/images/www2018-124-img1.svg" class="img-responsive" alt="" longdesc="" /></p>
        <figure id="fig3">
          <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186115/images/www2018-124-fig3.png" class="img-responsive" alt="Figure 3" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 3:</span> <span class="figure-title">Minimal subtree weight computations: (a) after traversing all leaves, (b) after traversing middle level, (c) after finishing at the root. Numbers above node candidates indicate minimum sub-tree weights stored in <span class="inline-equation"><span class="tex">$\texttt {CandNode}$</span></span> ; numbers on edges indicate edge weights stored in <span class="inline-equation"><span class="tex">$\texttt {CandEdge}$</span></span> .</span>
          </div>
        </figure>
        <p></p>
        <p>The bottom-up phase traverses the query tree in any bottom-up order and constructs a “candidate graph” consisting of two index structures: (1) <span class="inline-equation"><span class="tex">$\texttt {CandNode} (u)$</span></span> returns for query node <em>u</em> a hash index that maps a node candidate <em>c</em> to a list of minimum subtree weights, with one weight for each of <em>c</em>’s children. (2) <span class="inline-equation"><span class="tex">$\texttt {CandEdge} (u, u^{\prime })$</span></span> returns for each query edge between a node <em>u</em> and its child <em>u</em>′ a hash index that maps a candidate node <em>c</em> of <em>u</em> to all adjacent candidates <em>c</em>′ of <em>u</em>′.</p>
        <p>We illustrate Algorithm&nbsp;1 with Figures&nbsp;3a, 3b, and 3c . It first inserts candidate nodes for each query leaf node <em>u</em> into the corresponding candidates <span class="inline-equation"><span class="tex">$\texttt {CandNode} (u)$</span></span> , setting their weights to zero (line&nbsp;2). Note that leaves do not have children, hence the NIL value in the expression. In Figure&nbsp;3a there is a single candidate per leaf, but in practice it can be a larger subset of <em>V</em> for each query leaf, depending on the node constraints. Then, for each query node <em>u</em>, the algorithm (<em>i</em>) finds possible candidate nodes, (<em>ii</em>) prunes them, and (<em>iii</em>) calculates the minimum subtree weights</p>
        <p>In more detail: (<em>i</em>) for each query edge leading to a child (<em>u</em>, <em>u</em>′), it first finds all candidate edges (<em>c</em>, <em>c</em>′), storing the map <span class="inline-equation"><span class="tex">$\texttt {CandEdge}: (u, u^{\prime }) \mapsto [c \mapsto c^{\prime }]$</span></span> (line&nbsp;8). (<em>ii</em>) Then, the algorithm only keeps the list of candidates for each query node that are <em>reachable from candidate instances in all leaves of the query node</em> (line&nbsp;11): In Figure&nbsp;3c, the list of candidates for query node <em>group1</em> is {<em>c</em> <sub>1</sub>, <em>c</em> <sub>2</sub>, <em>c</em> <sub>3</sub>}. Notice how spurious candidates not reachable from the leaves, e.g., <em>e</em> <sub>1</sub> in <em>group2</em>, are not even accessed (compare with Figure&nbsp;<a class="fig" href="#fig2">2</a>). Similarly, while <em>d</em> <sub>1</sub> in <em>user3</em> is reachable from the left, it is not reachable from the right subtree and is thus automatically pruned as well. (<em>iii</em>)&nbsp;Then, the algorithm finds for each reachable node, the min weight along each query edge (<em>u</em>, <em>u</em>′) starting at <em>c</em> (line&nbsp;16). For example, in Figure&nbsp;3c, the left weight 5 for <em>c</em> <sub>2</sub> is computed as the minimum of weights for following (<em>d</em> <sub>2</sub>, <em>c</em> <sub>2</sub>), which is 5 as the sum of the weight of edge (<em>d</em> <sub>2</sub>, <em>c</em> <sub>2</sub>) (= 2) plus the weight of <em>c</em> <sub>2</sub> (= 2+1), or for following (<em>d</em> <sub>2</sub>, <em>c</em> <sub>3</sub>), which is 7 as the sum of the weight of edge (<em>d</em> <sub>2</sub>, <em>c</em> <sub>2</sub>) (= 4) plus the weight of <em>c</em> <sub>3</sub> (= 2+1). Notice we use here <span class="inline-equation"><span class="tex">${{\rm W}{\small\rm EIGHT}} (c)$</span></span> as short form for the sum of weights at a node <em>c</em>, which we get from <tt>CandNode</tt>. The two new created indices speed up finding adjacent edges in a subtree of the query pattern during top-down traversal.</p>
      </section>
      <section id="sec-11">
        <header>
          <div class="title-info">
            <h3><span class="section-number">3.2</span> Top-Down Phase</h3>
          </div>
        </header>
        <p>The second part of our algorithm performs top-down search, starting at the root node and proceeding downward to the leaves. This is essential for two reasons: First, the pre-computed subtree weights provide information to guide the search to the lightest patterns before exploring the heavier ones. Second, the top-down traversal implicitly prunes <em>all</em> remaining spurious candidates for sub-graph homomorphism, as we will prove in Section&nbsp;<a class="sec" href="#sec-12">4</a>. Again, pruning actually happens implicitly by not reaching those candidates. To see the latter, consider <em>group1</em> candidate <em>c</em> <sub>1</sub> in Figure&nbsp;3c . It is spurious, but could not be removed by the bottom-up sweep. However, it will never be accessed during top-down traversal, because <em>d</em> <sub>1</sub> was never recorded in <tt>CandNode</tt> by Algorithm&nbsp;1 .</p>
        <p><img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186115/images/www2018-124-img2.svg" class="img-responsive" alt="" longdesc="" /></p>
        <p>Algorithm&nbsp;2 shows the pseudo-code for top-down guided search. Initially, all candidates <em>c</em> in the query root <em>r</em> are inserted into priority queue <tt>pq</tt> (line&nbsp;3), with their priorities set to the sum of the candidate's weights. In Figure&nbsp;3c, there is a single candidate, <em>d</em> <sub>2</sub>, of weight 5 + 3 = 8. Then the algorithm repeatedly pops the top element from <tt>pq</tt> and expands the partial pattern using pre-order traversal. Function <span class="inline-equation"><span class="tex">${{\rm N}{\rm\small EXT}{\rm P}{\rm \small REORDER}}$</span></span> returns the edge, as the pair of parent and child node, along which the partial pattern will be expanded next (line&nbsp;12). The priority value of each expanded partial match is defined as the sum of the pattern's edge weights plus the sum of the weights of the unexplored subtrees. In the example, partial match (<em>d</em> <sub>2</sub>, <em>c</em> <sub>2</sub>) is inserted into <tt>pq</tt> with priority 8 = 2 (edge weight) + (2+1) (weights of <em>c</em> <sub>2</sub>) + 3 (weight of right subtree of <em>d</em> <sub>2</sub>). Similarly, partial match (<em>d</em> <sub>2</sub>, <em>c</em> <sub>3</sub>) is inserted with priority 4+(2+1)+3 = 10. Note that those values are computed incrementally during traversal (line&nbsp;16). Consider expansion of (<em>d</em> <sub>2</sub>) to (<em>d</em> <sub>2</sub>, <em>c</em> <sub>3</sub>). Priority of <em>d</em> <sub>2</sub> was 8, with weight 5 for the newly expanded subtree rooted at <em>group1</em>. After retrieving <em>c</em> <sub>3</sub> from <tt>CandEdge</tt>, priority of (<em>d</em> <sub>2</sub>, <em>c</em> <sub>3</sub>) is computed as 8 (<tt>old</tt>) - 5 (newly expanded subtree) + 4 (weight of edge (<em>d</em> <sub>2</sub>, <em>c</em> <sub>3</sub>)) + 3 (priority of <em>c</em> <sub>3</sub>) = 10 (line&nbsp;16 in Alg.&nbsp;2). Then (<em>d</em> <sub>2</sub>, <em>c</em> <sub>2</sub>) is popped next, and expanded to partial match (<em>d</em> <sub>2</sub>, <em>c</em> <sub>2</sub>, <em>a</em>) with priority 8 = 8 - 2 + 2 + (0+0). This pattern is then expanded next to (<em>d</em> <sub>2</sub>, <em>c</em> <sub>2</sub>, <em>a</em>, <em>b</em>), (<em>d</em> <sub>2</sub>, <em>c</em> <sub>2</sub>, <em>a</em>, <em>b</em>, <em>e</em> <sub>2</sub>), and finally (<em>d</em> <sub>2</sub>, <em>c</em> <sub>2</sub>, <em>a</em>, <em>b</em>, <em>e</em> <sub>2</sub>, <em>f</em>)—all with the same priority of 8. The latter is output as the minimal-weight solution. Only then will partial match (<em>d</em> <sub>2</sub>, <em>c</em> <sub>3</sub>) with the higher priority value 10 be expanded analogously. Each expansion operation requires a pop operation from priority queue, visiting potential edges once.</p>
      </section>
    </section>
    <section id="sec-12">
      <header>
        <div class="title-info">
          <h2><span class="section-number">4</span> Algorithm Analysis</h2>
        </div>
      </header>
      <p>All results in this section are for the relaxed version of the problem, based on sub-graph homomorphism instead of isomorphism. We discuss in Section&nbsp;<a class="sec" href="#sec-16">5</a> how to extend them to the isomorphism case. Proofs were omitted due to space constraints, but can be found in the extended version&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0038">38</a>].</p>
      <section id="sec-13">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.1</span> Minimality of Candidate Graph</h3>
          </div>
        </header>
        <p>We show that during top-down search (Alg.&nbsp;2), no spurious candidate node will ever be accessed. A candidate node <em>c</em> for a query node <em>q</em> is “<em>spurious</em>” if there does not exist any homomorphic result pattern where <em>c</em> is matched to <em>q</em>. Ensuring that no spurious nodes are accessed is crucial for proving strong upper bounds on the algorithm cost.</p>
        <div class="theorem" id="enc7">
          <label>Theorem 4.1.</label>
          <p>If node candidate <span class="inline-equation"><span class="tex">$c \in \texttt {CandNode} (q)$</span></span> for query node <em>q</em> ∈ <em>V<sub>Q</sub></em> is accessed by Alg.&nbsp;2, then there exists a homomorphic result pattern where <em>λ</em>(<em>q</em>) = <em>c</em>.</p>
        </div>
      </section>
      <section id="sec-14">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.2</span> Each Pop, One Result—In Order</h3>
          </div>
        </header>
        <p>Next, we show a powerful result that is crucial in establishing important algorithm properties: During the top-down guided search, for each query result there is <em>at most</em> one push and <em>at most</em> one pop operation on priority queue <tt>pq</tt>. For this, we need the following lemmas.</p>
        <div class="lemma" id="enc8">
          <label>Lemma 4.2.</label>
          <p>The priority value of a partial pattern <em>P</em> is always less than or equal to the priority of all its successors.</p>
        </div>
        <div class="lemma" id="enc9">
          <label>Lemma 4.3.</label>
          <p>Assume that Alg.&nbsp;2 popped partial pattern <em>P</em> = (<em>c</em> <sub>1</sub>, <em>c</em> <sub>2</sub>, …, <em>c<sub>j</sub></em> ), <em>j</em> &lt; |<em>V<sub>Q</sub></em> |, of priority <em>w</em> from <tt>pq</tt>. Then there exists a direct successor (<em>c</em> <sub>1</sub>, <em>c</em> <sub>2</sub>, …, <em>c<sub>j</sub></em> , <em>c</em> <sub><em>j</em> + 1</sub>) that has the same priority <em>w</em>.</p>
        </div>
        <p>Lemmas&nbsp;<a class="enc" href="#enc8">4.2</a> and <a class="enc" href="#enc9">4.3</a> immediately imply:</p>
        <div class="corollary" id="enc10">
          <label>Corollary 4.4.</label>
          <p>If the last pop operation on <tt>pq</tt> returned an incomplete pattern <em>P</em>, then one of the direct successors of <em>P</em> will have priority equal to the minimum priority over all elements in <tt>pq</tt>.</p>
        </div>
        <div class="example" id="enc11">
          <label>Example 4.5.</label>
          <p>Consider the changes of <tt>pq</tt> for the example in Figure&nbsp;3c . Initially it contains [(<em>d</em> <sub>2</sub>): 8], the sole root node candidate with priority 5+3=8. This element is popped and expanded along edges (<em>d</em> <sub>2</sub>, <em>c</em> <sub>2</sub>) and (<em>d</em> <sub>2</sub>, <em>c</em> <sub>3</sub>). The priority of the former is 2 (weight of edge (<em>d</em> <sub>2</sub>, <em>c</em> <sub>2</sub>)) plus (2+1) (subtree weights of <em>c</em> <sub>2</sub>) plus 3 (right subtree weight of <em>d</em> <sub>2</sub>) = 8. It is identical to the initial priority of <em>d</em> <sub>2</sub>, because edge (<em>d</em> <sub>2</sub>, <em>c</em> <sub>2</sub>) is the one that determined the minimum left subtree weight of 5 in <em>d</em> <sub>2</sub>. For (<em>d</em> <sub>2</sub>, <em>c</em> <sub>3</sub>), priority is 10 due to the higher weight of edge (<em>d</em> <sub>2</sub>, <em>c</em> <sub>3</sub>). After these two patterns are pushed, <tt>pq</tt> contains [(<em>d</em> <sub>2</sub>, <em>c</em> <sub>2</sub>): 8, (<em>d</em> <sub>2</sub>, <em>c</em> <sub>3</sub>): 10]. The next pop delivers (<em>d</em> <sub>2</sub>, <em>c</em> <sub>2</sub>): 8, which is expanded to (<em>d</em> <sub>2</sub>, <em>c</em> <sub>2</sub>, <em>a</em>): 8, followed by repeated pop and push operations on this pattern, every time obtaining the same priority of 8, until the top result (<em>d</em> <sub>2</sub>, <em>c</em> <sub>2</sub>, <em>a</em>, <em>b</em>, <em>e</em> <sub>2</sub>, <em>f</em>) of weight 8 is completed. Only then will expansion of (<em>d</em> <sub>2</sub>, <em>c</em> <sub>3</sub>): 10 commence.</p>
        </div>
        <p><strong>Front-element optimization.</strong> Based on Corollary&nbsp;<a class="enc" href="#enc10">4.4</a>, we next introduce an important optimization to Alg.&nbsp;2 . Since the corollary guarantees that one of the direct successors of the partial pattern popped before will have a minimal priority value, we avoid the push-pop cycle for it and keep expanding it directly, only pushing the other direct successors. More precisely, assume the algorithm just popped partial match <em>P</em> = (<em>c</em> <sub>1</sub>, <em>c</em> <sub>2</sub>, …, <em>c<sub>i</sub></em> ) of priority <em>w</em> from <tt>pq</tt>. While expanding this pattern by one more node, it keeps in memory the first direct successor <span class="inline-equation"><span class="tex">$P^{\prime }=(c_1, c_2,\ldots , c_i, c^{\prime }_{i+1})$</span></span> encountered that also has priority value <em>w</em>, pushing all other direct successors to <tt>pq</tt>. This way the algorithm still works on a min-priority element, but avoids the push-pop cycle for it. This seemingly minor optimization has strong implications as formalized in the following theorems.</p>
        <div class="theorem" id="enc12">
          <label>Theorem 4.6.</label>
          <p>Using front-element optimization, for any <em>k</em>, the <em>k</em>-th pop operation from <tt>pq</tt> produces the <em>k</em>-th lightest homomorphic result pattern, possibly requiring additional push operations, but no more pop operations until this result pattern is returned.</p>
        </div>
        <div class="corollary" id="enc13">
          <label>Corollary 4.7.</label>
          <p>No matter how many results are retrieved, Alg.&nbsp;2 never performs more than <em>r<sub>H</sub></em> push operations on <tt>pq</tt> <em>in total</em>. Here <em>r<sub>H</sub></em> denotes the number of homomorphic subtrees in <em>G</em>.</p>
        </div>
        <p>This follows directly from Theorem&nbsp;<a class="enc" href="#enc12">4.6</a> and the following observation. Assume the algorithm continues to run until all query results are found. At that point it has removed all partial matches from <tt>pq</tt> and the queue is empty. Theorem&nbsp;<a class="enc" href="#enc12">4.6</a> implies that retrieving all results requires exactly <em>r<sub>H</sub></em> pop operations. If the total number of push operations exceeded this, then the queue would not be empty. (And obviously, any execution of Alg.&nbsp;2 that stops before returning all results will only have performed a subset of the push operations executed by the time all results are returned.)</p>
      </section>
      <section id="sec-15">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.3</span> Algorithm Cost</h3>
          </div>
        </header>
        <p>To avoid notational clutter, we treat the size of the query pattern as a small constant and omit it from most formulas. (Note that pattern size is equal to the number of edges in <em>E<sub>Q</sub></em> , e.g., 5 in the photo-sharing network example.) It is straightforward to extend the formulas by including |<em>E<sub>Q</sub></em> | as a variable.</p>
        <p><strong>Algorithm&nbsp;1 .</strong> Theoretical worst case cost is O(|<em>E</em>|), i.e., linear in graph size: for each of the query pattern edges, in the worst case all graph edges are accessed. The time for constructing <span class="inline-equation"><span class="tex">$\texttt {CandEdge}$</span></span> and <span class="inline-equation"><span class="tex">$\texttt {CandNode}$</span></span> adds a constant overhead per edge processed. In practice, only a small fraction of <em>E</em> will be accessed because of the label constraints. In particular, by using <span class="inline-equation"><span class="tex">$\texttt {GraphEdge}$</span></span> in line&nbsp;8 in Alg.&nbsp;1, all neighbors of matching types (labels) are accessed in time linear in the number of these neighbors. Space cost is upper bounded by the combined size of <span class="inline-equation"><span class="tex">$\texttt {CandNode}$</span></span> and <span class="inline-equation"><span class="tex">$\texttt {CandEdge}$</span></span> , i.e., cannot exceed |<em>E<sub>Q</sub></em> | times input graph size.</p>
        <p><strong>Algorithm&nbsp;2 .</strong> The results from Section&nbsp;<a class="sec" href="#sec-14">4.2</a> lead to strong guarantees. Space complexity of Alg.&nbsp;2 is equal to the maximum size of the priority queue. Corollary&nbsp;<a class="enc" href="#enc13">4.7</a> immediately implies:</p>
        <div class="theorem" id="enc14">
          <label>Theorem 4.8.</label>
          <p>Space cost of Alg.&nbsp;2 is upper bounded by <em>r<sub>H</sub></em> , the total result size for sub-graph homomorphism.</p>
        </div>
        <p>From a user's point of view, the time it takes to produce the next lower-ranked result is crucial:</p>
        <div class="theorem" id="enc15">
          <label>Theorem 4.9.</label>
          <p>The initial latency for Alg.&nbsp;2 to return the top-ranked homomorphic match, and also the time between returning any two consecutive homomorphic matches, is O(outDegree + log <em>r<sub>H</sub></em> ). Here outDegree ≤ <em>r<sub>H</sub></em> is the maximum cardinality of the set of adjacent node candidates <em>c</em>′ in <span class="inline-equation"><span class="tex">$\texttt {CandEdge}: (u, u^{\prime }) \mapsto [c \mapsto \lbrace (c^{\prime }, w(c, c^{\prime }))\rbrace ]$</span></span> for any query graph edge (<em>u</em>, <em>u</em>′) and candidate <em>c</em>.</p>
        </div>
        <p>These strong results show that KARPET can effectively exploit selective label constraints. For instance, if there are a thousand homomorphic subgraphs in <em>G</em>, then Theorems&nbsp;<a class="enc" href="#enc14">4.8</a> and <a class="enc" href="#enc15">4.9</a> guarantee that Alg.&nbsp;2 will never store more than a thousand partial matches in memory and will perform at most a thousand (inexpensive) computation steps to deliver the next result to the user—no matter how big or connected the given graph!</p>
        <p>We show next that the anytime property of KARPET, i.e., that it can deliver the top-ranked results quickly and then the next ones on request, incurs <em>no performance penalty</em> for producing <em>all</em> homomorphic matches:</p>
        <div class="theorem" id="enc16">
          <label>Theorem 4.10.</label>
          <p>The lower bound for producing <em>all</em> homomorphic result patterns is <em>Ω</em>(<em>r<sub>H</sub></em> ); sorting them costs O(<em>r<sub>H</sub></em> log <em>r<sub>H</sub></em> ). Alg.&nbsp;2 has matching total time complexity O(<em>r<sub>H</sub></em> log <em>r<sub>H</sub></em> ).</p>
        </div>
      </section>
    </section>
    <section id="sec-16">
      <header>
        <div class="title-info">
          <h2><span class="section-number">5</span> Homomorphism to Isomorphism</h2>
        </div>
      </header>
      <p>KARPET as introduced in Section&nbsp;<a class="sec" href="#sec-9">3</a> returns homomorphic matches. To obtain the desired isomorphic matches, function <em>λ</em> mapping query nodes to tree-pattern nodes has to be bijective. To guarantee this, one simply has to filter out all results where different query nodes are mapped to the same graph node. Instead of filtering on the final result, KARPET can perform early pruning by checking in line&nbsp;15 in Alg.&nbsp;2 if newly added node <em>c</em>′ already appears in partial match <em>Z</em>—discarding <em>Z</em>′ if it does. This modification has the following implications for the cost analysis results in Section&nbsp;<a class="sec" href="#sec-15">4.3</a>.</p>
      <p>Since some of the items previously pushed to priority queue <tt>pq</tt> will now be discarded early, space consumption as well as computation cost of KARPET are lower than for finding all subgraph homomorphism results. However, worst-case complexity as established by Theorems&nbsp;<a class="enc" href="#enc14">4.8</a> and <a class="enc" href="#enc16">4.10</a> remains the same. And the guarantees for the time between results (Theorem&nbsp;<a class="enc" href="#enc15">4.9</a>) is weaker: In the worst case, e.g., when only the very first and the very last of the homomorphic matches represent isomorphic results, then time between consecutive results grows from O(outDegree + log <em>r<sub>H</sub></em> ) to O(<em>r<sub>H</sub></em> log <em>r<sub>H</sub></em> ). Fortunately, as our experiments indicate, heterogeneity indeed results in a small gap between homomorphism and isomorphism, i.e., real-world performance is closer to O(outDegree + log <em>r<sub>H</sub></em> ).</p>
    </section>
    <section id="sec-17">
      <header>
        <div class="title-info">
          <h2><span class="section-number">6</span> Experiments</h2>
        </div>
      </header>
      <p>Our experiments evaluate running time, memory consumption, and size of the search space explored by <em>KARPET</em> on several query templates and four data sets against two baseline algorithms. In order to allow reproducible results, our code can be downloaded from our project page&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0002">2</a>].</p>
      <p><strong>Baseline algorithms.</strong> We chose two baselines that allow us to evaluate the relative contribution of our two key steps (pruning the search space, and guided search) to the performance of <em>KARPET</em>.</p>
      <p><em>Unguided</em> first calculates all results from the candidate graph and only then ranks them. Since it uses our pruned search space, but does not include any prioritizing of query results, it serves as a baseline to evaluate the contribution of our guided search phase.</p>
      <p><em>Backbone</em> is intended to evaluate the effect of our aggressive tree-based pruning strategy. It extends the state-of-art top-<em>k</em> algorithm for <em>path</em> queries on HINs&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0027">27</a>]. First, it identifies the longest terminal-to-terminal path <em>R</em> in the tree pattern <em>Q</em> (called the “<em>backbone</em>” of <em>Q</em>). It then incrementally retrieves the lightest backbone instances in <em>G</em> one-by-one. Note that such an instance is a partial match with smaller unmapped subtrees “hanging off” the backbone path. Thus, we can execute Unguided on each such subpattern, yielding a divide and conquer algorithm. Since each subpattern is independent, we extract the lightest instance of each subpattern, and merge these solutions with the backbone instance. This involves checking for repeat node occurrences to enforce isomorphism. Then the next heavier subtree matches are explored etc. Given a pre-defined value of <em>k</em>, the algorithm can prune the set of remaining backbone instances every time a new full match is found. <em>In all our experiments, we supply the ultimate value of <em>k</em> to Backbone, to explore the best possible performance this algorithm might achieve (if it was able to guess the correct value of <em>k</em> from the start).</em></p>
      <p><strong>Datasets.</strong> We use four well-known heterogeneous datasets: Flickr [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0003">3</a>], DBLP [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0027">27</a>], Enron [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0027">27</a>], and Yelp [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0001">1</a>]. Figure&nbsp;<a class="fig" href="#fig4">4</a> gives an overview of their properties. Notice that Enron, DBLP and Flickr have denser graphs than Yelp. In order to create weights for individual edges, we used the age of the edge with an exponential decay based on the difference between edge creation time and query time.</p>
      <figure id="fig4">
        <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186115/images/www2018-124-fig4.svg" class="img-responsive" alt="Figure 4" longdesc="" />
        <div class="figure-caption">
          <span class="figure-number">Figure 4:</span> <span class="figure-title">Dataset statistics.</span>
        </div>
      </figure>
      <p></p>
      <p><strong>Query templates.</strong> We created five different pattern <em>templates</em> listed in Fig.&nbsp;<a class="fig" href="#fig5">5</a>. For each pattern, we chose 300 different assignments of actual nodes to the query leaves, which gave us 300 queries per template, for a total of 6,000 query instances across all datasets.</p>
      <figure id="fig5">
        <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186115/images/www2018-124-fig5.png" class="img-responsive" alt="Figure 5" longdesc="" />
        <div class="figure-caption">
          <span class="figure-number">Figure 5:</span> <span class="figure-title">Templates used to generate queries for each dataset. Shapes indicate node types; the cyan-colored nodes are terminals.</span>
        </div>
      </figure>
      <p></p>
      <p><strong>Performance metrics.</strong> We vary <em>k</em> between 1 and total number of results, and compare the algorithms on three performance metrics. 1) <em>Running time</em>: We measure the time between having loaded the dataset into memory and returning the k-th result, reporting the average for each template. 2) <em>Memory consumption</em>: We report the <em>maximum</em> number of nodes (i.e., partial matches weighted by the number of matched nodes they contain) stored at any time during the execution of each algorithm. 3) <em>Size of search space</em>: We report the <em>total</em> number of partial matches (weighted by the number of matched nodes they contain) that are stored during execution.</p>
      <p><strong>Experimental setup.</strong> Experiments were run on an Intel Xeon CPU E5-2440 1.90GHz with 200GB of memory running Linux. We compiled the source code with <tt>g++</tt> 4.8 (optimization flag <tt>O2</tt>).</p>
      <section id="sec-18">
        <header>
          <div class="title-info">
            <h3><span class="section-number">6.1</span> <strong>Discussion and Highlights</strong></h3>
          </div>
        </header>
        <p>To justify our “solving isomorphism through homomorphism” approach, we also ran KARPET with node-repetition check turned off. This produces all homomorphic matches, from which we can then determine offline how many were also results for the isomorphism case. We plot both numbers as we increase <em>k</em> in Figure&nbsp;<a class="fig" href="#fig6">6</a>. It shows a representative result, obtained from the Enron dataset using a query from Template&nbsp;1. The small gap between the lines confirms that the vast majority of homomorphic matches are also isomorphic result patterns.</p>
        <figure id="fig6">
          <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186115/images/www2018-124-fig6.png" class="img-responsive" alt="Figure 6" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 6:</span> <span class="figure-title">Number of isomorphic and homomorphic matches for an instance of Template 1 on the Enron dataset.</span>
          </div>
        </figure>
        <figure id="fig7">
          <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186115/images/www2018-124-fig7.png" class="img-responsive" alt="Figure 7" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 7:</span> <span class="figure-title">Running time for increasing k until all results are returned, for KARPET and Unguided.</span>
          </div>
        </figure>
        <p></p>
        <p>Figure&nbsp;<a class="fig" href="#fig7">7</a> shows a representative result comparing KARPET to Unguided, which bulk-computes the entire output and hence is not affected by the choice of <em>k</em>. It is clearly visible how our any-<em>k</em> algorithm continuously returns the top-ranked results in order, with very low latency between consecutive outputs. By the time Unguided finally returns the first match, KARPET has already delivered more than 85% of all matches. In the end, it took KARPET 4.98s to output <em>all</em> matches. For comparison, bulk-computation by Unguided took 4.31s, indicating a small overhead of 0.67s for supporting the anytime property.</p>
        <div class="table-responsive" id="tab2">
          <div class="table-caption">
            <span class="table-number">Table 2:</span> <span class="table-title">Average running time (milliseconds) for each dataset, algorithm, and template. Cells with the least running time in the three algorithms are marked gray.</span>
          </div>
          <table class="table">
            <thead>
              <tr>
                <th style="text-align:left;">Data</th>
                <th style="text-align:left;">Algorithm</th>
                <th style="text-align:right;">T1</th>
                <th style="text-align:right;">T2</th>
                <th style="text-align:right;">T3</th>
                <th style="text-align:right;">T4</th>
                <th style="text-align:right;">T5</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">KARPET</td>
                <td style="text-align:right;">43.86 .8</td>
                <td style="text-align:right;">58.17 .8</td>
                <td style="text-align:right;">99.28 .8</td>
                <td style="text-align:right;">20.12 .8</td>
                <td style="text-align:right;">81.92 .8</td>
              </tr>
              <tr>
                <td style="text-align:left;">Flickr</td>
                <td style="text-align:left;">Unguided</td>
                <td style="text-align:right;">2200</td>
                <td style="text-align:right;">2085</td>
                <td style="text-align:right;">5951</td>
                <td style="text-align:right;">2021</td>
                <td style="text-align:right;">5518</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">Backbone</td>
                <td style="text-align:right;">2946</td>
                <td style="text-align:right;">9678</td>
                <td style="text-align:right;">3033</td>
                <td style="text-align:right;">4114</td>
                <td style="text-align:right;">9963</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">KARPET</td>
                <td style="text-align:right;">9.51 .8</td>
                <td style="text-align:right;">8.87 .8</td>
                <td style="text-align:right;">104.33.8</td>
                <td style="text-align:right;">8.67.8</td>
                <td style="text-align:right;">8.15 .8</td>
              </tr>
              <tr>
                <td style="text-align:left;">DBLP</td>
                <td style="text-align:left;">Unguided</td>
                <td style="text-align:right;">1090</td>
                <td style="text-align:right;">1936</td>
                <td style="text-align:right;">1995</td>
                <td style="text-align:right;">814</td>
                <td style="text-align:right;">1110</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">Backbone</td>
                <td style="text-align:right;">839</td>
                <td style="text-align:right;">502</td>
                <td style="text-align:right;">337</td>
                <td style="text-align:right;">1109</td>
                <td style="text-align:right;">1059</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">KARPET</td>
                <td style="text-align:right;">10 .8</td>
                <td style="text-align:right;">57.8</td>
                <td style="text-align:right;">29.8</td>
                <td style="text-align:right;">57 .8</td>
                <td style="text-align:right;">104.8</td>
              </tr>
              <tr>
                <td style="text-align:left;">Enron</td>
                <td style="text-align:left;">Unguided</td>
                <td style="text-align:right;">202</td>
                <td style="text-align:right;">1036</td>
                <td style="text-align:right;">1013</td>
                <td style="text-align:right;">669</td>
                <td style="text-align:right;">891</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">Backbone</td>
                <td style="text-align:right;">4914</td>
                <td style="text-align:right;">18925</td>
                <td style="text-align:right;">5124</td>
                <td style="text-align:right;">7056</td>
                <td style="text-align:right;">11075</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">KARPET</td>
                <td style="text-align:right;">0.11.8</td>
                <td style="text-align:right;">0.13 .8</td>
                <td style="text-align:right;">0.78 .8</td>
                <td style="text-align:right;">0.20.8</td>
                <td style="text-align:right;">0.15.8</td>
              </tr>
              <tr>
                <td style="text-align:left;">Yelp</td>
                <td style="text-align:left;">Unguided</td>
                <td style="text-align:right;">1.68</td>
                <td style="text-align:right;">1.79</td>
                <td style="text-align:right;">2.27</td>
                <td style="text-align:right;">1.40</td>
                <td style="text-align:right;">2.06</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">Backbone</td>
                <td style="text-align:right;">3.84</td>
                <td style="text-align:right;">3.53</td>
                <td style="text-align:right;">1.02</td>
                <td style="text-align:right;">3.82</td>
                <td style="text-align:right;">3.02</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="table-responsive" id="tab3">
          <div class="table-caption">
            <span class="table-number">Table 3:</span> <span class="table-title">Average memory measured by the max number of nodes stored, for each dataset, algorithm, and template. Cells using the least memory are marked gray.</span>
          </div>
          <table class="table">
            <thead>
              <tr>
                <th style="text-align:left;">Data</th>
                <th style="text-align:left;">Algorithm</th>
                <th style="text-align:right;">T1</th>
                <th style="text-align:right;">T2</th>
                <th style="text-align:right;">T3</th>
                <th style="text-align:right;">T4</th>
                <th style="text-align:right;">T5</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td style="text-align:left;">Data</td>
                <td style="text-align:left;">Algorithm</td>
                <td style="text-align:right;">T1</td>
                <td style="text-align:right;">T2</td>
                <td style="text-align:right;">T3</td>
                <td style="text-align:right;">T4</td>
                <td style="text-align:right;">T5</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">KARPET</td>
                <td style="text-align:right;">278 .8</td>
                <td style="text-align:right;">286</td>
                <td style="text-align:right;">1212</td>
                <td style="text-align:right;">458 .8</td>
                <td style="text-align:right;">1957</td>
              </tr>
              <tr>
                <td style="text-align:left;">Flickr</td>
                <td style="text-align:left;">Unguided</td>
                <td style="text-align:right;">1212</td>
                <td style="text-align:right;">294</td>
                <td style="text-align:right;">17560</td>
                <td style="text-align:right;">833</td>
                <td style="text-align:right;">61603</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">Backbone</td>
                <td style="text-align:right;">460</td>
                <td style="text-align:right;">139.8</td>
                <td style="text-align:right;">76 .8</td>
                <td style="text-align:right;">939</td>
                <td style="text-align:right;">1057 .8</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">KARPET</td>
                <td style="text-align:right;">162</td>
                <td style="text-align:right;">146</td>
                <td style="text-align:right;">387</td>
                <td style="text-align:right;">251</td>
                <td style="text-align:right;">253</td>
              </tr>
              <tr>
                <td style="text-align:left;">DBLP</td>
                <td style="text-align:left;">Unguided</td>
                <td style="text-align:right;">162</td>
                <td style="text-align:right;">146</td>
                <td style="text-align:right;">409</td>
                <td style="text-align:right;">251</td>
                <td style="text-align:right;">253</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">Backbone</td>
                <td style="text-align:right;">29.8</td>
                <td style="text-align:right;">35.8</td>
                <td style="text-align:right;">26 .8</td>
                <td style="text-align:right;">72.8</td>
                <td style="text-align:right;">103.8</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">KARPET</td>
                <td style="text-align:right;">459</td>
                <td style="text-align:right;">676</td>
                <td style="text-align:right;">546</td>
                <td style="text-align:right;">727</td>
                <td style="text-align:right;">713</td>
              </tr>
              <tr>
                <td style="text-align:left;">Enron</td>
                <td style="text-align:left;">Unguided</td>
                <td style="text-align:right;">477</td>
                <td style="text-align:right;">697</td>
                <td style="text-align:right;">569</td>
                <td style="text-align:right;">745</td>
                <td style="text-align:right;">728</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">Backbone</td>
                <td style="text-align:right;">188 .8</td>
                <td style="text-align:right;">109 .8</td>
                <td style="text-align:right;">11 .8</td>
                <td style="text-align:right;">168.8</td>
                <td style="text-align:right;">87 .8</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">KARPET</td>
                <td style="text-align:right;">1.02</td>
                <td style="text-align:right;">1.02</td>
                <td style="text-align:right;">1.36</td>
                <td style="text-align:right;">1.01</td>
                <td style="text-align:right;">1.02</td>
              </tr>
              <tr>
                <td style="text-align:left;">Yelp</td>
                <td style="text-align:left;">Unguided</td>
                <td style="text-align:right;">1.02</td>
                <td style="text-align:right;">1.02</td>
                <td style="text-align:right;">1.36</td>
                <td style="text-align:right;">1.01</td>
                <td style="text-align:right;">1.02</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">Backbone</td>
                <td style="text-align:right;">1.03</td>
                <td style="text-align:right;">1.02</td>
                <td style="text-align:right;">1.00.8</td>
                <td style="text-align:right;">1.01</td>
                <td style="text-align:right;">1.02</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="table-responsive" id="tab4">
          <div class="table-caption">
            <span class="table-number">Table 4:</span> <span class="table-title">Average search space measured by weighted total number of partial matches, for each dataset, algorithm, and template. Cells exploring the least search space are marked gray.</span>
          </div>
          <table class="table">
            <thead>
              <tr>
                <th style="text-align:left;">Data</th>
                <th style="text-align:left;">Algorithm</th>
                <th style="text-align:right;">T1</th>
                <th style="text-align:right;">T2</th>
                <th style="text-align:right;">T3</th>
                <th style="text-align:right;">T4</th>
                <th style="text-align:right;">T5</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">KARPET</td>
                <td style="text-align:right;">1.16-e6 .8</td>
                <td style="text-align:right;">1.18-e6 .8</td>
                <td style="text-align:right;">9.29-e5 .8</td>
                <td style="text-align:right;">1.12-e4 .8</td>
                <td style="text-align:right;">1.56-e6 .8</td>
              </tr>
              <tr>
                <td style="text-align:left;">Flickr</td>
                <td style="text-align:left;">Unguided</td>
                <td style="text-align:right;">5.41-e6</td>
                <td style="text-align:right;">1.55-e6</td>
                <td style="text-align:right;">1.96-e7</td>
                <td style="text-align:right;">1.52-e5</td>
                <td style="text-align:right;">2.20-e7</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">Backbone</td>
                <td style="text-align:right;">5.37-e6</td>
                <td style="text-align:right;">1.99-e6</td>
                <td style="text-align:right;">1.16-e6</td>
                <td style="text-align:right;">1.02-e7</td>
                <td style="text-align:right;">8.04-e6</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">KARPET</td>
                <td style="text-align:right;">4.84-e4 .8</td>
                <td style="text-align:right;">3.98-e4 .8</td>
                <td style="text-align:right;">5.48-e4 .8</td>
                <td style="text-align:right;">9.35-e4 .8</td>
                <td style="text-align:right;">4.55-e4 .8</td>
              </tr>
              <tr>
                <td style="text-align:left;">DBLP</td>
                <td style="text-align:left;">Unguided</td>
                <td style="text-align:right;">7.25-e5</td>
                <td style="text-align:right;">3.35-e5</td>
                <td style="text-align:right;">1.58-e6</td>
                <td style="text-align:right;">2.16-e5</td>
                <td style="text-align:right;">8.91-e5</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">Backbone</td>
                <td style="text-align:right;">4.64-e5</td>
                <td style="text-align:right;">1.68-e5</td>
                <td style="text-align:right;">2.91-e5</td>
                <td style="text-align:right;">9.38-e5</td>
                <td style="text-align:right;">9.57-e5</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">KARPET</td>
                <td style="text-align:right;">4.22-e4 .8</td>
                <td style="text-align:right;">1.13-e5 .8</td>
                <td style="text-align:right;">7.39-e4 .8</td>
                <td style="text-align:right;">1.29-e4 .8</td>
                <td style="text-align:right;">3.52-e4 .8</td>
              </tr>
              <tr>
                <td style="text-align:left;">Enron</td>
                <td style="text-align:left;">Unguided</td>
                <td style="text-align:right;">8.41-e5</td>
                <td style="text-align:right;">9.50-e5</td>
                <td style="text-align:right;">9.11-e5</td>
                <td style="text-align:right;">8.93-e5</td>
                <td style="text-align:right;">8.60-e5</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">Backbone</td>
                <td style="text-align:right;">1.31-e6</td>
                <td style="text-align:right;">8.86-e5</td>
                <td style="text-align:right;">1.39-e6</td>
                <td style="text-align:right;">3.07-e5</td>
                <td style="text-align:right;">5.74-e5</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">KARPET</td>
                <td style="text-align:right;">58</td>
                <td style="text-align:right;">99 .8</td>
                <td style="text-align:right;">191</td>
                <td style="text-align:right;">51</td>
                <td style="text-align:right;">104</td>
              </tr>
              <tr>
                <td style="text-align:left;">Yelp</td>
                <td style="text-align:left;">Unguided</td>
                <td style="text-align:right;">58</td>
                <td style="text-align:right;">99</td>
                <td style="text-align:right;">233</td>
                <td style="text-align:right;">51</td>
                <td style="text-align:right;">104</td>
              </tr>
              <tr>
                <td style="text-align:left;"></td>
                <td style="text-align:left;">Backbone</td>
                <td style="text-align:right;">45 .8</td>
                <td style="text-align:right;">100</td>
                <td style="text-align:right;">17 .8</td>
                <td style="text-align:right;">48 .8</td>
                <td style="text-align:right;">62 .8</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>For each template (fixing <em>k</em> = 5) we show the average running time, memory usage, and search space of our algorithm, along with the two baselines, on all four datasets in Tables&nbsp;<a class="tbl" href="#tab2">2</a>, <a class="tbl" href="#tab3">3</a>, and <a class="tbl" href="#tab4">4</a>. In terms of average running time, KARPET outperforms the baselines in all cases. On DBLP, we can see 100x faster running time compared to Unguided, and 10x speedup compared to Backbone. We make the following detailed observations about these results.</p>
        <section id="sec-19">
          <header>
            <div class="title-info">
              <h4><span class="section-number">6.1.1</span> <strong>Varying the Dataset</strong></h4>
            </div>
          </header>
          <p>We observed that KARPET's margin of improvement over the baselines is generally greater on denser graphs. Higher density leads to more matches, which KARPET can handle best, because it prioritizes the search based on subtree weight more effectively than the two baselines. The <tt>Yelp</tt> graph is extremely sparse, causing many queries to have only one or two matches. For those queries, all three algorithms behave nearly identically, e.g., running time for a typical single-match query on <tt>Yelp</tt> was 0.15 msec for KARPET, 0.2 msec for Unguided, and 0.16 msec for Backbone. However, even for this sparse graph, there are several queries for each pattern that have a larger number of candidate instances. These result in a significantly slower average running time for both baselines, while KARPET averages to less than 1 msec.</p>
          <p>Backbone does relatively well compared to Unguided on the larger dataset DBLP, and is the same order of magnitude for Flickr, but fails to perform well on Enron. For dense graphs, if the branch-and-bound does not terminate quickly, the overhead required by the divide-and-conquer merging steps can be very large because the same subtree may be visited multiple times.</p>
        </section>
        <section id="sec-20">
          <header>
            <div class="title-info">
              <h4><span class="section-number">6.1.2</span> <strong>Memory</strong></h4>
            </div>
          </header>
          <p>The backbone-based algorithm often uses the least amount of memory, because in each iteration, it only holds the backbone matches and the single instance of the backbone it grows. The memory bottleneck for Unguided is the amount of storage needed to hold all matching trees when they are sorted by weight.</p>
        </section>
        <section id="sec-21">
          <header>
            <div class="title-info">
              <h4><span class="section-number">6.1.3</span> <strong>Relative Strengths and Weaknesses</strong></h4>
            </div>
          </header>
          <p>For “easy” queries, which only have a few matching instances, all three approaches show similar running time. On the other hand, when a query has to select the top-<em>k</em> from a larger result set, e.g., dozens or 100s of results, KARPET has a significant advantage from efficiently pruning the search space at an earlier stage. For such “hard” queries, Unguided enumerates all matching instances before sorting them. Backbone only partially exploits pruning opportunities for the backbone. The non-trivial extensions proposed for KARPET are required to fully benefit from the constraints encoded by the entire tree structure.</p>
          <p>Backbone can exhibit faster running times than Unguided in some cases. It achieves this speed-up due to its branch-and-bound nature, filtering out instances that exceed the threshold established by matches for the lightest backbones explored early on. (Note that this type of pruning takes advantage of advance knowledge of the final value of <em>k</em>. In practice, the algorithm would not know <em>k</em> and hence could not apply any such pruning.) Either way, in most cases, this advantage is outweighed by the fact that Backbone introduces an overhead for merging subtrees and repeatedly visiting some of the subtrees.</p>
        </section>
      </section>
    </section>
    <section id="sec-22">
      <header>
        <div class="title-info">
          <h2><span class="section-number">7</span> Related Work</h2>
        </div>
      </header>
      <p>Our proposed notion of an any-<em>k</em> algorithm is novel and extends the functionality of the previously-studied class of top-<em>k</em> algorithms. The problem of fast graph pattern search has been studied in different research communities, such as algorithms, graph databases, and data mining. While traditional data mining and work in theory focuses on the structure of the graph, meta-path based approaches&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0034">34</a>] also leverage the type information.</p>
      <p><strong>Subgraph isomorphism.</strong> Subgraph isomorphism is an NP-hard problem&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0028">28</a>], and state-of-art algorithms are not practical for large graphs. Lee <em>et al.</em> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0026">26</a>] empirically compare the performance of several state-of-art subgraph isomorphism algorithms, including the Generic Subgraph Isomorphism Algorithm&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0011">11</a>], Ullmann algorithm&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0036">36</a>], VF2&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0010">10</a>], QuickSI&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0033">33</a>], GADDI&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0041">41</a>], and GraphQL&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0017">17</a>]. They test on real-world datasets AIDS, NASA, Yeast and Human, covering a spectrum of relatively small graphs (|<em>V</em>| &lt; 1000). Modern social networks easily exceed that size by orders of magnitude, and the exact sub-graph isomorphism problem remains intractable for larger networks when label constraints and top-<em>k</em> are not fully exploited. Hence, to the best of our knowledge, none of these existing <em>precise</em> pattern matching algorithms could be used for our target application.</p>
      <p><strong>K-shortest simple paths.</strong> The <em>k</em>-shortest paths problem is a natural and long-studied generalization of the shortest path problem, in which not one but several paths in increasing order of length are sought. The additional constraint of “simple” paths requires that the paths be without loops. This problem has been researched for directed graphs&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0040">40</a>], undirected graphs&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0023">23</a>], approximation algorithms&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0032">32</a>], and algorithm engineering&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0015">15</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0018">18</a>]. However, this body of literature was developed for graphs without labels. In contrast, KARPET efficiently finds <em>k</em>-lightest instances matching a given query pattern by leveraging the heterogeneity constraints on the node and edge types to speed up the computation. Furthermore, in our scenario, <em>k</em> is not known upfront.</p>
      <p><strong>Querying graph data.</strong> In the database community, querying and managing of large-scale graph data has been studied&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0005">5</a>], <em>e.g.,</em> in the context of GIS, XML databases, bioinformatics, social networks, and ontologies. The main focus there has been on identifying connection patterns between the graph vertices&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0009">9</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0014">14</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0022">22</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0031">31</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0035">35</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0037">37</a>]. In contrast, KARPET finds matches for a given query pattern.</p>
      <p><strong>HINs and path patterns.</strong> Heterogeneous Information Networks (HINs)&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0016">16</a>] are an abstraction to represent graphs whose nodes are affiliated with different types. To derive complex relations from such information networks, “meta-paths” defined as node-typed paths on a heterogeneous network, are a representation of connections between nodes, by specifying the types along a path in the network&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0034">34</a>]. Thus, while the focus in that line of research has been on learning good meta-path patterns for various applications, KARPET efficiently finds matches for a given query pattern.</p>
      <p>Liang <em>et al.</em> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0027">27</a>] derived a top-k algorithm for ranking path patterns in HINs. However, their algorithm does not easily extend to more complicated patterns such as trees; our Backbone baseline attempts to adapt their algorithm for ranking tree patterns, and our experiments shows a considerable advantage of KARPET.</p>
      <p><strong>Top-k query evaluation in databases.</strong> There is considerable amount of work on top-k queries in a ranking environment&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0006">6</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0013">13</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0021">21</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0029">29</a>]. This work aims at minimizing I/O cost by trading sorted access vs. random access to data. In contrast to that body of work, we focus on main memory applications and a different cost model.</p>
      <p><strong>Graph search on RDFs and XML.</strong> Top-<em>k</em> keyword search algorithms for XML databases&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0008">8</a>] combine semantic pruning based on document structure encoding with top-<em>k</em> join algorithms from relational databases. The main challenge lies in dealing with query semantics based on least common ancestors. RDF is a flexible and extensible way to represent information about World Wide Web resources. Searching for a pattern on RDFs can be represented in SPARQL, and can be applied to ontology matching&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0012">12</a>]. Recent work on graph pattern matching in RDF databases&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0007">7</a>, Chapter 2] has resulted in several different approaches to database layout&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0007">7</a>, Chapter 3]. However, as in the case of top-<em>k</em> query evaluation, it appears that more focus has been placed on scalability issues, such as replication, parallelization, and distribution of workloads&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0019">19</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0020">20</a>], as RDF datasets are often too large for a single machine. It is well known that SPARQL is descriptive enough to capture graph pattern matching queries (so-called basic graph patterns&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0007">7</a>, Chapter 2]), and these queries are typically decomposed into combinations of database primitive operations such as joins, unions, difference, etc.&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0007">7</a>, Page 23]. Although work has been done optimizing these primitive operations in the context of graph patterns for certain types of queries that appear in practice&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0030">30</a>], we are not aware of a similar approach to KARPET being employed for general tree patterns in the context of RDF.</p>
    </section>
    <section id="sec-23">
      <header>
        <div class="title-info">
          <h2><span class="section-number">8</span> Conclusion</h2>
        </div>
      </header>
      <p>We proposed KARPET for finding tree patterns in labeled graphs, e.g., heterogeneous information networks. Compared to previous work, it combines two unique properties. First, it is a top-<em>k</em> anytime algorithm, in the sense that it quickly returns the top-ranked results, then incrementally delivers more on request. This is achieved without sacrificing performance for full-result retrieval compared to bulk-computation. Second, while being subject to the same general hardness of graph isomorphism, KARPET aggressively exploits the special properties of HINs. We demonstrate this by proving surprisingly strong theoretical guarantees that connect space and time complexity to parameters affected by heterogeneity: result cardinality for the slightly relaxed graph homomorphism problem and number of adjacent edges of a given type. The formulas show that greater heterogeneity of graph and query labels works in our favor by reducing the “gap” between homomorphism and isomorphism, and by reducing result size. In future work we will attempt to extend the approach to query patterns with cycles—which appears to be significantly more challenging. Intuitively, it is more challenging to perform elimination of spurious node and edge candidates when pruning based only on local neighborhoods.</p>
      <p><strong>Acknowledgments</strong>. This work was supported in part by the National Institutes of Health (NIH) under award number R01 NS091421 and by the National Science Foundation (NSF) under award number CAREER III-1762268. The content is solely the responsibility of the authors and does not necessarily represent the official views of NIH or NSF. We would also like to thank the reviewers for their constructive feedback.</p>
    </section>
  </section>
  <section class="back-matter">
    <section id="ref-001">
      <header>
        <div class="title-info">
          <h2 class="page-brake-head">REFERENCES</h2>
        </div>
      </header>
      <ul class="bibUl">
        <li id="BibPLXBIB0001" label="[1]">2017. Yelp data set. (2017). <a href="https://www.yelp.com/dataset_challenge/dataset" target="_blank">https://www.yelp.com/dataset_challenge/dataset</a>
        </li>
        <li id="BibPLXBIB0002" label="[2]">2018. Any-k: anytime top-k pattern retrieval in labeled graphs (code). (2018). <a href="https://github.com/northeastern-datalab/Any-k-KARPET" target="_blank">https://github.com/northeastern-datalab/Any-k-KARPET</a>
        </li>
        <li id="BibPLXBIB0003" label="[3]">2018. Flickr. (2018). <a href="http://www.flickr.com/" target="_blank">http://www.flickr.com/</a>
        </li>
        <li id="BibPLXBIB0004" label="[4]">2018. Vitrage. (2018). <a href="https://wiki.openstack.org/wiki/Vitrage" target="_blank">https://wiki.openstack.org/wiki/Vitrage</a>
        </li>
        <li id="BibPLXBIB0005" label="[5]">Charu&nbsp;C. Aggarwal and Haixun Wang. 2010. <em><em>Graph Data Management and Mining: A Survey of Algorithms and Applications</em></em>. Springer, 13–68.</li>
        <li id="BibPLXBIB0006" label="[6]">Reza Akbarinia, Esther Pacitti, and Patrick Valduriez. 2007. Best Position Algorithms for Top-k Queries. In <em><em>Proc. VLDB</em></em>. 495–506.</li>
        <li id="BibPLXBIB0007" label="[7]">Gunes Aluc. 2015. <em>Workload Matters: A Robust Approach to Physical RDF Database Design</em>. Ph.D. Dissertation. University of Waterloo, Ontario, Canada.</li>
        <li id="BibPLXBIB0008" label="[8]">L.&nbsp;J. Chen and Y. Papakonstantinou. 2010. Supporting top-K keyword search in XML databases. In <em><em>Proc. ICDE</em></em>. 689–700.</li>
        <li id="BibPLXBIB0009" label="[9]">James Cheng, Yiping Ke, and Wilfred Ng. 2009. Efficient processing of group-oriented connection queries in a large graph. In <em><em>CIKM</em></em>. ACM, 1481–1484.</li>
        <li id="BibPLXBIB0010" label="[10]">Luigi&nbsp;Pietro Cordella, Pasquale Foggia, Carlo Sansone, and Mario Vento. 2001. An improved algorithm for matching large graphs. In <em><em>Proc. IAPR-TC15 Workshop on Graph-based Representations in Pattern Recognition</em></em>. 149–159.</li>
        <li id="BibPLXBIB0011" label="[11]">Luigi&nbsp;P Cordella, Pasquale Foggia, Carlo Sansone, and Mario Vento. 2004. A (sub)graph isomorphism algorithm for matching large graphs. <em><em>IEEE Trans. on Pattern Analysis and Machine Intelligence</em></em> 26, 10 (2004), 1367–1372.</li>
        <li id="BibPLXBIB0012" label="[12]">Jérôme Euzenat, Pavel Shvaiko, <em>et al.</em> 2007. <em><em>Ontology matching</em></em>. Vol.&nbsp;18. Springer.</li>
        <li id="BibPLXBIB0013" label="[13]">Ronald Fagin, Amnon Lotem, and Moni Naor. 2003. Optimal aggregation algorithms for middleware. <em><em>J. Comput. Syst. Sci.</em></em> 66, 4 (2003), 614–656.</li>
        <li id="BibPLXBIB0014" label="[14]">Christos Faloutsos, Kevin&nbsp;S McCurley, and Andrew Tomkins. 2004. Fast discovery of connection subgraphs. In <em><em>Proc. ACM SIGKDD</em></em>. 118–127.</li>
        <li id="BibPLXBIB0015" label="[15]">Gang Feng. 2014. Finding <em>k</em> shortest simple paths in directed graphs: A node classification algorithm. <em><em>Networks</em></em> 64, 1 (2014), 6–17.</li>
        <li id="BibPLXBIB0016" label="[16]">Jiawei Han, Yizhou Sun, Xifeng Yan, and Philip&nbsp;S Yu. 2010. Mining knowledge from databases: an information network analysis approach. In <em><em>Proc. ACM SIGMOD</em></em>. 1251–1252.</li>
        <li id="BibPLXBIB0017" label="[17]">Huahai He and Ambuj&nbsp;K Singh. 2008. Graphs-at-a-time: query language and access methods for graph databases. In <em><em>Proc. ACM SIGMOD</em></em>. 405–418.</li>
        <li id="BibPLXBIB0018" label="[18]">John Hershberger, Matthew Maxel, and Subhash Suri. 2007. Finding the K Shortest Simple Paths: A New Algorithm and Its Implementation. <em><em>ACM Trans. Algorithms</em></em> 3, 4, Article 45 (Nov. 2007).</li>
        <li id="BibPLXBIB0019" label="[19]">Katja Hose and Ralf Schenkel. 2013. WARP: Workload-aware replication and partitioning for RDF. In <em><em>Proc. ICDE Workshops</em></em>. 1–6.</li>
        <li id="BibPLXBIB0020" label="[20]">Jiewen Huang, Daniel&nbsp;J. Abadi, and Kun Ren. 2011. Scalable SPARQL Querying of Large RDF Graphs. <em><em>PVLDB</em></em> 4, 11 (2011), 1123–1134.</li>
        <li id="BibPLXBIB0021" label="[21]">Ihab&nbsp;F. Ilyas, George Beskales, and Mohamed&nbsp;A. Soliman. 2008. A survey of top-<em>k</em> query processing techniques in relational database systems. <em><em>ACM Comput. Surv.</em></em> 40, 4 (2008), 11:1–11:58.</li>
        <li id="BibPLXBIB0022" label="[22]">Gjergji Kasneci, Shady Elbassuoni, and Gerhard Weikum. 2009. Ming: mining informative entity relationship subgraphs. In <em><em>Proc. CIKM</em></em>. ACM, 1653–1656.</li>
        <li id="BibPLXBIB0023" label="[23]">Naoki Katoh, Toshihide Ibaraki, and Hisashi Mine. 1982. An efficient algorithm for k shortest simple paths. <em><em>Networks</em></em> 12, 4 (1982), 411–427.</li>
        <li id="BibPLXBIB0024" label="[24]">Ioannis Koutis and Ryan Williams. 2016. LIMITS and Applications of Group Algebras for Parameterized Problems. <em><em>ACM Trans. Algorithms</em></em> 12, 3 (2016), 31:1–31:18.</li>
        <li id="BibPLXBIB0025" label="[25]">Robert Krauthgamer and Ohad Trabelsi. 2017. <em><em>Conditional Lower Bound for Subgraph Isomorphism with a Tree Pattern</em></em>. Technical Report. <a href="https://arxiv.org/abs/1708.07591" target="_blank">https://arxiv.org/abs/1708.07591</a>
        </li>
        <li id="BibPLXBIB0026" label="[26]">Jinsoo Lee, Wook-Shin Han, Romans Kasperovics, and Jeong-Hoon Lee. 2012. An In-depth Comparison of Subgraph Isomorphism Algorithms in Graph Databases. <em><em>PVLDB</em></em> 6, 2 (2012), 133–144.</li>
        <li id="BibPLXBIB0027" label="[27]">Jiongqian Liang, Deepak Ajwani, Patrick&nbsp;K Nicholson, Alessandra Sala, and Srinivasan Parthasarathy. 2016. What Links Alice and Bob? Matching and Ranking Semantic Patterns in Heterogeneous Networks. In <em><em>Proc. WWW</em></em>. 879–889.</li>
        <li id="BibPLXBIB0028" label="[28]">Anna Lubiw. 1981. Some NP-complete problems similar to graph isomorphism. <em><em>SIAM J. Comput.</em></em> 10, 1 (1981), 11–21.</li>
        <li id="BibPLXBIB0029" label="[29]">Apostol Natsev, Yuan-Chi Chang, John&nbsp;R. Smith, Chung-Sheng Li, and Jeffrey&nbsp;Scott Vitter. 2001. Supporting Incremental Join Queries on Ranked Inputs. In <em><em>Proc. VLDB</em></em>. 281–290.</li>
        <li id="BibPLXBIB0030" label="[30]">Thomas Neumann and Gerhard Weikum. 2010. The RDF-3X engine for scalable management of RDF data. <em><em>The VLDB Journal</em></em> 19, 1 (2010), 91–113.</li>
        <li id="BibPLXBIB0031" label="[31]">Cartic Ramakrishnan, William&nbsp;H Milnor, Matthew Perry, and Amit&nbsp;P Sheth. 2005. Discovering informative connection subgraphs in multi-relational graphs. <em><em>ACM SIGKDD Explorations Newsletter</em></em> 7, 2 (2005), 56–63.</li>
        <li id="BibPLXBIB0032" label="[32]">Liam Roditty. 2007. On the <em>K</em>-simple shortest paths problem in weighted directed graphs. In <em><em>Proc. SODA</em></em>. 920–928.</li>
        <li id="BibPLXBIB0033" label="[33]">Haichuan Shang, Ying Zhang, Xuemin Lin, and Jeffrey&nbsp;Xu Yu. 2008. Taming Verification Hardness: An Efficient Algorithm for Testing Subgraph Isomorphism. <em><em>PVLDB</em></em> 1, 1 (2008), 364–375.</li>
        <li id="BibPLXBIB0034" label="[34]">Yizhou Sun, Jiawei Han, Xifeng Yan, Philip&nbsp;S Yu, and Tianyi Wu. 2011. Pathsim: Meta path-based top-k similarity search in heterogeneous information networks. <em><em>PVLDB</em></em> 4, 11 (2011), 992–1003.</li>
        <li id="BibPLXBIB0035" label="[35]">Hanghang Tong and Christos Faloutsos. 2006. Center-piece subgraphs: problem definition and fast solutions. In <em><em>Proc. ACM SIGKDD</em></em>. 404–413.</li>
        <li id="BibPLXBIB0036" label="[36]">Julian&nbsp;R Ullmann. 1976. An algorithm for subgraph isomorphism. <em><em>JACM</em></em> 23, 1 (1976), 31–42.</li>
        <li id="BibPLXBIB0037" label="[37]">Fang Wei. 2010. Efficient graph reachability query answering using tree decomposition. In <em><em>Int. Workshop on Reachability Problems</em></em>. 183–197.</li>
        <li id="BibPLXBIB0038" label="[38]">Xiaofeng Yang, Deepak Ajwani, Wolfgang Gatterbauer, Patrick&nbsp;K Nicholson, Mirek Riedewald, and Alessandra Sala. 2018. <em><em>Any-k: anytime top-k pattern retrieval in labeled graphs</em></em>. Technical Report. <a href="https://arxiv.org/abs/1802.06060" target="_blank">https://arxiv.org/abs/1802.06060</a>
        </li>
        <li id="BibPLXBIB0039" label="[39]">Mihalis Yannakakis. 1981. Algorithms for Acyclic Database Schemes. In <em><em>Proc. VLDB</em></em>. 82–94.</li>
        <li id="BibPLXBIB0040" label="[40]">Jin&nbsp;Y. Yen. 1971. Finding the K Shortest Loopless Paths in a Network. <em><em>Management Science</em></em> 17, 11 (1971), 712–716.</li>
        <li id="BibPLXBIB0041" label="[41]">Shijie Zhang, Shirong Li, and Jiong Yang. 2009. GADDI: distance index based subgraph matching in biological networks. In <em><em>Proc. EDBT</em></em>. 192–203.</li>
      </ul>
    </section>
  </section>
  <section id="foot-001" class="footnote">
    <header>
      <div class="title-info">
        <h2>FOOTNOTE</h2>
      </div>
    </header>
    <p id="fn1"><a href="#foot-fn1"><sup>1</sup></a> <em>Kernelization</em> is a pre-processing technique that replaces the original input by a (usually) smaller representation called “kernel” in order to reduce the computation cost. Our approach enumerates solutions over a smaller pruned candidate graph.</p>
    <div class="bibStrip">
      <p>This paper is published under the Creative Commons Attribution 4.0 International (CC-BY&nbsp;4.0) license. Authors reserve their rights to disseminate the work on their personal and corporate Web sites with the appropriate attribution.</p>
      <p><em>WWW' 18, April 23-27, 2018, Lyon, France</em></p>
      <p>© 2018; IW3C2 (International World Wide Web Conference Committee), published under Creative Commons CC-BY&nbsp;4.0 License. ACM ISBN 978-1-4503-5639-8/18/04.<br />
      DOI: <a class="link-inline force-break" target="_blank" href="https://doi.org/10.1145/3178876.3186115">https://doi.org/10.1145/3178876.3186115</a></p>
    </div>
  </section>
  <div class="pubHistory">
    <p></p>
  </div>
</body>
</html>
