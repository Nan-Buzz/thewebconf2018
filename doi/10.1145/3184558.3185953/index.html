<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">  <head>  <title>Tierless Web Programming in the Large</title>  <!-- Copyright (c) 2010-2015 The MathJax Consortium --><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>  <meta name="viewport" content="width=device-width; initial-scale=1.0;"></meta>  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>  <link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/bootstrap.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/bootstrap-theme.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/main.css"/><script src="../../../data/dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script>  <script type="text/javascript"    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>  <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>  </head>  <body id="main">
<div>
<p style='font-size: 75%; color #444'>
This is a HTML copy of <a href='https://doi.org/10.1145/3184558.3185953'>https://doi.org/10.1145/3184558.3185953</a> 
originally published by ACM, 
redistributed under the terms of 
<a href='https://creativecommons.org/licenses/by/4.0/'>Creative Commons Attribution 4.0 (CC BY 4.0)</a>.
The <a href='https://github.com/usable-oa/thewebconf2018/tree/master/scripts'>modifications</a> 
from the original are solely to improve HTML accessability, compatibility, 
augmenting HTML metadata and avoiding ACM trademark.
To reference this HTML version, use:
</p><p>
<strong>Permalink:</strong>
<a href='https://w3id.org/oa/10.1145/3184558.3185953'>https://w3id.org/oa/10.1145/3184558.3185953</a>
</p></div>
<hr>

  <section class="front-matter">   <section>    <header class="title-info">     <div class="journal-title">     <h1>      <span class="title">Tierless Web Programming in the Large</span>      <br/>      <span class="subTitle"/>     </h1>     </div>    </header>    <div class="authorGroup">     <div class="author">     <span class="givenName">Gabriel</span>      <span class="surName">Radanne</span>     University of Freiburg, Germany, <a href="mailto:radanne@informatik.uni-freiburg.de">radanne@informatik.uni-freiburg.de</a>     </div>     <div class="author">     <span class="givenName">J&#x00E9;r&#x00F4;me</span>      <span class="surName">Vouillon</span>     IRIF UMR 8243 CNRS, Univ Paris Diderot, Sorbonne Paris Cit&#x00E9; &#x2013; CNRS, <a href="mailto:jerome.vouillon@irif.fr">jerome.vouillon@irif.fr</a>     </div>             <Affiliation id="aff3">BeSport, Paris, France</Affiliation>    </div>    <br/>    <div class="pubInfo">     <p>DOI: <a href="https://doi.org/10.1145/3184558.3185953" target="_blank">https://doi.org/10.1145/3184558.3185953</a>     <br/>WWW '18: <a href="https://doi.org/10.1145/3184558" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p>    </div>    <div class="abstract">     <p>     <small>Tierless Web programming languages allow combining client-side and server-side programming in a single program. This allows defining expressions with both client and server parts, and at the same time provides good static guarantees regarding client-server communication. However, these nice properties come at a cost: most tierless languages offer very poor support for modularity and separate compilation.</small>     </p>     <p>     <small>To regain this modularity and offer a larger-scale notion of composition, we propose to leverage a well-known tool: <SmallCap>ML</SmallCap>&#x00A0;-style modules. In modern <SmallCap>ML</SmallCap>&#x00A0;languages, the module system is a layer separate from the expression language.</small>     </p>     <p>     <small>      <SmallCap>Eliom</SmallCap>&#x00A0;is an extension of <SmallCap>OCaml</SmallCap>&#x00A0;for tierless Web programming which provides type-safe communication and an efficient execution model. In this article, we present how the <SmallCap>Eliom</SmallCap>&#x00A0;module system combines the flexibility of tierless Web programming languages with a powerful module system, thus providing good support for abstraction, modularity and separate compilation. We also show that we can provide all these advantages while providing seamless integration with <SmallCap>OCaml</SmallCap>&#x00A0;and its ecosystem.</small>     </p>    </div>    <div class="CCSconcepts">     <p> <small> <span style="font-weight:bold;">CCS Concepts:</span> &#x2022;<strong> Software and its engineering </strong>&#x2192; <strong>Functional languages;</strong></small> </p>    </div>    <div class="classifications">     <div class="author">     <span style="font-weight:bold;">      <small>Keywords:</small>     </span>     <span class="keyword">      <small>Web; client/server; OCaml&#x00A0;; ML&#x00A0;; Eliom&#x00A0;; functional; module</small>     </span>     </div>     <br/>     <div class="AcmReferenceFormat">     <p>      <small>       <span style="font-weight:bold;">ACM Reference Format:</span>       <br/>       Gabriel Radanne and J&#x00E9;r&#x00F4;me Vouillon. 2018. Tierless Web Programming in the Large. In <em>WWW '18 Companion: The 2018 Web Conference Companion,</em>       <em>April 23&#x2013;27, 2018,</em>       <em> Lyon, France. ACM, New York, NY, USA</em> 10 Pages. <a href="https://doi.org/10.1145/3184558.3185953" class="link-inline force-break"        target="_blank">https://doi.org/10.1145/3184558.3185953</a></small>     </p>     </div>    </div>   </section>  </section>  <section class="body">   <section id="sec-4">    <header>     <div class="title-info">     <h2>      <span class="section-number">1</span> Introduction</h2>     </div>    </header>    <p>Traditional Web applications are composed of several distinct tiers: Web pages are written in HTML and styled in CSS; these pages are produced by a server which can be written in just about any language: PHP, Ruby, C++&#x00A0;...; their dynamic behavior is controlled through client-side languages such as <SmallCap>JavaScript</SmallCap>. The traditional way to compose these languages is to write separate programs for the client and the server. Then, the programmer is expected to respect a common interface between the two programs. This constraint is usually not checked automatically, and it is the responsibility of the programmer to ensure that the two programs behave in a coherent manner. Of course, such checking is often error-prone. This issue, present in the Web since its inception, has become even more relevant in modern Web applications. Furthermore, the unit of composition here is a whole file (or compilation unit): files contain either client code or server code but cannot be composed of both client and server code. Such composition is very coarse-grained and hinders the modularity of Web programming libraries.</p>    <p>One goal of a modern client-server Web application framework should be to make it possible to build dynamic Web pages in a <em>composable</em> way. One should be able to define on the server a function that creates a fragment of a page together with its associated client-side behavior; this behavior might depend on the function parameters. The so-called <em>tierless</em> languages aim to solve such modularity issues by allowing to compose tiers inside expressions, by allowing to freely intersperse the client and server parts of the application in one language with seamless communication. For most of these languages, the program is sliced in two: a part which runs on the server and a part which is compiled to <SmallCap>JavaScript</SmallCap>&#x00A0;and runs on the client. This allows to write libraries and widgets with both client and server behaviors. It also provides static guarantees about client-server separation and a fine-grained notion of composition.</p>    <p>However, programming large-scale software and libraries still requires a form of larger-scale composition. Indeed, parts of a library could be entirely on the server or on the client. Most tierless languages do not support such modular approach to program architecture. Even worse, almost no tierless programming languages support separate compilation. Separate compilation, or its weaker form incremental compilation, is an essential-productivity boost for programmers working on medium to large scale software.</p>    <p>To solve these problems, we propose to leverage a well-known tool: <SmallCap>ML</SmallCap>&#x00A0;-style modules. By doing so, we gain a convenient paradigm for organizing large-scale software and support for separate compilation on top of the gains provided by tierless programming languages. Our module system is built as a complement to <SmallCap>Eliom</SmallCap>&#x00A0;, a tierless web programming language built on top of <SmallCap>OCaml</SmallCap>&#x00A0;, and retains its good properties such as static typing of client-server communications and an efficient excution model.</p>    <section id="sec-5">     <header>     <div class="title-info">      <h3>       <span class="section-number">1.1</span> Modules</h3>     </div>     </header>     <p>In modern <SmallCap>ML</SmallCap>&#x00A0;languages, the module language is separate from the expression language. While the language of expressions allows to program &#x201C;in the small&#x201D;, the module language allows to program &#x201C;in the large&#x201D;. In most languages, modules are compilation units: a simple collection of type and value declarations in a file. The SML module language [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0019">19</a>] uses this notion of collection of declarations (called <em>structures</em>) and extends it with types (module specifications, or <em>signatures</em>), functions (parametrized modules, or <em>functors</em>) and function application, forming a small typed functional language. Such a module system can account for separate compilation [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0016">16</a>] and provides support for datatype abstraction [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0008">8</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0017">17</a>], which allows to hide the implementation of a given type in order to enforce some invariants. In the history of <SmallCap>ML</SmallCap>&#x00A0;-programming languages, <SmallCap>ML</SmallCap>&#x00A0;-style modules have been informally shown to be very expressive tools to architect software. Functors, in particular, allow to write generic implementations by abstracting over a complete module. The <SmallCap>OCaml</SmallCap>&#x00A0;language provides such a module system, extended with various other constructs such as package types [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0032">32</a>] (also known as first-class modules). One distinctive feature is that modules in <SmallCap>OCaml</SmallCap>&#x00A0;are runtime entities. In contrast to systems such as MLton [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0023">23</a>], they are not eliminated at compile time.</p>    </section>    <section id="sec-6">     <header>     <div class="title-info">      <h3>       <span class="section-number">1.2</span>       <SmallCap>Eliom</SmallCap>&#x00A0;</h3>     </div>     </header>     <p>     <SmallCap>Eliom</SmallCap>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0029">29</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0030">30</a>] is an extension of <SmallCap>OCaml</SmallCap>&#x00A0;for tierless programming that supports composable and typesafe client-server interactions. It provides fine-grained modularity by allowing to manipulate <em>on the server</em>, as first class values, fragments of code which will be executed <em>on the client</em>. <SmallCap>Eliom</SmallCap>&#x00A0;is part of the larger <SmallCap>Ocsigen</SmallCap>&#x00A0;&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0002">2</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0011">11</a>] project, which also includes the compiler <SmallCap>js_of_ocaml</SmallCap>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0038">38</a>], a Web server, and various related libraries to build client-server applications. Besides the language presented here, <SmallCap>Eliom</SmallCap>&#x00A0;comes with a complete set of modules, for server and/or client side Web programming, such as RPCs; a functional reactive library for Web programming; a GUI toolkit&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0025">25</a>]; a powerful session mechanism and an advanced <em>service identification mechanism</em>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0001">1</a>]. The <SmallCap>Ocsigen</SmallCap>&#x00A0;project started in 2004, as a research project, with the goal of building a complete industrial-strength framework.</p>    </section>    <section id="sec-7">     <header>     <div class="title-info">      <h3>       <span class="section-number">1.3</span> Modules for tierless web programming</h3>     </div>     </header>     <p>All of the modules and libraries in <SmallCap>Ocsigen</SmallCap>&#x00A0;, and in particular in the <SmallCap>Eliom</SmallCap>&#x00A0;framework, are implemented on top of a core language described by Radanne et&#x00A0;al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0030">30</a>]. The design of this core language is guided by four complementary goals: easy composition of client and server code, type-safe communication between client and server, explicit communications that are easy to reason about an efficient execution model. We introduce additional properties that drive the design of our module language:</p>     <p>     <em>Integration with the host language.</em>. <SmallCap>Eliom</SmallCap>&#x00A0;is an extension of <SmallCap>OCaml</SmallCap>&#x00A0;. We should be able to leverage both the language and the ecosystem of <SmallCap>OCaml</SmallCap>&#x00A0;. <SmallCap>OCaml</SmallCap>&#x00A0;libraries can be useful on the server, on the client or on both. As such, any <SmallCap>OCaml</SmallCap>&#x00A0;file, even when compiled with the regular <SmallCap>OCaml</SmallCap>&#x00A0;compiler, is a valid <SmallCap>Eliom</SmallCap>&#x00A0;module. Furthermore, we can specify if we want to use a given library on the client, on the server, or everywhere.</p>     <p>     <em>Abstraction.</em>. Module languages are very powerful abstraction tools. By only exposing part of a module, the programmer can safely hide implementation details and enforce specific properties. <SmallCap>Eliom</SmallCap>&#x00A0;leverages module abstraction to provide encapsulation and separation of concerns for widgets and libraries. By combining module abstraction and tierless features, library authors can provide good APIs that do not expose the minute details of client-server communication to the users.</p>     <p>     <em>Modularity and separate compilation.</em>. Far from simple websites, modern Web applications are complex programs that rival regular desktop programs in size. Modularity and separate compilation are essential tools to make programmers productive for large applications. <SmallCap>Eliom</SmallCap>&#x00A0;is the only tierless programming language that provides static slicing, efficient execution and separate compilation.</p>     <p>In the rest of this article, we present how <SmallCap>Eliom</SmallCap>&#x00A0;module system provides abstraction and modularity for tierless applications. As a guiding example for our exploration of the <SmallCap>Eliom</SmallCap>&#x00A0;language, we consider the case of a commenting system, as can be found on numerous websites. A comment is a piece of HTML written by a user and identified by a unique identifier. Such a comment library features both server aspects (storing and rendering the comments) and client interactions (browsing and searching comments).</p>     <p>We first give a reminder of the <SmallCap>OCaml</SmallCap>&#x00A0;module system (Section <a class="sec" href="#sec-8">2</a>) and small-scale tierless programming (Section <a class="sec" href="#sec-12">3</a>). We then present the <SmallCap>Eliom</SmallCap>&#x00A0;module language (Section <a class="sec" href="#sec-19">4</a>) and the challenges regarding its implementation in (Section <a class="sec" href="#sec-25">5</a>). Finally, we give a quick comparison with existing work in Section <a class="sec" href="#sec-30">6</a>.</p>    </section>   </section>   <section id="sec-8">    <header>     <div class="title-info">     <h2>      <span class="section-number">2</span> Of comments and camels A short introduction to <SmallCap>OCaml</SmallCap>&#x00A0;modules</h2>     </div>    </header>    <p>The <SmallCap>OCaml</SmallCap>&#x00A0;module system forms a second language separate from the expression language. While the language of expressions allows programming &#x201C;in the small&#x201D;, the module language allows programming &#x201C;in the large&#x201D;. The <SmallCap>ML</SmallCap>&#x00A0;flavor of module systems, which <SmallCap>OCaml</SmallCap>&#x00A0;is part of, significantly extend usual module languages by providing module types (called signatures) and functions from modules to modules (called functors). The module system is implicitly used for any kind of <SmallCap>OCaml</SmallCap>&#x00A0;or <SmallCap>Eliom</SmallCap>&#x00A0;programming: Each <tt>.ml</tt> and <tt>.eliom</tt> file form a structure containing the list of declarations included in the file. It is also possible to specify a signature for such module by adding a <tt>.mli</tt> or <tt>eliomi</tt> file.</p>    <p>We can do a lot more with <SmallCap>OCaml</SmallCap>&#x00A0;modules. For example, let us say we are writing an <tt>HTML</tt> library. We want to gather the event related attributes in a single module. We can easily do so with the following construction.</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-graphic1.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>These functions can then be used through qualified accesses:</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-graphic2.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>Some users of our HTML library may want to experiment with new, custom-made HTML elements. They can easily do so by extending the <tt>Html</tt> module:</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-graphic3.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>Here, we declare a new module, <tt>HtmlPlus</tt>, in which we <em>include</em>     <tt>Html</tt> and define the new <tt>blink</tt> function. The include operation simply takes all the fields of a module and adds them to the enclosing module. This way, we obtain a new module <tt>HtmlPlus</tt> which can be used anywhere <tt>Html</tt> can, but also includes the new function.</p>    <section id="sec-9">     <header>     <div class="title-info">      <h3>       <span class="section-number">2.1</span> Abstraction and encapsulation</h3>     </div>     </header>     <p>We now want to build a simple library to handle internet comments. In our library, comments are pieces of HTML (constructed with the <tt>Html</tt> module) identified by a unique number. We are not sure yet if we should use simple sequential IDs, date-base IDs or something else like UUIDs and Hashids [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0012">12</a>]. Fortunately, we do not have to make this decision immediately! All we need in order to write the rest of our engine is an interface for creating and using identifiers. We can declare such an interface in <SmallCap>OCaml</SmallCap>&#x00A0;using a <em>signature</em>. Below, we declare the <tt>ID</tt> signature describing what a module implementing unique identifiers should look like.</p>     <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-graphic4.jpg" class="img-responsive" alt=""       longdesc=""/>     </p>     <p>We can then create various modules implementing this specification. Here we declare the modules <tt>SequentialID</tt> and <tt>DateID</tt>. We can then switch one module for the other easily.</p>     <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-graphic5.jpg" class="img-responsive" alt=""       longdesc=""/>     </p>     <p>One important thing to note here is that, to the outer world, these two modules have exactly the same type and can not be distinguished. The type that implements the identifiers in the <tt>ID</tt> signature is abstract: its implementation is only visible inside the module and can not be used outside. It is also useful to note that such abstraction can be provided after the fact. Declaring a module and abstracting its interface are completely distinct operations.</p>     <p>Hiding the internal details of our <tt>ID</tt> modules is not only useful for modularity: it also allows to enforce abstraction boundaries. For example in the case of <tt>SequentialID</tt>, it is impossible to inadvertently use the ID as an integer, since the fact that it is an integer is not revealed! We can use this fact to enforce numerous complex properties, as we see in the next section.</p>    </section>    <section id="sec-10">     <header>     <div class="title-info">      <h3>       <span class="section-number">2.2</span> Functors</h3>     </div>     </header>     <p>To implement our comment system, we sometimes need to find comments by their ID. The idiomatic <SmallCap>OCaml</SmallCap>&#x00A0;solution is to use maps, also called dictionaries. Such maps are implemented with Binary Search Trees which require a comparison function on the keys of the map. Map.Make is a pre-defined functor in the <SmallCap>OCaml</SmallCap>&#x00A0;standard library that takes a module implementing the COMPARABLE signature as argument and returns a module that implements dictionaries whose keys are of the type <tt>t</tt> in the provided module. In Fig. <a class="fig" href="#fig1">2</a>, we use this functor to create the <tt>IDMap</tt> module which defines dictionaries with IDs as keys. This is very easy, since the <tt>ID</tt> signature is already a super-set of the <tt>COMPARABLE</tt> signature. We then define <tt>register</tt>, a function which associates a fresh id to a comment <tt>c</tt>.</p>     <p>The <tt>Map.Make</tt> functor uses abstraction in two important ways. First, since the type of the map is abstract, it is impossible to modify it through means not provided by the module. In particular, this enforces that the binary tree is always balanced. Second, since the comparison function is provided in advance by the argument of the functor, it is impossible to mix different comparison functions by mistake. Indeed, application of the functor to different modules would yield different types of maps. <figure id="fig1">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-fig1.jpg" class="img-responsive" alt="Figure 1"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 1:</span>       <span class="figure-title">The Map module</span>      </div>     </figure>     <figure id="fig2">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-fig2.jpg" class="img-responsive" alt="Figure 2"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 2:</span>       <span class="figure-title">Dictionaries from IDs to comments</span>      </div>     </figure>     </p>    </section>    <section id="sec-11">     <header>     <div class="title-info">      <h3>       <span class="section-number">2.3</span> Going further</h3>     </div>     </header>     <p>This was just a taste of modules. For a longer (and better) introduction to modules, please consult the <SmallCap>OCaml</SmallCap>&#x00A0;manual&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0018">18</a>] or the Real World OCaml book&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0022">22</a>].</p>    </section>   </section>   <section id="sec-12">    <header>     <div class="title-info">     <h2>      <span class="section-number">3</span> Tierless widgets</h2>     </div>    </header>    <p>Until now, we presented how to write various elements of libraries useful for our comment system. For this purpose, we leveraged the power of the <SmallCap>OCaml</SmallCap>&#x00A0;module system in various ways. We now want to write the widget that presents a comment. For this purpose, we need to define both client and server code, along with some client-server communication, which is precisely where tierless languages shine. Through this example, we provide a quick overview of the <SmallCap>Eliom</SmallCap>&#x00A0;expression language, along with some basic associated concepts regarding tierless web programming.</p>    <section id="sec-13">     <header>     <div class="title-info">      <h3>       <span class="section-number">3.1</span> Sections</h3>     </div>     </header>     <p>     <em>Section</em> annotations allow the programmer to specify where a declaration should be executed. The programmer can specify whether a declaration is to be performed on the server or on the client as follows:</p>     <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-graphic8.jpg" class="img-responsive" alt=""       longdesc=""/>     </p>     <p>In particular, sections allow to group related code in the same file, regardless of where it is executed. In the rest of this article, we use the following color convention: client is in yellow, server is in blue and mixed is in green. Colors are however not mandatory to understand the rest of this article.</p>    </section>    <section id="sec-14">     <header>     <div class="title-info">      <h3>       <span class="section-number">3.2</span> Client fragments</h3>     </div>     </header>     <p>While section annotations allow programmers to gather code across locations, they don&#x0027;t allow convenient communication. For this purpose, <SmallCap>Eliom</SmallCap>&#x00A0;allows to include client-side expression inside a server section: an expression placed inside [%client ... ] will be computed on the client when the page is received; but the eventual client-side value of the expression can be passed around immediately as a black box on the server. These expressions are called client <em>fragments</em>.</p>     <p>In the example below, the expression 1 + 3 will be evaluated on the client, but it&#x0027;s possible to refer server-side to the future value of this expression (for example, put it in a list). The variable <tt>x</tt> is only usable server-side, and has type int fragment which should be read &#x201C;a fragment containing some integer&#x201D;. The value inside the client fragment cannot be accessed on the server.</p>     <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-graphic9.jpg" class="img-responsive" alt=""       longdesc=""/>     </p>    </section>    <section id="sec-15">     <header>     <div class="title-info">      <h3>       <span class="section-number">3.3</span> Injections</h3>     </div>     </header>     <p>Fragments allow programmers to manipulate client values on the server. We also need the opposite direction. Values that have been computed on the server can be used on the client by prefixing them with the symbol . We call this an <em>injection</em>.</p>     <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-graphic10.jpg" class="img-responsive" alt=""       longdesc=""/>     </p>     <p>Here, the expression 1 + 2 is evaluated and bound to variable s on the server. The resulting value 3 is transferred to the client together with the Web page. The expression s + 1 is computed client-side. An injection makes it possible to access client-side a client fragment which has been defined on the server. The value inside the client fragment is extracted by x, whose value is 4 here.</p>     <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-graphic11.jpg" class="img-responsive" alt=""       longdesc=""/>     </p>    </section>    <section id="sec-16">     <header>     <div class="title-info">      <h3>       <span class="section-number">3.4</span> Comment widget</h3>     </div>     </header>     <p>These three constructions are sufficient to create complex client-server interactions. Here, we use them to build a very simple widget to show one comment. Our widget, implemented by the function <tt>make_comment</tt> shown below, has the additional feature that it will hide the content of the comment when the user clicks on it. We also want the HTML to be generated server-side and sent to the client as a regular HTML page. This allows the comments to be accessible even when <SmallCap>JavaScript</SmallCap>&#x00A0;cannot run. The implementation, the interface and the produced HTML fragment are shown in Fig. <a class="fig" href="#fig3">3</a>.</p>     <p>In order to implement our comment widget, we use an HTML DSL&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0037">37</a>] that provides combinators such as <tt>div</tt> and <tt>a_onclick</tt> (which respectively create an HTML tag and an HTML attribute). The <tt>&#x00E3;</tt> is the <SmallCap>OCaml</SmallCap>&#x00A0;syntax for named arguments. Here, it is used for the list of HTML attributes. We first create a <tt>p</tt> element which contain the text of the comment and a unique id. The text is included in a <tt>div</tt> which represents the comment. We then use a handler listening to the <tt>onclick</tt> event: since clicks are performed client-side, this handler needs to be a client function inside a fragment. Inside the fragment, an injection is used to access the argument <tt>id</tt> which contains the identifier of the comment. We then use this identifier to fetch the correct element and toggle the &#x201C;hidden&#x201D; CSS property, which hides it.</p>     <p>As we can see, this type does not expose the internal details of the widget&#x0027;s behavior. In particular, the communication between server and client does not leak in the API: This provides proper encapsulation for client-server behaviors. Furthermore, this widget is easily composable: the embedded client state cannot affect nor be affected by any other widget and can be used to build larger widgets. <figure id="fig3">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-fig3.jpg" class="img-responsive" alt="Figure 3"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 3:</span>       <span class="figure-title">The comment widget</span>      </div>     </figure>     </p>    </section>    <section id="sec-17">     <header>     <div class="title-info">      <h3>       <span class="section-number">3.5</span> Notes on semantics</h3>     </div>     </header>     <p>In the examples above, we showed that we can interleave client and server expressions and communications in fairly arbitrary manners. This would be costly if the communication between client and server were done naively.</p>     <p>Instead, the server only sends data once when the Web page is sent. In particular, in the comment widget presented above, the id of the comment is not sent for each click. This is made possible by the fact that client fragments are not executed immediately when encountered inside server code. Intuitively, the semantics is the following. When the server code is executed, the encountered client code is not executed right away; instead it is just registered for later execution once the Web page has been sent to the client. Only then is the client code executed. We also guarantee that client code, be it either client sections or fragments, is executed in the order that it was encountered on the server. This presentation might makes it seem as if we dynamically create the client code during execution of the server code. This is not the case. Like <SmallCap>OCaml</SmallCap>&#x00A0;, <SmallCap>Eliom</SmallCap>&#x00A0;is statically compiled and separates client and server code at compile time. During compilation, we statically extract the code included inside fragments and compile it as part of the client code to <SmallCap>JavaScript</SmallCap>&#x00A0;. This allows us to provide both an efficient execution scheme that minimizes communication and preserve side-effect orders while still presenting an easy-to-understand semantics. We also benefits from optimizations done by the <SmallCap>js_of_ocaml</SmallCap>&#x00A0;compiler, thus producing efficient and compact <SmallCap>JavaScript</SmallCap>&#x00A0;code.</p>    </section>    <section id="sec-18">     <header>     <div class="title-info">      <h3>       <span class="section-number">3.6</span> Further reading</h3>     </div>     </header>     <p>We only gave a brief overview of what can be done with the new language constructs introduced by <SmallCap>Eliom</SmallCap>&#x00A0;. Radanne et&#x00A0;al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0029">29</a>] present numerous advanced examples which cover many Web programming idioms such as HTML, RPCs, broadcasts and other communication patterns. More formally, Radanne et&#x00A0;al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0030">30</a>] give a detailed account of the type system, the semantics and the compilation scheme for the <SmallCap>Eliom</SmallCap>&#x00A0;expression language. For the rest of this article, we focus on large-scale tierless Web programming through modules.</p>    </section>   </section>   <section id="sec-19">    <header>     <div class="title-info">     <h2>      <span class="section-number">4</span> Tierless modular programming</h2>     </div>    </header>    <p>We are now equipped with two tools. On one hand, we have a rich and expressive non-tierless module system, as presented in Section <a class="sec" href="#sec-8">2</a>, which provides abstraction and modularity at the library level. On the other hand, we have a powerful tierless programming language, as presented in Section <a class="sec" href="#sec-12">3</a>, which allows us to describe sophisticated client-server behaviors. In this section, we present how we can bring those two tools together and reap the numerous benefits of the <SmallCap>OCaml</SmallCap>&#x00A0;module system in a tierless setting.</p>    <section id="sec-20">     <header>     <div class="title-info">      <h3>       <span class="section-number">4.1</span> Interaction with <SmallCap>OCaml</SmallCap>&#x00A0;</h3>     </div>     </header>     <p>Web programming is never only about the Web. Web programmers needs external libraries and a rich ecosystem that can not be provided by a fresh new language. Before writing complex tierless programs, let us see how <SmallCap>Eliom</SmallCap>&#x00A0;can leverage the <SmallCap>OCaml</SmallCap>&#x00A0;ecosystem almost transparently.</p>     <p>Integration with the <SmallCap>OCaml</SmallCap>&#x00A0;language is provided through the use of a third location called <strong>base</strong>. Code located on base can be used both on the client and on the server.</p>     <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-graphic13.jpg" class="img-responsive" alt=""       longdesc=""/>     </p>     <p>5let%client a = f &#x201D;client&#x201D;</p>     <p>     <SmallCap>Eliom</SmallCap>&#x00A0;-specific features such as fragments and injections are not allowed inside base code. In fact, base code corresponds exactly to <SmallCap>OCaml</SmallCap>&#x00A0;code. This equivalence holds in theory but also in practice, meaning that any <SmallCap>OCaml</SmallCap>&#x00A0;library compiled by the vanilla <SmallCap>OCaml</SmallCap>&#x00A0;compiler can be directly reused by <SmallCap>Eliom</SmallCap>&#x00A0;as being on the base location. This allows a very smooth integration with the <SmallCap>OCaml</SmallCap>&#x00A0;ecosystem. Furthermore, a given <SmallCap>OCaml</SmallCap>&#x00A0;library can be loaded either on base, on the client or on the server, depending on what the user wants. For example, an <SmallCap>OCaml</SmallCap>&#x00A0;library manipulating file descriptors might be better kept only on the server in order to avoid misuse. The type-checker then raises an error if the library is mistakenly used on the client.</p>    </section>    <section id="sec-21">     <header>     <div class="title-info">      <h3>       <span class="section-number">4.2</span> Modules and locations</h3>     </div>     </header>     <p>As demonstrated in Section <a class="sec" href="#sec-20">4.1</a>, <SmallCap>OCaml</SmallCap>&#x00A0;modules, such as the <tt>String</tt> module taken from the standard library, are immediately available as <SmallCap>Eliom</SmallCap>&#x00A0;modules located on base. We can also use such modules on the client or on the server.</p>     <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-graphic14.jpg" class="img-responsive" alt=""       longdesc=""/>     </p>     <p>Locations are checked by the compiler. For example, using a server module on the client is forbidden.</p>     <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-graphic15.jpg" class="img-responsive" alt=""       longdesc=""/>     </p>     <p>It is also possible to reuse <SmallCap>OCaml</SmallCap>&#x00A0;module types freely. For example, we might want to define a client module <tt>DomHtml</tt> which shares the exact same API as the <tt>Html</tt> module, but is implemented using the Document Object Model that is available on the client. The type declaration for such a module would then be very simple, as shown below.</p>     <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-graphic16.jpg" class="img-responsive" alt=""       longdesc=""/>     </p>     <p>We can easily declare a new structure completely on one location. The constraint is that all the fields on such modules, including submodules, should be on the same location. For example, a client structure can only contain fields that are declared on the client. The following piece of code declares a <tt>JsMap</tt> client module containing various fields and implementing a dictionary data-structure with <SmallCap>JavaScript</SmallCap>&#x00A0;strings.</p>     <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-graphic17.jpg" class="img-responsive" alt=""       longdesc=""/>     </p>     <p>We can also use functors in client and server code as we would in regular <SmallCap>OCaml</SmallCap>&#x00A0;code. Consider the <tt>JsMap</tt> module above. The simplest way to obtain such a module would be to use the <tt>Map.Make</tt> functor presented in Section <a class="sec" href="#sec-10">2.2</a>. We could for example write a <tt>JsDate</tt> module which uses <SmallCap>JavaScript</SmallCap>&#x00A0;native support for dates. We can then obtain the <tt>JsDateMap</tt> module simply by applying Map.Make to the module <tt>JsDate</tt> defined in Fig. <a class="fig" href="#fig4">4</a>. As expected, the module we obtain is directly on the client. We can thus mix and match client and server modules using the tierless features and vanilla <SmallCap>OCaml</SmallCap>&#x00A0;modules. This also works with all the other module features such as abstraction, high order functors and module inclusion. In all these cases, the <SmallCap>Eliom</SmallCap>&#x00A0;typechecker ensures that modules always end up on the appropriate location. <figure id="fig4">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-fig4.jpg" class="img-responsive" alt="Figure 4"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 4:</span>       <span class="figure-title">Definition of <tt>JsID</tt> and <tt>JsMap</tt>       </span>      </div>     </figure>     </p>    </section>    <section id="sec-22">     <header>     <div class="title-info">      <h3>       <span class="section-number">4.3</span> Mixed modules</h3>     </div>     </header>     <p>Up until now, we only defined single-location modules, either base, client or server. It is natural to also want to write modules that contain base, client and server declarations. We call these modules &#x201C;mixed&#x201D;.</p>     <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-graphic19.jpg" class="img-responsive" alt=""       longdesc=""/>     </p>     <p>Just like sections, mixed modules allow to group together declarations that are semantically related, regardless of client-server boundaries. However, combining type declarations with mixed modules and module signatures can provide even further benefits.</p>     <section id="sec-23">     <p><em>4.3.1 Encapsulation and Abstraction.</em> A common idiom of web programming is to generate some HTML element on the server, add an <tt>id</tt> to it, and recover the element on the client through the <tt>get_element_by_id</tt> function. Indeed, this is exactly what we did in our comment widget in Section <a class="sec" href="#sec-16">3.4</a>. This is so common, in fact, that it could be considered the &#x201C;id design pattern&#x201D;. RPCs, channels and other communication APIs also follow the same mechanisms through the use of uniquely defined URLs. In all these cases, the means of identification for a given object is generally passed around explicitly, instead of being abstracted. Since client and server code are usually written separately, the programmer <em>must</em> expose the internal details to the outer world, including how to identify objects.</p>     <p>By combining tierless annotations and the abstraction capabilities provided by modules, we can recover that lost abstraction. Fig. <a class="fig" href="#fig5">6</a> presents an API that encapsulates unique ids for HTML elements. The API is composed of an abstract type, <tt>id</tt>, and two operations. The server function <tt>with_id</tt> takes an HTML element, generates a fresh id and returns a pair composed of the HTML element with that id and the id. The client function <tt>find</tt> takes an id and retrieves the associated element as a DOM node on the client. The <tt>id</tt> type is abstract. Both the client and the server functions can use the real definition of <tt>id</tt> since they are both inside the module. The outer world, however, can not. Mixed modules allow us to allow abstraction to extends over the client-server boundary. This can provide further benefits in the case of more complex data-structures, as we will see in the next section. <figure id="fig5">       <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-fig5.jpg" class="img-responsive" alt="Figure 5"        longdesc=""/>       <div class="figure-caption">        <span class="figure-number">Figure 5:</span>        <span class="figure-title">Interface of abstract HTML ids</span>       </div>      </figure>      <figure id="fig6">       <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-fig6.jpg" class="img-responsive" alt="Figure 6"        longdesc=""/>       <div class="figure-caption">        <span class="figure-number">Figure 6:</span>        <span class="figure-title">Implementation of abstract HTML ids</span>       </div>      </figure>     </p>     </section>    </section>    <section id="sec-24">     <header>     <div class="title-info">      <h3>       <span class="section-number">4.4</span> Mixed data structures</h3>     </div>     </header>     <p>We now want to implement a system of client-side search and filtering of comments. The user should be able to search and filter comments directly on the client, without the need to reload the page. For this purpose, we need to maintain the sets of comments both on the server and on the client. One simple way to do that is to create a replicated cache of comments which ensures that all the comments available on the server are also available on the client.</p>     <p>We use the Map module as inspiration and create a functor that takes as argument a module describing the keys. The idea is that adding an entry to a server-side table also adds the element to the client-side table. Consequently, the server-side representation of a table needs to include a client-side one.</p>     <p>The result API is shown in Fig. <a class="fig" href="#fig7">7</a>. The resulting module contains both a client and a server side types, both named <tt>&#x2019;a table</tt>, which represent the local table. The module also exposes traditional <tt>Map</tt> functions. The implementation, shown in Fig. <a class="fig" href="#fig8">8</a>, is more interesting. We exploit the fact that client and server namespaces are distinct, and name both client and server map modules <tt>M</tt>. On the server, the cache is implemented as a pair of a server-side and a client-side dictionary. The server-side add implementation stores a new value locally in the expected way, but additionally builds a fragment that has the side-effect of performing a client-side addition. The retrieval operation (find) returns a shared value that contains both the server side version and the client side. On the client, however, we can directly use the local values. Since the client-side type exactly corresponds to a regular map, we can directly use the usual definitions for the various map operations. This is done by including the client <tt>M</tt> module on the client.</p>     <p>Note that this functor cannot be implemented in a decomposed way without sacrifying either abstraction or modularity. Indeed, the server implementation relies on the client-side version of the functor argument (Comparable) to implement proper usage of the keys. Furthermore, the signature of the functor ensures that the server-side and client-side parts of the cache are in sync without leaking any implementation details. Separating this mixed functors in two would require exposing the guts of the data-structure. Abstraction also makes it easy to extend such modules with new features. For example, it would possible to add full-blown replication through &#x201C;push&#x201D; or &#x201C;pull&#x201D; communications between the client and the server. Thanks to the abstraction provided by the signature of the module, this can even be done while keeping the API of the functor unchanged. <figure id="fig7">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-fig7.jpg" class="img-responsive" alt="Figure 7"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 7:</span>       <span class="figure-title">Interface of <tt>MakeCache</tt>       </span>      </div>     </figure>     <figure id="fig8">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-fig8.jpg" class="img-responsive" alt="Figure 8"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 8:</span>       <span class="figure-title">Implementation of <tt>MakeCache</tt>       </span>      </div>     </figure>     </p>     <p>We can now use this cache for our comment system by using, for example, the <tt>DateID</tt> module for the keys. This is done in Fig. <a class="fig" href="#fig9">9</a>. Adding a new comment to the page is done through the <tt>add_comment</tt> server function. This function creates the associated HTML using the widget defined in Section <a class="sec" href="#sec-16">3.4</a> and adds it to the cache. We can then create the webpage containing all the comments simply by collecting all the comments and putting them inside a <tt>div</tt>. This is done by the <tt>generate_page</tt> server function. Finally, the client function <tt>filter_comments</tt> filters the shown comments on the client. It takes as argument a predicate function and the current client cache. It uses this predicate function to filter the cache, using the function <tt>CommentCache.filter</tt>, which directly uses the equivalent function from the <tt>Map</tt> module. We then find the HTML element containing all the elements and replace them them by the updated list. <figure id="fig9">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-fig9.jpg" class="img-responsive" alt="Figure 9"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 9:</span>       <span class="figure-title">Using <tt>MakeCache</tt>       </span>      </div>     </figure>     </p>     <p>Through these various examples, we demonstrated how we can combine traditional tierless features with advanced features of the <SmallCap>OCaml</SmallCap>&#x00A0;module system to create powerful and expressive APIs. One one hand, tierless languages traditionally allows for complex interplay of client and server code. Module systems, on the other hand, allows to manipulate large pieces of code while preserving abstraction, encapsulation and modularity. The <SmallCap>Eliom</SmallCap>&#x00A0;module system, and mixed functors in particular, allows to preserve these abstraction capabilities while enjoying the free-form tierless programming style.</p>    </section>   </section>   <section id="sec-25">    <header>     <div class="title-info">     <h2>      <span class="section-number">5</span> Under the hood</h2>     </div>    </header>    <p>Rich module systems such as <SmallCap>ML</SmallCap>&#x00A0;&#x2019;s are notoriously difficult to formalize and implement. The best evidence of this is the very rich body of work attempting to provide a theoretic background for modules [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0008">8</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0009">9</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0015">15</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0016">16</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0017">17</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0031">31</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0036">36</a>] compared to the very few implementations in modern languages [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0018">18</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0021">21</a>]. Adding tierless elements to the mix certainly does not make the situation simpler.</p>    <p>For space reasons, we do not attempt to provide a complete description of our module language. Instead, we highlight a few key elements that are novel in our approach. We first present some notes in the typechecking of modules (Section <a class="sec" href="#sec-26">5.1</a>) and the compilation process (Section <a class="sec" href="#sec-28">5.3</a>).</p>    <section id="sec-26">     <header>     <div class="title-info">      <h3>       <span class="section-number">5.1</span> Typechecking and Specialization</h3>     </div>     </header>     <p>On several occasions, we used base, client, server or even mixed modules in conjunction. We even applied a base functor such as <tt>Map.Make</tt> on a client module. Typechecking such a mix of base and non-base modules is not so trivial. Indeed, let us consider the functor application <tt>Map.Make(JsDate)</tt> presented in Section <a class="sec" href="#sec-21">4.2</a>. Both the input and output signatures of <tt>Map.Make</tt> contain base fields. However, <tt>JsDate</tt> only contains client fields. Furthermore, one would expect <tt>JsMap</tt>, the result of the application, to be only usable on the client. In all these cases, we must &#x201C;specialize&#x201D; the <tt>Map.Make</tt> module to be usable on the client. This problem is similar to the application of a polymorphic function. Indeed, when checking the application of a function of type &#x2200;<em>&#x03B1;</em>.<em>&#x03B1;</em> &#x2192; <em>&#x03B1;</em> to an argument of type <em>int</em>, we first instantiate the function to <em>int</em> &#x2192; <em>int</em> before checking the application.</p>     <p>We use a similar technique to typecheck tierless modules. Instead of a set of type variables, we have a single &#x201C;location variable&#x201D; that is always called &#x201C;base&#x201D;. When using a module in a client or a server context, we specialize it to ensure that all the fields are properly accessible. The specialization operation, noted ..&#x2113; where &#x2113; is &#x201C;client&#x201D; or &#x201C;server&#x201D;, projects a &#x201C;view&#x201D; of the type of the module where all the fields are in the current location. For base modules, it simply rewrites the signature by substituting all instances of the location &#x201C;base&#x201D; by the specified &#x201C;client&#x201D; or &#x201C;server&#x201D; location. Fig. <a class="fig" href="#fig10">10</a> presents two example of specialization for base modules. Note that before being specialized, a module should be actually accessible in the given scope. This means that we never have to specialize a server module on the client (or conversely).</p>     <p>The important part however is that specialization is completely transparent for the user. Much like instantiation of polymorphic function, specialization is automatically handled by the typechecker and requires no special care from the programmer. The programmer only has to specify client, server and base locations. <figure id="fig10">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-fig10.jpg" class="img-responsive" alt="Figure 10"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 10:</span>       <span class="figure-title">Examples of specialization &#x2013; ..</span>      </div>     </figure>     </p>    </section>    <section id="sec-27">     <header>     <div class="title-info">      <h3>       <span class="section-number">5.2</span> Mixed modules</h3>     </div>     </header>     <p>Specialization is also used to enforce proper location usage for mixed modules. Indeed, mixed modules can be used on the client and on the server. In these cases, only the server (resp. client) part should be visible.</p>     <p>     <em>Mixed structures</em>. For a structure, aka a collection of declarations, specialization hides the parts of a module that are not relevant to the current side. An example of specialization of a mixed structure is provided in the top half of Fig. <a class="fig" href="#fig13">13</a>. Here we can see that, as is the case for base modules, base declarations are now client. Furthermore, we also remove all the server declarations present in the structure. The end result is a structure that only contains client declarations. From a runtime point of view, the specialized type is also faithful to the content of the module: indeed, a base declaration can always be considered to be present client-side (as well as server-side) and declarations can be hidden thanks to module subtyping. This way, we ensure that if a structure <span class="inline-equation"><span class="tex">$(\mathtt {struct}\ M\ \mathtt {end})$</span>     </span> can be given a type <span class="inline-equation"><span class="tex">$(\mathtt {sig}\ S\ \mathtt {end})$</span>     </span>, then it can also be given a type <span class="inline-equation"><span class="tex">$\left.{sig}\ S\ \mathtt {end}\right.{\ell }$</span>     </span>.</p>     <p>     <em>Mixed functors</em>. Functors bring additional complexity. A naive implementation of specialization of mixed functors would be to specialize on both side of the arrow and apply the resulting functor. Let us see on an example why this solution does not work. In Section , the functor F takes as argument a module containing a base declaration and uses it on both sides. If the type of the functor parameter were specialized, the functor application in Fig. <a class="fig" href="#fig11">12</a> would be well-typed. However, this makes no sense: <tt>M.y</tt> is supposed to represent a fragment whose content is the client value of <em>b</em>, but this value doesn&#x0027;t exist, since <em>b</em> was declared on the server. There would be no value available to inject in the declaration of <tt>y&#x2019;</tt>.</p>     <p>The solution here is that specialization on mixed functors should only specialize the return type, not the argument type. This is demonstrated in the bottom half of Fig. <a class="fig" href="#fig13">13</a>. This way, the complete mixed module is given as argument to the mixed functor and specialization happens on the result of the functor only. <figure id="fig11">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-fig11.jpg" class="img-responsive" alt="Figure 11"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 11:</span>       <span class="figure-title">A mixed functor using a base dectaration</span>      </div>     </figure>     <figure id="fig12">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-fig12.jpg" class="img-responsive" alt="Figure 12"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 12:</span>       <span class="figure-title">An ill-typed application of F</span>      </div>     </figure>     <figure id="fig13">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185953/images/www18companion-14-fig13.jpg" class="img-responsive" alt="Figure 13"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 13:</span>       <span class="figure-title">Examples of specialization on mixed modules</span>      </div>     </figure>     </p>    </section>    <section id="sec-28">     <header>     <div class="title-info">      <h3>       <span class="section-number">5.3</span> Compilation and execution</h3>     </div>     </header>     <p>In Section <a class="sec" href="#sec-17">3.5</a>, we presented the semantics in term of a two-stage execution: first the server, then the client. This interpreted semantics is easier to understand, but would involve runtime code generation which would be quite inefficient. In the implementation, the <SmallCap>Eliom</SmallCap>&#x00A0;compilers slices tierless programs in two parts, the client and the server. The slicing is done by emitting two <SmallCap>OCaml</SmallCap>&#x00A0;programs containing additional communication primitives.</p>     <p>For one-sided modules, the process is fairly simple: we simply take the whole module to the appropriate side. Similarly for mixed structures, we cut the whole structure in two. Complications arise for mixed functors. The idea is the following: we equip each mixed module with a unique identifier. This identifier is static for mixed structures but is dynamic for modules resulting of a functor application, such as <tt>F</tt>. On the server, this identifier is added as a field of the module. On the client, we simply maintain a table from identifiers to modules. When applying a functor, we remember the fact that the associated functor application should be done on the client. When sending the page to the client, we also send this information. The client will then ensure that this functor application is done at the appropriate time. This process can be seen as an extended version of the one used for <SmallCap>Eliom</SmallCap>&#x00A0;fragments [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0030">30</a>].</p>     <p>This compilation method also hints at some limitations of mixed functors: arguments of mixed functors must have an identifier pointing to their client half. One method is to add these identifiers to every mixed structures and force arguments of mixed functors to also be mixed. This restriction can be partially lifted through some simple static analysis to insert identifiers appropriately. Evaluating how constraining these restriction are in practice is the subject of future work.</p>    </section>    <section id="sec-29">     <header>     <div class="title-info">      <h3>       <span class="section-number">5.4</span> Formal description</h3>     </div>     </header>     <p>Radanne [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0028">28</a>] gives a formal description of both the expression and the module language. It presents the type system, the module system, the interpreted semantics presented in Section <a class="sec" href="#sec-17">3.5</a> and the compilation scheme. This formalization demonstrates, among other things that the integration with <SmallCap>OCaml</SmallCap>&#x00A0;works and that interpreted and compiled semantics coincide.</p>    </section>   </section>   <section id="sec-30">    <header>     <div class="title-info">     <h2>      <span class="section-number">6</span> Related work</h2>     </div>    </header>    <p>A comprehensive comparison of the tierless expression language can be found in Radanne et&#x00A0;al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0029">29</a>]. It is notoriously delicate to compare modules systems. Instead, we focus on the modularity and abstraction aspects and in particular the interaction between tierless programming, separate compilation and data abstraction. Within these criteria, the various approaches can be separated into three categories: slicing as a global compiler transformation, interpreted languages and modular compiled languages.</p>    <section id="sec-31">     <header>     <div class="title-info">      <h3>       <span class="section-number">6.1</span> Global slicing</h3>     </div>     </header>     <p>One approach for slicing a tierless program into a client part and a server part is to apply a whole-program transformation over the complete program. Such approach is, by essence, incompatible with separate compilation. Furthermore, whole-program slicing usually relies on some other program transformations (inlining, monomorphisation, defunctorisation, ...) that tend to be non-modular and cross abstraction boundaries.</p>     <p>     <SmallCap>Ur/Web</SmallCap>&#x00A0;&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0005">5</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0006">6</a>] is a statically typed <SmallCap>ML</SmallCap>&#x00A0;-like tierless programming language. It only provides compilation units, not modules. Its approach to compilation is similar to <SmallCap>MLton</SmallCap>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0023">23</a>]: it applies a set of whole-program optimizations to remove all high order calls, then slices the program. This process is incompatible with separate compilation.</p>     <p>There has been a lot of work on bringing static slicing to <SmallCap>JavaScript</SmallCap>&#x00A0; [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0026">26</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0027">27</a>]. These approaches do not provide any tools to talk about modules and are whole-program transformations. Furthermore, <SmallCap>JavaScript</SmallCap>&#x00A0;modules do not provide any form of data abstraction.</p>    </section>    <section id="sec-32">     <header>     <div class="title-info">      <h3>       <span class="section-number">6.2</span> Dynamic slicing</h3>     </div>     </header>     <p>Some interpreted languages relies on slicing at runtime to extract the client part of the program and send it alongside the generated Web page. While this is more expressive, it does not provide any of the guarantees provided by static slicing.</p>     <p>     <SmallCap>Hop</SmallCap>&#x00A0;&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0003">3</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0034">34</a>] is a dialect of Scheme for programming Web applications. Its successor, <SmallCap>Hop</SmallCap>&#x00A0;.js&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0033">33</a>] takes the same concepts and brings them to <SmallCap>JavaScript</SmallCap>&#x00A0;. There is no static typing, <SmallCap>JavaScript</SmallCap>&#x00A0;modules do not provide any data abstraction feature and the slicing is not modular.</p>     <p>     <SmallCap>Meteor.js</SmallCap>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0020">20</a>] is a framework where both client and server side of an application are written in <SmallCap>JavaScript</SmallCap>&#x00A0;. It does not provide static typing nor any form of abstraction.</p>     <p>     <SmallCap>Links</SmallCap>&#x00A0;&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0007">7</a>] is an experimental functional language for client-server Web programming with a type and effect system. The slicing is type-directed, leveraging effects to annotate client, server or database functions. The current implementation of <SmallCap>Links</SmallCap>&#x00A0;is interpreted and relies on dynamic slicing. It does not have a module system. Some work has been done on introducing static compilation [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0004">4</a>], but it relies on normalization by evaluation, which is not immediately compatible with separate compilation.</p>    </section>    <section id="sec-33">     <header>     <div class="title-info">      <h3>       <span class="section-number">6.3</span> Modular languages</h3>     </div>     </header>     <p>     <SmallCap>Haste</SmallCap>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0010">10</a>] is an extension of <SmallCap>Haskell</SmallCap> similar to <SmallCap>Eliom</SmallCap>&#x00A0;. Instead of using syntactic annotations, it embeds client and server code into monads. It inherits the <SmallCap>Haskell</SmallCap> features in term of modules and data abstraction. Furthermore, the tierless compiler for <SmallCap>Haste</SmallCap> relies heavily on the GHC, providing support for separate-compilation. Kilpatrick et&#x00A0;al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0013">13</a>] developed a complete expressive module language for <SmallCap>Haskell</SmallCap>.</p>     <p>     <SmallCap>MetaOCaml</SmallCap>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0014">14</a>] is an extension of <SmallCap>OCaml</SmallCap>&#x00A0;for staged meta-programming. While the expression language is quite similar to <SmallCap>Eliom</SmallCap>&#x00A0;, <SmallCap>MetaOCaml</SmallCap> provides no support for modules. Staging annotations are only on expressions, not on declarations. Code generation and checking of the generated code is dynamic.</p>     <p>Modular macros&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0024">24</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0039">39</a>] are another extension of <SmallCap>OCaml</SmallCap>&#x00A0;. It uses staging to implement macros. It provides both a quotation-based expression language along with staging annotations on declarations. It also aims to support modules and functors. Contrary to <SmallCap>Eliom</SmallCap>&#x00A0;, there is only one type universe and the slicing can also be seen as dynamic (since code is executed at compile time). In particular, this allows to lift most of the restriction imposed on multi-stage functors.</p>     <p>     <SmallCap>Acute</SmallCap>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0035">35</a>] is an extension of <SmallCap>OCaml</SmallCap>&#x00A0;for distributed programming. It provides typesafe serialization and deserialization and also allows arbitrary loading of modules at runtime. Like <SmallCap>Eliom</SmallCap>&#x00A0;, it provides a full-blown module system. However, it takes an opposite stance on the execution model: each actor runs independent programs and communications are completely dynamic. Handling of multiple type universes is done by providing a description of the type with each message and by versioning APIs.</p>    </section>   </section>   <section id="sec-34">    <header>     <div class="title-info">     <h2>Conclusion</h2>     </div>    </header>    <p>We presented a module system for <SmallCap>Eliom</SmallCap>&#x00A0;, a statically typed functional tierless Web programming language based on <SmallCap>OCaml</SmallCap>&#x00A0;. It combines a powerful tierless expression language, as described by [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0029">29</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0030">30</a>], and a rich <SmallCap>ML</SmallCap>&#x00A0;-style module language. To achieve this, we propose to annotate declarations with four <em>locations</em>: base, client, server or mixed. These locations allows to express tierless libraries conveniently while providing all the essential properties of a module system. In particular, <SmallCap>Eliom</SmallCap>&#x00A0;is the only language that supports an efficient static compilation scheme, proper data abstraction and separate compilation. Furthermore, <SmallCap>Eliom</SmallCap>&#x00A0;integrates seamlessly with the <SmallCap>OCaml</SmallCap>&#x00A0;language and its ecosystem. We implemented this language as an extension of the <SmallCap>OCaml</SmallCap>&#x00A0;compiler which includes typechecking, compilation and a runtime.</p>    <p>The need for a module system which integrates tierless annotations comes directly from the development of libraries and Web applications as part of <SmallCap>Ocsigen</SmallCap>&#x00A0;. Web sites have become increasingly complex in the past decade. While several solutions for the &#x201C;tiers&#x201D; problem has been proposed, very few tackle the practical issues raised by programming large web applications with tierless languages. We believe that good support for modularity and abstraction is essential for any serious large-scale programming.</p>   </section>  </section>  <section class="back-matter">   <section id="ref-001">    <header>     <div class="title-info">     <h2 class="page-brake-head">REFERENCES</h2>     </div>    </header>    <ul class="bibUl">     <li id="BibPLXBIB0001" label="[1]">Vincent Balat. 2014. Rethinking Traditional Web Interaction: Theory and Implementation. <em>      <em>International Journal on Advances in Internet Technology</em>     </em> (2014). <a class="link-inline force-break"      href="http://www.iariajournals.org/internet_technology/"      target="_blank">http://www.iariajournals.org/internet_technology/</a></li>     <li id="BibPLXBIB0002" label="[2]">Vincent Balat, J&#x00E9;r&#x00F4;me Vouillon, and Boris Yakobowski. 2009. Experience report: Ocsigen, a Web programming framework. In <em>      <em>ICFP</em>     </em>, Graham Hutton and Andrew&#x00A0;P. Tolmach (Eds.). ACM, 311&#x2013;316.</li>     <li id="BibPLXBIB0003" label="[3]">G&#x00E9;rard Boudol, Zhengqin Luo, Tamara Rezk, and Manuel Serrano. 2012. Reasoning about Web Applications: An Operational Semantics for HOP. <em>      <em>ACM Trans. Program. Lang. Syst.</em>     </em>34, 2 (2012), 10.</li>     <li id="BibPLXBIB0004" label="[4]">James Cheney, Sam Lindley, Gabriel Radanne, and Philip Wadler. 2013. Effective Quotation. <em>      <em>CoRR</em>     </em>abs/1310.4780(2013). <a class="link-inline force-break" href="http://arxiv.org/abs/1310.4780"      target="_blank">http://arxiv.org/abs/1310.4780</a></li>     <li id="BibPLXBIB0005" label="[5]">Adam Chlipala. 2018. Ur/Web: A Simple Model for Programming the Web(<em>POPL &#x2019;15</em>). <a class="link-inline force-break" href="https://doi.org/10.1145/2676726.2677004"      target="_blank">https://doi.org/10.1145/2676726.2677004</a></li>     <li id="BibPLXBIB0006" label="[6]">Adam Chlipala. 2015. An Optimizing Compiler for a Purely Functional Web-Application Language. In <em>      <em>ICFP</em>     </em>.</li>     <li id="BibPLXBIB0007" label="[7]">Ezra Cooper, Sam Lindley, Philip Wadler, and Jeremy Yallop. 2006. Links: Web Programming Without Tiers. In <em>      <em>FMCO</em>     </em>. 266&#x2013;296.</li>     <li id="BibPLXBIB0008" label="[8]">Karl Crary. 2017. Modules, abstraction, and parametric polymorphism, Giuseppe Castagna and Andrew&#x00A0;D. Gordon (Eds.). <a class="link-inline force-break"      href="http://dl.acm.org/citation.cfm?id=3009892"      target="_blank">http://dl.acm.org/citation.cfm?id=3009892</a></li>     <li id="BibPLXBIB0009" label="[9]">Derek Dreyer. 2005. <em>Understanding and Evolving the ML Module System</em>. Ph.D. Dissertation. CMU. <a class="link-inline force-break"      href="https://people.mpi-sws.org/~dreyer/thesis/main.pdf"      target="_blank">https://people.mpi-sws.org/~dreyer/thesis/main.pdf</a></li>     <li id="BibPLXBIB0010" label="[10]">Anton Ekblad and Koen Claessen. 2018. A Seamless, Client-centric Programming Model for Type Safe Web Applications(<em>Haskell &#x2019;14</em>). <a class="link-inline force-break" href="https://doi.org/10.1145/2633357.2633367"      target="_blank">https://doi.org/10.1145/2633357.2633367</a></li>     <li id="BibPLXBIB0011" label="[11]">Eliom2017. <em>      <em>Eliom web site</em>     </em>. <a class="link-inline force-break" href="https://ocsigen.org/eliom."      target="_blank">https://ocsigen.org/eliom.</a></li>     <li id="BibPLXBIB0012" label="[12]">Hashids2017. <em>      <em>Hashids</em>     </em>. <a class="link-inline force-break" href="http://hashids.org/." target="_blank">http://hashids.org/.</a></li>     <li id="BibPLXBIB0013" label="[13]">Scott Kilpatrick, Derek Dreyer, Simon&#x00A0;L. Peyton Jones, and Simon Marlow. 2014. Backpack: retrofitting Haskell with interfaces. <a class="link-inline force-break" href="https://doi.org/10.1145/2535838.2535884"      target="_blank">https://doi.org/10.1145/2535838.2535884</a></li>     <li id="BibPLXBIB0014" label="[14]">Oleg Kiselyov. 2014. The Design and Implementation of BER MetaOCaml(<em>Lecture Notes in Computer Science</em>), Michael Codish and Eijiro Sumii (Eds.). Vol.&#x00A0;8475. Springer. <a class="link-inline force-break"      href="https://doi.org/10.1007/978-3-319-07151-0_6"      target="_blank">https://doi.org/10.1007/978-3-319-07151-0_6</a></li>     <li id="BibPLXBIB0015" label="[15]">Daniel&#x00A0;K. Lee, Karl Crary, and Robert Harper. 2007. Towards a mechanized metatheory of standard ML, Martin Hofmann and Matthias Felleisen (Eds.). ACM. <a class="link-inline force-break" href="https://doi.org/10.1145/1190216.1190245"      target="_blank">https://doi.org/10.1145/1190216.1190245</a></li>     <li id="BibPLXBIB0016" label="[16]">Xavier Leroy. 1994. Manifest Types, Modules, and Separate Compilation, Hans-Juergen Boehm, Bernard Lang, and Daniel&#x00A0;M. Yellin (Eds.). ACM Press. <a class="link-inline force-break" href="https://doi.org/10.1145/174675.176926"      target="_blank">https://doi.org/10.1145/174675.176926</a></li>     <li id="BibPLXBIB0017" label="[17]">Xavier Leroy. 1995. Applicative Functors and Fully Transparent Higher-Order Modules, Ron&#x00A0;K. Cytronand Peter Lee (Eds.). ACM Press. <a class="link-inline force-break" href="https://doi.org/10.1145/199448.199476"      target="_blank">https://doi.org/10.1145/199448.199476</a></li>     <li id="BibPLXBIB0018" label="[18]">Xavier Leroy, Damien Doligez, Alain Frisch, Jacques Garrigue, Didier R&#x00E9;my, and J&#x00E9;r&#x00F4;me Vouillon. 2016. <em>      <em>The OCaml system release 4.04, Documentation and user&#x0027;s manual</em>     </em>. Projet Gallium, INRIA.</li>     <li id="BibPLXBIB0019" label="[19]">David&#x00A0;B. MacQueen. 1984. Modules for Standard ML. In <em>      <em>LISP and Functional Programming</em>     </em>. 198&#x2013;207.</li>     <li id="BibPLXBIB0020" label="[20]">Meteor.js2017. <em>      <em>Meteor.js</em>     </em>. <a class="link-inline force-break" href="http://meteor.com." target="_blank">http://meteor.com.</a></li>     <li id="BibPLXBIB0021" label="[21]">Robin Milner, Mads Tofte, and Robert Harper. 1990. <em>      <em>Definition of standard ML</em>     </em>. MIT Press.</li>     <li id="BibPLXBIB0022" label="[22]">Yaron Minsky, Anil Madhavapeddy, and Jason Hickey. 2013. <em>      <em>Real World OCaml - Functional Programming for the Masses</em>     </em>. O&#x0027;Reilly. <a class="link-inline force-break" href="https://realworldocaml.org/"      target="_blank">https://realworldocaml.org/</a></li>     <li id="BibPLXBIB0023" label="[23]">MLton2014. MLton. (2014). <a class="link-inline force-break" href="http://mlton.org/Home" target="_blank">http://mlton.org/Home</a></li>     <li id="BibPLXBIB0024" label="[24]">Olivier Nicole. 2016. Bringing typed, modular macros to OCaml. (2016). <a class="link-inline force-break"      href="https://oliviernicole.github.io/about_macros.html"      target="_blank">https://oliviernicole.github.io/about_macros.html</a></li>     <li id="BibPLXBIB0025" label="[25]">Ocsigen Toolkit2017. <em>      <em>Ocsigen Toolkit</em>     </em>. <a class="link-inline force-break" href="http://ocsigen.org/ocsigen-toolkit/."      target="_blank">http://ocsigen.org/ocsigen-toolkit/.</a></li>     <li id="BibPLXBIB0026" label="[26]">Laure Philips, Coen De&#x00A0;Roover, Tom Van&#x00A0;Cutsem, and Wolfgang De&#x00A0;Meuter. 2014. Towards Tierless Web Development Without Tierless Languages(<em>Onward! 2014</em>). 69&#x2013;81. <a class="link-inline force-break" href="https://doi.org/10.1145/2661136.2661146"      target="_blank">https://doi.org/10.1145/2661136.2661146</a></li>     <li id="BibPLXBIB0027" label="[27]">Laure Philips, Joeri&#x00A0;De Koster, Wolfgang&#x00A0;De Meuter, and Coen&#x00A0;De Roover. 2016. Dependence-driven delimited CPS transformation for JavaScript. <a class="link-inline force-break" href="https://doi.org/10.1145/2993236.2993243"      target="_blank">https://doi.org/10.1145/2993236.2993243</a></li>     <li id="BibPLXBIB0028" label="[28]">Gabriel Radanne. 2017. <em>Tierless Web Programming in ML</em>. Ph.D. Dissertation. Paris Diderot. <a class="link-inline force-break"      href="https://www.irif.fr/~gradanne/papers/phdthesis.pdf"      target="_blank">https://www.irif.fr/~gradanne/papers/phdthesis.pdf</a></li>     <li id="BibPLXBIB0029" label="[29]">Gabriel Radanne, Vasilis Papavasileiou, J&#x00E9;r&#x00F4;me Vouillon, and Vincent Balat. 2016. Eliom: tierless Web programming from the ground up, Tom Schrijvers (Ed.). ACM. <a class="link-inline force-break" href="https://doi.org/10.1145/3064899.3064901"      target="_blank">https://doi.org/10.1145/3064899.3064901</a></li>     <li id="BibPLXBIB0030" label="[30]">Gabriel Radanne, J&#x00E9;r&#x00F4;me Vouillon, and Vincent Balat. 2016. Eliom: A Core ML Language for Tierless Web Programming(<em>Lecture Notes in Computer Science</em>). <a class="link-inline force-break"      href="https://doi.org/10.1007/978-3-319-47958-3_20"      target="_blank">https://doi.org/10.1007/978-3-319-47958-3_20</a></li>     <li id="BibPLXBIB0031" label="[31]">Andreas Rossberg, Claudio&#x00A0;V. Russo, and Derek Dreyer. 2014. F-ing modules. <em>      <em>J. Funct. Program.</em>     </em>24, 5 (2014), 529&#x2013;607. <a class="link-inline force-break"      href="https://doi.org/10.1017/S0956796814000264"      target="_blank">https://doi.org/10.1017/S0956796814000264</a></li>     <li id="BibPLXBIB0032" label="[32]">Claudio&#x00A0;V. Russo. 2000. First-Class Structures for Standard ML. <em>      <em>Nord. J. Comput.</em>     </em>7, 4 (2000), 348&#x2013;374.</li>     <li id="BibPLXBIB0033" label="[33]">Manuel Serrano and Vincent Prunet. 2016. A glimpse of Hopjs, Jacques Garrigue, Gabriele Keller, and Eijiro Sumii (Eds.). ACM. <a class="link-inline force-break" href="https://doi.org/10.1145/2951913.2951916"      target="_blank">https://doi.org/10.1145/2951913.2951916</a></li>     <li id="BibPLXBIB0034" label="[34]">Manuel Serrano and Christian Queinnec. 2010. A multi-tier semantics for Hop. <em>      <em>Higher-Order and Symbolic Computation</em>     </em>23, 4 (2010), 409&#x2013;431.</li>     <li id="BibPLXBIB0035" label="[35]">Peter Sewell, James&#x00A0;J. Leifer, Keith Wansbrough, Francesco&#x00A0;Zappa Nardelli, Mair Allen-Williams, Pierre Habouzit, and Viktor Vafeiadis. 2007. Acute: High-level programming language design for distributed computation. <em>      <em>J. Funct. Program.</em>     </em> (2007). <a class="link-inline force-break"      href="https://doi.org/10.1017/S0956796807006442"      target="_blank">https://doi.org/10.1017/S0956796807006442</a></li>     <li id="BibPLXBIB0036" label="[36]">Mads Tofte. 1988. <em>Operational Semantics and Polymorphic Type Inference</em>. Ph.D. Dissertation. University of Edinburgh.</li>     <li id="BibPLXBIB0037" label="[37]">TyXML2017. <em>      <em>TyXML</em>     </em>. <a class="link-inline force-break" href="http://ocsigen.org/tyxml/"      target="_blank">http://ocsigen.org/tyxml/</a></li>     <li id="BibPLXBIB0038" label="[38]">J&#x00E9;r&#x00F4;me Vouillon and Vincent Balat. 2014. From bytecode to JavaScript: the Js_of_ocaml compiler. <em>      <em>Software: Practice and Experience</em>     </em>(2014). <a class="link-inline force-break" href="https://doi.org/10.1002/spe.2187"      target="_blank">https://doi.org/10.1002/spe.2187</a></li>     <li id="BibPLXBIB0039" label="[39]">Jeremy Yallop and Leo White. 2015. Modular macros. <em>      <em>OCaml Workshop</em>     </em> (2015). <a class="link-inline force-break" href="http://www.lpw25.net/ocaml2015-abs1.pdf"      target="_blank">http://www.lpw25.net/ocaml2015-abs1.pdf</a></li>    </ul>   </section>  </section>  <section id="foot-001" class="footnote">   <header>    <div class="title-info">     <h2>FOOTNOTE</h2>    </div>   </header>   <div class="bibStrip">    <p>This paper is published under the Creative Commons Attribution 4.0 International (CC-BY&#x00A0;4.0) license. Authors reserve their rights to disseminate the work on their personal and corporate Web sites with the appropriate attribution.</p>    <p>     <em>WWW '18, April 23-27, 2018, Lyon, France</em>    </p>    <p>&#x00A9; 2018; IW3C2 (International World Wide Web Conference Committee), published under Creative Commons CC-BY&#x00A0;4.0 License. ACM ISBN 978-1-4503-5640-4/18/04.<br/>DOI: <a class="link-inline force-break" target="_blank"     href="https://doi.org/10.1145/3184558.3185953">https://doi.org/10.1145/3184558.3185953</a>    </p>   </div>  </section>  <div class="pubHistory">   <p/>  </div>  </body> </html> 
