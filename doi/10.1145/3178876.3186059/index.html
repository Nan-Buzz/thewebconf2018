<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> <head>  <title>Aladdin: Automating Release of Deep-Link APIs on Android</title>  <!-- Copyright (c) 2010-2015 The MathJax Consortium --><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>  <meta name="viewport" content="width=device-width; initial-scale=1.0;"></meta>  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>  <link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/bootstrap.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/bootstrap-theme.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/main.css"/><script src="../../../data/dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script>  <script type="text/javascript"    src="../../../data/dl.acm.org/pubs/lib/js/MathJax.js?config=TeX-AMS_CHTML"></script>  <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script> </head> <body id="main">  <section class="front-matter">   <section>    <header class="title-info">    <div class="journal-title">     <h1>      <span class="title">Aladdin: Automating Release of Deep-Link APIs on Android</span>      <br/>      <span class="subTitle"/>     </h1>    </div>    </header>    <div class="authorGroup">    <div class="author">     <span class="givenName">Yun</span>     <span class="surName">Ma</span>,     Key Lab of High-Confidence Software Technology, MoE (Peking University) Tsinghua University, <a href="mailto:mayun@pku.edu.cn">mayun@pku.edu.cn</a></div>    <div class="author">     <span class="givenName">Ziniu</span>     <span class="surName">Hu</span>,     Key Lab of High-Confidence Software Technology, MoE (Peking University), <a href="mailto:bull@pku.edu.cn">bull@pku.edu.cn</a>    </div>    <div class="author">     <span class="givenName">Yunxin</span>     <span class="surName">Liu</span>,     Microsoft Research, <a href="mailto:yunxin.liu@microsoft.com">yunxin.liu@microsoft.com</a>    </div>    <div class="author">     <span class="givenName">Tao</span>     <span class="surName">Xie</span>,     University of Illinois at Urbana-Champaign, <a href="mailto:taoxie@illinois.edu">taoxie@illinois.edu</a>    </div>    <div class="author">     <span class="givenName">Xuanzhe</span>     <span class="surName">Liu</span><a class="fn" href="#fn1" id="foot-fn1"><sup>*</sup></a>,     Key Lab of High-Confidence Software Technology, MoE (Peking University), <a href="mailto:xzl@pku.edu.cn">xzl@pku.edu.cn</a>     </div>        </div>    <br/>    <div class="pubInfo">    <p>DOI: <a href="https://doi.org/10.1145/3178876.3186059" target="_blank">https://doi.org/10.1145/3178876.3186059</a>     <br/>WWW '18: <a href="https://doi.org/10.1145/3178876" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p>    </div>    <div class="abstract">    <p>     <small>Compared to the Web where each web page has a global URL for external access, a specific &#x201C;page&#x201D; inside a mobile app cannot be easily accessed unless the user performs several steps from the landing page of this app. Recently, the concept of &#x201C;deep link&#x201D; is expected to be a promising solution and has been advocated by major service providers to enable targeting and opening a specific page of an app externally with an accessible uniform resource identifier. In this paper, we present a large-scale empirical study to investigate how deep links are really adopted, over 25,000 Android apps. To our surprise, we find that deep links have quite low coverage, e.g., more than 70% and 90% of the apps do not have deep links on app stores Wandoujia and Google Play, respectively. One underlying reason is the mandatory and non-trivial manual efforts of app developers to provide APIs for deep links. We then propose the Aladdin approach along with its supporting tool to help developers practically automate the release of deep-link APIs to access locations inside their apps. Aladdin includes a novel cooperative framework by synthesizing the static analysis and the dynamic analysis while minimally engaging developers&#x2019; inputs and configurations, without requiring any coding efforts or additional deployment efforts. We evaluate Aladdin with 579 popular apps and demonstrate its effectiveness and performance.</small>    </p>    </div>    <div class="CCSconcepts">    <p> <small> <span style="font-weight:bold;">CCS Concepts:</span> &#x2022;<strong> Human-centered computing </strong>&#x2192; <strong>Ubiquitous and mobile computing systems and tools;</strong></small> </p>    </div>    <div class="classifications">    <div class="author">     <span style="font-weight:bold;">      <small>Keywords:</small>     </span>     <span class="keyword">      <small>Deep link; Android apps; program analysis</small>     </span>    </div>    <br/>    <div class="AcmReferenceFormat">     <p>      <small>       <span style="font-weight:bold;">ACM Reference Format:</span>       <br/>       Yun Ma, Ziniu Hu, Yunxin Liu, Tao Xie, and Xuanzhe Liu. 2018. Aladdin: Automating Release of Deep-Link APIs on Android. In <em>WWW 2018: The 2018 Web Conference,</em>       <em>April 23&#x2013;27, 2018,</em>       <em> Lyon, France. ACM, New York, NY, USA</em> 11 Pages. <a href="https://doi.org/10.1145/3178876.3186059" class="link-inline force-break"       target="_blank">https://doi.org/10.1145/3178876.3186059</a></small>     </p>    </div>    </div>   </section>  </section>  <section class="body">   <section id="sec-7">    <header>    <div class="title-info">     <h2>      <span class="section-number">1</span> Introduction</h2>    </div>    </header>    <p>One key factor leading to the great success of the Web is that there are hyperlinks to access web pages and even to specific pieces of &#x201C;<em>deep</em>&#x201D; web contents. For example, the hyperlink <em><a href="https://en.wikipedia.org/wiki/World_Wide_Web#History" target="_blank">https://en.wikipedia.org/wiki/World_Wide_Web#History</a> </em> points to the &#x201C;<em>history</em>&#x201D; section of the &#x201C;<em>WorldWideWeb</em>&#x201D; wiki page. Indeed, the hyperlinks play a fundamental role on the Web in various aspects, e.g., enabling users to navigate among web pages and add bookmarks to interested contents, and making search engines capable of crawling the web contents&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0018">18</a>].</p>    <p>In the current era of mobile computing, mobile applications (a.k.a., apps) have become the dominant entrance to access the Internet&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0011">11</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0041">41</a>]. However, compared to the Web, the support for &#x201C;<em>hyperlinks</em>&#x201D; is inherently missing in mobile apps so that users have to perform tedious and trivial actions to access a specific in-app content. Other advantages from traditional Web hyperlinks are naturally missing as well.</p>    <p>After such limitation is realized, the concept of &#x201C;<strong>Deep Link</strong>&#x201D; has been proposed to enable directly opening a specific page/location inside an app from outside of this app by means of a uniform resource identifier (URI)&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0009">9</a>]. Intuitively, deep links are &#x201C;hyperlinks&#x201D; for mobile apps. For example, with the deep link &#x201C;<em><a href="../../../data/deliveryimages.acm.org/10.1145/3190000/3186059/android-app://org.wikipedia/http/en.m.wikipedia.org/wiki/World_Wide_Web" target="_blank">android-app://org.wikipedia/http/en.m.wikipedia.org/wiki/World_Wide_Web</a> </em>&#x201D;, users can directly open the page of &#x201C;<em>WorldWideWeb</em>&#x201D; in the Wikipedia app. Currently, various major service providers such as Google&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0007">7</a>], Facebook&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0006">6</a>], Baidu&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0003">3</a>], and Microsoft&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0004">4</a>] have strongly advocated deep links, and major mobile OS platforms such as iOS&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0016">16</a>] and Android&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0002">2</a>] have encouraged their developers to release deep links in their apps. Indeed, deep links bring various benefits to current stakeholders in the ecosystem of mobile computing. Mobile users can have better experiences of consuming in-app contents by directly navigating to the target app pages. App developers can make their deep links open to others who are interested in the content, data, or functionality of their apps, so that the app developers can find potential collaborators to realize the &#x201C;composition&#x201D; of apps.</p>    <p>However, it is unclear how deep links have been supported so far in the state of the broad practice. To address such issue, in this paper, we first conduct an empirical study on popular Android apps and uncover the following findings:</p>    <ul class="list-no-style">    <li id="list1" label="&#x2022;"><strong>An increasing number of deep links with app-version evolution</strong>. When the first version and latest version of the top 200 apps on Wandoujia<a class="fn" href="#fn2" id="foot-fn2"><sup>1</sup></a> are compared, the percentage of apps that support deep links increases from 30% to 80%;<br/></li>    <li id="list2" label="&#x2022;"><strong>Low coverage of deep links of current apps</strong>. Among the top 20,000 and 5,000 popular apps on Wandoujia and Google Play, more than 70% and 90% do not have deep links, respectively. For apps with deep-link support, only 4% of activities actually have deep links;<br/></li>    <li id="list3" label="&#x2022;"><strong>Non-trivial efforts from developer.</strong> Based on our study of open-source Android apps from GitHub, developers need to manually modify 45&#x2013;411 lines of code to implement one deep-link API for one activity.<br/></li>    </ul>    <p>In order to reduce the developer efforts of supporting deep links, we propose <strong><em>Aladdin</em></strong>, a novel approach that helps developers <strong>a</strong>utomate re<strong>l</strong>ease of <strong>A</strong>ndroi<strong>d</strong> app&#x0027;s <strong>d</strong>eep-l<strong>in</strong>k APIs based on a cooperative framework. Our cooperative framework combines static analysis and dynamic analysis as well as engaging minimal human efforts to provide inputs to the framework for automation. In particular, given an Android app, Aladdin first uses static analysis to find how to reach activities (each of which is the basic UI component of Android apps) inside the app most efficiently from the entrance of the app. After developers select activities of which the dynamic locations need to be deep linked, Aladdin then performs dynamic analysis to find how to reach fragments (each of which is a part of a UI component) inside each activity. Finally, Aladdin synthesizes the analysis results and generates the templates that record the scripts of how to reach a location inside the app. Aladdin provides a deep-link proxy integrated with the app code to take over the deep-link processing, and thus does not instrument the original business logic of the app. Such a proxy can accept the access via released deep-link APIs from third-party apps or services. We evaluate Aladdin on 579 popular Android apps. The evaluation results show that deep-link APIs released by Aladdin can cover a large portion of an app, and the runtime performance is desirable.</p>    <p>To the best of our knowledge, Aladdin is the first work to automate the release of deep-link APIs of Android apps without any obtrusion of their normal functionality, and thus establishes the foundation of &#x201C;<em>web-like</em>&#x201D; user experiences for Android apps. More specifically, this paper makes the following major contributions.</p>    <ul class="list-no-style">    <li id="list4" label="&#x2022;">We conduct an extensive empirical study of current deep links based on 25,000 popular Android apps, uncovering the current status of deep links and the developer efforts to implement deep links.<br/></li>    <li id="list5" label="&#x2022;">We propose an approach to helping developers practically automate the release of deep-link APIs based on a cooperative framework, with developers&#x2019; only very minimal configuration efforts and no interference of the normal functionalities of an app.<br/></li>    <li id="list6" label="&#x2022;">We evaluate the effectiveness of our approach on popular Android apps.<br/></li>    </ul>   </section>   <section id="sec-8">    <header>    <div class="title-info">     <h2>      <span class="section-number">2</span> Background</h2>    </div>    </header>    <p>In this section, we present some background knowledge of Android apps and deep links.</p>    <section id="sec-9">    <header>     <div class="title-info">      <h3>       <span class="section-number">2.1</span> A Conceptual Analogy</h3>     </div>    </header>    <p>An Android app, identified by its package name, usually consists of multiple <tt>Activities</tt> that are loosely bound to each other. An activity is a component that provides a user interface for users to interact with, such as dialing phones, watching videos, or reading news. Each activity is assigned a window to draw its graphical user interface. One activity in an app is specified as the &#x201C;main&#x201D; activity, which is first presented to users when the app is launched.</p>    <p>For ease of understanding, we can draw an analogy between Android apps and the Web, as compared in Table&#x00A0;<a class="tbl" href="#tab1">1</a>. An Android app can be regarded as a website where the package name of the app is like the domain of the website. Therefore, activities can be regarded as web pages because both of them are basic blocks for apps and websites, respectively, providing user interfaces. The main activity is just like the home page of a website.</p>    <p>An activity has several view components to display its user interface, such as <tt>TextView, ButtonView</tt>, and <tt>ListView</tt>. View components are similar to web elements consisting of a web page, such as <tt>&#x003C;p&#x003E;</tt>, <tt>&#x003C;button&#x003E;</tt>, and <tt>&#x003C;ul&#x003E;</tt>. When a web page is complex, frames are often used to embed some web elements for better organization. Frames are subpages of a web page. Similarly, since the screen size of mobile devices is rather limited, Android provides <tt>Fragment</tt> as a portion of user interfaces to enclose some view components in an activity. An activity could have one or more fragments, forming subpages of the activity.</p>    <p>Activities and fragments hold the contents inside apps, just like web pages and frames, which encapsulate contents on the Web. In the rest of this paper, we use the term &#x201C;page&#x201D; and &#x201C;activity&#x201D; exchangeably, as well as &#x201C;subpage&#x201D; and &#x201C;fragment&#x201D; exchangeably, for ease of presentation.</p>    <p>Transitions between activities are executed through <tt>Intents</tt>. An intent is a messaging object used to request an action from another component, and thus essentially supports Inter-Process Communication (IPC) at the OS level. Note that intents can be used to transit between activities from both the same apps and two different apps. There are two types of intents: (1) <em>explicit</em> intents, which specify the target activity by its class name; (2) <em>implicit</em> intents, which declare <tt>action</tt>, <tt>category</tt>, and/or <tt>data</tt> that can be handled by another activity. Messages are encapsulated in the <tt>extra</tt> field of an intent. When an activity <em>P</em> sends out an intent <em>I</em>, the Android system finds the target activity <em>Q</em> that can handle <em>I</em>, and then loads <em>Q</em>, achieving the transition from <em>P</em> to <em>Q</em>.</p>    <div class="table-responsive" id="tab1">     <div class="table-caption">      <span class="table-number">Table 1:</span>      <span class="table-title">Conceptual comparison between Android apps and the Web.</span>     </div>     <table class="table">      <thead>       <tr>       <th style="text-align:left;">        <strong>Concepts of Android Apps</strong>       </th>       <th>        <strong>Concepts of Web</strong>       </th>       </tr> 						</thead> 						<tbody>       <tr>       <td style="text-align:left;">app</td>       <td>website</td>       </tr>       <tr>       <td style="text-align:left;">package name</td>       <td>domain</td>       </tr>       <tr>       <td style="text-align:left;">activity</td>       <td>web page</td>       </tr>       <tr>       <td style="text-align:left;">main activity</td>       <td>home page</td>       </tr>       <tr>       <td style="text-align:left;">view component</td>       <td>web element</td>       </tr>       <tr>       <td style="text-align:left;">fragment</td>       <td>frame</td>       </tr>      </tbody>     </table>    </div>    </section>    <section id="sec-10">    <header>     <div class="title-info">      <h3>       <span class="section-number">2.2</span> Deep Links</h3>     </div>    </header>    <p>The idea of deep links for mobile apps originates from the prevalence of hyperlinks on the Web. Every single web page has a globally unique identifier, namely URL. In this way, web pages are accessible directly from anywhere by means of URLs. Typically, web users can enter the URL of a web page in the address bar of web browsers, and click the &#x201C;Go&#x201D; button to open the target web page. The web users can also click through hyperlinks on one web page to navigate directly to other web pages. <figure id="fig1">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186059/images/www2018-68-fig1.jpg" class="img-responsive" alt="Figure 1"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 1:</span>       <span class="figure-title">The trend and status of deep links among Android apps.</span>      </div>     </figure>    </p>    <p>Compared to web pages, the mechanism of hyperlinks is historically missing for mobile apps. To address the problem, deep links are proposed to enable directly opening a specific page inside an app from outside of this app with a uniform resource identifier (URI). The biggest benefit of deep links is not limited in enabling users to directly navigate to specific locations of an app, but further supports other apps or services (e.g., search engines) to be capable of accessing the internal data of an app and thus enables &#x201C;communication&#x201D; of apps to explore more features, user experiences, and even revenues. Below are some usage scenarios of deep links.</p>    <ul class="list-no-style">     <li id="list7" label="&#x2022;"><strong>In-App Search</strong>. In-app search&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"       href="#BibPLXBIB0007">7</a>] enables mobile users to search contents inside apps and enter directly into the app page containing the information from search results.<br/></li>     <li id="list8" label="&#x2022;"><strong>Bookmarking</strong>. Mobile users can create bookmarks to the information or functionalities inside apps for later use&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"       href="#BibPLXBIB0018">18</a>].<br/></li>     <li id="list9" label="&#x2022;"><strong>Content Sharing</strong>. With deep links, mobile users can share pages from one app to friends in social networking apps&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"       href="#BibPLXBIB0006">6</a>].<br/></li>     <li id="list10" label="&#x2022;"><strong>App Mashup</strong>. Other than simple content sharing, deep links can further act as the support for realizing &#x201C;<em>app mashup</em>&#x201D;&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"       href="#BibPLXBIB0035">35</a>] to integrate services from different apps, such as IFTTT&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"       href="#BibPLXBIB0008">8</a>].<br/></li>    </ul>    </section>   </section>   <section id="sec-11">    <header>    <div class="title-info">     <h2>      <span class="section-number">3</span> Empirical Study</h2>    </div>    </header>    <p>Given the benefits of deep links for mobile apps, in this section, we present an empirical study to understand the state of practice of deep links in current Android apps. We focus on three aspects: <em>(1) the trend of deep links with version evolution of apps</em>; <em>(2) the number of deep links in popular apps</em>; (3) <em>how deep links are realized in current Android apps.</em>    </p>    <p>In practice, there is no standard way of measuring how many deep links an app has. However, according to Android&#x0027;s developer guide&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>], we can infer an essential condition, i.e., <strong>activities that support deep links MUST have a special kind of intent filters declared in the</strong>     <tt>     <strong>AndroidManifest.xml</strong>    </tt>    <strong>file</strong>. Such kind of intent filters should use the <tt>android.intent.</tt>    <tt>action.VIEW</tt> with the <tt>android.</tt>    <tt>intent.category.BROWSABLE</tt> category. We denote these intent filters as deep-link related. If an activity has deep-link related intent filters, then we say that the activity is registered with deep links. Therefore, we can take the number of activities registered with deep links as an indicator to estimate the number of deep links for an Android app. We should mention that activities without deep-link related intent filters may still support deep links because developers can register a single activity with deep links and forward the link request to other activities. As a result, our estimation of deep links may be below the actual number. However, such case usually exists in apps that have only one activity registered with deep links. So our results are still able to reveal the status of deep links in practice.</p>    <section id="sec-12">    <header>     <div class="title-info">      <h3>       <span class="section-number">3.1</span> Evolution of Deep Links with Versions</h3>     </div>    </header>    <p>We first validate that the support of deep links is really desired. To this end, we investigate the trend of deep links along with the version evolution. We choose top 200 apps (as of Jan. 2017) ranked by Wandoujia, a leading Android app store in China, which was studied in our previous work&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0031">31</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0034">34</a>]. To make comparison, we manually download each app&#x0027;s first version that could be publicly found on the Internet and its latest version published on Wandoujia as of Jan. 2017. We compare the number of deep links in the two versions of each app. Figure&#x00A0;<a class="fig" href="#fig1">1</a>(a) shows the distribution of the number of deep links among all the apps in each version. Generally, it is observed that when first released, only 30% of apps have deep links. In contrast, more than 80% of these apps have supported deep links in their latest versions. More specifically, the maximum number of deep links is 35 in the first version and it increases to 81 in the latest version. Such a change indicates that the popularity of deep links keeps increasing in the past few years.</p>    </section>    <section id="sec-13">    <header>     <div class="title-info">      <h3>       <span class="section-number">3.2</span> Coverage of Deep Links</h3>     </div>    </header>    <p>Although the number of deep-link supported apps increases, the percentage of activities that have deep links in deep-link supported apps is still rather low. We compute the ratio of activities with deep links to the total number of activities. As shown in Figure&#x00A0;<a class="fig" href="#fig1">1</a>(b) . It is surprising to find that the percentage of activities with deep links becomes smaller from the first to the latest version. For the first version, there are more than 20% of apps of which the percentage of activities with deep links is above 10%, but the number of apps decreases to 15% for the latest version. The reason is that developers add more activities when upgrading their apps but they release deep links to only fixed activities.</p>    <p>Aiming to expand the investigation to a wide scope, we study the latest version of 20,000 popular apps on Wandoujia, and 5,000 popular apps on Google Play as of Jan. 2017. Figure&#x00A0;<a class="fig" href="#fig1">1</a>(c) shows the distribution of the number of deep links among apps in the two app stores. Similar to the preceding results, more than 70% and 90% of the apps do not have deep links on Wandoujia and Google Play, respectively. Such a result indicates that deep links are not well supported in a large scope of current Android apps, especially the international apps on Google Play.</p>    <p>Considering the percentage of activities with deep links, Figure&#x00A0;<a class="fig" href="#fig1">1</a>(d) shows that the median percentage is just about 4%, implying that a very small fraction of the locations inside apps can be actually accessed via deep links. About only 10% of apps have more than 20% of activities with deep links. There is no significant difference between the distribution on Wandoujia and Google Play, meaning that the low coverage of deep links is common for the Android ecosystem.</p>    <p>In summary, our study result shows the low coverage of deep links in current Android apps. Such a result is a bit out of our expectation, since deep links are widely encouraged in industry. There are four possible reasons leading to the low coverage of deep links. First, as deep link is a relatively new concept, it may take some time to be adopted by Android developers. Second, due to commercial or security considerations, developers may not be willing to expose their apps to third parties through deep links. Third, developers may not have clear motivation to determine which part of their apps needs to be exposed by deep links. Fourth, as we show later, implementing deep links requires non-trivial developer efforts so that developers may not be proactive to introduce deep links in their apps. However, deep link is still promising in the mobile ecosystem given major Internet companies being strong advocates as well as the potential revenue brought by opening data and cooperating with other apps.</p>    <div class="table-responsive" id="tab2">     <div class="table-caption">      <span class="table-number">Table 2:</span>      <span class="table-title">LoC changes when adding deep links of open-source apps on GitHub.</span>     </div>     <table class="table">      <thead>       <tr>       <th style="text-align:left;">        <strong>Repository Name</strong>       </th>       <th>        <strong>LoC Changes</strong>       </th>       </tr>       </thead> 						<tbody> 						<tr>       <td style="text-align:left;">stm-sdk-android</td>       <td>45</td>       </tr>       <tr>       <td style="text-align:left;">mobiledeeplinking-android</td>       <td>62</td>       </tr>       <tr>       <td style="text-align:left;">WordPress-Android</td>       <td>73</td>       </tr>       <tr>       <td style="text-align:left;">mopub-android-sdk</td>       <td>78</td>       </tr>       <tr>       <td style="text-align:left;">ello-android</td>       <td>87</td>       </tr>       <tr>       <td style="text-align:left;">bachamada</td>       <td>179</td>       </tr>       <tr>       <td style="text-align:left;">sakai</td>       <td>237</td>       </tr>       <tr>       <td style="text-align:left;">SafetyPongAndroid</td>       <td>411</td>       </tr>      </tbody>     </table>    </div>    </section>    <section id="sec-14">    <header>     <div class="title-info">      <h3>       <span class="section-number">3.3</span> Developer Efforts</h3>     </div>    </header>    <p>Supporting deep links requires the developers to provide deep-link APIs that implement the processing logics for deep-link requests, not just by declaring the intent filter in the AndroidManifest.xml file. Although there have already been some SDKs for deep links&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0005">5</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0010">10</a>], providing deep-link APIs exactly requires the modifications or even refactoring of the original implementation of the apps. We then study the actual developer efforts when supporting deep links for an Android app.</p>    <p>For simplicity, we study the code evolution history of open-source apps on GitHub. We search on GitHub with the key word &#x201C;<em>deep link</em>&#x201D; among all the code-merging requests in the Java language. There are totally 4,514 results returned. After manually examining all the results, we find 8 projects that actually add deep links in their code-commit history. We carefully check the code changes in the commits related to deep links. Table&#x00A0;<a class="tbl" href="#tab2">2</a> shows the LoC (lines of code) changes in each project when implementing a deep-link API to just <em>one</em> activity in the corresponding code commit. The changes include the addition, modification, and deletion of the code. We can observe that the smallest number of the LoC change is 45 and the largest number can reach 411. Take the app <tt>SafetyPongAndroid</tt><a class="fn" href="#fn3" id="foot-fn3"><sup>2</sup></a> as an example. We find that a large number of changes attribute to the refactoring of app logics to enable an activity to be directly launched without relying on other activities. Several objects that are previously initialized in other activities need to be initialized in the activity to be deep linked. Such an observation can provide us the preliminary findings that developers need to invest non-trivial manual efforts on existing apps to support deep links. Such a factor could be one of the potential reasons why deep links are of low coverage.</p>    </section>   </section>   <section id="sec-15">    <header>    <div class="title-info">     <h2>      <span class="section-number">4</span> Aladdin: In a Nutshell</h2>    </div>    </header>    <p>The findings of our empirical study demonstrate the <strong>low coverage</strong> and <strong>non-trivial developer efforts</strong> of supporting deep links in current Android apps. To make deep links practically and broadly supported by existing apps, we propose the <em>     <strong>Aladdin</strong>    </em> approach to automating release of Android app&#x0027;s deep-link APIs that enable apps to reach the target locations with deep-link requests. The design goals of Aladdin are four aspects:</p>    <p>    <strong>Maximal deep-link coverage</strong>. Aladdin should release deep-link APIs to as many activities as possible for developers to choose the desirable locations to actually expose deep links.</p>    <p>    <strong>Supporting fine-grained deep links</strong>. Current deep links point to only activities. However, it becomes popular that activities have multiple fragments for different features. Aladdin should release deep-link APIs not only to activities, but also to fragments for better user experience.</p>    <p>    <strong>Minimal developer efforts</strong>. Aladdin should automate the process of releasing deep-link APIs and require few or zero coding efforts.</p>    <p>    <strong>Minimal runtime overhead</strong>. The performance of requesting deep links via the APIs generated by Aladdin should be efficient enough to ensure good user experience.</p>    <p>Figure&#x00A0;<a class="fig" href="#fig2">2</a> shows the overview of Aladdin. Aladdin achieves the preceding goals via designing a cooperative framework of program analysis and a proxy architecture of deep-link execution. More specifically, Aladdin&#x0027;s cooperative framework combines static program analysis and dynamic program analysis while minimally engaging developers to provide inputs to obtain the app&#x0027;s execution paths that can be re-executed afterwards given the parameter values. Each path represents a deep-link API pointing to a specific kind of locations inside the app. Leveraging the Android testing framework, Aladdin&#x0027;s proxy architecture can enable deep-link execution without having to modify the app code. We next present the details of our approach. <figure id="fig2">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186059/images/www2018-68-fig2.jpg" class="img-responsive" alt="Figure 2"      longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 2:</span>      <span class="figure-title">Approach overview.</span>     </div>    </figure>    </p>    <section id="sec-16">    <header>     <div class="title-info">      <h3>       <span class="section-number">4.1</span> Analyzing Execution Paths to Activities</h3>     </div>    </header>    <p>Essentially, reaching an activity with a deep link is to issue one intent that could launch the target activity. However, the complexity of activity communications in Android apps makes it not easy to use a single intent to reach an activity for existing apps. For example, a target activity may rely on internal objects that are created by previous activities in the path from the main activity to the target activity. To address the issue, for each activity, Aladdin analyzes an intent sequence from the main activity of the app to the activity. Therefore, the activity dependency can be resolved because we actually follow the original logic of activity communications.</p>    <section id="sec-17">     <p><em>4.1.1 Navigation Analysis.</em> Since activities are loosely coupled, communicating through intents, there is no explicit control flow between activities. Therefore, we design a <em>Navigation Graph</em> to abstract the activity transitions. Here we give the formal definitions of activity transition and navigation graph.</p>     <div class="definition" id="enc1">      <Label>Definition 1 (Activity Transition).</Label>      <p> An activity transition <span class="inline-equation"><span class="tex">$t(\mathcal {L})$</span>       </span> is triggered by an intent, where <span class="inline-equation"><span class="tex">$\mathcal {L}$</span>       </span> is the combination of all the fields of the intent including action, category, data, and objects of basic types from the extra field.</p>     </div>     <p>Since an intent essentially encapsulates several messages passed between two activities, we use a label set <span class="inline-equation"><span class="tex">$\mathcal {L}$</span>      </span> to abstract an intent. Two intents are equivalent if and only if the label sets are the same. Note that from the extra field, which is the major place to encapsulate messages, we take into account only the objects of basic types including <tt>int</tt>, <tt>double</tt>, <tt>String</tt>, etc. The reason is that objects of app-specific classes are usually internally created but cannot be populated from outside of the app. As a result, this kind of intents cannot be re-executed at runtime.</p>     <div class="definition" id="enc2">      <Label>Definition 2 (Navigation Graph).</Label>      <p> A Navigation Graph <em>G</em> is a directed graph with a start vertex. It is denoted as a 3-tuple, <em>G</em> < <em>V</em>, <em>E</em>, <em>r</em> > , where <em>V</em> is the set of vertices, representing all the activities of an app; <em>E</em> is the set of directed edges, and every single <em>e</em>(<em>v</em>       <sub>1</sub>, <em>v</em>       <sub>2</sub>) represents an activity transition <span class="inline-equation"><span class="tex">$t(\mathcal {L})$</span>       </span>; <em>r</em> is the start vertex.</p>     </div>     <p>In such a navigation graph, the start vertex <em>r</em> refers to the main activity of the app. We assume that each node in <em>V</em> could be reachable from the start vertex <em>r</em>. The navigation graph can have multi-edges, i.e., &#x2203;<em>e</em>      <sub>1</sub>, <em>e</em>      <sub>2</sub> &#x2208; <em>E</em>, <em>v<sub>start</sub>      </em>(<em>e</em>      <sub>1</sub>) = <em>v<sub>start</sub>      </em>(<em>e</em>      <sub>2</sub>)~<em>and</em>~<em>v<sub>end</sub>      </em>(<em>e</em>      <sub>1</sub>) = <em>v<sub>end</sub>      </em>(<em>e</em>      <sub>2</sub>), indicating that there can be more than one transition between two activities. In addition, it should be noted that the navigation graph can be cyclic.</p>    </section>    <section id="sec-18">     <p><em>4.1.2 Shortcut Analysis.</em> After constructing the navigation graph, we analyze the paths to each activity.</p>     <div class="definition" id="enc3">      <Label>Definition 3 (Path).</Label>      <p> A path to an activity <span class="inline-equation"><span class="tex">$\mathcal {P}_a$</span>       </span> is an ordered list of activity transitions {<em>t</em>       <sub>1</sub>, <em>t</em>       <sub>2</sub>, &#x2026;, <em>t<sub>k</sub>       </em>} starting from the main activity, where <em>k</em> is the length of the path.</p>     </div>     <p>According to the path definition, the activity transition <em>t</em>      <sub>1</sub> is always the app-launching intent that opens the main activity. The path <span class="inline-equation"><span class="tex">$\mathcal {P}_a$</span>      </span> can ensure that all the internal dependencies are properly initialized before reaching the activity <em>a</em>.</p>     <p>In practice, there can be various paths to reach a specific activity. Since our approach uses the activity transitions to reach activities by deep links, the path should be as short as possible to reduce the execution time at the system level. Therefore, for each activity, we compute the shortest path, denoted as the shortcut, and the combination of labels in the activity transitions of the path constitutes the label set of the shortcut.</p>     <div class="definition" id="enc4">      <Label>Definition 4 (Shortcut).</Label>      <p> A Shortcut <span class="inline-equation"><span class="tex">$\mathcal {T}(\mathcal {L})$</span>       </span> of an activity <em>a</em> is the shortest path <span class="inline-equation"><span class="tex">$\mathcal {P}_a = \lbrace t_i\rbrace$</span>       </span>, and <span class="inline-equation"><span class="tex">$\mathcal {L} = \cup \mathcal {L}{t_i}$</span>       </span>.</p>     </div>    </section>    </section>    <section id="sec-19">    <header>     <div class="title-info">      <h3>       <span class="section-number">4.2</span> Analyzing Execution Paths to Fragments</h3>     </div>    </header>    <p>As shown in Section&#x00A0;<a class="sec" href="#sec-8">2</a>, there are different fragments in an activity for serving as user interface, just like the frames in a web page. In order to reach a specific fragment directly with a deep link, we should further analyze how to transfer to fragments of an activity.</p>    <p>Contrary to activity transitions where intents can be sent to invoke the transition, the fragment transitions often occur after users perform an action on the interface such as clicking a view component, then the app gets the user action and executes the transition. Due to the dynamics of activities, fragments of activities may be dynamically generated, just like AJAX on the Web. To the best of our knowledge, it is currently not possible to find out fragments by static analysis. Thus, we choose to use dynamic analysis, traversing the activity by clicking all the view components on the page in order to identify all the fragments and their corresponding triggering actions.</p>    <section id="sec-20">     <p><em>4.2.1 Fragment Identification.</em> Unlike activities where the class name is the identifier of an activity, fragments usually do not have explicit identifiers. To determine whether we have switched fragments after clicking a view component, we use the view structure to identify a certain fragment. In Android, all the view components are organized in a hierarchy view tree. We get the view tree at runtime and design Algorithm&#x00A0;1 to calculate the structure hash of this tree, and use the hash to identify the fragments. The algorithm is recursive with a view component <em>r</em> as input. If <em>r</em> does not have children, the result is only the string hash of <em>r</em>&#x2019;s view tag (Line 2). If <em>r</em> has children (Line 3), then we use the algorithm to calculate all the hash values of its children recursively (Lines 5-7). Then, we sort <em>r</em>&#x2019;s children based on their hash values to ensure the consistency of the structure hash, because a view component&#x0027;s children do not keep the same order every time (Line 8). Next, we add the children&#x0027;s hash values together with the view tag forming a new string (Line 10), and finally return the string hash (Line 13). When inputting the root view component of the tree to the algorithm, we could get a structure hash of the view tree. The hash can be used as an identifier of a fragment.</p>     <p>      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186059/images/www2018-68-img1.svg" class="img-responsive" alt="" longdesc=""/>     </p>    </section>    <section id="sec-21">     <p><em>4.2.2 Fragment Transition Graph.</em> In order to retrieve all the fragments as well as triggering actions to each fragment, we define a fragment transition graph to represent how fragments are switched in an activity.</p>     <div class="definition" id="enc5">      <Label>Definition 5 (Fragment Transition Graph).</Label>      <p> A Fragment Transition Graph is a directed graph with a start vertex. It is denoted by a 3-tuple, <em>FTG</em> < <em>V</em>, <em>E</em>, <em>r</em> > . <em>V</em> is the set of vertices, representing all the fragments of an activity, identified by the structure hash. <em>E</em> is the set of directed edges. Each edge e is a 3-tuple, <em>e</em> < <em>S</em>, <em>T</em>, <em>I</em> > . <em>S</em> and <em>T</em> are source and target fragments where <em>I</em> represents the resource id of the view component that invokes the transition. <em>r</em> is the start vertex.</p>     </div>     <p>The dynamic analysis is performed on an instance of a given activity. Therefore, after developers select this given activity to support deep links to fragments, a simulator is launched and developers are asked to transfer to an instance page of this activity. From this page, the simulator traverses view components from the activity in the depth-first order. For each traversed view component, we try to click it and make sure that the UI stays in the same given activity (if not, then we use the system method <tt>doback()</tt> to directly return to the given activity, and traverse the next view component). Then, we check whether the clicking has caused the view component&#x0027;s enclosing fragment to transit to a new fragment, determined based on the fragments&#x2019; structure hash values. If a new fragment is reached, we add the fragment transition (from the previous fragment to the new fragment) to the edge set. The dynamic analysis is similar to the web crawlers that need to traverse every web page, except that Android provides only the <tt>doback()</tt> method for returning to the previous activity, but not to the previous fragment. So to implement backtrace after fragment transitions, we have to restart the app and recover to the previous fragment.</p>     <p>After finishing the traversal, we get the fragment transition graph and a list of fragments. To get the action path toward a certain fragment, we simply combine all the edges from the start vertex to the fragment.</p>    </section>    </section>    <section id="sec-22">    <header>     <div class="title-info">      <h3>       <span class="section-number">4.3</span> Releasing Deep-Link Supported Apps</h3>     </div>    </header>    <p>After we compute the shortcuts to activities and action paths to fragments, the last step is to create the target APK file that supports the deep-link APIs. Note that developers may want to create deep links to only some locations inside their apps. Therefore, Aladdin allows developers to configure the locations to release deep-link APIs, including the activities and fragments inside activities. Then for each selected location, Aladdin generates the API schema represented by an abstract URI, and the API implementation represented by a deep-link template.</p>    <figure id="fig3">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186059/images/www2018-68-fig3.jpg" class="img-responsive" alt="Figure 3"      longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 3:</span>      <span class="figure-title">Example of deep link templates.</span>     </div>    </figure>    <p>For the API schema, in order to conform to the latest deep link specification starting from Android 6&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0002">2</a>], we employ the format of &#x201C;<em><a href="http://host/target?parameter#fragment" target="_blank">http://host/target?parameter#fragment</a></em>&#x201D;. We use the reverse string of the <tt>packageName</tt> (usually the domain of the corresponding website) for the <em>host</em> field and the <tt>className</tt> of the activity for the <em>target</em> field. The <em>parameter</em> fields are just the labels in the activity&#x0027;s shortcut. For deep links to fragments, the name of the target fragment is after a <span class="inline-equation"><span class="tex">$\#$</span>     </span>.</p>    <p>A deep-link template consists of the shortcut of the corresponding activity and the action path of the corresponding fragment. Figure&#x00A0;<a class="fig" href="#fig3">3</a> shows two deep link templates of the <tt>Anki</tt> app for the <tt>CardTemplateEditor</tt> and <tt>NoteEditor</tt> activities, respectively. Two intents with two parameters <tt>CALLER</tt> and <tt>modeId</tt> have to be issued before reaching <tt>CardTemplateEditor</tt>. Therefore, the deep link to <tt>CardTemplateEditor</tt> should explicitly specify the values of the two parameters. <tt>NoteEditor</tt> has a fragment naming &#x201C;<em>tags</em>&#x201D;. The action to the fragment is clicking the view component whose resource id is <tt>CardEditorTagButton</tt>. Therefore, to reach the tags fragment, not only should the value of intents be assigned (<em>CALLER</em> = 3), but the fragment should be specified as well (<span class="inline-equation"><span class="tex">$\#tags$</span>     </span>).</p>    <p>We leverage a proxy architecture to realize minimal refactorings to the original app. Figure&#x00A0;<a class="fig" href="#fig4">4</a> depicts the structure of the created APK. A <em>Proxy Activity</em> is used to handle all the incoming requests. For each deep-link API, we generate an intent filter according to the API&#x0027;s schema and attach the intent filter to the <em>Proxy Activity</em> in the <tt>AndroidManifest.xml</tt> file. When an intent is passed to the <em>Proxy Activity</em>, if the intent matches one of the schemas of deep-link APIs, the <em>Proxy Activity</em> informs the <em>Execution Engine</em> to execute the deep link. If the incoming intent cannot match to any of the schemas, it is then forwarded directly to the original <em>App Code</em> for default execution.</p>    <p>When a deep link is requested via the API, the corresponding deep-link template is instantiated with concrete values to create an execution script. Then the <em>Execution Engine</em> communicates with the original <em>App Code</em> and instructs the app to transit through activities and perform actions on view components according to the script. For example, in Figure&#x00A0;<a class="fig" href="#fig3">3</a>(b), when the deep link <a class="link-inline force-break"      href="http://anki.ichi2.com/NoteEditor?CALLER=3#tags">http://anki.ichi2.com/NoteEditor?CALLER=3#tags</a> is requested, it implies that the user wants to reach the tags fragment of <tt>NoteEditor</tt> in the <tt>Anki</tt> app. So the <em>Execution Engine</em> first issues the intent with the parameter <tt>CALLER</tt> as 3, and then performs a click on the view component whose resource id is <tt>CardEditorTagButton</tt>, reaching the target location. <figure id="fig4">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186059/images/www2018-68-fig4.jpg" class="img-responsive" alt="Figure 4"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 4:</span>       <span class="figure-title">Structure of the app with deep link enabled.</span>      </div>     </figure>    </p>    </section>   </section>   <section id="sec-23">    <header>    <div class="title-info">     <h2>      <span class="section-number">5</span> Implementation</h2>    </div>    </header>    <p>To construct the <em>Navigation Graph</em>, we first use the <tt>IC3</tt> tool&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0038">38</a>] to extract all the activities and intents from the APK file of an Android app. Then we apply the <tt>PRIMO</tt> tool&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0037">37</a>] to compute the links among activities. For each link computed by <tt>PRIMO</tt>, we add the corresponding activity as a node to the <em>Navigation Graph</em> and connect the two nodes with an edge. The labels on the edge are retrieved from the output of <tt>IC3</tt>. In particular, some edges have only a sink activity, indicating that this activity can be directly opened from outside of the app. For these edges, we add an edge from the main activity node, to make all the nodes reachable from the main activity.</p>    <figure id="fig5">    <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186059/images/www2018-68-fig5.jpg" class="img-responsive" alt="Figure 5"      longdesc=""/>    <div class="figure-caption">     <span class="figure-number">Figure 5:</span>     <span class="figure-title">Distribution of the percentage of deep-linked activities before and after applying Aladdin.</span>    </div>    </figure>    <figure id="fig6">    <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186059/images/www2018-68-fig6.jpg" class="img-responsive" alt="Figure 6"      longdesc=""/>    <div class="figure-caption">     <span class="figure-number">Figure 6:</span>     <span class="figure-title">Distribution of the percentage of reached activities with Aladdin released deep-link APIs.</span>    </div>    </figure> <figure id="fig7">    <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186059/images/www2018-68-fig7.jpg" class="img-responsive" alt="Figure 7"      longdesc=""/>    <div class="figure-caption">     <span class="figure-number">Figure 7:</span>     <span class="figure-title">The recall and precision of identifying fragments by Aladdin's dynamic analysis.</span>    </div>    </figure>    <p>We use the instrumentation test framework provided by the Android SDK to implement the dynamic analysis. The framework can load both a test package and the App-Under-Test (AUT) into the same process. Therefore, we are able to inspect and change the runtime of an app, such as retrieving view components of an activity and triggering user actions.</p>    <p>To generate the APK file with deep link enabled, the <em>Execution Engine</em> is actually implemented as a test case of the instrumentation test to execute the deep-link templates with parameter values. The deep-link proxy is implemented as a normal Android activity and the corresponding schemas are regularly configured as intent filters in the <tt>AndroidManifest.xml</tt> file. When the proxy activity receives a deep-link request, it launches the instrumentation test to run the Execution Engine. The Execution Engine uses the instrumentation object provided by the framework to send intents in the app process, reaching the target activity. Then it sends action events to finally reach the target fragment.</p>   </section>   <section id="sec-24">    <header>    <div class="title-info">     <h2>      <span class="section-number">6</span> Evaluations</h2>    </div>    </header>    <p>In this section, we evaluate Aladdin from four aspects, i.e., the coverage improvement of deep links to activities, the effectiveness of deep links to fragments, the performance of executing deep links, and the overhead incurred by Aladdin.</p>    <section id="sec-25">    <header>     <div class="title-info">      <h3>       <span class="section-number">6.1</span> Deep Link Coverage of Activities</h3>     </div>    </header>    <p>We first investigate to what extent Aladdin can help support deep links to activities. We collect a representative dataset by choosing top 50 apps from each of the 14 categories (without Game) on Wandoujia. Then we perform Aladdin&#x0027;s static analysis to all the apps in our dataset, and calculate the percentage of activities that can be released with deep-link APIs after applying Aladdin. Due to the bytecode obfuscation and proguard, some of the apps fail to be analyzed by Aladdin. Such failures are due to the limitation of the static analysis tool that we use to implement Aladdin, not the Aladdin approach itself. We finally get results from 579 apps. Figure&#x00A0;<a class="fig" href="#fig5">5</a> shows the distribution of the percentage of &#x201C;deep-linked&#x201D; activities before and after applying Aladdin. The current coverage of deep links in these apps is very low (the median coverage is 0). In contrast, Aladdin can release deep-link APIs for more than 90% of these apps (the median coverage reaches 60%). In particular, 55 apps (about 9%) have more than 90% of deep linked activities after Aladdin is applied. Such an observation indicates that Aladdin can effectively support deep links to most activities, thus improving the coverage of deep links. Note that the coverage does not reach 100% after applying Aladdin because Aladdin handles the intents whose parameters are all basic types, but intents to some activities actually have complex objects of app-specific classes.</p>    <p>To evaluate whether the released deep-link APIs can be executed correctly, we further run every single app in the dataset to collect a set of concrete deep links. For each app, we use the popular Monkey tool&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0012">12</a>] to randomly generate 1,000 events every 60 ms, and retrieve the intents from ADB when activities are switched. We record all the reached activities as well as the corresponding intents. Then we filter out those activities where deep-link APIs have been released by Aladdin, extract parameter values from the intents, and assign the values to the corresponding API to instantiate concrete deep links. Then we request each concrete deep link to check whether the same activity instance as the recorded one can be reached. If the requested activity can be accessed, we can confirm that the derived deep link is correct. The results show that <em>all the deep links can be correctly executed to the target activity instance</em>, indicating that the correctness of the released deep-link APIs is well assured.</p>    <p>Additionally, the collected activities could represent the commonly used features in an app. For each app, we calculate the percentage of activities with Aladdin-released deep-link APIs over all the reached activities. Figure&#x00A0;<a class="fig" href="#fig6">6</a> shows the distribution of the percentage among all the apps. It is observed that for more than 90% of the apps, all the reached activities are released with deep-link APIs by Aladdin. Such a result indicates that Aladdin can support deep links to most of the commonly used features in an app. <figure id="fig8">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186059/images/www2018-68-fig8.jpg" class="img-responsive" alt="Figure 8"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 8:</span>       <span class="figure-title">Performance of executing deep links.</span>      </div>     </figure> <figure id="fig9">      <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186059/images/www2018-68-fig9.jpg" class="img-responsive" alt="Figure 9"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 9:</span>       <span class="figure-title">Distribution of the size of the deep-link templates.</span>      </div>     </figure>    </p>    </section>    <section id="sec-26">    <header>     <div class="title-info">      <h3>       <span class="section-number">6.2</span> Deep Link Effectiveness of Fragments</h3>     </div>    </header>    <p>We then evaluate how Aladdin&#x0027;s dynamic analysis can effectively support deep links to fragments. From the 579 apps described in Section&#x00A0;<a class="sec" href="#sec-25">6.1</a>, we select 30 apps whose main activity has at least 5 fragments. Then we apply Aladdin&#x0027;s dynamic analysis to identify fragments for the main activity in each app. The number of fragments found by the dynamic analysis is denoted as <em>N</em>. We also manually explore the main activity in each app to examine the number of desired fragments (denoted as <em>D</em>) as the ground truth for comparison. Next, we manually compare the screenshots between the fragments identified by Aladdin and the manually examined fragments, and the number of the same fragments in both sets is denoted as <em>C</em>. Therefore, we can use the <em>recall</em> (which is <em>C</em>/<em>D</em>) and <em>precision</em> (which is <em>C</em>/<em>N</em>) to measure the effectiveness of Aladdin&#x0027;s dynamic analysis.</p>    <p>Figure&#x00A0;<a class="fig" href="#fig7">7</a> shows the scatter diagram of the recall and precision for the 30 apps. Each cross in the diagram represents the apps with the same recall and precision value. We can see that for 9 out of the 30 apps, both the precision and recall can reach 100% (represented by the biggest cross in the top right corner), indicating that our dynamic analysis has just found all the fragments as desired and no redundant fragments are identified.</p>    <p>For 10 apps, the precision reaches 100% but the recall does not, indicating that all the identified fragments are desired but some desired fragments are omitted. The reason is that the view component triggering the fragment transition does not have an explicit resource ID and thus cannot be found by the dynamic analysis. To address this issue, we can use the relative location in the view tree that we build at runtime to identify every single view component rather than relying on only the resource ID.</p>    <p>For 3 apps, the recall reaches 100% but the precision does not, indicating that Aladdin has identified all the desired fragments but there exist some redundant results, i.e., more than two identified fragments are actually mapped to one desired fragment. The reason is the limitation of the structure hash calculated by Algorithm&#x00A0;1 . At runtime, some pop-up messages and other trivial changes to the original view tree can result in a totally different hash value. As a result, the dynamic analysis process treats the same fragment as a new one. Therefore, taking into account only a single hash value can cause some mistakes. One possible solution is to record the whole view tree, and design an efficient algorithm to calculate the differences of the view tree after the action is performed.</p>    <p>For other apps, neither recall nor precision can reach 100%. However, the lowest recall and precision are about 70% and 55%, respectively. Such results indicate that more than 70% of the desired fragments can be identified and no more than half of the identified results are redundant. Therefore, Aladdin&#x0027;s dynamic analysis is effective for developers to use in practice.</p>    </section>    <section id="sec-27">    <header>     <div class="title-info">      <h3>       <span class="section-number">6.3</span> Performance of Executing Deep Links</h3>     </div>    </header>    <p>We compare the performance of executing deep links via APIs released by Aladdin with two alternative solutions: one is uLink&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0018">18</a>], which enables user-defined deep links to Android apps; the other is UI operation, which represents the case where users manually interact with the app to reach the target location. Different from Aladdin, uLink employs a program-by-demonstration philosophy to retrieve deep links when users are using the app. It uses a record-and-replay technique for deep-link execution where all the recorded intents are replayed one by one. For the case of UI operation, we use it as a baseline to investigate the benefits brought by deep links.</p>    <p>Based on the concrete deep links collected in Section&#x00A0;<a class="sec" href="#sec-25">6.1</a>, we select 20 activities from 20 apps. Each activity can be launched via shortcuts, and the length of the original intent path is more than three. We use a <tt>Nexus 5</tt> smartphone (2.3GHz CPU, 2GB RAM) equipped with Android 5.1 to deploy the three alternative solutions. For Aladdin, we just deploy the output APK of each app and execute the corresponding deep link to each selected activity. For uLink, since it is not open source, we just remove the computation of the shortest path from the implementation of Aladdin to simulate the behaviors of uLink. For UI operation, we re-send the captured UI events. To simulate the real user behaviors, after sending one event, we ensure that the screen is fully rendered before we send the successive event. We record the time spent on executing the deep link for each solution. During the execution, we also record the CPU and memory usage information via ADB. We repeat each case three times.</p>    <p>Figure&#x00A0;<a class="fig" href="#fig8">8</a> shows the results. Both Aladdin and uLink save significant amount of time to reach the target activity compared with UI operation, while the CPU and memory usages are not significantly different. Such result indicates that deep links can efficiently reach deeper locations inside apps, and our implementation of Aladdin does not cause noticeable overhead. The execution time of Aladdin is two times faster than uLink, demonstrating the benefits of shortcuts. In addition, Aladdin&#x0027;s CPU usage is smaller than uLink&#x0027;s while the memory usage is almost the same. The reason may be that Aladdin passes a smaller number of activities before reaching the target than uLink does, requiring more CPU resources to execute the transition activity&#x0027;s logic. In summary, Aladdin performs better than uLink in terms of execution time and resource consumption.</p>    </section>    <section id="sec-28">    <header>     <div class="title-info">      <h3>       <span class="section-number">6.4</span> Overhead of Aladdin</h3>     </div>    </header>    <p>Aladdin packages the app code of the original app together with the code of deep-link proxy and deep-link templates when releasing the APK file. The core logic of the deep-link proxy is 2,319 lines of Java code and its size is only 489KB including some third-party libraries. In other words, the proxy&#x0027;s size is rather small compared to that of the original app. We compute the size of the deep-link templates for all the 579 apps in our dataset from Section&#x00A0;<a class="sec" href="#sec-25">6.1</a>. Figure&#x00A0;<a class="fig" href="#fig9">9</a> shows the distribution of the template size among all the templates. The median size is 123B, the smallest is 93B, and the largest is 423B. For the 25,000 most popular apps in Section&#x00A0;<a class="sec" href="#sec-13">3.2</a>, we find that the median number of activities in an app is 160, so the total code size of templates on average is no more than 70KB. Overall, Aladdin introduces very tiny volume compared to the original app.</p>    </section>   </section>   <section id="sec-29">    <header>    <div class="title-info">     <h2>      <span class="section-number">7</span> Discussion</h2>    </div>    </header>    <p>As the first effort of deep-link automation up to date, we realize that there are some issues worth discussing to improve the real-world applicability of Aladdin.</p>    <p>&#x2022; <strong>Access to arbitrary locations.</strong> Due to the complexity of mobile apps, some special cases have not been handled by Aladdin so that Aladdin&#x0027;s coverage does not reach 100%. First, Aladdin could not release deep-link APIs to activities that are launched by intents with complex object messages. Second, some activities can be launched only in specific states of the app, e.g., after logging in. So far, Aladdin has not considered the app state. But most apps have implemented complementary logics when the state is not expected. For example, when a user enters an activity that requires a user account but she does not log in, the app may ask the user to log in first and afterwards return back to the previous activity. Therefore, this limitation could be alleviated. Third, there may be pop-up views that have to be closed before performing actions on the activity. Currently, Aladdin does not consider such a condition so that the fragment may not be correctly reached. In future work, we plan to enhance Aladdin to address complex conditions of app executions.</p>    <p>&#x2022; <strong>Instantiation of deep links.</strong> Aladdin releases deep-link APIs that provide the infrastructural support of wider usage scenarios of deep links. An orthogonal issue is how to retrieve the values of parameters to execute a concrete deep link. Indeed, such an issue is dependent on the exact context where deep links are used. For example, search engines such as Google and Bing can crawl every single page of the app, and thus can get all the possible values for the crawled page.</p>    <p>&#x2022; <strong>Security and privacy.</strong> Indeed, importing deep links to apps may lead to security and privacy issues. Currently, Aladdin relies on the developers to decide which activities to support deep links or not. For simplicity, we assume that all the instances are permitted to be deep linked. However, there might be some potential risks to be exploited by attackers via deep links&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0033">33</a>]. Addressing security threats of deep links is out of the scope of this paper, left for future work, e.g., via the <tt>WHYPER</tt> technique&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0040">40</a>].</p>    <p>&#x2022; <strong>Support of out-of-date contents</strong>. Similar to a web hyperlink, it is argued that a deep link can be out of date and unavailable if the app-content providers remove the content that the deep link refers to&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0018">18</a>]. As mentioned earlier, Aladdin generates deep-link APIs for the locations that the developers desire to be &#x201C;linked&#x201D;, the instantiation of deep links is made at runtime. Hence, Aladdin-generated deep links inherently are not affected with respect to the updated or removed content. When the developers decide to add, update, or remove the support of deep links for a location inside their latest released app version, they just need to apply Aladdin to the new version and configure the desirable deep links.</p>    <p>&#x2022; <strong>Generalizability.</strong> Aladdin facilitates the developers who are willing to release deep links. Although the techniques in Aladdin are for Android apps implemented in Java, the idea and basic principle itself can be extended and applied to other platforms such as iOS, e.g., by replacing the underlying static/dynamic analysis techniques.</p>   </section>   <section id="sec-30">    <header>    <div class="title-info">     <h2>      <span class="section-number">8</span> Related Work</h2>    </div>    </header>    <p>In this section, we summarize the related work.</p>    <p>&#x2022; <strong>Deep Link</strong>. Deep link&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0009">9</a>] is an emerging concept for mobile apps. Recently, some major companies, especially search engine ones, have made many efforts on deep links and proposed their criteria for deep links. Google App Indexing&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0007">7</a>] allows people to click from listings in Google&#x0027;s search results into apps on their Android and iOS devices. Bing App Linking &#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0004">4</a>] associates apps with Bing&#x0027;s search results on Windows devices. Facebook App Links&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0006">6</a>] is an open cross platform solution for deep linking to content in mobile apps. However, these state-of-the-art solutions all require the need-to-be-deep-linked apps to have corresponding webpages, narrowing their application scope. The research community is at the early stage of studying deep links and very few efforts have been proposed. Azim et al.&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0018">18</a>] designed and implemented uLink, a lightweight approach to generating user-defined deep links. uLink is implemented as an Android library with which developers can refactor their apps. At runtime, uLink captures intents to pages and actions on each page, and then generates a deep link dynamically, just as bookmarking. Compared to uLink, Aladdin releases deep-link APIs that are the underlying support for deep links, and requires zero coding efforts and no obtrusion to apps&#x2019; original code. Besides, Aladdin computes the shortest path to each activity in order to open a page more quickly than uLink, as shown in Section&#x00A0;<a class="sec" href="#sec-27">6.3</a>.</p>    <p>Other possible solutions to implement deep links are to leverage the record-and-replay techniques on mobile devices&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0026">26</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0029">29</a>]. However, these tools are too heavy-weight&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0025">25</a>] and require either a rooted phone or changes to the mobile OS. Aladdin provides a developer tool to refactor the apps, achieving both non-obtrusion and lightweight execution.</p>    <p>&#x2022; <strong>Analysis of Inter-Component Communication</strong>. Executing a deep link is highly related to Inter-Component Communication (ICC) of apps. Paulo et al.&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0019">19</a>] presented static analysis for two types of implicit control flow that frequently appear in Android apps: Java reflection and Android intents. Bastani et al.&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0020">20</a>] proposed a process for producing apps certified to be free of malicious explicit information flows. Li et al.&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0032">32</a>] proposed IccTA to improve the precision of the ICC analysis by propagating context information between components. Damien et al.&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0038">38</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0039">39</a>] developed a tool to analyze the intents as well as entry and exist points among Android apps. Their more recent work&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0037">37</a>] showed how to overlay a probabilistic model, trained using domain knowledge, on top of static analysis results to triage static analysis results. Our recent work&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0042">42</a>] analyzed the collusion behaviors among Android apps.</p>    <p>&#x2022; <strong>Automated App Testing</strong>. Aladdin essentially draws lessons from existing app testing efforts&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0014">14</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0015">15</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0022">22</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0023">23</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0030">30</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0043">43</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0044">44</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0045">45</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0046">46</a>], and combines the test generation methodology for dynamic analysis. The Google Android development kit provides two testing tools, Monkey&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0012">12</a>] and MonkeyRunner&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0013">13</a>]. Hu and Neamtiu&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0028">28</a>] developed a bug finding and tracing tool based on Monkey. Shauvik et al.&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0024">24</a>] presented a comparative study of existing major test generation techniques and corresponding tools for Android. Ravi et al.&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0021">21</a>] presented an app automation tool called Brahmastra to the problem of third-party component integration testing at scale. Machiry et al.&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0036">36</a>] presented the Dynodroid tool for generating relevant inputs to Android apps. Azim et al.&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0017">17</a>] presented A3E, an approach and tool for allowing substantial Android apps to be explored systematically while running on actual phones. Hao et al.&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0027">27</a>] designed PUMA, a programmable UI automation framework for conducting dynamic analyses of mobile apps at scale. Different from these previous tools or frameworks, the goal of Aladdin&#x0027;s dynamic analysis is to identify fragments or sub-screens of activities that are internal states of apps. So we design UI-tree-based fragment identification and fragment transition graph to address such issue.</p>   </section>   <section id="sec-31">    <header>    <div class="title-info">     <h2>      <span class="section-number">9</span> Conclusion</h2>    </div>    </header>    <p>In this paper, we have presented an empirical study of deep links on 25,000 Android apps and proposed the Aladdin approach to help developers automatically release deep-link APIs. The evaluations on 579 apps have demonstrated that the coverage of deep links can be increased by 60% on average while incurring minimal developer efforts. Some ongoing efforts are making Aladdin more practical. First, we are enhancing the static analysis of activities to resolve the objects of app-specific classes encapsulated in the intents to further improve the coverage. Second, we are optimizing the algorithm of dynamic analysis to improve the precision and recall of the fragment coverage. Finally, we are applying Aladdin to more apps to get feedback from app developers for further evaluation.</p>   </section>   <section id="sec-32">    <header>    <div class="title-info">     <h2>Acknowledgment</h2>    </div>    </header>    <p>This work was supported by the National Key Research and Development Program under the grant numbers 2016YFB1000105 and 2017YFB1003000, the National Natural Science Foundation of China under grant numbers 61725201, 61528201, 61529201, and in part by National Science Foundation under grants no. CCF-1409423, CNS-1513939, CNS-1564274. Xuanzhe Liu is the corresponding author of this paper.</p>   </section>  </section>  <section class="back-matter">   <section id="ref-001">    <header>    <div class="title-info">     <h2 class="page-brake-head">REFERENCES</h2>    </div>    </header>    <ul class="bibUl">    <li id="BibPLXBIB0001" label="[1]">Android guide. <a href="http://developer.android.com/guide/components/index.html" target="_blank">http://developer.android.com/guide/components/index.html</a>.</li>    <li id="BibPLXBIB0002" label="[2]">App links in Android 6. <a href="https://developer.android.com/training/app-links/index.html" target="_blank">https://developer.android.com/training/app-links/index.html</a>.</li>    <li id="BibPLXBIB0003" label="[3]">Baidu app link. <a href="http://applink.baidu.com" target="_blank">http://applink.baidu.com</a>.</li>    <li id="BibPLXBIB0004" label="[4]">Bing app linking. <a href="https://msdn.microsoft.com/en-us/library/dn614167" target="_blank">https://msdn.microsoft.com/en-us/library/dn614167</a>.</li>    <li id="BibPLXBIB0005" label="[5]">Deeplinkdispatch. <a href="https://github.com/airbnb/DeepLinkDispatch" target="_blank">https://github.com/airbnb/DeepLinkDispatch</a>.</li>    <li id="BibPLXBIB0006" label="[6]">Facebook app links. <a href="https://developers.facebook.com/docs/applinks" target="_blank">https://developers.facebook.com/docs/applinks</a>.</li>    <li id="BibPLXBIB0007" label="[7]">Google app indexing. <a href="https://developers.google.com/app-indexing/" target="_blank">https://developers.google.com/app-indexing/</a>.</li>    <li id="BibPLXBIB0008" label="[8]">IFTTT. <a href="https://ifttt.com/" target="_blank">https://ifttt.com/</a>.</li>    <li id="BibPLXBIB0009" label="[9]">Mobile deep linking. <a href="https://en.wikipedia.org/wiki/Mobile_deep_linking" target="_blank">https://en.wikipedia.org/wiki/Mobile_deep_linking</a>.</li>    <li id="BibPLXBIB0010" label="[10]">Mobile deep linking. <a href="http://mobiledeeplinking.org/" target="_blank">http://mobiledeeplinking.org/</a>.</li>    <li id="BibPLXBIB0011" label="[11]">Mobile Internet use passes desktop. <a href="https://techcrunch.com/2016/11/01/mobile-internet-use-passes-desktop-for-the-first-time-study-finds" target="_blank">https://techcrunch.com/2016/11/01/mobile-internet-use-passes-desktop-for-the-first-time-study-finds</a>.</li>    <li id="BibPLXBIB0012" label="[12]">Monkey. <a href="http://developer.android.com/tools/help/monkey.html" target="_blank">http://developer.android.com/tools/help/monkey.html</a>.</li>    <li id="BibPLXBIB0013" label="[13]">MonkeyRunner. <a href="http://developer.android.com/tools/help/MonkeyRunner.html" target="_blank">http://developer.android.com/tools/help/MonkeyRunner.html</a>.</li>    <li id="BibPLXBIB0014" label="[14]">Ranorex. <a href="http://www.ranorex.com/" target="_blank">http://www.ranorex.com/</a>.</li>    <li id="BibPLXBIB0015" label="[15]">Robotium. <a href="https://github.com/RobotiumTech/robotium" target="_blank">https://github.com/RobotiumTech/robotium</a>.</li>    <li id="BibPLXBIB0016" label="[16]">Universal links in iOS 9. <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/AppSearch/UniversalLinks.html" target="_blank">https://developer.apple.com/library/ios/documentation/General/Conceptual/AppSearch/UniversalLinks.html</a>.</li>    <li id="BibPLXBIB0017" label="[17]">T.&#x00A0;Azim and I.&#x00A0;Neamtiu. Targeted and depth-first exploration for systematic testing of Android apps. In <em>Proceedings of the 2013 ACM SIGPLAN International Conference on Object Oriented Programming Systems Languages and Applications, OOPSLA 2013</em>, pages 641&#x2013;660, 2013.</li>    <li id="BibPLXBIB0018" label="[18]">T.&#x00A0;Azim, O.&#x00A0;Riva, and S.&#x00A0;Nath. uLink: Enabling user-defined deep linking to app content. In <em>Proceedings of the 14th Annual International Conference on Mobile Systems, Applications, and Services, MobiSys 2016</em>, pages 305&#x2013;318, 2016.</li>    <li id="BibPLXBIB0019" label="[19]">P.&#x00A0;Barros, R.&#x00A0;Just, S.&#x00A0;Millstein, P.&#x00A0;Vines, W.&#x00A0;Dietl, M.&#x00A0;dAmorim, and M.&#x00A0;D. Ernst. Static analysis of implicit control flow: Resolving Java reflection and Android intents. In <em>Proceedings of the 30th IEEE/ACM International Conference on Automated Software Engineering, ASE 2015</em>, pages 669&#x2013;679, 2015.</li>    <li id="BibPLXBIB0020" label="[20]">O.&#x00A0;Bastani, S.&#x00A0;Anand, and A.&#x00A0;Aiken. Interactively verifying absence of explicit information flows in Android apps. In <em>Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications, OOPSLA 2015</em>, pages 299&#x2013;315, 2015.</li>    <li id="BibPLXBIB0021" label="[21]">R.&#x00A0;Bhoraskar, S.&#x00A0;Han, J.&#x00A0;Jeon, T.&#x00A0;Azim, S.&#x00A0;Chen, J.&#x00A0;Jung, S.&#x00A0;Nath, R.&#x00A0;Wang, and D.&#x00A0;Wetherall. Brahmastra: Driving apps to test the security of third-party components. In <em>Proceedings of the 23rd USENIX Security Symposium, USENIX Security 2014</em>, pages 1021&#x2013;1036, 2014.</li>    <li id="BibPLXBIB0022" label="[22]">N.&#x00A0;Boushehrinejadmoradi, V.&#x00A0;Ganapathy, S.&#x00A0;Nagarakatte, and L.&#x00A0;Iftode. Testing cross-platform mobile app development frameworks. In <em>Proceedings of the 30th IEEE/ACM International Conference on Automated Software Engineering, ASE 2015</em>, pages 441&#x2013;451, 2015.</li>    <li id="BibPLXBIB0023" label="[23]">W.&#x00A0;Choi, G.&#x00A0;Necula, and K.&#x00A0;Sen. Guided GUI testing of Android apps with minimal restart and approximate learning. In <em>Proceedings of the 2013 ACM SIGPLAN International Conference on Object Oriented Programming Systems Languages and Applications, OOPSLA 2013</em>, pages 623&#x2013;640, 2013.</li>    <li id="BibPLXBIB0024" label="[24]">S.&#x00A0;R. Choudhary, A.&#x00A0;Gorla, and A.&#x00A0;Orso. Automated test input generation for Android: Are we there yet? In <em>Proceedings of the 30th IEEE/ACM International Conference on Automated Software Engineering, ASE 2015</em>, pages 429&#x2013;440, 2015.</li>    <li id="BibPLXBIB0025" label="[25]">J.&#x00A0;Flinn and Z.&#x00A0;M. Mao. Can deterministic replay be an enabling tool for mobile computing? In <em>Proceedings of the 12th Workshop on Mobile Computing Systems and Applications, HotMobile 2011</em>, pages 84&#x2013;89, 2011.</li>    <li id="BibPLXBIB0026" label="[26]">L.&#x00A0;Gomez, I.&#x00A0;Neamtiu, T.&#x00A0;Azim, and T.&#x00A0;D. Millstein. RERAN: timing- and touch-sensitive record and replay for Android. In <em>Proceedings of the 35th International Conference on Software Engineering, ICSE 2013</em>, pages 72&#x2013;81, 2013.</li>    <li id="BibPLXBIB0027" label="[27]">S.&#x00A0;Hao, B.&#x00A0;Liu, S.&#x00A0;Nath, W.&#x00A0;G.&#x00A0;J. Halfond, and R.&#x00A0;Govindan. PUMA: programmable ui-automation for large-scale dynamic analysis of mobile apps. In <em>Proceedings of the 12th Annual International Conference on Mobile Systems, Applications, and Services, MobiSys 2014</em>, pages 204&#x2013;217, 2014.</li>    <li id="BibPLXBIB0028" label="[28]">C.&#x00A0;Hu and I.&#x00A0;Neamtiu. A GUI bug finding framework for Android applications. In <em>Proceedings of the 2011 ACM Symposium on Applied Computing, SAC 2011</em>, pages 1490&#x2013;1491, 2011.</li>    <li id="BibPLXBIB0029" label="[29]">Y.&#x00A0;Hu, T.&#x00A0;Azim, and I.&#x00A0;Neamtiu. Versatile yet lightweight record-and-replay for Android. In <em>Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications, OOPSLA 2015</em>, pages 349&#x2013;366, 2015.</li>    <li id="BibPLXBIB0030" label="[30]">W.&#x00A0;Lam, Z.&#x00A0;Wu, D.&#x00A0;Li, W.&#x00A0;Wang, H.&#x00A0;Zheng, H.&#x00A0;Luo, P.&#x00A0;Yan, Y.&#x00A0;Deng, and T.&#x00A0;Xie. Record and replay for Android: are we there yet in industrial cases? In <em>Proceedings of the 11th Joint Meeting on the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering, ESEC/FSE 2017</em>, pages 854&#x2013;859, 2017.</li>    <li id="BibPLXBIB0031" label="[31]">H.&#x00A0;Li, X.&#x00A0;Lu, X.&#x00A0;Liu, T.&#x00A0;Xie, K.&#x00A0;Bian, F.&#x00A0;X. Lin, Q.&#x00A0;Mei, and F.&#x00A0;Feng. Characterizing smartphone usage patterns from millions of Android users. In <em>Proceedings of the ACM SIGCOMM Conference on Internet Measurement, IMC 2015</em>, pages 459&#x2013;472, 2015.</li>    <li id="BibPLXBIB0032" label="[32]">L.&#x00A0;Li, A.&#x00A0;Bartel, T.&#x00A0;F. Bissyand&#x00E9;, J.&#x00A0;Klein, Y.&#x00A0;L. Traon, S.&#x00A0;Arzt, S.&#x00A0;Rasthofer, E.&#x00A0;Bodden, D.&#x00A0;Octeau, and P.&#x00A0;McDaniel. IccTA: Detecting inter-component privacy leaks in Android apps. In <em>Proceedings of the 37th International Conference on Software Engineering, ICSE 2015</em>, pages 280&#x2013;291, 2015.</li>    <li id="BibPLXBIB0033" label="[33]">F.&#x00A0;Liu, C.&#x00A0;Wang, A.&#x00A0;Pico, D.&#x00A0;Yao, and G.&#x00A0;Wang. Measuring the insecurity of mobile deep links of Android. In <em>Proceedings of the 26th USENIX Security Symposium, USENIX Security 2017</em>, pages 953&#x2013;969, 2017.</li>    <li id="BibPLXBIB0034" label="[34]">X.&#x00A0;Lu, X.&#x00A0;Liu, H.&#x00A0;Li, T.&#x00A0;Xie, Q.&#x00A0;Mei, G.&#x00A0;Huang, and F.&#x00A0;Feng. PRADA: Prioritizing Android devices for apps by mining large-scale usage data. In <em>Proceedings of the 38th International Conference on Software Engineering, ICSE 2016</em>, pages 3&#x2013;13, 2016.</li>    <li id="BibPLXBIB0035" label="[35]">Y.&#x00A0;Ma, X.&#x00A0;Liu, M.&#x00A0;Yu, Y.&#x00A0;Liu, Q.&#x00A0;Mei, and F.&#x00A0;Feng. Mash Droid: An approach to mobile-oriented dynamic services discovery and composition by in-app search. In <em>Proceedings of 2015 IEEE International Conference on Web Services, ICWS 2015</em>, pages 725&#x2013;730, 2015.</li>    <li id="BibPLXBIB0036" label="[36]">A.&#x00A0;Machiry, R.&#x00A0;Tahiliani, and M.&#x00A0;Naik. Dynodroid: An input generation system for Android apps. In <em>Proceedings of the 9th joint meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering, ESEC/FSE 2013</em>, pages 224&#x2013;234, 2013.</li>    <li id="BibPLXBIB0037" label="[37]">D.&#x00A0;Octeau, S.&#x00A0;Jha, M.&#x00A0;Dering, P.&#x00A0;McDaniel, A.&#x00A0;Bartel, L.&#x00A0;Li, J.&#x00A0;Klein, and Y.&#x00A0;Le&#x00A0;Traon. Combining static analysis with probabilistic models to enable market-scale Android inter-component analysis. In <em>Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2016</em>, pages 469&#x2013;484, 2016.</li>    <li id="BibPLXBIB0038" label="[38]">D.&#x00A0;Octeau, D.&#x00A0;Luchaup, M.&#x00A0;Dering, S.&#x00A0;Jha, and P.&#x00A0;McDaniel. Composite constant propagation: Application to Android inter-component communication analysis. In <em>Proceedings of the 37th IEEE/ACM International Conference on Software Engineering, ICSE 2015</em>, pages 77&#x2013;88, 2015.</li>    <li id="BibPLXBIB0039" label="[39]">D.&#x00A0;Octeau, P.&#x00A0;McDaniel, S.&#x00A0;Jha, A.&#x00A0;Bartel, E.&#x00A0;Bodden, J.&#x00A0;Klein, and Y.&#x00A0;L. Traon. Effective inter-component communication mapping in Android: An essential step towards holistic security analysis. In <em>Proceedings of the 22th USENIX Security Symposium, USENIX Security 2013</em>, pages 543&#x2013;558, 2013.</li>    <li id="BibPLXBIB0040" label="[40]">R.&#x00A0;Pandita, X.&#x00A0;Xiao, W.&#x00A0;Yang, W.&#x00A0;Enck, and T.&#x00A0;Xie. WHYPER: Towards automating risk assessment of mobile applications. In <em>Proceedings of the 22th USENIX Security Symposium, USENIX Security 2013</em>, pages 527&#x2013;542, 2013.</li>    <li id="BibPLXBIB0041" label="[41]">H.&#x00A0;Wang, Z.&#x00A0;Liu, Y.&#x00A0;Guo, X.&#x00A0;Chen, M.&#x00A0;Zhang, G.&#x00A0;Xu, and J.&#x00A0;Hong. An explorative study of the mobile app ecosystem from app developers&#x2019; perspective. In <em>Proceedings of the 26th International Conference on World Wide Web, WWW 2017</em>, pages 163&#x2013;172, 2017.</li>    <li id="BibPLXBIB0042" label="[42]">M.&#x00A0;Xu, Y.&#x00A0;Ma, X.&#x00A0;Liu, F.&#x00A0;X. Lin, and Y.&#x00A0;Liu. AppHolmes: Detecting and characterizing app collusion among third-party Android markets. In <em>Proceedings of the 26th International Conference on World Wide Web, WWW 2017</em>, pages 143&#x2013;152, 2017.</li>    <li id="BibPLXBIB0043" label="[43]">W.&#x00A0;Yang, M.&#x00A0;R. Prasad, and T.&#x00A0;Xie. A grey-box approach for automated GUI-model generation of mobile applications. In <em>Proceedings of the 16th International Conference on Fundamental Approaches to Software Engineering, FASE 2013</em>, pages 250&#x2013;265, 2013.</li>    <li id="BibPLXBIB0044" label="[44]">X.&#x00A0;Zeng, D.&#x00A0;Li, W.&#x00A0;Zheng, F.&#x00A0;Xia, Y.&#x00A0;Deng, W.&#x00A0;Lam, W.&#x00A0;Yang, and T.&#x00A0;Xie. Automated test input generation for Android: Are we really there yet in an industrial case? In <em>Proceedings of the 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering, FSE 2016</em>, pages 987&#x2013;992, 2016.</li>    <li id="BibPLXBIB0045" label="[45]">B.&#x00A0;Zhang, E.&#x00A0;Hill, and J.&#x00A0;Clause. Automatically generating test templates from test names. In <em>Proceedings of the 30th IEEE/ACM International Conference on Automated Software Engineering, ASE 2015</em>, pages 506&#x2013;511, 2015.</li>    <li id="BibPLXBIB0046" label="[46]">H.&#x00A0;Zheng, D.&#x00A0;Li, B.&#x00A0;Liang, X.&#x00A0;Zeng, W.&#x00A0;Zheng, Y.&#x00A0;Deng, W.&#x00A0;Lam, W.&#x00A0;Yang, and T.&#x00A0;Xie. Automated test input generation for Android: Towards getting there in an industrial case. In <em>Proceedings of the 39th International Conference on Software Engineering: Software Engineering in Practice Track, ICSE-SEIP 2017</em>, pages 253&#x2013;262, 2017.</li>    </ul>   </section>  </section>  <section id="foot-001" class="footnote">   <header>    <div class="title-info">    <h2>FOOTNOTE</h2>    </div>   </header>   <p id="fn1"><a href="#foot-fn1"><sup>*</sup></a>Corresponding author: xzl@pku.edu.cn.</p>   <p id="fn2"><a href="#foot-fn2"><sup>1</sup></a>Wandoujia (<a class="link-inline force-break" href="http://www.wandoujia.com">http://www.wandoujia.com</a>) is a leading Android app store in China.</p>   <p id="fn3"><a href="#foot-fn3"><sup>2</sup></a><a class="link-inline force-break"    href="https://github.com/SafetyMarcus/SafetyPongAndroid">https://github.com/SafetyMarcus/SafetyPongAndroid</a>   </p>   <div class="bibStrip">    <p>This paper is published under the Creative Commons Attribution 4.0 International (CC-BY&#x00A0;4.0) license. Authors reserve their rights to disseminate the work on their personal and corporate Web sites with the appropriate attribution.</p>    <p>    <em>WWW '18, April 23-27, 2018, Lyon, France</em>    </p>    <p>&#x00A9; 2018; IW3C2 (International World Wide Web Conference Committee), published under Creative Commons CC-BY&#x00A0;4.0 License. ACM ISBN 978-1-4503-5639-8/18/04.<br/>DOI: <a class="link-inline force-break" target="_blank"     href="https://doi.org/10.1145/3178876.3186059">https://doi.org/10.1145/3178876.3186059</a>    </p>   </div>  </section>  <div class="pubHistory">   <p/>  </div> </body> </html> 
