<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta name="generator" content=
  "HTML Tidy for HTML5 for Linux version 5.7.16" />
  <title>JSExplain: A Double Debugger for JavaScript</title>
  <!-- Copyright (c) 2010-2015 The MathJax Consortium -->
  <meta http-equiv="Content-Type" content=
  "text/html; charset=utf-8" />
  <meta name="viewport" content=
  "width=device-width; initial-scale=1.0;" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="screen, print" rel="stylesheet" href=
  "../../../data/dl.acm.org/pubs/lib/css/bootstrap.min.css" />
  <link media="screen, print" rel="stylesheet" href=
  "../../../data/dl.acm.org/pubs/lib/css/bootstrap-theme.min.css" />
  <link media="screen, print" rel="stylesheet" href=
  "../../../data/dl.acm.org/pubs/lib/css/main.css" />
  <script src="../../../data/dl.acm.org/pubs/lib/js/jquery.min.js" type=
  "text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/bootstrap.min.js"
  type="text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/bibCit.js" type=
  "text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/divTab.js" type=
  "text/javascript"></script>
  <script type="text/javascript" src=
  "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>
  <script type="text/x-mathjax-config">
  <![CDATA[
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  ]]>
  </script>
</head>
<body id="main">
<div>
<p style='font-size: 75%; color #444'>
This is a web copy of <a href='https://doi.org/10.1145/3184558.3185969'>https://doi.org/10.1145/3184558.3185969</a> 
originally published by ACM Press, 
redistributed under the terms of 
<a href='https://creativecommons.org/licenses/by/4.0/'>Creative Commons Attribution 4.0 (CC BY 4.0)</a>.
The <a href='https://github.com/usable-oa/thewebconf2018/tree/master/scripts'>modifications</a> 
from the original are solely to improve HTML aiming to make it Findable, Accessible, Interoperable and Reusable. 
augmenting HTML metadata and avoiding ACM trademark.
To reference this HTML version, use:
</p><p>
<strong>Permalink:</strong>
<a href='https://w3id.org/oa/10.1145/3184558.3185969'>https://w3id.org/oa/10.1145/3184558.3185969</a>
</p></div>
<hr>


  <section class="front-matter">
    <section>
      <header class="title-info">
        <div class="journal-title">
          <h1><span class="title">JSExplain: A Double Debugger for
          JavaScript</span><br />
          <span class="subTitle"></span></h1>
        </div>
      </header>
      <div class="authorGroup">
        <div class="author">
          <span class="givenName">Arthur</span> <span class=
          "surName">Charguéraud</span>, Inria &amp; Université de
          Strasbourg, CNRS, ICube UMR 7357, <a href=
          "mailto:arthur.chargueraud@inria.fr">arthur.chargueraud@inria.fr</a>
        </div>
        <div class="author">
          <span class="givenName">Alan</span> <span class=
          "surName">Schmitt</span>, Inria &amp; Univ Rennes, CNRS,
          IRISA, <a href=
          "mailto:alan.schmitt@inria.fr">alan.schmitt@inria.fr</a>
        </div>
        <div class="author">
          <span class="givenName">Thomas</span> <span class=
          "surName">Wood</span>, Imperial College London, <a href=
          "mailto:thomas.wood09@imperial.ac.uk">thomas.wood09@imperial.ac.uk</a>
        </div>
      </div><br />
      <div class="pubInfo">
        <p>DOI: <a href="https://doi.org/10.1145/3184558.3185969"
        target=
        "_blank">https://doi.org/10.1145/3184558.3185969</a><br />
        WWW '18: <a href="https://doi.org/10.1145/3184558" target=
        "_blank">Proceedings of The Web Conference 2018</a>, Lyon,
        France, April 2018</p>
      </div>
      <div class="abstract">
        <p><small>We present JSExplain, a reference interpreter for
        JavaScript that closely follows the specification and that
        produces execution traces. These traces may be
        interactively investigated in a browser, with an interface
        that displays not only the code and the state of the
        interpreter, but also the code and the state of the
        interpreted program. Conditional breakpoints may be
        expressed with respect to both the interpreter and the
        interpreted program. In that respect, JSExplain is a
        double-debugger for the specification of
        JavaScript.</small></p>
      </div>
      <div class="classifications">
        <div class="AcmReferenceFormat">
          <p><small><span style="font-weight:bold;">ACM Reference
          Format:</span><br />
          Arthur Charguéraud, Alan Schmitt, and Thomas Wood. 2018.
          JSExplain: A Double Debugger for JavaScript. In <em>WWW
          '18 Companion: The 2018 Web Conference Companion,</em>
          <em>April 23–27, 2018,</em> <em>Lyon, France</em>. ACM,
          New York, NY, USA 9 pages. <a href=
          "https://doi.org/10.1145/3184558.3185969" class=
          "link-inline force-break" target=
          "_blank">https://doi.org/10.1145/3184558.3185969</a></small></p>
        </div>
      </div>
    </section>
  </section>
  <section class="body">
    <section id="sec-4">
      <header>
        <div class="title-info">
          <h2><span class="section-number">1</span>
          Introduction</h2>
        </div>
      </header>
      <section id="sec-5">
        <header>
          <div class="title-info">
            <h3><span class="section-number">1.1</span> A reference
            interpreter for JS</h3>
          </div>
        </header>
        <p>JavaScript (JS) has a complex semantics. As of 2017, its
        specification by ECMA consists of 885 pages of English
        prose&nbsp;[<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0006">6</a>] (details in&nbsp;§<a class="sec"
        href="#sec-6">1.2</a>). Unsurprisingly, this prose-based
        presentation of the specification does not meet the needs
        of the JavaScript designers and implementers. In
        particular, the JavaScript standardization committee (TC39)
        has repeatedly expressed the need for better tools for
        describing and interacting with the semantics (§<a class=
        "sec" href="#sec-7">1.3</a>).</p>
        <p>Prior work on the formalization of JS semantics, notably
        JSCert&nbsp;[<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0003">3</a>] and KJS&nbsp;[<a class="bib"
        data-trigger="hover" data-toggle="popover" data-placement=
        "top" href="#BibPLXBIB0011">11</a>], has made some
        progress, yet falls short of delivering several of the
        features needed by TC39 (§<a class="sec" href=
        "#sec-8">1.4</a>). In this work, we aim at addressing these
        requests: we revisit the JSCert semantics by giving it a
        presentation more accessible to the JavaScript community.
        Our presentation aims to be well-suited for writing and
        reading the specifications, executing test cases, checking
        coverage, and interatively debugging the specification
        (§<a class="sec" href="#sec-9">1.5</a>).</p>
        <p>The JS specification is essentially describing a
        reference interpreter. Although it consists of English
        prose, the ECMA standard reads almost like pseudo-code.
        Most ambiguities and unclear paragraphs that were present
        in ECMA3 and ECMA5 were progressively resolved in
        subsequent editions. Thus, turning ECMA pseudo-code into
        real code, i.e., code expressed in a real programming
        language, is not so hard. Yet, there are two nontrivial
        aspects: dealing with the representation of the state, and
        dealing with abrupt termination, such as exceptions,
        return, break, and continue statements.</p>
        <p>Indeed, in JS, the evaluation of any sub-expression, of
        any type conversion, and of most internal operations from
        the specification may result in the execution of user code,
        hence the raising of an exception, interrupting the normal
        control flow. Throught its successive editions, the ECMA
        standard progressively introduced a notation akin to an
        exception monad (§<a class="sec" href="#sec-6">1.2</a>).
        This notation is naturally translated into real code by a
        proper monadic bind operator of the exception monad.</p>
        <p>Regarding the state, the standard assumes a global
        state. A reference interpreter could either assume a global
        state, modified with side-effects, or thread the state
        explicitly in purely-functional style. We chose the latter
        approach for three reasons. First, we already need a monad
        for exceptions, so we may easily extend this monad to also
        account for the state. Second, starting from code with an
        explicit state would make it easier to generate a
        corresponding inductive definition in a formal logic (e.g.,
        Coq), which we would like to investigate in the future.
        Third, to ease the reading, one may easily hide a state
        that is explicitly threaded; the converse, materializing a
        state that is implicit, would be much more challenging.</p>
        <p>We thus write our reference interpreter in a
        purely-functional language extended with syntactic sugar
        for the monadic notation to account for the state and the
        propagation of abrupt termination (§<a class="sec" href=
        "#sec-10">2</a>). For historical reasons, we chose a subset
        of OCaml as source syntax, but other languages could be
        used. In fact, we implemented a translator from our subset
        of OCaml to a subset of JS (a subset involving no side
        effects and no type conversions). We thereby obtain a JS
        interpreter that is able to execute JS programs inside a JS
        virtual machine—JS fans should be delighted. To further
        improve accessibility to JS programmers, we also translate
        the source code of our interpreter into a human-readable
        JS-style syntax, which we call pseudo-JS, and that
        essentially consists of JS syntax augmented with a monadic
        notation and with basic pattern matching.</p>
        <p>Our reference semantics for JS is inherently executable.
        We may thus execute our interpreter on test suites, either
        by compiling and executing the OCaml code, or by executing
        the JS translation of that code. It is indeed useful to be
        able to check that the evaluation of examples from the JS
        test suites against our reference semantics produces the
        desired output.</p>
        <p>Even more interesting is the possibility to investigate,
        step by step, the evaluation of the interpreter on a given
        test case. Such investigation allows to understand
        <em>why</em> the evaluation of a particular test case
        produces a particular output—given the complexity of JS,
        even an expert may easily get puzzled by the output value
        of a particular piece of code. Furthermore, interactive
        execution makes it easier for the contributor of a new JS
        feature to add new test cases and to check that these tests
        trigger the new features and correctly interact with
        existing features.</p>
        <p>In this paper, we present a tool, called JSExplain, for
        investigating JS executions. This tool can be thought as a
        <em>double debugger</em>, which displays both the state of
        the interpreted program and that of the interpreter
        program. In particular, our tool supports conditional
        breakpoints expressed simultaneously on the interpreter
        program and the interpreted program. To implement this
        tool, we generate a version of our interpreter that is
        instrumented for producing execution traces (§<a class=
        "sec" href="#sec-13">3</a>), and we provide a web-based
        tool to navigate through such traces (§<a class="sec" href=
        "#sec-14">4</a>). As far as we know, our tool is the first
        such double debugger, i.e., debugger with specific
        additions for dealing with programs that interpret other
        programs (§<a class="sec" href="#sec-15">5</a>).</p>
      </section>
      <section id="sec-6">
        <header>
          <div class="title-info">
            <h3><span class="section-number">1.2</span> English
            Specification of JS</h3>
          </div>
        </header>
        <p>To illustrate the style in which the JavaScript standard
        (ECMA)&nbsp;[<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0006">6</a>] is written, consider the
        description of addition, which will be our running example
        throughout the paper. In JS, the addition operator casts
        its arguments to integers and computes their sum, except if
        one of the two arguments is a string, in which case the
        other argument is cast to a string and the two strings are
        concatenated.</p>
        <p>The ECMA5 presentation (prior to June 2016) appears in
        Figure&nbsp;<a class="fig" href="#fig1">1</a>. First,
        observe that the presentation describes both the parsing
        rule for addition and its evaluation rule. Presumably for
        improved accessibility, the JS standard does not make
        explicit the notion of an abstract syntax tree (AST). The
        semantics of addition goes as follows: first evaluate the
        left branch to a value, then evaluate the right branch to a
        value, then converts both values (which might be objects)
        into primitive values (e.g., string, number, ...), then
        test whether one of the two arguments is a string. If so,
        cast both arguments to strings and return their
        concatenation; otherwise cast both arguments to numbers and
        return their sum.</p>
        <figure id="fig1">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185969/images/www18companion-30-fig1.jpg"
          class="img-responsive" alt="Figure 1" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 1:</span>
            <span class="figure-title">ECMA5 specification of
            addition.</span>
          </div>
        </figure>
        <p></p>
        <p>This presentation style used in ECMA5 gives no details
        about the propagation of exceptions. While the treatment of
        exceptions is explicit for statements, it is left implicit
        for expressions. For example, if the evaluation of the left
        branch raises an exception, the right branch should not be
        evaluated. It appeared that leaving the treatment of
        exceptions implicit could lead to ambiguities at what
        exactly should or should not be evaluated when an exception
        gets triggered. The ECMA committee hates such ambiguities,
        because it could (and typically does) result in different
        browsers exhibiting different behaviors—the nightmare of
        web-developers.</p>
        <p>In ECMA6, such ambiguities were resolved by making the
        propagation of exceptions explicit. Figure&nbsp;<a class=
        "fig" href="#fig2">2</a> shows the updated specification
        for the addition operator. There are two main changes.
        First, each piece of evaluation is described on its own
        line, thereby making the evaluation order crystal clear.
        Second, the meta-operation ReturnIfAbrupt is invoked on
        every intermediate result. This meta-operation essentially
        corresponds to an exception monad. The ECMA6 standards,
        which aims to be accessible to a large audience, avoids the
        introduction of the word “monad”. Instead, it specifies
        ReturnIfAbrupt as a “macro”, as shown in
        Figure&nbsp;<a class="fig" href="#fig3">3</a>. Essentially,
        every result consists of a “completion record”, which
        corresponds to a sum type distinguishing normal results
        from exceptions.</p>
        <figure id="fig2">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185969/images/www18companion-30-fig2.jpg"
          class="img-responsive" alt="Figure 2" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 2:</span>
            <span class="figure-title">ECMA6 specification of
            addition.</span>
          </div>
        </figure>
        <figure id="fig3">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185969/images/www18companion-30-fig3.jpg"
          class="img-responsive" alt="Figure 3" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 3:</span>
            <span class="figure-title">ECMA6 interpretation of
            ReturnIfAbrupt.</span>
          </div>
        </figure>
        <p></p>
        <p>In all constructs except try-catch blocks, exceptions
        interrupt the normal flow of the evaluation. As a result,
        ECMA6 specification is scattered with about 1100 occurences
        of ReturnIfAbrupt operations. Realizing the
        impracticability of that style of specification, the
        standardization committee decided to introduce in ECMA7 an
        additional layer of syntactic sugar in subsequent versions
        of the specification. As detailed in Figure&nbsp;<a class=
        "fig" href="#fig4">4</a>, they define the question mark
        symbol to be a lightweight shorthand for ReturnIfAbrupt
        steps. The specification of addition in that new style is
        shown in Figure&nbsp;<a class="fig" href="#fig5">5</a>.</p>
        <figure id="fig4">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185969/images/www18companion-30-fig4.jpg"
          class="img-responsive" alt="Figure 4" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 4:</span>
            <span class="figure-title">ECMA7 and ECMA8 addition for
            ReturnIfAbrupt.</span>
          </div>
        </figure>
        <figure id="fig5">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185969/images/www18companion-30-fig5.jpg"
          class="img-responsive" alt="Figure 5" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 5:</span>
            <span class="figure-title">ECMA7 and ECMA8
            specification of addition.</span>
          </div>
        </figure>
        <p></p>
        <p>The presentation of ECMA7 and ECMA8
        (Figure&nbsp;<a class="fig" href="#fig5">5</a>) is both
        more concise than that of ECMA6 (Figure&nbsp;<a class="fig"
        href="#fig2">2</a>) and more formal than that of ECMA5
        (Figure&nbsp;<a class="fig" href="#fig1">1</a>). The use of
        question marks is to be compared in §<a class="sec" href=
        "#sec-10">2</a> with the monadic notation that we use for
        our formal semantics.</p>
      </section>
      <section id="sec-7">
        <header>
          <div class="title-info">
            <h3><span class="section-number">1.3</span> Requests
            from the JS Committee</h3>
          </div>
        </header>
        <p>The JavaScript standardization body, part of ECMA and
        known as TC39, includes representatives from browser
        vendors, major actors of the web, and academics. It aims at
        defining a common semantics that all browsers should
        implement. TC39 faces major challenges. On the one hand, it
        must ensure full backward compatibility, to avoid “breaking
        the web”. In particular, no feature used in the wild ever
        gets removed from the specification. On the other hand, the
        committee imposes the rule that no feature may be added to
        the standard before it has been implemented, shipped, and
        tested at scale in at least two distinct major browsers.
        Any member of the committee may propose new features, hence
        there are many proposals being actively developed, at
        different stages of formalization&nbsp;[<a class="bib"
        data-trigger="hover" data-toggle="popover" data-placement=
        "top" href="#BibPLXBIB0014">14</a>].</p>
        <p>The rapid evolution of the standard stresses the need
        for appropriate tools to assist in the rewriting, testing,
        and debugging of the semantics. In particular, several
        members with whom we have had interactions expressed their
        need for several basic tools, such as:</p>
        <ul class="list-no-style">
          <li id="list1" label="•">a tool for knowing whether all
          variables that occur in the specification are properly
          defined (bound) somewhere;<br /></li>
          <li id="list2" label="•">a tool to perform basic
          type-checking of the meta-functions and of the variables
          involved in the specification;<br /></li>
          <li id="list3" label="•">a tool for checking that
          effectful operations go on a line of their own, to avoid
          ambiguity in the order of evaluation;<br /></li>
          <li id="list4" label="•">a tool for checking that the
          behavior is specified in all cases;<br /></li>
          <li id="list5" label="•">a tool able to tell which lines
          from the specification are not covered by any test from
          the main test suite (test262&nbsp;[<a class="bib"
          data-trigger="hover" data-toggle="popover"
            data-placement="top" href=
            "#BibPLXBIB0015">15</a>]);<br />
          </li>
          <li id="list6" label="•">a tool able to execute
          step-by-step the specification on concrete JS programs,
          and to inspect the value of the variables.<br /></li>
        </ul>
        <p>In particular, step-by-step execution is critically
        needed to evaluate new features. When the committee decides
        that a feature proposal is worth integrating, it typically
        does not accept the proposal as is, but instead modifies
        the proposal in a way that is amenable to a simple, clear
        specification without corner cases, carefully trying to
        avoid harmful interactions with other existing features (or
        planned features). During this process, at some point the
        committee members have in their hand a draft of the
        extended semantics as well as a collection of test cases
        illustrating the new behaviors that should be introduced.
        Naturally, they would like to check that their
        formalization of the extended semantics assigns the
        expected behavior to each of the test cases.</p>
        <p>One might argue that such a task could be performed by
        modifying one of the mainstream browsers. Yet, existing JS
        runtimes are built with efficiency in mind, with huge code
        bases involving numerous optimizations. As such, modifying
        the code in any way is too costly for committee members to
        investigate variations on a feature request. Even if they
        could invest the effort, the distance between the English
        prose specification and the implementation would be too
        large to have any confidence that the two match, i.e., that
        the behavior implemented in the code matches the behavior
        described by the prose.</p>
        <p>An alternative approach to testing a new feature is to
        develop an elaboration (local translation) of that feature
        into plain JS. This can take the form of syntactic sugar
        adding a missing API, namely a <em>polyfill</em>, or the
        form of a source to source translation, namely a
        <em>transpiler</em>. For instance, one might translate
        so-called “template literals” into simple string
        concatenation.</p>
        <figure id="fig6">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185969/images/www18companion-30-fig6.jpg"
          class="img-responsive" alt="" longdesc="" />
        </figure>
        <p></p>
        <p>While polyfills and transpilers are a simple approach to
        testing new features, they have two major limitations.
        First, the encoding might be very invasive. For instance,
        the 2015 version of ECMAScript added <em>proxies</em>, and
        as a consequence significantly changed the internal methods
        of the language; the Babel [<a class="bib" data-trigger=
        "hover" data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0001">1</a>] transpiler for
        proxies&nbsp;[<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0002">2</a>] is able to simulate this feature in
        prior version of JS, but at the cost of replacing all field
        access operations with calls to wrapper functions. Second,
        the interaction of several new features implemented using
        these approaches is very difficult to anticipate.</p>
      </section>
      <section id="sec-8">
        <header>
          <div class="title-info">
            <h3><span class="section-number">1.4</span> Formal
            Specifications of JS</h3>
          </div>
        </header>
        <p>In recent years, two projects, JSCert&nbsp;[<a class=
        "bib" data-trigger="hover" data-toggle="popover"
        data-placement="top" href="#BibPLXBIB0003">3</a>] and
        KJS&nbsp;[<a class="bib" data-trigger="hover" data-toggle=
        "popover" data-placement="top" href=
        "#BibPLXBIB0011">11</a>] have proposed a formal
        specification for a significant subset of JS. JSCert
        provides a big-step inductive definition for ECMA5,
        (technically, a pretty-big-step
        specification&nbsp;[<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0005">5</a>]), formalized in the Coq proof
        assistant&nbsp;[<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0016">16</a>]. JSCert comes along with a
        reference interpreter, called JSRef, that is proved correct
        with respect to the inductive definition. JSRef may be
        extracted into executable OCaml code for executing tests.
        KJS describes a small-step semantics for JS as a set of
        rewriting rules, using the K framework&nbsp;[<a class="bib"
        data-trigger="hover" data-toggle="popover" data-placement=
        "top" href="#BibPLXBIB0013">13</a>]. This framework has
        been used to formalize the semantics of several other
        real-world languages. It provides in particular tool
        support for executing (syntax-directed) transition rules on
        a concrete input program.</p>
        <p>At first sight, it might seem that a formal
        specification addresses all the requests from the
        committee. Definitions are thoroughly type-checked; in
        particular, all variables must be properly bound.
        Definitions, being defined in a formal language, are
        ambiguity-free; in particular, the order of evaluation and
        the propagation of exceptions is precisely specified. The
        semantics can be executed on concrete input programs;
        moreover, with some extra tooling, one may execute a set of
        programs and report on the coverage of the specification by
        the tests.</p>
        <p>Given all the nice features of formal semantics, why
        wouldn't the standardization committee TC39 consider one of
        these formal semantics as the reference for the language?
        After discussing with senior members from TC39, we
        understand that there are (at least) three main reasons why
        there is no chance for a formal semantics such as JSCert or
        KJS to be adopted as reference semantics.</p>
        <ol class="list-no-style">
          <li id="list7" label="(1)">Formal specifications in Coq
          or in K use syntax and concepts that are not easily
          accessible to JS programmers. Yet, the specification is
          meant to be read by a wide audience.<br /></li>
          <li id="list8" label="(2)">These formal languages have a
          cost of entry that is too high for committee members to
          reach the level of proficiency required for contributing
          new definitions all by themselves.<br /></li>
          <li id="list9" label="(3)">JSCert and KJS come with
          specifications that can be executed, yet provide no
          debugger-style support for interactively navigating
          through an execution and for visualizing the state and
          the values of the variables, and thus do not help so much
          in tuning the description of new features.<br /></li>
        </ol>
        <p>In the present work, we temporarily leave aside the
        motivation of giving a formal semantics to JS that one
        could use to formalize properties of the language (e.g.,
        security properties), and rather focus on trying to provide
        a formal semantics that meets better the day-to-day needs
        of the TC39 committee.</p>
      </section>
      <section id="sec-9">
        <header>
          <div class="title-info">
            <h3><span class="section-number">1.5</span>
            Contribution</h3>
          </div>
        </header>
        <p>In this paper, we present a tool, called JSExplain,
        which aims at providing a formal semantics for JS that
        addresses the aforementioned limitations of prior work. Our
        contribution is two-fold. First, we present a specification
        for JS expressed in a language that, we argue, JS
        programmers can easily read and write (§<a class="sec"
        href="#sec-10">2</a>). Second, we present an interactive
        tool that supports step-by-step execution of the
        specification on an input JS program (§<a class="sec" href=
        "#sec-13">3</a> and §<a class="sec" href="#sec-14">4</a>).
        Our tool mimics the features of a debugger, such as
        navigation controls, state and variable visualization, and
        conditional breakpoints, but does so for both the
        interpreter program and the interpreted program.</p>
        <p>The language in which we display the specification
        consists of a subset of JS extended with syntactic sugar
        for monads and basic pattern matching. This language, which
        we call pseudo-JS, could be the source syntax for our
        specification. However, for historical and technical
        reasons, we use as input syntax a subset of OCaml, which is
        processed using the OCaml type-checker. Our current tool
        automatically converts the OCaml AST into pseudo-JS code.
        In the future, we might as well have our reference
        interpreter be directly in pseudo-JS syntax, and we could
        typecheck that code either by converting it to OCaml or by
        reimplementing a basic ML type-checker. A third alternative
        would be to use the Reason syntax [<a class="bib"
        data-trigger="hover" data-toggle="popover" data-placement=
        "top" href="#BibPLXBIB0012">12</a>], a JS-like syntax for
        OCaml programs. The only difference between the approaches
        is whether TC39 committee members would prefer to write
        OCaml style or JS style code.</p>
      </section>
    </section>
    <section id="sec-10">
      <header>
        <div class="title-info">
          <h2><span class="section-number">2</span> Specification
          language</h2>
        </div>
      </header>
      <section id="sec-11">
        <header>
          <div class="title-info">
            <h3><span class="section-number">2.1</span> Constructs
            of the Language</h3>
          </div>
        </header>
        <p>The input syntax in which we write and display the
        specification is a purely-functional language that includes
        the following constructs: variables, constants, sequence,
        conditional, let-binding, function definition, function
        application (with support for prefix and infix functions),
        data constructors, records (including record projections,
        and the “record-with” construct to build a copy of a record
        with a number of fields updated), tuples (i.e., anonymous
        records), and simple pattern matching (only with non-nested
        patterns, restricted to data constructors, constants,
        variables, and wildcards). For convenience, let-bindings
        and functions may bind patterns (as opposed to only
        variables).</p>
        <p>We purposely aim for a specification language with a
        limited number of constructs and a very standard semantics,
        to minimize the cost of entry into that language. Note that
        the input code is type-checked in ML. (Polymorphism is used
        mainly for type-checking options and lists, and operations
        on them.)</p>
        <p>As explained earlier (§<a class="sec" href=
        "#sec-6">1.2</a>), the semantics involves the propagation
        of exceptions and other abrupt behaviors (break, continue,
        and return). Their propagation can be described within our
        small language, using functions and pattern matching.
        Nevertheless, introducing a little bit of syntactic sugar
        greatly improves readability. For example, we write
        “let%run x = e1 in e2” to mean “if_run e1 (fun x -&gt;
        e2)”, where if_run is a function that implements our
        monad.</p>
        <p>The monadic operator if_run admits a polymorphic type,
        hence functions from the specification may return objects
        of various types. Nevertheless, in practice most functions
        from the ECMA standard are described as returning a
        “completion triple”, which either describe abrupt
        termination or describe a value. In a number of cases, the
        value is in fact constrained to be of a particular type.
        For example, if to_number produces a value, then this value
        is necessarily a number. The standard exploits this
        invariant implicitly in formulation such as “let <em>n</em>
        be the number produced by calling to_number”. In constrast,
        our code needs to explicitly project the number from the
        value returned. To that end, we introduce specialized
        monads such as if_number, written in practice “let%number n
        = e1 in e2”. (An alternative approach would be to assign
        polymorphic types to completion triples, however following
        this route would require diverging slightly from ECMA's
        specification in a number of places.)</p>
        <p>Figure&nbsp;<a class="fig" href="#fig7">6</a> shows the
        specification of addition in our reference interpreter, in
        OCaml syntax extended with the monadic notation. This code
        implements its informal equivalent from
        Figure&nbsp;<a class="fig" href="#fig2">2</a>. In that
        code, s denotes the state, c denotes the environment
        (variable and lexical environment, in JS terminology), op
        corresponds to the operator (here, the constructor
        C_binary_op_add corresponds to the AST token describing the
        operator +), v1 and v2 corresponds to the arguments, and w1
        and w2 to their primitive values. The function strappend
        denote string concatenation, whereas “+.” denotes addition
        on floating pointer numbers (i.e., JS's numbers).</p>
        <figure id="fig7">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185969/images/www18companion-30-fig7.jpg"
          class="img-responsive" alt="Figure 6" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 6:</span>
            <span class="figure-title">Current input syntax of our
            specification language: a subset of pure OCaml,
            extended with monadic notation.</span>
          </div>
        </figure>
        <p></p>
        <p>First observe that, as explained earlier (§<a class=
        "sec" href="#sec-5">1.1</a>), the state is threaded
        throughout the code. We show in the next section how to
        hide the state variables (§<a class="sec" href=
        "#sec-12">2.2</a>). Observe also that the code also relies
        on a few auxiliary functions. The function type_compare
        implements comparison over JS types—to keep our language
        small and explicit, we do not want to assume a generic
        comparison function with nontrivial specification. The
        functions to_primitive_def, to_string, and to_number are
        internal functions from the specification that implement
        conversions. These operations might end up evaluating
        arbitrary user code, and thus could perform side-effects or
        raise exceptions, hence the need to wrap them in monadic
        let-bindings.</p>
        <p>One important feature of this source language is that it
        does not involve any “implicit” mechanism. All type
        conversions are explicit in the code, so it is always
        perfectly clear what is meant. In particular, there is no
        need to type-check the code to figure out its semantics. In
        summary, the OCaml code of the interpreter (e.g.,
        Figure&nbsp;<a class="fig" href="#fig7">6</a>) is
        well-suited as a non-ambiguous input language. Note that
        this code may be compiled using OCaml's compiler in order
        to run test cases; the current version of our interpreter
        passes more than 5000 test cases from the official test
        suite (test262).</p>
        <figure id="fig8">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185969/images/www18companion-30-fig8.jpg"
          class="img-responsive" alt="Figure 7" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 7:</span>
            <span class="figure-title">Generated code for the
            interpreter in pseudo-JS syntax, with implicit
            environments, state, and casts.</span>
          </div>
        </figure>
        <p></p>
      </section>
      <section id="sec-12">
        <header>
          <div class="title-info">
            <h3><span class="section-number">2.2</span> Translation
            into Pseudo-JS Syntax</h3>
          </div>
        </header>
        <p>Although we believe that it is a desirable feature to
        have a source langage fully explicit, there is also virtue
        in pretty-printing the source code of our interpreter in a
        more concise syntax. The “noise” that appears in the formal
        specification (e.g. Figure&nbsp;<a class="fig" href=
        "#fig7">6</a>) comes from three main sources:</p>
        <ol class="list-no-style">
          <li id="list10" label="(1)">every function takes as
          argument the environment;<br /></li>
          <li id="list11" label="(2)">every function takes as
          argument and returns a description of the mutable state
          (a.k.a. heap);<br /></li>
          <li id="list12" label="(3)">values are typically built
          using numerous constructors, e.g. C_value_prim, which
          lifts a number (an OCaml value of type float) into a JS
          value (an OCaml value of type value).<br /></li>
        </ol>
        <p>Fortunately, we can easily eliminate these three sources
        of noises.</p>
        <p>First, the environment is almost always passed
        unchanged. It may be modified only during the scope of a
        function call, a with construct, or a block. When it is
        modified, new bindings are simply pushed into the
        environment (which behaves like a stack), and subsequently
        popped. Thus, we may assume, like the ECMA specification
        does, that the environment is stored in a global state.
        This saves the need to pass an argument called “c”
        around.</p>
        <p>Second, the description of the mutable state is threaded
        through the code. The “current state” is passed as argument
        to every function that might perform side-effects, and,
        symmetrically, the “updated state” is returned to the
        caller, which binds a fresh name for it. Considering that
        there is only one version of the state at any given point
        of an execution, we may assume, like the ECMA specification
        does, that state to be stored in a global variable. This
        saves the need to pass values called “s1”, “s2”...
        around.</p>
        <p>Third, the presence of many constructors is due to the
        need for casts. Many of these casts could, however, be
        viewed as “implicit casts” (or “coercions”, in Coq's
        terminology). For a carefully chosen set of casts, defined
        once and for all, and for a well-typed program with
        implicit casts, there exists a unique (non-ambiguous) way
        to insert casts in order to make the program type-check.
        Although we have previously argued that explicit casts are
        useful, as they allow giving a semantics that does not
        depend on type-checking, we now argue that it may also be
        useful to pretty-print the code assuming implicit casts, in
        order to improve readability.</p>
        <p>In summary, we propose to the reader of the
        specification a version that features implicit state,
        implicit context, and implicit casts. Given that we are
        playing the game of pretty-printing syntax, we take the
        opportunity to switch along the way to a JS-friendly
        syntax, using brackets and semicolons. This target
        language, called pseudo-JS syntax, consists of a subset of
        the JS syntax, extended with monadic notation, and an
        extended switch construct that is able to bind variables
        (like OCaml's pattern matching, but restricted to
        non-nested patterns for simplicity).</p>
        <p>The pretty-printing of the addition operator in
        pseudo-JS syntax appears in Figure&nbsp;<a class="fig"
        href="#fig8">7</a>. To illustrate our extended pattern
        matching syntax feature of pseudo-JS, we show below an
        excerpt from the main switch that interprets an
        expression.</p>
        <figure id="fig9">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185969/images/www18companion-30-fig9.jpg"
          class="img-responsive" alt="" longdesc="" />
        </figure>
        <p></p>
      </section>
    </section>
    <section id="sec-13">
      <header>
        <div class="title-info">
          <h2><span class="section-number">3</span> Trace-producing
          executions</h2>
        </div>
      </header>
      <p>JSExplain is a tool for interactively investigating
      execution traces of our JS interpreter executing example JS
      programs. The interface consists of a web page [<a class=
      "bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0008">8</a>] that embeds
      a JS parser and a trace-producing version of our interpreter
      implemented in standard JS.</p>
      <p>So far, we have shown how to translate the OCaml source
      into pseudo-JS syntax (§<a class="sec" href=
      "#sec-12">2.2</a>). In this section, we explain how to
      translate the OCaml source into proper JS syntax, and then
      how to instrument the JS code in a systematic way for
      producing execution traces.</p>
      <p>Figure&nbsp;<a class="fig" href="#fig10">8</a> illustrates
      the output of translating from our OCaml subset towards JS.
      Note that this code is not meant for human consumption. We
      implement monadic operators as function calls, introduce the
      return keyword where necessary, encode sum types as object
      literals with a tag field, encode tuples as arrays (encoding
      tuples as object literals would work too), turn constructor
      applications into functions calls, implement pattern matching
      by first switching on the tag field then binding fresh
      variables to denote the arguments of constructors.</p>
      <figure id="fig10">
        <img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3185969/images/www18companion-30-fig10.jpg"
        class="img-responsive" alt="Figure 8" longdesc="" />
        <div class="figure-caption">
          <span class="figure-number">Figure 8:</span> <span class=
          "figure-title">Snippet of generated code for the
          interpreter in standard JS syntax, without trace
          instrumentation.</span>
        </div>
      </figure>
      <p></p>
      <p>We thus obtain an executable JS interpreter in JS which,
      like our JS interpreter in OCaml, may be used for executing
      test cases. One interest of the JS version is that it may be
      easily executed inside a browser, a set up that might be more
      convenient for a number of users. One limitation, however, is
      that the number of steps that can be simulated may be limited
      on JS virtual machines that do not optimize tail-recursive
      function calls. Indeed, the execution of monadic code
      involves repeated calls to continuations, whose (tail-call)
      invocation unnecessarily grows the call stack.</p>
      <p>To set up our interactive debugger, we produce, from our
      OCaml source code, an instrumented version of the JS
      translation. This instrumented code produces execution traces
      as a result of interpreting an input JS program. These traces
      store information about all the states that the interpreter
      goes through. In particular, each event in the trace provides
      information about the code pointer and the instantiations of
      local variables from the interpreter code.</p>
      <p>More precisely, we log events at every entry point of a
      function, every exit point, and on every variable binding.
      Each event captures the state, the stack, and the values of
      all local variables in scope of the interpreter code at the
      point where the event gets triggered. To reduce noise in the
      trace, we only log events in the core code of the
      interpreter, and not the code from the auxiliary libraries.
      Overall, an execution of the instrumented interpreter on some
      input JS program produces an array of events. This array can
      then be investigated using our double debugger (§<a class=
      "sec" href="#sec-14">4</a>).</p>
      <p>Figure&nbsp;<a class="fig" href="#fig11">9</a> shows an
      example snippet of code, giving an idea of the mechanisms at
      play. Note, again, that this code is not meant for human
      consumption. The function log_event augments the trace.
      Consider for instance log_event(”Main.js”, 4033, ctx_747,
      ”enter”). The first two arguments identify the position in
      the source file, as a file name and a unique token used to
      recover the line numbers. The third argument is a context
      describing values of the local variables, and the fourth
      argument describes the type of event.</p>
      <figure id="fig11">
        <img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3185969/images/www18companion-30-fig11.jpg"
        class="img-responsive" alt="Figure 9" longdesc="" />
        <div class="figure-caption">
          <span class="figure-number">Figure 9:</span> <span class=
          "figure-title">Snippet of generated code for the
          interpreter in standard JS syntax, with trace
          instrumentation.</span>
        </div>
      </figure>
      <p></p>
      <p>When investigating the trace, we need to be able to
      highlight the corresponding line of the interpreter code. We
      wish to be able to do so for the three versions of the
      interpreter code: the OCaml version, the pseudo-JS version,
      and the plain JS version. To implement this feature, our
      generator, when processing the OCaml source code, also
      produces a table that maps, for each version and for each
      file of the interpreter, event tokens to line numbers.</p>
      <p>The contexts stored in events are extended each time a
      function is entered, a new variable is declared, or the
      function returns (so as to capture the returned value).
      Contexts are represented as a purely-functional linked list
      of mappings between variable names and values. This
      representation maximizes sharing and thus minimize the memory
      footprint of the generated trace. The length of the trace
      grows linearly with the number of execution steps performed.
      For example, the simple program “var i = 0; while (i &lt; N)
      { i++ }” generates a trace of size 2 990 for <em>N</em> = 1,
      of size 14 166 for <em>N</em> = 10, of size 126 126 for
      <em>N</em> = 100, and of size 1 245 726 for <em>N</em> =
      1000.</p>
      <p>The fact that these numbers are large reflects the fact
      that the reference interpreter is inherently vastly
      inefficient, as it follows the specification faithfully,
      without any optimization. Due to our use of functional data
      structures, the memory footprint of the trace should be
      linear in the length of the trace. We have not observed the
      memory footprint to be a limit, but if it were we could more
      carefully select which events should be stored.</p>
    </section>
    <section id="sec-14">
      <header>
        <div class="title-info">
          <h2><span class="section-number">4</span> JSExplain: a
          double debugger for JS</h2>
        </div>
      </header>
      <p>The global architecture of JSExplain is depicted in
      Figure&nbsp;<a class="fig" href="#fig12">10</a>. Starting
      from our JS interpreter in OCaml, we generate a JS
      interpreter in JS. We instrument the JS code to produce a
      trace of events. This compilation is done ahead of time and
      depicted by solid arrows.</p>
      <figure id="fig12">
        <img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3185969/images/www18companion-30-fig12.jpg"
        class="img-responsive" alt="Figure 10" longdesc="" />
        <div class="figure-caption">
          <span class="figure-number">Figure 10:</span>
          <span class="figure-title">Architecture of
          JSExplain.</span>
        </div>
      </figure>
      <p></p>
      <p>When hitting the <tt>run</tt> button, the flow depicted by
      the dotted arrows occurs. The web page parses the code from
      the text area, using the Esprima library [<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0007">7</a>]. This parser produces an
      AST, with nodes annotated with locations. This AST is then
      provided as input to the instrumented interpreter, which
      generates a trace of events. This trace may then be inspected
      and navigated interactively.</p>
      <p>For a given event from the execution trace, our interface
      highlights the corresponding piece of code from the
      interpreter, and shows the values of the local variables, as
      illustrated in Figure&nbsp;<a class="fig" href=
      "#fig13">11</a>. It also highlights the corresponding piece
      of code in the interpreted program, as illustrated at the top
      of Figure&nbsp;<a class="fig" href="#fig15">13</a>, and
      displays the state and the environment of the program at that
      point of the execution, as illustrated in
      Figure&nbsp;<a class="fig" href="#fig14">12</a>.</p>
      <figure id="fig13">
        <img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3185969/images/www18companion-30-fig13.jpg"
        class="img-responsive" alt="Figure 11" longdesc="" />
        <div class="figure-caption">
          <span class="figure-number">Figure 11:</span>
          <span class="figure-title">Display of the variables from
          the interpreter code.</span>
        </div>
      </figure>
      <figure id="fig14">
        <img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3185969/images/www18companion-30-fig14.jpg"
        class="img-responsive" alt="Figure 12" longdesc="" />
        <div class="figure-caption">
          <span class="figure-number">Figure 12:</span>
          <span class="figure-title">Display of the state and
          environment of the interpreted code. The environment
          includes the local variables.</span>
        </div>
      </figure>
      <figure id="fig15">
        <img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3185969/images/www18companion-30-fig15.jpg"
        class="img-responsive" alt="Figure 13" longdesc="" />
        <div class="figure-caption">
          <span class="figure-number">Figure 13:</span>
          <span class="figure-title">Example of a conditional
          breakpoint, constraining the state of both the
          interpreter and the interpreted code.</span>
        </div>
      </figure>
      <p></p>
      <p>Recovering the information about the interpreted code is
      not completely straightforward. For example, to recover the
      fragment of code to highlight, we find in the trace the
      closest previous event that contains a call to function with
      an argument named _term_. This argument corresponds to the
      AST of a subexpression, and this AST is decorated (by the
      parser) with locations. Note that, for efficiency reasons, we
      associate to each event from the trace its corresponding
      _term_ argument during a single pass, performed immediately
      after the trace is produced.</p>
      <p>Similarly, we are able to recover the state and
      environment associated with the event. The state of the
      interpreted program consists of four fields: the strictness
      flag, the value of the this keyword, the lexical environment,
      and the variable environment. We implemented a custom display
      for these elements, and also for values of the languages, in
      particular for objects: one may click on an object to reveal
      its contents and recursively explore it.</p>
      <p>We provide several ways to navigate the trace. First, we
      provide buttons for reaching the beginning or end of the
      execution, and buttons for stepping one event at a time.
      Second, we provide, similarly to debuggers, <em>next</em> and
      <em>previous</em> buttons for skipping function calls, as
      well as a <em>finish</em> button to reach the end of the
      current function. These features are implemented by
      navigating the trace, keeping track of the number of
      <em>enter</em> and <em>return</em> events. Third, we provide
      buttons for navigation based not on steps related to the
      interpreter program but instead based on steps of the
      interpreted program: <em>source previous</em> and <em>source
      next</em> find the closest event which induces a change in
      the location on the subexpression evaluated in the
      interpreted code, and <em>source cursor</em> finds the last
      event in the trace for which the associated subexpression
      contains the active cursor in the “source program” text
      area.</p>
      <p>The aforementioned tools are sufficient for simple
      explorations of the trace, yet we have found that it is
      sometimes useful to reach events at which specific conditions
      occur, such as being at a specific line in the interpreter,
      in the interpreted code, with variables from the interpreter
      or interpreted code having specific values. We thus provide a
      text box to enter arbitrary breakpoint conditions to be
      evaluated on events from the trace. For example, the
      condition in Figure&nbsp;<a class="fig" href="#fig15">13</a>
      reaches the next occurrence of a call to run_binary_op_add in
      a context where the source variable j has value 1. The break
      point condition may be any JS expression using the following
      API: I_line() returns the current line of the interpreter,
      S_line() returns the current line of the source, I(’x’)
      returns the value of x in the interpreter, S_raw(’x’) returns
      the value of x in the source (e.g. the JS object {tag:
      ”value_number”, arg: 5}), and S(’x’) returns the JS
      interpretation of the value of x in the source (e.g. the JS
      value 5).</p>
    </section>
    <section id="sec-15">
      <header>
        <div class="title-info">
          <h2><span class="section-number">5</span> Related
          work</h2>
        </div>
      </header>
      <p>There are many formal semantics of JavaScript, from
      pen-and-paper ones [<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0010">10</a>], to the aforementioned JSCert
      [<a class="bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0003">3</a>] and KJS
      [<a class="bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0011">11</a>]. As
      described in §<a class="sec" href="#sec-8">1.4</a>, these
      semantics are admirable but lack crucial features to be
      actively used in the standardization effort.</p>
      <p>To our knowledge, the closest work to the double-debugger
      approach is the multi-level debugging approach of Kruck et
      al. [<a class="bib" data-trigger="hover" data-toggle=
      "popover" data-placement="top" href="#BibPLXBIB0009">9</a>].
      They present a debugger for an interpreter for
      domain-specific languages that lets developers choose the
      level of abstraction at which they debug their program. An
      abstraction is a way to display some values (encoded in the
      host language, or as present in the DSL) as well as showing
      only stack frames that represent computation at the DSL
      level. Our technique is more general as it does not focus on
      domain-specific languages.</p>
      <p>In fact, our double-debugger approach could be easily
      adapted to interpreter for other languages than JS. To that
      end, it suffices to implemented an interpreter for the
      desired language in the subset of OCaml that we support, and
      to provide code for extracting and displaying the term and
      state associated with a given event. We have recently
      followed that approach and adapted our framework to derive a
      double-debugger for (a significant subset of) the OCaml
      programming language.</p>
      <p>Regarding the translation from OCaml to JS that we
      implement, one might consider using an existing,
      general-purpose tool. Js_of_ocaml&nbsp;[<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0017">17</a>] converts OCaml bytecode
      into efficient JS code. Presumably, we could implement the
      logging instrumentation as an OCaml source-to-source
      translation and then invoke Js_of_ocaml. Yet, with that
      approach, we would need to convert the representation of
      trace events from the encoding of these values performed by
      Js_of_ocaml into proper JS objects that we can display in the
      interactive interface. This conversion is nontrivial, as some
      information, such as the name of constructors, is lost in the
      process. As we already implemented a translator from OCaml to
      pseudo-JS, it was simpler to implement a translator from
      OCaml to plain JS.</p>
      <p>Another translator from OCaml to JS is
      Bucklescript&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0004">4</a>], which was released after we started
      our work. Similarly to our translator, Bucklescript converts
      OCaml code into JS code advertised as readable. Bucklescript
      also has the limitation that the names of constructors are
      lost, although presumably this could be easily fixed.
      Besides, if we wanted to revisit our implementation to base
      it on Bucklescript, for trace generation we would need to
      either modify Bucklescript, which is quite complex as it
      covers the full OCaml language, or to reimplement trace
      instrumentation at the OCaml level, which should be doable
      yet would involve a bit more work than at the level of
      untyped JS code.</p>
    </section>
    <section id="sec-16">
      <header>
        <div class="title-info">
          <h2><span class="section-number">6</span> Conclusion and
          future work</h2>
        </div>
      </header>
      <p>We presented JSExplain to TC39<a class="fn" href="#fn1"
      id="foot-fn1"><sup>1</sup></a> and the committee expressed
      strong interest. They would like us to extend our
      specification to cover all of the specification. We have
      almost finished the formalization of proxies, which are a
      challenging addition to the language as they change many
      internal methods. Although all members seem to agree that the
      current toolset for developing the specification is
      inappropriate, it requires a strong leadership and a
      consensus to commit to a new toolchain. Our goal is to cover
      the current version of ECMAScript, we currently cover
      ECMAScript 5, and to help committee members use it to
      formalize new additions to JavaScript.</p>
      <p>There are numerous directions for future work. (1) We plan
      to set up a modular mechanism for describing unspecified
      behaviors (e.g. “for-in” enumeration order) as well as
      browser-specific behaviors (sometimes browsers deviate from
      the specification, for historical reasons). (2) We could
      investigate the possibility of extending the formalization of
      the standard by also covering the parsing rules of JS;
      currently, our semantics is expressed with respect to the AST
      of the input program. (3) To re-establish a link with the
      original JSCert inductive definition, which is useful for
      conducting formal proofs about the metatheory of the langage,
      we would like to investigate the possibility of automatically
      generating pretty-big-step&nbsp;[<a class="bib" data-trigger=
      "hover" data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0005">5</a>] definitions from the reference
      semantics expressed in our small language, possibly using
      some amount of annotation to guide the process. (4) To close
      even further the gap between a formal language and the
      English prose, we could also investigate the possibility of
      automatically generating English sentences from the code.
      Indeed, the prose from the ECMAScript standard is written in
      such a systematic manner that this should be doable, at least
      to some extent.</p>
    </section>
  </section>
  <section class="back-matter">
    <section id="sec-17">
      <header>
        <div class="title-info">
          <h2>ACKNOWLEDGMENTS</h2>
        </div>
      </header>
      <p>We acknowledge funding from the ANR project AJACS
      ANR-14-CE28-0008 and the CominLabs project SecCloud.</p>
    </section>
    <section id="ref-001">
      <header>
        <div class="title-info">
          <h2 class="page-brake-head">REFERENCES</h2>
        </div>
      </header>
      <ul class="bibUl">
        <li id="BibPLXBIB0001" label="[1]">2017. Babel. (October
        25, 2017). <a class="link-inline force-break" href=
        "https://babeljs.io/" target=
        "_blank">https://babeljs.io/</a>.
        </li>
        <li id="BibPLXBIB0002" label="[2]">2017. Babel proxy
        plugin. (October 25, 2017). <a class=
        "link-inline force-break" href=
        "https://www.npmjs.com/package/babel-plugin-proxy"
          target="_blank">https://www.npmjs.com/package/babel-plugin-proxy</a>.
        </li>
        <li id="BibPLXBIB0003" label="[3]">Martin Bodin, Arthur
        Charguéraud, Daniele Filaretti, Philippa Gardner, Sergio
        Maffeis, Daiva Naudziuniene, Alan Schmitt, and Gareth
        Smith. 2014. A Trusted Mechanised javascript specification.
        In <em><em>Proceedings of POPL 2014</em></em> ,
        87–100.</li>
        <li id="BibPLXBIB0004" label="[4]">2017. Bucklescript.
        (October 27, 2017). <a class="link-inline force-break"
          href="https://bucklescript.github.io/bucklescript/"
          target=
          "_blank">https://bucklescript.github.io/bucklescript/</a>.
        </li>
        <li id="BibPLXBIB0005" label="[5]">Arthur Charguéraud.
        2013. Pretty-Big-Step Semantics. In <em><em>Proceedings of
        ESOP 2013</em></em> (LNCS). Volume&nbsp;7792. Springer,
        41–60.</li>
        <li id="BibPLXBIB0006" label="[6]">ECMA. 2017. ECMAScript
        2017 Language specification (ecma-262, 8th edition). (June
        2017). <a class="link-inline force-break" href=
        "https://www.ecma-international.org/ecma-262/8.0/index.html"
          target=
          "_blank">https://www.ecma-international.org/ecma-262/8.0/index.html</a>.
        </li>
        <li id="BibPLXBIB0007" label="[7]">2017. ECMAScript parsing
        infrastructure for multipurpose analysis. (October 26,
        2017). <a class="link-inline force-break" href=
        "http://esprima.org/" target=
        "_blank">http://esprima.org/</a>.
        </li>
        <li id="BibPLXBIB0008" label="[8]">2017. JSExplain.
        (October 26, 2017). <a class="link-inline force-break"
          href="https://jscert.github.io/jsexplain/branch/master/driver.html"
          target=
          "_blank">https://jscert.github.io/jsexplain/branch/master/driver.html</a>.
        </li>
        <li id="BibPLXBIB0009" label="[9]">Bastian Kruck, Stefan
        Lehmann, Christoph Keßler, Jakob Reschke, Tim Felgentreff,
        Jens Lincke, and Robert Hirschfeld. 2016. Multi-level
        debugging for interpreter developers. In <em><em>MODULARITY
        (Companion)</em></em> . ACM, 91–93.</li>
        <li id="BibPLXBIB0010" label="[10]">Sergio Maffeis,
        John&nbsp;C. Mitchell, and Ankur Taly. 2008. An operational
        semantics for javascript. In <em><em>Proceedings of APLAS
        2008</em></em> (LNCS). Volume&nbsp;5356. Springer,
        307–325.</li>
        <li id="BibPLXBIB0011" label="[11]">Daejun Park, Andrei
        Stefanescu, and Grigore Rosu. 2015. KJS: a complete formal
        semantics of javascript. In <em><em>Proceedings of PLDI
        2015</em></em> . ACM, 346–356.</li>
        <li id="BibPLXBIB0012" label="[12]">2017. Reason. (October
        27, 2017). <a class="link-inline force-break" href=
        "https://reasonml.github.io/" target=
        "_blank">https://reasonml.github.io/</a>.
        </li>
        <li id="BibPLXBIB0013" label="[13]">Grigore Rosu and
        Traian-Florin Serbanuta. 2010. An overview of the K
        semantic framework. <em><em>Journal of Logic and Algebraic
        Programming</em></em> 79, 6 (2010), 397–434.</li>
        <li id="BibPLXBIB0014" label="[14]">2017. TC39 proposals.
        (October 26, 2017). <a class="link-inline force-break"
          href="https://github.com/tc39/proposals" target=
          "_blank">https://github.com/tc39/proposals</a>.
        </li>
        <li id="BibPLXBIB0015" label="[15]">2017. Test262. (October
        26, 2017). <a class="link-inline force-break" href=
        "https://github.com/tc39/test262" target=
        "_blank">https://github.com/tc39/test262</a>.
        </li>
        <li id="BibPLXBIB0016" label="[16]">The Coq development
        team. 2014. <em><em>The Coq proof assistant reference
        manual</em></em> . Version 8.4. <a class=
        "link-inline force-break" href="http://coq.inria.fr"
          target="_blank">http://coq.inria.fr</a>.
        </li>
        <li id="BibPLXBIB0017" label="[17]">Jérôme Vouillon and
        Vincent Balat. 2014. From bytecode to javascript: the
        js_of_ocaml compiler. <em><em>Software: Practice and
        Exprerience</em></em> 44, 8, 951–972.</li>
      </ul>
    </section>
  </section>
  <section id="foot-001" class="footnote">
    <header>
      <div class="title-info">
        <h2>FOOTNOTE</h2>
      </div>
    </header>
    <p id="fn1"><a href="#foot-fn1"><sup>1</sup></a><a class=
    "link-inline force-break" href=
    "https://tc39.github.io/tc39-notes/2016-05_may-25.html#jsexplain-as--tw">https://tc39.github.io/tc39-notes/2016-05_may-25.html#jsexplain-as--tw</a></p>
    <div class="bibStrip">
      <p>This paper is published under the Creative Commons
      Attribution 4.0 International (CC BY&nbsp;4.0) license.
      Authors reserve their rights to disseminate the work on their
      personal and corporate Web sites with the appropriate
      attribution.</p>
      <p><em>WWW '18, April 23-27, 2018, Lyon, France</em></p>
      <p>© 2018; IW3C2 (International World Wide Web Conference
      Committee), published under Creative Commons CC BY&nbsp;4.0
      License.<br />
      ACM ISBN 978-1-4503-5640-4/18/04.<br />
      DOI: <a class="link-inline force-break" target="_blank" href=
      "https://doi.org/10.1145/3184558.3185969">https://doi.org/10.1145/3184558.3185969</a></p>
    </div>
  </section>
  <div class="pubHistory">
    <p></p>
  </div>
</body>
</html>
