<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">  <head>  <title>Web Reasoning Using Fact Tagging</title>  <!-- Copyright (c) 2010-2015 The MathJax Consortium --><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>  <meta name="viewport" content="width=device-width; initial-scale=1.0;"></meta>  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>  <link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/bootstrap.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/bootstrap-theme.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/main.css"/><script src="../../../data/dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script>  <script type="text/javascript"    src="../../../data/dl.acm.org/pubs/lib/js/MathJax.js?config=TeX-AMS_CHTML"></script>  <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>  </head>  <body id="main">  <section class="front-matter">   <section>    <header class="title-info">     <div class="journal-title">     <h1>      <span class="title">Web Reasoning Using Fact Tagging</span>      <br/>      <span class="subTitle"/>     </h1>     </div>    </header>    <div class="authorGroup">     <div class="author">     <span class="givenName">Mehdi</span>      <span class="surName">Terdjimi</span>,     Univ Lyon, LIRIS - Universit&#x00E9;, Lyon 1 - CNRS UMR5205, Villeurbanne, France, <a href="mailto:mehdi.terdjimi@liris.cnrs.fr">mehdi.terdjimi@liris.cnrs.fr</a>     </div>     <div class="author">     <span class="givenName">Lionel</span>      <span class="surName">M&#x00E9;dini</span>,     Univ Lyon, LIRIS - Universit&#x00E9;, Lyon 1 - CNRS UMR5205, Villeurbanne, France, <a href="mailto:lionel.medini@liris.cnrs.fr">lionel.medini@liris.cnrs.fr</a>     </div>     <div class="author">     <span class="givenName">Michael</span>      <span class="surName">Mrissa</span>,     Univ Pau &#x0026; Pays Adour, LIUPPA, EA3000, Pau, France, <a href="mailto:michael.mrissa@univ-pau.fr">michael.mrissa@univ-pau.fr</a>     </div>                 </div>    <br/>    <div class="pubInfo">     <p>DOI: <a href="https://doi.org/10.1145/3184558.3191615" target="_blank">https://doi.org/10.1145/3184558.3191615</a>     <br/>WWW '18: <a href="https://doi.org/10.1145/3184558" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p>    </div>    <div class="abstract">     <p>     <small>Today&#x0027;s Web applications tend to reason about cyclic data (i.e. facts that re-occur periodically) on the client side. Although they can benefit from efficient incremental maintenance algorithms capable of handling frequent data updates, existing rule-based algorithms cause successive re-derivations of previously inferred information. In this paper, we propose an incremental maintenance approach for rule-based reasoning that prevents successive re-computations of fact derivations. We tag (i.e. annotate) facts to keep trace of their provenance and validity. We compare our solution with the DRed-based incremental reasoning algorithm and show that it significantly outperforms this algorithm for fact updates in re-occurring situations, to the cost of tagging facts at their first insertion. Our experiments show that this cost can be recovered within a small number of cycles of deletions and reinsertions of explicit facts. We discuss the utility and limitations of our approach on Web clients and provide implementation packages of this reasoner that can be directly integrated in Web applications, on both server and client sides.</small>     </p>    </div>    <div class="CCSconcepts">     <p> <small> <span style="font-weight:bold;">CCS Concepts:</span> &#x2022;<strong> Theory of computation </strong>&#x2192; <strong>Semantics and reasoning;</strong> &#x2022;<strong> Computing methodologies </strong>&#x2192; <strong>Causal reasoning and diagnostics;</strong> &#x2022;<strong> Information systems </strong>&#x2192; <em>Web applications;</em> <em>Web Ontology Language (OWL);</em></small> </p>    </div>    <div class="classifications">     <div class="author">     <span style="font-weight:bold;">      <small>Keywords:</small>     </span>     <span class="keyword">      <small>rule-based reasoning; Web reasoning; incremental fact maintenance; fact tagging</small>     </span>     </div>     <br/>     <div class="AcmReferenceFormat">     <p>      <small>       <span style="font-weight:bold;">ACM Reference Format:</span>       <br/>       Mehdi Terdjimi, Lionel M&#x00E9;dini, and Michael Mrissa. 2018. Web Reasoning Using Fact Tagging. In <em>The 2018 Web Conference Companion,</em>       <em>April 23&#x2013;27, 2018,</em>       <em> Lyon, France</em>. ACM, New York, NY, USA, 8 pages. <a href="https://doi.org/10.1145/3184558.3191615" class="link-inline force-break"        target="_blank">https://doi.org/10.1145/3184558.3191615</a></small>     </p>     </div>    </div>   </section>  </section>  <section class="body">   <section id="sec-4">    <header>     <div class="title-info">     <h2>      <span class="section-number">1</span> Introduction</h2>     </div>    </header>    <p>Everyday Web applications must dynamically handle various types of contents generated by users or client sensors. Semantic technologies could improve these applications, but are currently under-exploited. One reason is that full-fledged semantic stacks are perceived as costly, unreliable server-sided architectures, in opposition with current (i.e. modular and client-side) Web design practices [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0019">19</a>]. We have addressed this problem in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0018">18</a>], by proposing HyLAR, a reasoner that can be both used on the server and client sides. Our goal is to allow using reasoning for tasks currently located on Web application clients, that satisfy several conditions. We focus on datasets of relatively small size (< 50k triples) and target Web applications based on stable data models (TBoxes) and more varying model instances (ABoxes). State-of-the-art in semantic reasoning research work&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0013">13</a>] aims at improving reasoning through maintenance algorithms such as incremental reasoning (IR). However, when the updated data is cyclic (i.e. facts that re-occur periodically), applications should not only rely on IR to optimize reasoning, as they are regularly exposed to overheads caused by re-deriving implicit facts that have been already derived in the past.</p>    <p>In this paper, we propose a maintenance approach inspired by IR that prevents successive re-derivations by tagging facts with respect to their provenance and validity. Our solution includes the following contributions:</p>    <ul class="list-no-style">     <li id="list1" label="&#x2022;"><strong>Faster deletions using validity tagging.</strong> We provide validity tagging for explicit facts and do not process overdeletion tasks. Instead, explicit facts are tagged as invalid at deletion time and as valid at re-insertion time.<br/></li>     <li id="list2" label="&#x2022;"><strong>Faster re-insertions using provenance tagging.</strong> We track the provenance of all implicit facts (i.e. all possible derivations), which avoids having to re-evaluate them if they are reinserted in the knowledge base.<br/></li>     <li id="list3" label="&#x2022;"><strong>Reasoning on the Web.</strong> We provide a rule-based reasoner that currently supports a subset of OWL 2 RL rules, usable on both JavaScript-enabled servers and Web browsers.<br/></li>    </ul>    <p>This paper is structured as follows. Section&#x00A0;<a class="sec" href="#sec-5">2</a> formalizes and highlights the re-derivation overhead problem, in a scenario involving a mobile Web application. Section&#x00A0;<a class="sec" href="#sec-6">3</a> presents our contribution with three algorithms: implicit fact tagging, tag-based KB update and fact selection filtering. Section&#x00A0;<a class="sec" href="#sec-11">4</a> describes our prototype and enumerates the entailment rules it is currently capable to handle. Section&#x00A0;<a class="sec" href="#sec-12">5</a> evaluates our solution by comparing it with IR and discusses the results with respect to different application settings. Section&#x00A0;<a class="sec" href="#sec-17">6</a> overviews related work on reasoning profiles and optimizations. Section&#x00A0;<a class="sec" href="#sec-20">7</a> concludes and draws perspectives of our work.</p>   </section>   <section id="sec-5">    <header>     <div class="title-info">     <h2>      <span class="section-number">2</span> Problem statement</h2>     </div>    </header>    <p>Web applications can be subject to frequent updates. Possibly re-occurring data can be re-inserted or re-deleted, which can cause significant computational overheads. We illustrate this issue with the scenario of a mobile Web application connected to a smart house: Julia uses this application on her smartphone to automatically regulate her house temperature when she approaches her house. The application locates her mobile phone either using its GPS sensor or by recognizing the network it is connected to. She will be considered close to her house either if her cell phone GPS coordinates correspond to her house neighborhood or if she connects the phone to the house local network. This activates temperature regulation and deactivates it otherwise. Julia&#x0027;s proximity from her house is the re-occurring data: the application infers or not this information as she moves back and forth with her cell phone, as she switches on and off the GPS sensor, or as she connects and disconnects her phone from the house network.</p>    <p>We use the following formalization, from Motik et al.&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0013">13</a>]: a fact <span class="inline-equation"><span class="tex">${\rm\small {F}}$</span> can be explicit (<em>i.e.</em> provided at startup or update), implicit (<em>i.e.</em> derived as a rule consequence), or both implicit and explicit (<em>i.e.</em> explicitly stated and derived). A rule <em>r</em> has an antecedent, conjunction of facts <span class="inline-equation"><span class="tex">${\rm\small {F}}_i$</span>     </span>, <span class="inline-equation"><span class="tex">$i \in \mathbb {N}$</span>     </span>) and an implied consequence (a single fact <span class="inline-equation"><span class="tex">${\rm {I}}$</span>     </span>); when it applies, the consequence is derived as an implicit fact: <em>r</em> :- <span class="inline-equation"><span class="tex">${\rm\small {F}}1 \wedge {\rm\small {F}}2\, \wedge \, ... \, \wedge \, {\rm\small {F}}x \rightarrow {\rm {I}}$</span>     </span>.</p>    <p>     <strong>Application ontology.</strong> Julia&#x0027;s application in our scenario uses the following fixed ontology (Classes and Properties) and entailment rules.</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191615/images/www18companion-354-img1.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191615/images/www18companion-354-img2.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191615/images/www18companion-354-img3.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>     <strong>Application instances and rules.</strong> Below are the initial explicit and implicit facts inferred via the Business Rules (Listing&#x00A0;4), which drive the application behavior. The set of initial explicit facts declares Julia, her cell phone, her house and the instance that activates temperature regulation in the KB, and assumes that Julia always carries her cell phone with her. The application can reason about their locations via <em>r</em>1 (as they are inferred as physical agents), and can switch on the regulation via <em>r</em>2.</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191615/images/www18companion-354-img4.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191615/images/www18companion-354-img5.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191615/images/www18companion-354-img6.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>We consider the following 3-steps scenario.</p>    <ol class="list-no-style">     <li id="list4" label="(1)">Julia approaches her neighborhood with her cell phone. The application analyzes the phone GPS coordinates and adds the explicit fact E6. This allows the reasoner to infer I6 via <em>r</em>1 and I7 via <em>Transitivity</em>. <img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191615/images/www18companion-354-graphic1.jpg" class="img-responsive" alt=""       longdesc=""/>     <br/>The application then enables temperature regulation as I7 triggers I8 via <em>r</em>2. <img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191615/images/www18companion-354-graphic2.jpg" class="img-responsive" alt=""       longdesc=""/>     <br/></li>     <li id="list5" label="(2)">Julia enters her house and cuts off the GPS to save energy. The phone position becomes unknown. The application removes E6, which also triggers the removal of I6, I7, I8, and disables temperature regulation. <img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191615/images/www18companion-354-graphic3.jpg" class="img-responsive" alt=""       longdesc=""/>     <br/></li>     <li id="list6" label="(3)">Julia connects her phone to the house local network. The application inserts E7, causing I7 and I8 to be re-derived respectively via <em>Transitivity</em> and <em>r</em>2. <img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191615/images/www18companion-354-graphic4.jpg" class="img-responsive" alt=""       longdesc=""/>     <br/></li>    </ol>    <p>Step 3 highlights the re-evaluation overhead caused by over-deletion in the IR algorithm: the deletion and reinsertion of explicit facts leads to the re-derivation of two implicit facts that have already been derived at first insertion.</p>   </section>   <section id="sec-6">    <header>     <div class="title-info">     <h2>      <span class="section-number">3</span> Tag-based Incremental Maintenance</h2>     </div>    </header>    <p>To avoid recurrent re-derivations, we propose to keep the origin of previously obtained inferences so that when already known facts re-occur, the reasoner can quickly retrieve their consequences. To do so, it must <em>keep track of all facts</em>, including deleted ones, and be able to <em>assess their validity</em>: explicit facts are tagged as valid/invalid, and implicit fact validity is retrieved using those of the explicit facts they have been derived from. When the reasoner receives an INSERT query, it only runs its inference algorithm on the explicit facts that have not been inserted before and simply validates the others. Processing DELETE queries only consists in invalidating the corresponding facts instead of removing them from the KB (as done in IR). At SELECT queries, the reasoner queries the knowledge base and filters the resulting facts according to their validity.</p>    <p>The speed of this process relies on the principle of storing explicit fact validity in memory and obtaining implicit fact validity from simple logic operations on these values: an implicit fact can originate from the disjunction of several sets of facts (explicit or implicit) that match the antecedent pattern of a same rule or from multiple rules, and rule antecedents are defined as conjunctions.</p>    <p>Finally, we introduce a <em>fact forgetting</em> mechanism to avoid KB inflation: each fact is tagged with the timestamp of its latest validity update, so that the oldest invalid facts are asynchronously removed when the KB size reaches a threshold.</p>    <p>In our scenario, when Julia switches the phone GPS off, the application &#x201C;loses&#x201D; its location and asks the reasoner to remove E6. But the reasoner only invalidates this fact. Then, the application sends a SELECT query on I8. The reasoner performs a simple logical operation (explained below) on I8 causes (E4, E6) that assesses that I8 is invalid, as E6 is invalid. It then does not return I8. When the phone connects to the house network, the application creates E7. The reasoner attaches it as alternative derivation of I7. At the next SELECT query, it deduces that I8 is valid as I7 is valid, and sends it back to the application. The next subsections detail the main elements of our Tag-Based (TB) maintenance approach: validity assessement, fact tagging, reasoning process and selection tasks.</p>    <section id="sec-7">     <header>     <div class="title-info">      <h3>       <span class="section-number">3.1</span> Fact validity</h3>     </div>     </header>     <p>Let <em>F<sub>e</sub>     </em> and <em>F<sub>i</sub>     </em> be respectively the sets of explicit and implicit facts in the KB. We propose to keep all facts (explicit and implicit) in the KB until the reasoning process is stopped or the fact forgetting mechanism triggered, and to assess their validity instead of removing them at DELETE queries. To do so, we tag explicit facts with a <em>valid</em> boolean indicator: <span class="inline-equation"><span class="tex">${f_e}.valid \in \mathbb {B}, f_e \in F_e$</span>     </span>, which is set to <em>true</em> on insertion and <em>false</em> on deletion. We tag implicit facts with a <em>derivedFrom</em> indicator that represents the minimal set of disjoint <em>causes</em> of an implicit fact. We define a cause <em>C</em> as a set of explicit facts that must all be valid to validate an implicit fact<a class="fn" href="#fn1" id="foot-fn1"><sup>1</sup></a>: <em>C</em> = {<em>f<sub>e</sub>     </em> | <em>f<sub>e</sub>     </em> &#x2208; <em>F<sub>e</sub>     </em>}. Hence, &#x2200;<em>f<sub>i</sub>     </em> &#x2208; <em>F<sub>i</sub>     </em>, <em>f<sub>i</sub>     </em>.<em>derivedFrom</em> = <span class="inline-equation"><span class="tex">$\lbrace C_i\rbrace , i\in \mathbb {N} / \forall x, y, 0 \le x {\lt} y \le i, C_x \nsubseteq C_y, C_y \nsubseteq C_x$</span>     </span>.</p>     <p>We provide an <em>isValid</em>() function that checks the validity of an implicit fact using its <em>derivedFrom</em> tag. It evaluates the disjunction between the tag elements and for each element, the conjunction between the <em>valid</em> tags of the explicit facts referenced in this element: <span class="inline-equation"><span class="tex">$isValid(f_i) = \vee _{C_i}\lbrace \wedge _{f_{ej}} \lbrace f_{ej}.valid\rbrace \rbrace , C_i\in f_{i}.derivedFrom, f_{ej}\in C_i$</span>     </span>. Implicit fact validity in our temperature regulation scenario is assessed as follows: &#x00A0;</p>     <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191615/images/www18companion-354-img7.jpg" class="img-responsive" alt=""       longdesc=""/>     </p>    </section>    <section id="sec-8">     <header>     <div class="title-info">      <h3>       <span class="section-number">3.2</span> Implicit fact tagging</h3>     </div>     </header>     <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191615/images/www18companion-354-img8.svg" class="img-responsive" alt=""       longdesc=""/>     </p>     <p>Each time an implicit fact is derived, Algorithm&#x00A0;1 is applied to set its <em>derivedFrom</em> tag. Let <em>F<sub>e</sub>     </em> (resp. <em>F<sub>i</sub>     </em>) be the sets of explicit (resp. implicit) facts a newly inferred fact <em>f</em> have been derived from. In the general case, the algorithm builds the set <em>resolvedExplicitCauses</em> of resolved explicit causes by replacing implicit facts with their explicit causes<a class="fn" href="#fn2" id="foot-fn2"><sup>2</sup></a> and deduplicating these causes (lines 4-10). It then builds the set <em>explicitCauses</em> of explicit causes by distributing the initial set of explicit facts <em>F<sub>e</sub>     </em> into <em>resolvedExplicitCauses</em> (lines 14-16). It finally sets <em>explicitCauses</em> as <em>derivedFrom</em> tag of <em>f</em> &#x2013; now tagged with a set of disjoint explicit causes &#x2013; and terminates (lines 17-18).</p>     <p>Two optimizations allow avoiding unnecessary loops: (i) if no implicit fact is present (<em>i.e. F<sub>i</sub>     </em> is empty), the algorithm sets <em>f</em>.<em>derivedFrom</em> to <em>F<sub>e</sub>     </em> and terminates at line 3; (ii) if no explicit fact is present (<em>i.e. F<sub>e</sub>     </em> is empty), the algorithm sets <em>f</em>.<em>derivedFrom</em> to <em>resolvedExplicitCauses</em> and terminates at line 13.</p>    </section>    <section id="sec-9">     <header>     <div class="title-info">      <h3>       <span class="section-number">3.3</span> Enabling tagging in reasoning</h3>     </div>     </header>     <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191615/images/www18companion-354-img9.svg" class="img-responsive" alt=""       longdesc=""/>     </p>     <p>The KB update algorithm (Algorithm 2) performs the reasoning process while answering INSERT and DELETE queries. Let <em>R</em> be the set of rules and <span class="inline-equation"><span class="tex">$F_e^+$</span>     </span> and <span class="inline-equation"><span class="tex">$F_e^-$</span>     </span> the sets of explicit facts to be respectively added and removed (from the query). It first invalidates the explicit facts to be deleted, and validates those to be inserted (lines 2-6), so that <span class="inline-equation"><span class="tex">$F_e^+$</span>     </span> only contains new facts to be evaluated at line 7. Hence, for all deletions and re-insertions, our approach allows to skip the whole evaluation loop (lines 9-13).</p>     <p>For the remaining facts in <span class="inline-equation"><span class="tex">$F_e^+$</span>     </span>, the evaluation loop works very similarly to IR&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0013">13</a>]: the reasoner restricts <em>R</em> to the set <em>R<sub>kb</sub>     </em> of rules that match at least one cause in the updated KB (<em>F<sub>e</sub>     </em> &#x222A; <em>F<sub>i</sub>     </em>) in <em>restrictRuleSet</em>() (line 11), evaluates <em>R<sub>kb</sub>     </em> over <em>F<sub>e</sub>     </em> &#x222A; <em>F<sub>i</sub>     </em> (<em>evaluateRuleSet</em>(), line 12) and loops as long as new implicit facts are inferred. TB reasoning requires two additional steps: (i) at each iteration, the <em>combine</em>() function deduplicates identical facts by concatenating their causes and removes unnecessary causes<a class="fn" href="#fn3" id="foot-fn3"><sup>3</sup></a> (line 13), and (ii) when new implicit facts have been inferred (<em>i.e.</em> in the innermost loop of the <em>evaluateRuleSet</em>() function), it calls Algorithm&#x00A0;1 to set the fact causes in their <em>derivedFrom</em> tags (line 12). After the evaluation loop, the algorithm terminates and returns <em>F<sub>e</sub>     </em>&#x222A;<em>F<sub>i</sub>     </em>, that reflects the KB changes, namely the updates in <span class="inline-equation"><span class="tex">$F_e^+$</span>     </span> and <span class="inline-equation"><span class="tex">$F_e^-$</span>     </span> and the <em>valid</em> and <em>derivedFrom</em> tags of facts.</p>    </section>    <section id="sec-10">     <header>     <div class="title-info">      <h3>       <span class="section-number">3.4</span> Fact-filtering</h3>     </div>     </header>     <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191615/images/www18companion-354-img10.svg" class="img-responsive" alt=""       longdesc=""/>     </p>     <p>The fact-filtering algorithm (Algorithm 3) is applied after SELECT queries to filter out valid facts. As these queries are time-critical for the application and this step represents an overhead compared to other approaches, this algorithm must be kept fast. Let <em>F</em> be a query result set of facts. The algorithm performs a single loop over <em>F</em> to construct &#x2013; and return &#x2013; the set of valid facts <em>V</em> of <em>F</em>: <em>V</em> = {<em>f<sub>e</sub>     </em> &#x2208; <em>F</em>&#x2229;<em>F<sub>e</sub>     </em>/<em>F<sub>e</sub>     </em>.<em>valid</em> = <em>true</em>}&#x222A;{<em>f<sub>i</sub>     </em> &#x2208; <em>F</em>&#x2229;<em>F<sub>i</sub>     </em>/<em>isValid</em>(<em>F<sub>e</sub>     </em>) = <em>true</em>}<a class="fn" href="#fn4" id="foot-fn4"><sup>4</sup></a>.</p>    </section>   </section>   <section id="sec-11">    <header>     <div class="title-info">     <h2>      <span class="section-number">4</span> Implementation</h2>     </div>    </header>    <p>Our approach targets a particular working context: OWL reasoning embedded in Web applications. This differs from traditional setups where regular OWL (e.g. Pellet<a class="fn" href="#fn5" id="foot-fn5"><sup>5</sup></a>) or rule-based (e.g. RDFox<a class="fn" href="#fn6" id="foot-fn6"><sup>6</sup></a> or CHR<a class="fn" href="#fn7" id="foot-fn7"><sup>7</sup></a>) reasoners can be found. Hence, we implemented our approach in HyLAR<a class="fn" href="#fn8" id="foot-fn8"><sup>8</sup></a>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0017">17</a>], a rule-based reasoner that includes both the IR algorithm from&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0013">13</a>] and our tag-based algorithms: update (Algorithms&#x00A0;1 and&#x00A0;2) and selection (Algorithm&#x00A0;3) from Section&#x00A0;<a class="sec" href="#sec-6">3</a>. It currently processes the following subset of OWL 2 RL rules&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0012">12</a>] (section 4.3):</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191615/images/www18companion-354-img11.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>We restrained to these rules as they seemed to us of reasonable complexity (regarding the fact that applications are supposed to perform reasoning tasks on diverse clients) whilst corresponding to the needs of &#x201C;average&#x201D; Web applications (i.e. manipulating typed objects &#x2013; instances &#x2013; and inheriting their properties from classes). However, this set of rules can be extended: the reasoner similarly processes entailment and business rules, application developers can add entailment rules among business logics ones, without modifying the reasoner package itself. HyLAR also supports consistency checking in both IR and TB algorithms. Entailment rules involving disjointness, complementness or type checking can be provided as built-in rules using the &#x201D;false&#x201D; fact as consequence. HyLAR handles this fact as any other and uses TB maintenance approach to efficiently perform rule-based consistency checking. HyLAR runs on both server (Node.js<a class="fn" href="#fn9" id="foot-fn9"><sup>9</sup></a> 5.1.1) and client (Browserify<a class="fn" href="#fn10" id="foot-fn10"><sup>10</sup></a>) sides, which allows its integration into frameworks designed to optimize reasoning process location, such as&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0018">18</a>]. HyLAR benefits from JavaScript&#x0027;s asynchronous patterns (promises, callbacks), Web workers (on browsers) and event emitters (on Node.js), allowing for background task processing. It is composed of the modules depicted in Figure&#x00A0;<a class="fig" href="#fig1">1</a>. <figure id="fig1">     <img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191615/images/www18companion-354-fig1.jpg" class="img-responsive" alt="Figure 1"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 1:</span>      <span class="figure-title">HyLAR global architecture.</span>     </div>     </figure>    </p>    <ul class="list-no-style">     <li id="list7" label="&#x2022;"><strong>Controller:</strong> handles ontology loading (parsing and classification) and querying requests: inferences on INSERT and DELETE queries (using IR or tag-based algorithms) and filtered SELECT queries for tag-based reasoning.<br/></li>     <li id="list8" label="&#x2022;"><strong>Parsing Interface:</strong> integrates rdf-ext&#x0027;s RDF/XML parser and SPARQL.js<a class="fn" href="#fn11" id="foot-fn11"><sup>11</sup></a> library, and is able to convert triples (as described in RDF Interfaces 1.0<a class="fn" href="#fn12" id="foot-fn12"><sup>12</sup></a>) into turtle (for direct triplestore insertion/deletion) and facts (for reasoning).<br/></li>     <li id="list9" label="&#x2022;"><strong>Storage Manager:</strong> based on rdfstore.js<a class="fn" href="#fn13" id="foot-fn13"><sup>13</sup></a>&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0007">7</a>], this module handles ontology loading, updates and queries.<br/></li>     <li id="list10" label="&#x2022;"><strong>Reasoner:</strong> holds and processes rules using a pattern matching mechanism; its engine both includes an incremental and a tag-based algorithms.<br/></li>     <li id="list11" label="&#x2022;"><strong>Dictionary:</strong> indexes all triples registered in the store and their representations as facts in the KB; this accelerates validity checking at selection time.<br/></li>     <li id="list12" label="&#x2022;"><strong>Logics:</strong> contains first-order logic operations: fact instantiation, fact tagging, fact merging (<em>combine</em>()), and rule restriction (<em>restrictRuleSet</em>()).<br/></li>    </ul>   </section>   <section id="sec-12">    <header>     <div class="title-info">     <h2>      <span class="section-number">5</span> Evaluation</h2>     </div>    </header>    <p>We evaluate our tag-based algorithm by comparing it to Motik et al.&#x2019;s incremental reasoning (IR) algorithm based on DRed, described in the Delta-Reasoner&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0013">13</a>]. We chose to compare those algorithms on the same implementation rather than comparing them on different applicative solutions: our goal is not to provide the fastest reasoner, but rather to offer an optimal solution for maintaining datasets incrementally in Web browsers using JavaScript. We evaluate these algorithms for ontology classification and initial insertion, insertion of new triples, deletion, insertion of known triples and selection. The three latter represent Web applications cycles as illustrated in Section&#x00A0;<a class="sec" href="#sec-5">2</a>. We run each algorithm in Google Chrome v.54.0.2840.99, on a Lenovo Ideapad 700-15ISK (Intel Core i5-6300HQ @2.3GHz - 4GB RAM).</p>    <section id="sec-13">     <header>     <div class="title-info">      <h3>       <span class="section-number">5.1</span> Datasets and rules</h3>     </div>     </header>     <p>We generated 3 datasets (O1, O2 and O3) using the Lehigh University Benchmark (LUBM)&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0005">5</a>]. They are based on the Univ-Bench Ontology<a class="fn" href="#fn14" id="foot-fn14"><sup>14</sup></a> schema, which has <span class="inline-equation"><span class="tex">$\mathcal {ALEHI}+$</span>     </span> expressivity and contains 36 SubClassOf, 6 EquivalentClasses, 5 SubObjectPropertyOf, 1 TransitiveObjectProperty, 21 ObjectPropertyDomain, 18 ObjectPropertyRange and 4 DataPropertyDomain axioms, as well as 43 Class Assertions, 25 Object Property Assertions and 7 Data Property Assertions<a class="fn" href="#fn15" id="foot-fn15"><sup>15</sup></a>. O1, O2 and O3 contain respectively 8824, 7394, and 5759 triples, and correspond to the initial insertion. The evaluation uses the same rule sets as in Section&#x00A0;<a class="sec" href="#sec-11">4</a>.</p>    </section>    <section id="sec-14">     <header>     <div class="title-info">      <h3>       <span class="section-number">5.2</span> Practical evaluation</h3>     </div>     </header>     <p>We ran 5 evaluation tasks: classification and initial dataset insertion (CLASSIF+INIT), insertion, deletion, re-insertion and selection for both IR and TB algorithms<a class="fn" href="#fn16" id="foot-fn16"><sup>16</sup></a>. Inserted and deleted data have also been generated with LUBM and contain 500 triples. Each task applies the five rule sets described above. Our results are depicted in Figure&#x00A0;<a class="fig" href="#fig2">2</a>. Processing times for each task are written in milliseconds. This table also shows the time difference betweeen IR and TB (Diff.), as well as the <em>performance</em> of TB (Perf.), i.e. the percentage of time gained if using our solution instead of IR, for a particular task. The &#x201C;10 CYCLES&#x201D; column sums the results for (i) classification and initial insertion, (ii) insertion, and ten cycles of (iii) deletion and (iv) re-insertion. Such cycles correspond to applicative scenarios such as the one described in Section&#x00A0;<a class="sec" href="#sec-5">2</a>. <figure id="fig2">      <img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191615/images/www18companion-354-fig2.jpg" class="img-responsive" alt="Figure 2"       longdesc=""/>      <div class="figure-caption">       <span class="figure-number">Figure 2:</span>       <span class="figure-title">Evaluation results</span>      </div>     </figure>     </p>     <ul class="list-no-style">     <li id="uid37"><strong>Classification and initial insertion.</strong>As expected, TB maintenance does not outperform IR for these tasks, as it adds the cost of tagging facts. Although the number of rules and the size of the schema influence these results (e.g. O1 is more costly on TB as it is more expressive), RL profile reasoners do not target large classification tasks (an OWL-EL reasoner would probably be more suitable). Moreover, in Web applications, the classification and initial dataset insertion usually involve shared data and their results can therefore be computed on a server and cached for all clients. As tagging time is related to the number of triggered rules and their possible recursivity, its overhead is reduced for already closed datasets.<br/></li>     <li id="uid38"><strong>First insertion.</strong>Again, it takes longer for TB maintenance to perform a first insertion due to the additional tagging step. In this case, we can note that the instance number and the expressivity influences the results, as all facts - including instances - have to be tagged while firstly inserted in the ontology. Results show that this overhead varies according to the number of activated rules (<em>i.e.</em> the number and variety of OWL constructs).<br/></li>     <li id="uid39"><strong>Deletion.</strong>As expected, deletion is much (more than 50%) faster on TB maintenance, as IR over-deletion is replaced with a single iteration over the KB. Instance numbers significantly affect processing times in both algorithms.<br/></li>     <li id="uid40"><strong>Re-insertion.</strong>Re-inserting the same triples is also much faster on TB maintenance, as re-inserted triples do not have to be re-evaluated. TB performs particularly well with high expressivity (such as transitivity + inverse and equivalence rules). As in the deletion process, the number of instances is the most influential parameter.<br/></li>     <li id="uid41"><strong>Selection.</strong>Selections in IR are straightforward and give stable processing times. They are slower on TB maintenance as our algorithm checks the validity of each fact returned by the KB. With respect to IR, TB maintenance could then significantly impact SELECT queries with high numbers of triples or highly interrelated datasets. However, SELECT operations are much faster than the previous ones. Hence, despite its important value in percentage, this overhead sounds acceptable in terms of absolute times (about twenty milliseconds), as it only corresponds to a couple of frame rates of the most performant Web applications.<br/></li>     <li id="uid42"><strong>Multiple cycles.</strong>Here, we can see all the interest of our approach: the initial tagging cost at classification and first insertion is re-gained along deletions/re-insertion cycles. Due to space limitation, we only show figures for 10 cycles. However, for all situations in our evaluation, TB maintenance outperforms the given IR implementation from 4 cycles, and its gain in total computing time exceeds 50% for 100 cycles.<br/></li>     </ul>    </section>    <section id="sec-15">     <header>     <div class="title-info">      <h3>       <span class="section-number">5.3</span> Evaluation synthesis</h3>     </div>     </header>     <p>This evaluation shows that TB maintenance outperforms this implementation of the IR algorithm when data are being cyclicly deleted and reinserted into the reasoner, despite its cost on first insertions and selections. For applications going through hundreds of such cycles, TB maintenance can represent a massive performance improvement. This approach can particularly fit applications that rely on constantly changing data. For instance, context-aware applications that take adaptation decisions according to environmental (sensor) data can now integrate their own Web-based reasoner, process these data in Web clients and behave autonomously.</p>    </section>    <section id="sec-16">     <header>     <div class="title-info">      <h3>       <span class="section-number">5.4</span> Discussion</h3>     </div>     </header>     <p>Inserting a fact in a KB requires performing a transitive closure of the graph. The number of times a rule-based reasoner executes the rule evaluation loop depends on the data and on the expressivity of the used DL<a class="fn" href="#fn17" id="foot-fn17"><sup>17</sup></a>. As tag-based is a maintenance approach, it does not aim at reducing the whole reasoning process complexity, but at performing it as rarely as possible. Hence, it can be considered as &#x201C;storing&#x201D; the reasoning complexity in causes to avoid recomputing it at deletions and rederivations. However, our evaluations show that in a common use case, it keeps affordable. We then propose a method to ensure its cost stay limited. In order to limit both the number of causes and the inflation of the knowledge base size (which is higher in TB maintenance as explicit facts are not removed), we suggest to limit the number of explicit facts. Our underlying hypothesis is that our reasoner targets Web applications that can run on small devices such as smartphones. It is not intended for storing application history but to receive facts that will trigger rules at the application level. In our scenario, the phone GPS coordinates are raw numeric values. They are not inserted &#x201C;as is&#x201D; in the reasoner but are transformed into facts that fit the application requirements (the phone is located in the house neighborhood). In these conditions, client-side reasoning can save both Web application developers&#x2019; time while constructing their datasets (by using regular Semantic Web modeling tools), and bandwidth (by leaving saturation and decision processes up to the clients). Using a known set of explicit tags, TB reasoning allows application designers to first-insert and delete these facts at bootstrap or asynchronously, to pre-compute the tagging step and ensure performance at runtime.</p>    </section>   </section>   <section id="sec-17">    <header>     <div class="title-info">     <h2>      <span class="section-number">6</span> Related work</h2>     </div>    </header>    <section id="sec-18">     <header>     <div class="title-info">      <h3>       <span class="section-number">6.1</span> OWL profiles and Web reasoning</h3>     </div>     </header>     <p>OWL 2 profiles<a class="fn" href="#fn18" id="foot-fn18"><sup>18</sup></a> help adjusting the trade-off between expressivity and efficiency. Each profile (EL, QL, RL) has its own specificities and targets different reasoning tasks. Reasoning tasks differ in terms of data, query and taxonomic complexity&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0012">12</a>]. The choice of the appropriate OWL profile is crucial to reduce reasoning overheads, but not always sufficient as reasoners mostly rely on materialization (e.g. pre-compute and store inferences&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0014">14</a>]) which is computationally intensive. EL is suitable for very large TBoxes and would not fit Web applications such as the one we describe in Section&#x00A0;<a class="sec" href="#sec-5">2</a> as we expect their ABoxes to be heavier than their TBoxes. QL is appropriate for applications that manipulate high volumes of instances. It relies on query rewriting, which is not appropriate for Web applications that require fast query answering such as in our scenario. RL is more suitable, as it allows all axioms to be represented as logical implications and rules to be constructed as needed: to enable reasoning about OWL constructs, one can define both entailment rules corresponding to the expressive power expected for the application, and application-specific rules. RL reasoners can involve a large amount of explicit facts&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0011">11</a>], and inferences are pre-computed and explicitly stored, so that queries can be answered simply by querying the store&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0008">8</a>]. This makes this profile suitable Web applications that require flexibility and need fast query answering.</p>    </section>    <section id="sec-19">     <header>     <div class="title-info">      <h3>       <span class="section-number">6.2</span> Incremental reasoning in RL</h3>     </div>     </header>     <p>Web applications also need to handle numerous data updates. Reasoners embedded in those applications can then rely on IR&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0013">13</a>] to avoid entire recomputations. Several improvements of IR currently exist. The <em>fact-dependency tracking</em> from&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0004">4</a>] is similar to our <em>derivedFrom</em> tagging. However, unlike their solution, we track references of facts and provide improved query answering through validity checking in comparison to their query reformulation. The <em>counting</em> method&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0006">6</a>] also tracks alternative derivations for each fact but does not support recursive rules. However, even <em>counting</em> algorithms that support recursion such as in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0001">1</a>] do not reduce the re-insertion cost as alternative derivations are not explicitly stated but rather counted. Nowadays, most incremental maintenance algorithms are based on Gupta et al.&#x2019;s delete-rederive (DRed)&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0006">6</a>]. DRed improves performance as it ensures that the rules apply only to modified facts and thus prevents complete and successive recalculations of the KB on each update. The solution presented in&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0010">10</a>] relies on DRed for the classification task, but it exclusively targets <span class="inline-equation"><span class="tex">$\mathcal {EL+}$</span>     </span> ontologies with complex and changing TBoxes to tackle re-classification issues, which differs from our approach. In&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0015">15</a>], Motik et al. tackle the derivation redundancy issue encountered in the overdeletion step using a semi-naive materialization approach that combines backward and forward (BF) chaining. This improvement however still relies on rule matching and evaluation at deletion, whereas our solution avoids overdeletion and re-derivation. They implemented this approach in the RDFox triplestore&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0016">16</a>] that targets highly scalable applications. Yet, the HyLAR Reasoner is a JavaScript solution that targets Web browsers, which is currently not possible with RDFox. Hence, we did not compare those two reasoners. Nor did we compare BF with TB because the complex data structures used in BF (several rules bodies that would be duplicated into annotated queries) are not efficient in JavaScript (they actually perfom worse than regular IR). The Constraint Handling Rules&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"      href="#BibPLXBIB0003">3</a>] language also allows efficient rule-based reasoning and has been implemented in JavaScript. Unfortunately, it is not able to keep track of inferences, which prevents our fact-tagging approach to be used on this reasoner.</p>    </section>   </section>   <section id="sec-20">    <header>     <div class="title-info">     <h2>      <span class="section-number">7</span> Conclusion</h2>     </div>    </header>    <p>This paper addresses the issue of overdeleting and re-deriving facts in DRed Incremental Reasoning (IR). We propose a Tag-Based (TB) incremental maintenance approach that improves the DRed-based Incremental Reasoning (IR) overdeletion and re-derivation steps with three algorithms: implicit fact tagging, tag-based update and fact-filtering. The first two are executed to update the KB and the third to filter valid facts out of SELECT query results. Our approach targets Web applications that face multiple cycles of data deletions and reinsertions. Our complexity analysis shows that, to the initial cost of fact tagging at first insertion and validity assessment at selection, the complexity of re-insertion and deletion operations drops to linear, regardless of the reasoning conditions. Evaluation results show that the cost of TB maintenance is slightly higher for first insertions and for selections, but outperforms an implementation of IR at deletion and reinsertion. This cost is also re-gained within a few cycles.</p>    <p>In order to stimulate the adoption of semantic technologies in the Web community, it is implemented in the HyLAR reasoner, that proposes both IR and TB algorithms and is available as server-side (Node.js) or client-side (Bower) packages. HyLAR ships with a basic set of entailment rules that can be extended or reduced according to applications needs, and can be integrated with other tools, such as popular JavaScript frameworks, as well as our reasoning location adaptation framework&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0018">18</a>].</p>    <p>As future work, we will extend the set of built-in OWL rules and stream reasoning capabilities to deal with larger datasets, and explore pattern mining techniques to discretize frequent sets of causes to reduce the KB size. We also plan to provide SWRL support in the reasoner to easily integrate it with authoring tools, such as Prot&#x00E9;g&#x00E9;<a class="fn" href="#fn19" id="foot-fn19"><sup>19</sup></a>, to foster Semantic Web application adoption.</p>   </section>   <section id="sec-21">    <header>     <div class="title-info">     <h2>Acknowledgement</h2>     </div>    </header>    <p>This work is supported by the French ANR (Agence Nationale de la Recherche) under the grant number < ANR-13-INFR-012 > .</p>   </section>  </section>  <section class="back-matter">   <section id="ref-001">    <header>     <div class="title-info">     <h2 class="page-brake-head">REFERENCES</h2>     </div>    </header>    <ul class="bibUl">     <li id="BibPLXBIB0001" label="[1]">Hasanat&#x00A0;M Dewan, David Ohsie, Salvatore&#x00A0;J Stolfo, Ouri Wolfson, and Sushil Silva. 1992. Incremental database rule processing in PARADISER. <em>      <em>Journal of Intelligent Information Systems</em>     </em>1, 2 (1992), 177&#x2013;209.</li>     <li id="BibPLXBIB0002" label="[2]">Francesco&#x00A0;M Donini. 2003. Complexity of reasoning. In <em>      <em>The description logic handbook</em>     </em>. Cambridge University Press, 96&#x2013;136.</li>     <li id="BibPLXBIB0003" label="[3]">Thom Fr&#x00FC;hwirth. 2015. Constraint handling rules-what else?. In <em>      <em>International Symposium on Rules and Rule Markup Languages for the Semantic Web</em>     </em>. Springer, 13&#x2013;34.</li>     <li id="BibPLXBIB0004" label="[4]">Fran&#x00E7;ois Goasdou&#x00E9;, Ioana Manolescu, and Alexandra Roatis. 2013. Efficient query answering against dynamic RDF databases. In <em>      <em>Proceedings of the 16th International Conference on Extending Database Technology</em>     </em>. ACM, 299&#x2013;310.</li>     <li id="BibPLXBIB0005" label="[5]">Yuanbo Guo, Zhengxiang Pan, and Jeff Heflin. 2005. LUBM: A benchmark for OWL knowledge base systems. <em>      <em>Web Semantics: Science, Services and Agents on the World Wide Web</em>     </em>3, 2(2005), 158&#x2013;182.</li>     <li id="BibPLXBIB0006" label="[6]">Ashish Gupta, Inderpal&#x00A0;Singh Mumick, and Venkatramanan&#x00A0;Siva Subrahmanian. 1993. Maintaining views incrementally. <em>      <em>ACM SIGMOD Record</em>     </em>22, 2 (1993), 157&#x2013;166.</li>     <li id="BibPLXBIB0007" label="[7]">Antonio&#x00A0;Garrote Hern&#x00E1;ndez. [n. d.]. A JavaScript RDF store and application library for linked data client applications. <em>Citeseer</em>.</li>     <li id="BibPLXBIB0008" label="[8]">I Horrocks and PF Patel-Schneider. 2010. Knowledge Representation and Reasoning on the Semantic Web: OWL. (2010).</li>     <li id="BibPLXBIB0009" label="[9]">Ullrich Hustadt, Boris Motik, and Ulrike Sattler. 2005. Data complexity of reasoning in very expressive description logics. In <em>      <em>IJCAI</em>     </em>, Vol.&#x00A0;5. 466&#x2013;471.</li>     <li id="BibPLXBIB0010" label="[10]">Yevgeny Kazakov and Pavel Klinov. 2013. Incremental reasoning in OWL EL without bookkeeping. In <em>      <em>The Semantic Web&#x2013;ISWC 2013</em>     </em>. Springer, 232&#x2013;247.</li>     <li id="BibPLXBIB0011" label="[11]">Markus Kr&#x00F6;tzsch. 2012. <em>      <em>OWL 2 Profiles: An introduction to lightweight ontology languages</em>     </em>. Springer.</li>     <li id="BibPLXBIB0012" label="[12]">Boris Motik, Bernardo&#x00A0;Cuenca Grau, Ian Horrocks, Zhe Wu, Achille Fokoue, Carsten Lutz, <em>et al.</em> 2009. OWL 2 web ontology language: Profiles. <em>      <em>W3C recommendation</em>     </em>27(2009), 61. <a class="link-inline force-break" href="https://www.w3.org/TR/owl2-profiles/">https://www.w3.org/TR/owl2-profiles/</a></li>     <li id="BibPLXBIB0013" label="[13]">Boris Motik, Ian Horrocks, and Su&#x00A0;Myeon Kim. 2012. Delta-reasoner: a semantic web reasoner for an intelligent mobile platform. In <em>      <em>Proceedings of the 21st international conference companion on World Wide Web</em>     </em>. ACM, 63&#x2013;72.</li>     <li id="BibPLXBIB0014" label="[14]">Boris Motik, Yavor Nenov, Robert Piro, and Ian Horrocks. 2015. Combining rewriting and incremental materialisation maintenance for datalog programs with equality. <em>      <em>arXiv preprint arXiv:1505.00212</em>     </em>(2015).</li>     <li id="BibPLXBIB0015" label="[15]">Boris Motik, Yavor Nenov, Robert Piro, and Ian Horrocks. 2015. Incremental Update of Datalog Materialisation: the Backward/Forward Algorithm. In <em>      <em>Proc. AAAI</em>     </em>.</li>     <li id="BibPLXBIB0016" label="[16]">Yavor Nenov, Robert Piro, Boris Motik, Ian Horrocks, Zhe Wu, and Jay Banerjee. 2015. RDFox: A Highly-Scalable RDF Store. In <em>      <em>The Semantic Web - ISWC 2015</em>     </em>. Vol.&#x00A0;9367. Springer International Publishing, 3&#x2013;20.</li>     <li id="BibPLXBIB0017" label="[17]">Mehdi Terdjimi, Lionel M&#x00E9;dini, and Michael Mrissa. 2015. HyLAR: Hybrid Location-Agnostic Reasoning. In <em>      <em>ESWC Developers Workshop 2015</em>     </em>. 1.</li>     <li id="BibPLXBIB0018" label="[18]">Mehdi Terdjimi, Lionel M&#x00E9;dini, and Michael Mrissa. 2016. HyLAR+: Improving Hybrid Location-Agnostic Reasoning with Incremental Rule-based Update. In <em>      <em>WWW&#x2019;16: 25th International World Wide Web Conference Companion</em>     </em>.</li>     <li id="BibPLXBIB0019" label="[19]">Ruben Verborgh, Miel&#x00A0;Vander Sande, Pieter Colpaert, Sam Coppens, Erik Mannens, and Rik&#x00A0;Van de Walle. 2014. Web-Scale Querying through Linked Data Fragments. In <em>      <em>LDOW</em>     </em>(<em>CEUR Workshop Proceedings</em>), Vol.&#x00A0;1184. CEUR-WS.org.</li>    </ul>   </section>  </section>  <section id="foot-001" class="footnote">   <header>    <div class="title-info">     <h2>FOOTNOTE</h2>    </div>   </header>   <p id="fn1"><a href="#foot-fn1"><sup>1</sup></a>To avoid recursion while assessing implicit fact validity, algorithm&#x00A0;2 (see below) only stores explicit facts in causes.</p>   <p id="fn2"><a href="#foot-fn2"><sup>2</sup></a>These implicit facts have been inferred from prior evaluation loops; hence their derivedFrom tag is already set and stricly composed of explicit facts.</p>   <p id="fn3"><a href="#foot-fn3"><sup>3</sup></a>For instance, if <em>f<sub>i</sub>    </em> can be caused by both <em>f</em>    <sub>     <em>e</em>1</sub>&#x2227;<em>f</em>    <sub>     <em>e</em>2</sub> and <em>f</em>    <sub>     <em>e</em>1</sub>&#x2227;<em>f</em>    <sub>     <em>e</em>2</sub>&#x2227;<em>f</em>    <sub>     <em>e</em>3</sub>, only the former conjunction is stored as a cause.</p>   <p id="fn4"><a href="#foot-fn4"><sup>4</sup></a>For the sake of understandability, the algorithm comprises an <em>hasTag</em>() function to filter explicit from implicit facts. This function is not implemented in practice.</p>   <p id="fn5"><a href="#foot-fn5"><sup>5</sup></a><a class="link-inline force-break" href="http://pellet.owldl.com/">http://pellet.owldl.com/</a>   </p>   <p id="fn6"><a href="#foot-fn6"><sup>6</sup></a><a class="link-inline force-break" href="https://www.cs.ox.ac.uk/isg/tools/RDFox/">https://www.cs.ox.ac.uk/isg/tools/RDFox/</a>   </p>   <p id="fn7"><a href="#foot-fn7"><sup>7</sup></a><a class="link-inline force-break" href="http://chrjs.net/">http://chrjs.net/</a></p>   <p id="fn8"><a href="#foot-fn8"><sup>8</sup></a><a class="link-inline force-break" href="https://www.npmjs.com/package/hylar">https://www.npmjs.com/package/hylar</a>   </p>   <p id="fn9"><a href="#foot-fn9"><sup>9</sup></a><a class="link-inline force-break" href="https://nodejs.org">https://nodejs.org</a></p>   <p id="fn10"><a href="#foot-fn10"><sup>10</sup></a><a class="link-inline force-break" href="http://browserify.org/">http://browserify.org/</a></p>   <p id="fn11"><a href="#foot-fn11"><sup>11</sup></a><a class="link-inline force-break" href="https://github.com/RubenVerborgh/SPARQL.js">https://github.com/RubenVerborgh/SPARQL.js</a></p>   <p id="fn12"><a href="#foot-fn12"><sup>12</sup></a><a class="link-inline force-break"     href="http://www.w3.org/TR/rdf-interfaces/#triples">http://www.w3.org/TR/rdf-interfaces/#triples</a>   </p>   <p id="fn13"><a href="#foot-fn13"><sup>13</sup></a>Rdfstore.js is a graph store implementation with support for SPARQL 1.0 and 1.1/Update. Available at <a class="link-inline force-break" href="https://github.com/antoniogarrote/rdfstore-js">https://github.com/antoniogarrote/rdfstore-js</a></p>   <p id="fn14"><a href="#foot-fn14"><sup>14</sup></a><a class="link-inline force-break"     href="http://swat.cse.lehigh.edu/onto/univ-bench.owl">http://swat.cse.lehigh.edu/onto/univ-bench.owl</a>   </p>   <p id="fn15"><a href="#foot-fn15"><sup>15</sup></a>Metrics provided by Prot&#x00E9;g&#x00E9; 5.0.0 - <a class="link-inline force-break" href="http://protege.stanford.edu/">http://protege.stanford.edu/</a>   </p>   <p id="fn16"><a href="#foot-fn16"><sup>16</sup></a>The TB fact forgetting algorithm that prevents KB inflation is not evaluated, as it is performed asynchronously during idle time.</p>   <p id="fn17"><a href="#foot-fn17"><sup>17</sup></a>It is said to be EXPTIME-complete in |<em>KB</em>| with <span class="inline-equation"><span class="tex">$\mathcal {SHIQ}$</span>    </span> [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0009">9</a>], and even untractable with other DLs&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0002">2</a>] for tasks such as satisfiability or subsumption.</p>   <p id="fn18"><a href="#foot-fn18"><sup>18</sup></a><a class="link-inline force-break" href="http://www.w3.org/TR/owl2-profiles/">http://www.w3.org/TR/owl2-profiles/</a>   </p>   <p id="fn19"><a href="#foot-fn19"><sup>19</sup></a><a class="link-inline force-break" href="http://protege.stanford.edu/">http://protege.stanford.edu/</a>   </p>   <div class="bibStrip">    <p>This paper is published under the Creative Commons Attribution 4.0 International (CC BY&#x00A0;4.0) license. Authors reserve their rights to disseminate the work on their personal and corporate Web sites with the appropriate attribution. In case of republication, reuse, etc., the following attribution should be used: &#x201C;Published in WWW2018 Proceedings &#x00A9; 2018 International World Wide Web Conference Committee, published under Creative Commons CC BY 4.0 License.&#x201D;</p>    <p>     <em>WWW '18 Companion, April 23-27, 2018, Lyon, France</em>    </p>    <p>&#x00A9; 2018; IW3C2 (International World Wide Web Conference Committee), published under Creative Commons CC BY&#x00A0;4.0 License.<br/>ACM ISBN 978-1-4503-5640-4/18/04.<br/>DOI: <a class="link-inline force-break" target="_blank"     href="https://doi.org/10.1145/3184558.3191615">https://doi.org/10.1145/3184558.3191615</a>    </p>   </div>  </section>  <div class="pubHistory">   <p/>  </div>  </body> </html> 
