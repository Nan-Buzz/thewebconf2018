<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta name="generator" content=
  "HTML Tidy for HTML5 for Linux version 5.7.16" />
  <title>A Formal Semantics of the Core DOM in Isabelle/HOL</title>
  <!-- Copyright (c) 2010-2015 The MathJax Consortium -->
  <meta http-equiv="Content-Type" content=
  "text/html; charset=utf-8" />
  <meta name="viewport" content=
  "width=device-width; initial-scale=1.0;" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="screen, print" rel="stylesheet" href=
  "../../../data/dl.acm.org/pubs/lib/css/bootstrap.min.css" />
  <link media="screen, print" rel="stylesheet" href=
  "../../../data/dl.acm.org/pubs/lib/css/bootstrap-theme.min.css" />
  <link media="screen, print" rel="stylesheet" href=
  "../../../data/dl.acm.org/pubs/lib/css/main.css" />
  <script src="../../../data/dl.acm.org/pubs/lib/js/jquery.min.js" type=
  "text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/bootstrap.min.js"
  type="text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/bibCit.js" type=
  "text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/divTab.js" type=
  "text/javascript"></script>
  <script type="text/javascript" src=
  "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>
  <script type="text/x-mathjax-config">
  <![CDATA[
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  ]]>
  </script>
</head>
<body id="main">
<div>
<p style='font-size: 75%; color #444'>
This is a HTML copy of <a href='https://doi.org/10.1145/3184558.3185980'>https://doi.org/10.1145/3184558.3185980</a> 
originally published by ACM, 
redistributed under the terms of 
<a href='https://creativecommons.org/licenses/by/4.0/'>Creative Commons Attribution 4.0 (CC BY 4.0)</a>.
The <a href='https://github.com/usable-oa/thewebconf2018/tree/master/scripts'>modifications</a> 
from the original are solely to improve HTML accessability, compatibility, 
augmenting HTML metadata and avoiding ACM trademark.
To reference this HTML version, use:
</p><p>
<strong>Permalink:</strong>
<a href='https://w3id.org/oa/10.1145/3184558.3185980'>https://w3id.org/oa/10.1145/3184558.3185980</a>
</p></div>
<hr>


  <section class="front-matter">
    <section>
      <header class="title-info">
        <div class="journal-title">
          <h1><span class="title">A Formal Semantics of the Core
          DOM in Isabelle/HOL</span><br />
          <span class="subTitle"></span></h1>
        </div>
      </header>
      <div class="authorGroup">
        <div class="author">
          <a href="https://orcid.org/0000-0002-6355-1200" ref=
          "author"><span class="givenName">Achim D.</span>
          <span class="surName">Brucker</span></a>, Department of
          Computer Science, The University of Sheffield, Sheffield,
          UK, <a href=
          "mailto:a.brucker@sheffield.ac.uk">a.brucker@sheffield.ac.uk</a>
        </div>
        <div class="author">
          <span class="givenName">Michael</span> <span class=
          "surName">Herzberg</span>, Department of Computer
          Science, The University of Sheffield, Sheffield, UK,
          <a href=
          "mailto:msherzberg1@sheffield.ac.uk">msherzberg1@sheffield.ac.uk</a>
        </div>
      </div><br />
      <div class="pubInfo">
        <p>DOI: <a href="https://doi.org/10.1145/3184558.3185980"
        target=
        "_blank">https://doi.org/10.1145/3184558.3185980</a><br />
        WWW '18: <a href="https://doi.org/10.1145/3184558" target=
        "_blank">Proceedings of The Web Conference 2018</a>, Lyon,
        France, April 2018</p>
      </div>
      <div class="abstract">
        <p><small>At its core, the Document Object Model (DOM)
        defines a tree-like data structure for representing
        documents in general and HTML documents in particular. It
        is the heart of any modern web browser.</small></p>
        <p><small>Formalizing the key concepts of the DOM is a
        prerequisite for the formal reasoning over client-side
        JavaScript programs and for the analysis of security
        concepts in modern web browsers.</small></p>
        <p><small>We present a formalization of the core DOM, with
        focus on the <em>node-tree</em> and the operations defined
        on node-trees, in Isabelle/HOL. We use the formalization to
        verify the functional correctness of the most important
        functions defined in the DOM standard. Moreover, our
        formalization is (1) <em>extensible</em>, i.e., can be
        extended without the need of re-proving already proven
        properties and (2) <em>executable</em>, i.e., we can
        generate executable code from our
        specification.</small></p>
      </div>
      <div class="CCSconcepts">
        <p><small><span style="font-weight:bold;">CCS
        Concepts:</span> • <strong>Information systems</strong> →
        <strong>Markup languages;</strong> Document structure; •
        <strong>Software and its engineering</strong> →
        <strong>Software verification;</strong>
        <strong>Semantics;</strong> <em>Formal software
        verification;</em></small></p>
      </div>
      <div class="classifications">
        <div class="author">
          <span style=
          "font-weight:bold;"><small>Keywords:</small></span>
          <span class="keyword"><small>Document Object Model; DOM;
          Formal Semantics; Isabelle/HOL</small></span>
        </div><br />
        <div class="AcmReferenceFormat">
          <p><small><span style="font-weight:bold;">ACM Reference
          Format:</span><br />
          Achim D. Brucker and Michael Herzberg. 2018. A Formal
          Semantics of the Core DOM in Isabelle/HOL. In <em>WWW '18
          Companion: The 2018 Web Conference Companion,</em>
          <em>April 23–27, 2018,</em> <em>Lyon, France. ACM, New
          York, NY, USA</em> 9 Pages. <a href=
          "https://doi.org/10.1145/3184558.3185980" class=
          "link-inline force-break" target=
          "_blank">https://doi.org/10.1145/3184558.3185980</a></small></p>
        </div>
      </div>
    </section>
  </section>
  <section class="body">
    <section id="sec-3">
      <header>
        <div class="title-info">
          <h2><span class="section-number">1</span>
          Introduction</h2>
        </div>
      </header>
      <p>In a world in which more and more applications are offered
      as services on the internet, web browsers start to take on a
      similarly central role in our daily IT infrastructure as
      operating systems. Thus, web browsers should be developed as
      rigidly and formally as operating systems. While formal
      methods are a well-established technique in the development
      of operating systems (see, e.&nbsp;g.,&nbsp;Klein [<a class=
      "bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0015">15</a>] for an
      overview), there are few proposals for improving the
      development of web browsers using formal
      approaches&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0002">2</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0009">9</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0012">12</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0017">17</a>].</p>
      <p>As a first step towards a verified client-side web
      application stack, we model and formally verify the Document
      Object Model (DOM) in Isabelle/HOL. The DOM&nbsp;[<a class=
      "bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0021">21</a>, <a class=
      "bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0023">23</a>] is
      <em>the</em> central data structure of all modern web
      browsers. At its core, the Document Object Model (DOM)
      defines a tree-like data structure for representing documents
      in general and HTML documents in particular. Thus, the
      correctness of a DOM implementation is crucial for ensuring
      that a web browser displays web pages correctly. Moreover,
      the DOM is the core data structure underlying client-side
      JavaScript programs, i.&nbsp;e., client-side JavaScript
      programs are mostly programs that read, write, and update the
      DOM.</p>
      <p>In more detail, we formalize the core DOM as a shallow
      embedding&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0014">14</a>] in Isabelle/HOL. Our formalization
      is based on a typed data model for the <em>node-tree</em>,
      i.&nbsp;e., a data structure for representing XML-like
      documents in a tree structure. Furthermore, we formalize a
      typed heap for storing (partial) node-trees together with the
      necessary consistency constraints. Finally, we formalize the
      operations (as described in the DOM standard&nbsp;[<a class=
      "bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0023">23</a>]) on this
      heap that allow manipulating node-trees.</p>
      <p>Our machine-checked formalization of the DOM node
      tree&nbsp;[<a class="bib" data-trigger="hover" data-toggle=
      "popover" data-placement="top" href="#BibPLXBIB0023">23</a>]
      has the following desirable properties:</p>
      <ol class="list-no-style">
        <li id="list1" label="(1)">It provides a <em>consistency
        guarantee.</em> Since all definitions in our formal
        semantics are conservative and all rules are derived, the
        logical consistency of the DOM node-tree is reduced to the
        consistency of HOL.<br /></li>
        <li id="list2" label="(2)">It serves as a <em>technical
        basis for a proof system.</em> Based on the derived rules
        and specific setup of proof tactics over node-trees, our
        formalization provides a generic proof environment for the
        verification of programs manipulating
        node-trees.<br /></li>
        <li id="list3" label="(3)">It is <em>executable</em>, which
        allows to validate its compliance to the standard by
        evaluating the compliance test suite on the formal model
        and<br /></li>
        <li id="list4" label="(4)">It is <em>extensible</em> in the
        sense of&nbsp;[<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0005">5</a>], i.&nbsp;e., properties proven over
        the core DOM do not need to be re-proven for
        object-oriented extensions such as the HTML document
        model.<br />
        </li>
      </ol>
      <p>Finally, we show the correctness of the functions for
      manipulating the DOM w.r.t. the assumptions made in the
      standard.</p>
      <p>After introducing Isabelle and higher-order logic in Sect.
      2, we introduce the formal data model of the DOM and
      operations over the DOM in Sect. 3. In Sect. 4, we formalize
      the requirements for a valid heap, followed by the discussion
      of the verification of important properties of DOM operations
      in Sect. 5. Finally, we discuss related work (Sect. 6) and
      draw conclusions (Sect. 7).</p>
    </section>
    <section id="sec-4">
      <header>
        <div class="title-info">
          <h2><span class="section-number">2</span> Formal and
          Technical Background</h2>
        </div>
      </header>
      <p>In this section, we will outline the underlying logical
      and methodological framework of our formalization of the DOM
      node-tree.</p>
      <section id="sec-5">
        <header>
          <div class="title-info">
            <h3><span class="section-number">2.1</span>
            Higher-Order Logic and Isabelle</h3>
          </div>
        </header>
        <p>Isabelle&nbsp;[<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0016">16</a>] is a generic theorem prover
        implemented in the functional programming language SML.
        Isabelle/HOL is the instance of Isabelle supporting
        Higher-order logic (HOL)&nbsp;[<a class="bib" data-trigger=
        "hover" data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0001">1</a>, <a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0008">8</a>]. It supports conservativity checks
        of definitions, datatypes, primitive and well-founded
        recursion, and powerful generic proof engines based on
        rewriting and tableau provers.</p>
        <p>HOL is a classical logic with equality enriched with
        total polymorphic higher-order functions. HOL is strongly
        typed, i.e., each expression <tt>e</tt> has a type
        <tt>'a</tt>, written <tt>e::'a</tt>. In Isabelle, we denote
        type variables with a prime (e.&nbsp;g., <tt>'a</tt>)
        instead of Greek letters (e.&nbsp;g., <em>α</em>) that are
        usually used in textbooks. The type constructor for the
        function space is written using infix notation: <tt>'a
        <span class="tex">$\Rightarrow$</span> 'b</tt>. HOL is
        centered around the extensional logical equality <tt>_ =
        _</tt> with type <tt>'a <span class=
        "tex">$\Rightarrow$</span> 'a <span class=
        "tex">$\Rightarrow$</span> bool</tt>, where <tt>bool</tt>
        is the fundamental logical type.</p>
        <p>Functions in HOL are curried and pure, i.e., they take
        exactly one argument, return exactly one result, and cannot
        produce side-effects. To simulate functions with more than
        one argument, we let these functions again return a
        function, until it will finally return a non-function.
        Therefore, when reading curried function definitions, it
        can be helpful to interpret the chain of function
        definitions in the following way: the last type definition
        represents the “return value“ of the function, whereas the
        other types in the chain represent arguments to the
        function. When modeling stateful functions, such as in our
        case, we usually define functions that take an argument
        that represents the state and return an updated version
        (i.e., a map that contains an additional entry) that
        represents the state change.</p>
        <p>The type discipline rules out paradoxes such as Russel's
        paradox in untyped set theory. Sets of type <tt>'a Set</tt>
        can be defined isomorphic to functions of type <tt>'a
        <span class="tex">$\Rightarrow$</span> bool</tt>; the
        element-of-relation <tt>_ <span class="tex">$\in$</span>
        _</tt> has the type <tt>'a <span class=
        "tex">$\Rightarrow$</span> 'a set <span class=
        "tex">$\Rightarrow$</span> bool</tt> and corresponds
        basically to the function application; the set
        comprehension <tt>{_ . _}</tt> (usually written
        <span class="inline-equation"><span class="tex">$\lbrace
        \_\mid \_\rbrace$</span></span> in textbooks) has type
        <tt>'a set <span class="tex">$\Rightarrow$</span> ('a
        <span class="tex">$\Rightarrow$</span> bool) <span class=
        "tex">$\Rightarrow$</span> 'a set</tt> and corresponds to
        the <tt><span class=
        "tex">$\lambda$</span></tt>-abstraction.</p>
        <p>Isabelle/HOL allows for defining abstract datatypes. For
        example, the following statement introduces the option
        type:</p>
        <p><img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-graphic3.jpg"
        class="img-responsive" alt="" longdesc="" /></p>
        <p>Besides the <em>constructors</em> <tt>None</tt> and
        <tt>Some</tt>, there is the match-operation <tt>case x of
        None <span class="tex">$\Rightarrow$</span> F | Some a
        <span class="tex">$\Rightarrow$</span> G a</tt>. The option
        type allows us to represent <em>partial functions</em>
        (often <em>called maps</em>) as total functions of type
        <tt>'a <span class="tex">$\Rightarrow$</span> 'b
        option</tt>. For this type, we introduce the short-hand
        <tt>'a <span class="tex">$\rightharpoonup$</span> 'b</tt>.
        We define <tt>dom f</tt>, called the <em>domain</em> of a
        partial function <tt>f</tt>, by the set of all arguments of
        <tt>f</tt> that do not yield <tt>None</tt>.</p>
        <p>We also make use of the sum type, <tt>'a + 'b</tt>, and
        the product type, <tt>'a <span class="tex">$\times$</span>
        'b</tt>. With the sum type, it is possible to express
        tuples, which, for example, can be used to achieve a
        similar result to returning a tuple from a function. The
        product type represents either <tt>'a</tt> or <tt>'b</tt>,
        and is useful to model errors, as it allows to let
        functions return either some result on a successful
        calculation, or return an error.</p>
        <p>When extending logics, two approaches can be
        distinguished: the <em>axiomatic method</em> on the one
        hand and <em>conservative extensions</em> on the other.
        Extending the HOL core via axioms, i.e., introducing new,
        <em>unproven</em> laws seems to be the easier approach but
        it usually leads easily to inconsistency; given the fact
        that in any major theorem proving system the core theories
        and libraries contain several thousand theorems and lemmas,
        the axiomatic approach is worthless in practice. In
        contrast, a conservative extension introduces new constants
        (via <em>constant definitions</em>) and types (<em>type
        definitions</em>) only via a particular schema of axioms;
        the (meta-level) proof that axioms of this schema preserve
        consistency can be found in&nbsp;[<a class="bib"
        data-trigger="hover" data-toggle="popover" data-placement=
        "top" href="#BibPLXBIB0010">10</a>].</p>
      </section>
      <section id="sec-6">
        <header>
          <div class="title-info">
            <h3><span class="section-number">2.2</span> Shallow
            Embeddings vs. Deep Embeddings</h3>
          </div>
        </header>
        <p>We are now concerned with the question <em>how</em> a
        language is represented in a logic. Two techniques are
        distinguished: First, <em>deep embeddings</em> represent
        the abstract syntax as a datatype and define a semantic
        function <em>I</em> from syntax to semantics. Second,
        <em>shallow embeddings</em> define the semantics directly;
        each construct is represented by some function on a
        semantic domain.</p>
        <p>Assume we want to embed a simple logical language BOOL,
        consisting of the two logical operators <span class=
        "inline-equation"><span class="tex">$\_
        \operatorname{\mathsf {and}}\_$</span></span> and
        <span class="inline-equation"><span class="tex">$\_
        \operatorname{\mathsf {or}}\_$</span></span> , into HOL.
        The semantics <em>I</em>: <em>expr</em> → <em>env</em> →
        <em>bool</em> is a function that maps BOOL expressions and
        environments to <em>bool</em>, where
        <em>environmentsenv</em> = <em>var</em> → <em>bool</em>
        maps variables to <em>bool</em> values. Using a shallow
        embedding, we define directly:</p>
        <div class="table-responsive">
          <div class="display-equation">
            <span class="tex mytex">\begin{equation*} x
            \operatorname{\mathsf {and}}y \equiv \mathop {\lambda
            }e \bullet x~e \wedge y~e \qquad x
            \operatorname{\mathsf {or}}y \equiv \mathop {\lambda }e
            \bullet x~e \vee y~e\end{equation*}</span><br />
          </div>
        </div>Shallow embeddings allow for direct definitions in
        terms of semantic domains and operations on them. In a deep
        embedding, we have to define the syntax of BOOL as a
        recursive datatype:
        <div class="table-responsive">
          <div class="display-equation">
            <span class="tex mytex">\begin{equation*} \mathit
            {expr} = \textsf {var}~\mathit
            {var}\hspace{5.0pt}|\hspace{5.0pt}\mathit
            {expr}~\textsf {and}~\mathit
            {expr}\hspace{5.0pt}|\hspace{5.0pt}\mathit
            {expr}~\textsf {or}~\mathit
            {expr}\end{equation*}</span><br />
          </div>
        </div>and the explicit semantic function <em>I</em>:
        <div class="table-responsive">
          <div class="display-equation">
            <span class="tex mytex">\begin{eqnarray*} I[[ \textsf
            {var}~x]] &amp;=&amp; \mathop {\lambda }e\bullet
            e(x)\\I[[ x \operatorname{\mathsf {and}}y]] &amp;=&amp;
            \mathop {\lambda }e\bullet I[[ x]] ~e \wedge I[[ y]]
            ~e\\I[[ x \operatorname{\mathsf {or}}y]] &amp;=&amp;
            \mathop {\lambda }e\bullet I[[ x]] ~e \vee I[[ y]]
            ~e\end{eqnarray*}</span><br />
          </div>
        </div>This example reveals the main drawback of deep
        embeddings: the language is more distant to the underlying
        meta language HOL, i.e. semantic functions represent
        obstacles for deduction. However; for analyzing certain
        meta-theoretic analysis, deep-embeddings have advantages.
        Since we are interested in a concise semantic description
        of the DOM and efficient proof support (and we are not
        interested in meta-theoretic proofs), we chose a shallow
        embedding.
        <p></p>
      </section>
    </section>
    <section id="sec-7">
      <header>
        <div class="title-info">
          <h2><span class="section-number">3</span> Formalizing the
          DOM</h2>
        </div>
      </header>
      <p>In this section, we will present our formalization of the
      core DOM which follows the WHATWG
      specification&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0023">23</a>], the updated version of the W3C DOM
      4 standard&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0021">21</a>]. This includes the definition of the
      tree-like data structure for representing documents and a set
      of functions for creating and modifying a document.</p>
      <section id="sec-8">
        <header>
          <div class="title-info">
            <h3><span class="section-number">3.1</span> The Core
            DOM Data Model: The Node-Tree</h3>
          </div>
        </header>
        <p>The main purpose of the DOM is to provide the data
        structure for managing tree-structured documents,
        e.&nbsp;g., following the HTML or XML standard. Fig.
        <a class="fig" href="#fig1">1</a> illustrates a small
        example: Fig. <a class="fig" href="#fig1">1</a>a shows the
        textual representation of a simple document (using HTML as
        syntax), Fig. <a class="fig" href="#fig1">1</a>b shows the
        visualization of the DOM <em>node-tree</em>, and Fig.
        <a class="fig" href="#fig1">1</a>c shows the rendered
        output (e.&nbsp;g., in a web browser).</p>
        <figure id="fig1">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-fig1.jpg"
          class="img-responsive" alt="Fig. 1" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Fig. 1:</span> <span class=
            "figure-title">A simple example of a DOM: (a) shows a
            textual representation using HTML syntax, (b) a
            visualization of the node-tree of the DOM, and (c)
            shows the result of rendering this DOM, e.g., by a
            rendering engine of a web browser.</span>
          </div>
        </figure>
        <p>As the DOM models a tree-like data structure, it is not
        a surprise that the core datatypes of the DOM
        specifications are <tt>Document</tt> and the datatype
        <tt>Node</tt> with the two specializations <tt>Element</tt>
        and <tt>CharacterData</tt>. In our data model, we omitted
        attributes that can computed from others, e.g., the
        <tt>parent</tt> attribute which represent the inverse
        relation already represented by the <tt>childNodes</tt> and
        <tt>documentElement</tt> attributes.</p>
        <p>While the core idea of formalizing object-oriented data
        models in an extensible way<a class="fn" href="#fn1" id=
        "foot-fn1"><sup>1</sup></a> follows the construction
        presented in&nbsp;[<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0003">3</a>, <a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0005">5</a>], we differ significantly in aspects
        such as the modeling of typed pointers (references) and
        late binding of method invocations. Due to space
        constraints, we will not discuss this in this paper.</p>
        <p>First, we start by defining abstract datatypes for typed
        pointers for the common super-class <tt>Object</tt> and the
        classes <tt>Node</tt>, <tt>Element</tt>,
        <tt>CharacterData</tt>, and <tt>Document</tt>:</p>
        <p><img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-graphic5.jpg"
        class="img-responsive" alt="" longdesc="" /></p>
        <p>The pointers to the abstract classes <tt>object_ptr</tt>
        and <tt>node_ptr</tt> only support a constructor for
        extensions; regular classes also have a constructor for the
        reference of the object itself. We use these datatypes to
        introduce type synonyms representing the actual pointer
        types for our DOM model (see Fig. <a class="fig" href=
        "#fig2">2</a>).</p>
        <figure id="fig2">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-fig2.jpg"
          class="img-responsive" alt="Fig. 2" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Fig. 2:</span> <span class=
            "figure-title">The HOL types of our extensible, typed
            pointers for the core DOM. The type polynomials ensure
            that pointers for sub-classes in the object-oriented
            data model are instances of the HOL type of the pointer
            of their super-class.</span>
          </div>
        </figure>
        <p></p>
        <p>The type polynomials are constructed in such a way that
        the HOL types for pointers of sub-classes in the
        object-oriented model are instances of the HOL type of
        their super-class. This is the key construction allowing an
        extensible formalization. For details, we are referring the
        reader to [<a class="bib" data-trigger="hover" data-toggle=
        "popover" data-placement="top" href=
        "#BibPLXBIB0005">5</a>].</p>
        <p>In the rest of this paper, we will use an underscore to
        denote the tuple of type variables of the type constructors
        for pointer and object types. For example, we will write
        <tt>_ node_ptr<sub>Core_DOM</sub></tt> instead of</p>
        <p><img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-graphic7.jpg"
        class="img-responsive" alt="" longdesc="" /></p>
        <p>and assume that type variables of the same name are
        instantiated with the same types.</p>
        <p>Second, we define HOL types representing objects using
        the record-package provided in Isabelle. Overall, we use
        the same construction of type polynomials to represent
        inheritance in HOL. Due to space reasons, we omit the
        technical details of the type construction. We refer
        interested readers to the Isabelle
        formalization&nbsp;[<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0004">4</a>]. For each class, we define one
        record:</p>
        <p><img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-graphic8.jpg"
        class="img-responsive" alt="" longdesc="" /></p>
        <p>Due to technical constraints of the record package, we
        need to introduce an attribute <tt>nothing</tt> for classes
        that do not define at least one attribute themselves. Given
        these definitions, we can, e.g., define a
        <tt>CharacterData</tt> object as follows:</p>
        <p><img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-graphic9.jpg"
        class="img-responsive" alt="" longdesc="" /></p>
        <p>Essentially, this models an object-oriented data model
        of a tree-like data structure, called <em>node-tree</em> in
        the DOM standard, where</p>
        <ol class="list-no-style">
          <li id="list5" label="(1)">the root of the tree is an
          instance of <tt>Document</tt>,<br /></li>
          <li id="list6" label="(2)">instances of the class
          <tt>Element</tt> can be internal nodes or leaves,
          and<br /></li>
          <li id="list7" label="(3)">instances of the class
          <tt>CharacterData</tt> can only appear as
          leaves.<br /></li>
        </ol>
        <p>Finally, we define a heap for storing node-trees, i.e.,
        instances of our DOM data model. A DOM heap is a map from
        object pointers to objects:</p>
        <p><img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-graphic10.jpg"
        class="img-responsive" alt="" longdesc="" /></p>
        <p>Where <tt>_ Object<sub>Core_DOM</sub></tt> is the type
        synonym for the instantiated super-type of object (similar
        to the construction for pointers).</p>
        <p>Fig. <a class="fig" href="#fig3">3</a> illustrates how
        the simple document from our example in Fig. <a class="fig"
        href="#fig1">1</a> can be expressed in our formal DOM
        heap.</p>
        <figure id="fig3">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-fig3.jpg"
          class="img-responsive" alt="Fig. 3" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Fig. 3:</span> <span class=
            "figure-title">The formal representation of a heap
            containing our simple example DOM (recall Fig.
            <a class="fig" href="#fig1">1</a>).</span>
          </div>
        </figure>
        <p></p>
      </section>
      <section id="sec-9">
        <header>
          <div class="title-info">
            <h3><span class="section-number">3.2</span> Operations
            and Queries on Node-Trees</h3>
          </div>
        </header>
        <p>In the following, we will define the core DOM methods
        for creating, querying, and modifying the node-trees that
        are stored in a DOM heap. We define the following functions
        formally in Isabelle/HOL. Fig. <a class="fig" href=
        "#fig4">4</a> provides an overview of their formal type
        signatures.</p>
        <figure id="fig4">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-fig4.jpg"
          class="img-responsive" alt="Fig. 4" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Fig. 4:</span> <span class=
            "figure-title">The formal type signatures of the
            methods for creating, querying, and modifying the core
            DOM.</span>
          </div>
        </figure>
        <p>All operations are defined over the DOM heap, i.e., they
        take a heap as input and return either an exception or a
        tuple containing the return value and a new heap:</p>
        <p><img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-graphic12.jpg"
        class="img-responsive" alt="" longdesc="" /></p>
        <p>All operations result in an exception if an argument is
        invalid, e.&nbsp;g., a pointer that does not represent a
        valid object in the current heap. We use a heap and error
        monad for modeling exceptions. This allows us to define
        composite methods similar to stateful programming in
        Haskell, but also to stay close to the official
        specification.</p>
        <p>The function <tt>create_element</tt> takes an
        (owner)document and the tag name of the new element. It
        returns the updated heap that includes the new element with
        no children and no attributes along with a reference to the
        new element, which is stored in the first free location in
        the heap. This ensures that it will not change any existing
        locations in the heap, which we will prove later.
        Additionally, the new element is added to the list of
        disconnected nodes of the given document, as it is not yet
        part of the node tree.</p>
        <p>The function <tt>get_child_nodes</tt> takes a heap and a
        pointer to a node and returns a list of pointers to its
        children. For elements, it returns the children list that
        is stored in the datatype. For text nodes, it returns the
        empty list. For documents, we convert their document
        element into the appropriate node list.</p>
        <p>The function <tt>get_attribute</tt> looks up the given
        attribute in the element's attribute map. It returns
        <tt>Some attr</tt> if there exists an attribute with the
        given key, and <tt>None</tt> otherwise. The official
        specification also has a concept called “reflected content
        attribute,” which basically returns the stored attribute of
        the same name, but returns the empty string if the
        attribute is not present.</p>
        <p>The function <tt>set_attribute</tt> updates the given
        attribute of the pointer in the heap. In the official
        specification, it is not allowed to set the attribute to
        <tt>None</tt> or null, respectively, to delete the
        attribute. We generalize this definition by allowing
        this.</p>
        <p>The function <tt>get_parent_node</tt> takes a pointer to
        a node and returns a pointer to its parent, or
        <tt>None</tt>, if the node does not have a parent. The case
        where a node does not have a parent can only occur in
        <em>disconnected</em> node-trees, which we will discuss
        later. Our API does not accept <tt>document</tt>s, since
        they can never have a parent. Having the types as narrow as
        possible will enable easier proofs. The function
        <tt>get_parent_node</tt> is an example of a method where
        the official specification leaves much room for
        interpretation regarding the implementation. It neither
        provides an algorithm explaining to how obtain a parent,
        given a node, nor does it specify that the parent reference
        should be stored in the objects. To avoid specifying
        additional consistency constraints that would be needed if
        both children and parent references were to be stored, we
        implemented <tt>get_parent_node</tt> by searching the whole
        heap for any node whose <tt>get_child_nodes</tt> contains
        the given reference.</p>
        <p>The function <tt>remove_child</tt> is rather close to
        the official specification; if <tt>child</tt>’s
        <tt>parent</tt> is different from the passed parent, then
        we “throw” a <tt>NotFoundError</tt>. Otherwise, we add the
        removed child to the disconnected node list of its owner
        document and remove it from either the
        <tt>document_element</tt> or the <tt>child_nodes</tt>
        attribute.</p>
        <p>The function <tt>get_element_by_id</tt> searches in tree
        order (depth-first, left-to-right) for the first element
        with the given id. Our definition is more general than the
        official specification, as we dropped the requirement that
        <tt>get_element_by_id</tt> should only be available on
        documents, which is a legacy requirement.</p>
        <section id="sec-10">
          <p><em>3.2.1 Adopting Nodes.</em> The method
          <tt>adopt_node</tt> removes a node from its previous
          parent, if it had any, and assigns it to the new
          <tt>ownerDocument</tt>. First, it tries to retrieve the
          parent of the node to be adopted. If the node has a
          parent node, it removes the node from the children list,
          otherwise it removes it from the list of disconnected
          nodes of the previous owner document. Finally, the node
          is now added to the disconnected nodes of the new
          document.</p>
          <p><img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-graphic14.jpg"
          class="img-responsive" alt="" longdesc="" /></p>
        </section>
        <section id="sec-11">
          <p><em>3.2.2 Inserting Nodes.</em> Using
          <tt>insert_before</tt>, one can insert arbitrary nodes
          (i.e., not necessarily in the same node-tree) from the
          heap into a node-tree:</p>
          <p><img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-graphic15.jpg"
          class="img-responsive" alt="" longdesc="" /></p>
          <p>A node that should be inserted needs to fulfill
          certain well-formedness criteria. This is checked using
          the <tt>ensure_preinsertion_validity</tt> function which
          formalizes the concept of <em>pre-insertion validity</em>
          from the DOM standard. Then, the reference child needs to
          be determined, which is that node before which the
          to-be-inserted node should be placed. Then, we adopt the
          node into the (possibly new) node-tree and actually
          insert the node into either the <tt>child_nodes</tt> or
          <tt>document_element</tt> attributes.</p>
        </section>
      </section>
    </section>
    <section id="sec-12">
      <header>
        <div class="title-info">
          <h2><span class="section-number">4</span> Well-Formedness
          of the DOM Heap</h2>
        </div>
      </header>
      <p>Our DOM heap is a map from object pointer to object. While
      a map alone would allow numerous “illegal” heaps, two
      features of our formalization already rule out many
      misconfigurations: Our data model is typed and, thus, rules
      out illegal heaps such as one that contains a document that
      contains a character data object as its only child.
      Additionally, our data model omits some fields of the
      standard, such as <tt>parentNode</tt>, which we calculate by
      using the heap and <tt>get_child_nodes</tt>.</p>
      <p>Still, some possible illegal heap configurations remain,
      such as one with a cyclic <tt>get_child_nodes</tt>
      relationship. Thus, we need further well-formedness
      constraints and we need to show that the DOM methods preserve
      the well-formedness. We will now introduce predicates that
      validate whether a given heap conforms to the standard.</p>
      <section id="sec-13">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.1</span> The Owner
            Document</h3>
          </div>
        </header>
        <p>The DOM specifications requires that each node is owned
        by exactly one document, its owner document. Moreover, each
        node participates in a tree w.r.t. the
        <tt>get_child_nodes</tt>-relation. A DOM might—and usually
        will—consist of several trees, i.e., a DOM is a forest of
        trees. We call the tree that has the main document as root
        the <em>visible document</em>, as this is the part of the
        DOM that would be rendered, e.&nbsp;g., by a web
        browser.</p>
        <figure id="fig5">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-fig5.jpg"
          class="img-responsive" alt="Fig. 5" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Fig. 5:</span> <span class=
            "figure-title">DOM with a visible document (gray) and a
            runtime tree (white).</span>
          </div>
        </figure>
        <p></p>
        <p>Fig. <a class="fig" href="#fig5">5</a> illustrates this
        relationship for an example: the gray nodes (connected by
        solid arrows that visualize the
        <tt>get_child_nodes</tt>-relation) represent the visible
        document. The white nodes (connected by dotted arrows that
        visualize the <tt>get_owner_document</tt> relationship) are
        forming a temporary <em>runtime tree</em>. Runtime trees
        are not serialized (e.&nbsp;g., in an HTML or XML document)
        and only exist at runtime.</p>
        <p>We define <tt>get_owner_document</tt> of a node to be
        the root, if the root is an document; otherwise, we return
        that document whose <tt>disconnected_nodes</tt> contains
        said node. In order for this definition to be well-formed,
        we need the following predicate:</p>
        <p><img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-graphic17.jpg"
        class="img-responsive" alt="" longdesc="" /></p>
        <p>This predicate guarantees us that the set of nodes in
        all <tt>disconnected_nodes</tt> fields is exactly the set
        of nodes that do not have a document as their root.</p>
      </section>
      <section id="sec-14">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.2</span> Restricting
            DOMs to Trees</h3>
          </div>
        </header>
        <p>So far, we do not restrict the relation given by
        <tt>get_child_nodes</tt> to be <em>acyclic</em>, which is
        possible since we use pointers. To prevent this, we can use
        the following predicate:</p>
        <p><img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-graphic18.jpg"
        class="img-responsive" alt="" longdesc="" /></p>
        <p>We leverage the definition of acyclicity on relations,
        i.e., a set of tuples. Our relation contains all pointers
        <tt>parent</tt> and <tt>child</tt> where <tt>child</tt> is
        in the set of children of <tt>parent</tt>.</p>
      </section>
      <section id="sec-15">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.3</span> Node
            Sharing</h3>
          </div>
        </header>
        <p>The DOM standard assumes that a node cannot be the child
        of more than one node. This property of heaps is informally
        implied by the official standard, and all tree-modifying
        methods ensure that such a DOM cannot be built. We,
        however, must deal with all heaps that conform to our heap
        type. Therefore, in addition to our heap predicate that
        guarantees us that all trees in our heap are acyclic, we
        need a predicate that prevents the nodes from having more
        than one parent. Therefore, we formally define another heap
        predicate:</p>
        <p><img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-graphic19.jpg"
        class="img-responsive" alt="" longdesc="" /></p>
        <p>The definition checks whether for any node, the set of
        possible parents (i.e., pointers whose children contains
        said node), contains exactly zero or one parents.</p>
      </section>
      <section id="sec-16">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.4</span> Pointer
            Validity</h3>
          </div>
        </header>
        <p>Moreover, we need to ensure that objects do not contain
        invalid pointers (e.&nbsp;g., pointers that do not point to
        an object stored in the heap of the same type). Otherwise,
        whenever we work with our pointers, we would have to deal
        with the possibility of a “null-pointer exception”. Thus,
        we require:</p>
        <p><img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-graphic20.jpg"
        class="img-responsive" alt="" longdesc="" /></p>
        <p>The only place where we can find pointers (without
        arbitrarily constructing them, which should be avoided) is
        in one of the datatype fields. Therefore, for all pointers
        in the heap, we retrieve the corresponding object, and
        check whether all pointers stored in applicable fields
        (<tt>childNodes</tt>, <tt>document_element</tt>, and
        <tt>disconnected_nodes</tt>) are present in the heap.</p>
      </section>
      <section id="sec-17">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.5</span> Heaps are
            Strongly Typed</h3>
          </div>
        </header>
        <p>As we model typed pointers and objects, we want to
        assure that a pointer of a certain type actually maps to an
        object of the related type in a given heap, e.&nbsp;g.,
        that a <tt>document_ptr</tt> actually maps to a document.
        The following predicate assures us that this holds for the
        whole heap:</p>
        <p><img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-graphic21.jpg"
        class="img-responsive" alt="" longdesc="" /></p>
        <p>Similarly to document, the definition also contains
        checks for the other classes, which we omitted here due to
        space constraints. The definition checks whether for all,
        e.g., document pointers, the heap actually returns and
        object for which <tt>is_document_kind</tt> holds.</p>
      </section>
      <section id="sec-18">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.6</span> No
            Multi-Edges</h3>
          </div>
        </header>
        <p>The <tt>childNodes</tt> and <tt>disconnected_nodes</tt>
        attributes are of type list. Thus, they may contain
        duplicates, i.e., the same pointer multiple times. This can
        lead to strange effects, such as that after
        <tt>remove_child</tt> has been called, the pointer still is
        in the list. This behavior is not addressed by the official
        specification. We make this requirement explicit:</p>
        <p><img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-graphic22.jpg"
        class="img-responsive" alt="" longdesc="" /></p>
        <p>We retrieve the lists for every pointer in the heap and
        require that they are distinct. In Sect. 5.2, we will show
        a formal proof of the fact that <tt>insert_node</tt>
        actually can never lead to a <tt>childNodes</tt> list with
        duplicates.</p>
      </section>
      <section id="sec-19">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.7</span> Well-Formed
            Heaps</h3>
          </div>
        </header>
        <p>To put it all together, we define a well-formed heap as
        a heap that satisfies all discussed constraints:</p>
        <p><img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-graphic23.jpg"
        class="img-responsive" alt="" longdesc="" /></p>
      </section>
    </section>
    <section id="sec-20">
      <header>
        <div class="title-info">
          <h2><span class="section-number">5</span> Reasoning Over
          the DOM</h2>
        </div>
      </header>
      <p>So far we only defined the DOM data structure, a heap for
      storing DOM instances, and methods over them. We now discuss
      the verification of these methods in the sense of formally
      proving that they preserve the well-formedness of the
      heap.</p>
      <section id="sec-21">
        <header>
          <div class="title-info">
            <h3><span class="section-number">5.1</span> Properties
            of DOM Methods</h3>
          </div>
        </header>
        <section id="sec-22">
          <p><em>5.1.1 Well-formedness of the Heap Methods.</em>
          The DOM methods (see Sect. 3.2 and Table <a class="tab"
          href="#tab1">1</a>) can be divided into two categories:
          All query functions (starting with the prefix
          <tt>get_</tt>) use the heap to compute a value, but do
          not modify the heap. It is therefore easy to show that
          they preserve the well-formedness of the heap. For all
          other function, we have to formally prove their
          correctness w.r.t. preserving the well-formedness of the
          heap. If all methods preserve the well-formedness then we
          have shown that any exception-free sequence of DOM
          methods creates a well-formed DOM heap.</p>
          <div class="table-responsive" id="tab1">
            <div class="table-caption">
              <span class="table-number">Table 1:</span>
              <span class="table-title">Well-formedness properties
              of core heap methods.</span>
            </div>
            <table class="table">
              <tbody>
                <tr>
                  <td style="text-align:left;"></td>
                  <td style="text-align:center;">side-effect</td>
                  <td style="text-align:center;">modifies</td>
                  <td style="text-align:center;">preserves</td>
                </tr>
                <tr>
                  <td style="text-align:left;"></td>
                  <td style="text-align:center;">free</td>
                  <td style="text-align:center;">only</td>
                  <td style="text-align:center;">
                  well-formedness</td>
                </tr>
                <tr>
                  <td style="text-align:left;">2-4
                  <tt>get_child_nodes</tt></td>
                  <td style="text-align:center;"><span class=
                  "inline-equation"><span class=
                  "tex">$\checkmark$</span></span></td>
                  <td style="text-align:center;"></td>
                  <td style="text-align:center;"></td>
                </tr>
                <tr>
                  <td style="text-align:left;">
                  <tt>get_parent_node</tt></td>
                  <td style="text-align:center;"><span class=
                  "inline-equation"><span class=
                  "tex">$\checkmark$</span></span></td>
                  <td style="text-align:center;"></td>
                  <td style="text-align:center;"></td>
                </tr>
                <tr>
                  <td style="text-align:left;">
                  <tt>get_element_by_id</tt></td>
                  <td style="text-align:center;"><span class=
                  "inline-equation"><span class=
                  "tex">$\checkmark$</span></span></td>
                  <td style="text-align:center;"></td>
                  <td style="text-align:center;"></td>
                </tr>
                <tr>
                  <td style="text-align:left;">
                  <tt>get_attribute</tt></td>
                  <td style="text-align:center;"><span class=
                  "inline-equation"><span class=
                  "tex">$\checkmark$</span></span></td>
                  <td style="text-align:center;"></td>
                  <td style="text-align:center;"></td>
                </tr>
                <tr>
                  <td style="text-align:left;">
                  <tt>create_element</tt></td>
                  <td style="text-align:center;"></td>
                  <td style="text-align:center;"><span class=
                  "inline-equation"><span class=
                  "tex">$\checkmark$</span></span></td>
                  <td style="text-align:center;"><span class=
                  "inline-equation"><span class=
                  "tex">$\checkmark$</span></span></td>
                </tr>
                <tr>
                  <td style="text-align:left;">
                  <tt>set_attribute</tt></td>
                  <td style="text-align:center;"></td>
                  <td style="text-align:center;"><span class=
                  "inline-equation"><span class=
                  "tex">$\checkmark$</span></span></td>
                  <td style="text-align:center;"><span class=
                  "inline-equation"><span class=
                  "tex">$\checkmark$</span></span></td>
                </tr>
                <tr>
                  <td style="text-align:left;">
                  <tt>remove_child</tt></td>
                  <td style="text-align:center;"></td>
                  <td style="text-align:center;"><span class=
                  "inline-equation"><span class=
                  "tex">$\checkmark$</span></span></td>
                  <td style="text-align:center;"><span class=
                  "inline-equation"><span class=
                  "tex">$\checkmark$</span></span></td>
                </tr>
                <tr>
                  <td style="text-align:left;">
                  <tt>adopt_node</tt></td>
                  <td style="text-align:center;"></td>
                  <td style="text-align:center;"><span class=
                  "inline-equation"><span class=
                  "tex">$\checkmark$</span></span></td>
                  <td style="text-align:center;"><span class=
                  "inline-equation"><span class=
                  "tex">$\checkmark$</span></span></td>
                </tr>
                <tr>
                  <td style="text-align:left;">
                  <tt>insert_before</tt></td>
                  <td style="text-align:center;"></td>
                  <td style="text-align:center;"><span class=
                  "inline-equation"><span class=
                  "tex">$\checkmark$</span></span></td>
                  <td style="text-align:center;"><span class=
                  "inline-equation"><span class=
                  "tex">$\checkmark$</span></span></td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>For all methods, we need to prove a lemma of this
          form:</p>
          <p><img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-graphic24.jpg"
          class="img-responsive" alt="" longdesc="" /></p>
          <p>All variables in lemmas are all-quantified, meaning
          they can take all possible values of the corresponding
          type, only restricted by the statements in the
          assumption. As the predicate <tt>heap_is_wellformed</tt>
          is a conjunction of more specific predicates (e.&nbsp;g.,
          <tt>acyclic_heap</tt>), we can split the proof for these
          lemmas into separate proofs that the methods are
          preserving those more specific conditions. We will
          discuss such a proof in more detail at the end of this
          section. Due to space limitations we will omit most
          proofs, for which we refer the reader to our full
          formalization.</p>
        </section>
        <section id="sec-23">
          <p><em>5.1.2 Heap Modifications are Local.</em> We want
          to ensure that heap-modifying functions do not modify the
          heap <em>arbitrarily</em>. Thus, we first introduce two
          predicates that characterize a function by specifying
          which locations (pointers) and fields are being read or
          written, respectively:</p>
          <p><img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-graphic25.jpg"
          class="img-responsive" alt="" longdesc="" /></p>
          <p>Both predicates take a set of pointers and predicates
          that assert something about the specified heap location
          in both the old and new heap. This will be, for example,
          a predicate checking whether the <tt>attributes</tt>
          field of <tt>Element</tt> will have the same value in
          both heaps. The <tt>writes</tt> predicate is
          characterized by these getter predicates that remain
          unaffected, which is why it references a set
          <tt>S<sub>g</sub></tt>, which contains all such getter
          predicates for the getters of our classes. For example,
          for the <tt>get_attribute</tt> and <tt>set_attribute</tt>
          DOM methods we prove the following:</p>
          <p><img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-graphic26.jpg"
          class="img-responsive" alt="" longdesc="" /></p>
        </section>
        <section id="sec-24">
          <p><em>5.1.3 Exceptions.</em> All our functions can throw
          exceptions, i.&nbsp;e., they return a sum type of
          <tt>exception</tt> and their real return type, which is a
          common way to model exceptions in functional languages.
          Therefore, we can provide lemmas that show under which
          preconditions our functions will return their normal
          result and not throw an exception. Most functions will
          throw an exception under exactly one circumstance: if
          they try to resolve a pointer on the given heap, but the
          heap does not have an object of the same type stored in
          that location, i.&nbsp;e., the lookup returns
          <tt>None</tt>. This is not surprising, since most
          functions will need to do something with the object, and
          not just the pointer to the object. For example, we
          show:</p>
          <p><img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-graphic27.jpg"
          class="img-responsive" alt="" longdesc="" /></p>
        </section>
      </section>
      <section id="sec-25">
        <header>
          <div class="title-info">
            <h3><span class="section-number">5.2</span> Proving
            Properties Over DOM Methods</h3>
          </div>
        </header>
        <p>Our DOM model allows us to prove properties of our
        specified DOM methods over arbitrary heaps. In proofs, the
        general line of arguing will usually utilize the fact that
        heap-modifying methods consist of a series of heap updates
        in single locations, whose proven properties we can
        utilize. We will show one example of such a proof to
        demonstrate how one can work with the formalization.</p>
        <p>For example, we can prove that using
        <tt>insert_before</tt> does certainly never lead to
        duplicates in the node's children list, even if a pointer
        is being inserted that is already in this node's children.
        We express this property in our formalization as
        follows:</p>
        <p><img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-graphic28.jpg"
        class="img-responsive" alt="" longdesc="" /></p>
        <p>We first assume that we start with a wellformed heap.
        The next two assumptions guarantee us that <tt>ptr</tt> and
        the parent, if any, of <tt>new_child</tt> are of a known
        type — so either a <tt>element_ptr</tt>,
        <tt>character_data_ptr</tt>, or <tt>document_ptr</tt>.
        These two assumptions are necessary to prove something
        about one of our late-bound functions,
        <tt>get_child_nodes</tt> and <tt>set_child_nodes</tt>,
        later. The last assumption introduces <tt>h2</tt> as the
        heap after an application of <tt>insert_before</tt>.</p>
        <p>The conclusion is to be read as follows: After the use
        of <tt>insert_before</tt> (<tt>h2</tt>), all lists of
        children of all known pointers will be distinct. Fig.
        <a class="fig" href="#fig9">9</a> shows a formal proof
        sketch (i.e., a simplified excerpt of a formal proof using
        Isabelle's proof language Isar&nbsp;[<a class="bib"
        data-trigger="hover" data-toggle="popover" data-placement=
        "top" href="#BibPLXBIB0022">22</a>]).</p>
        <figure id="fig6">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-fig6.jpg"
          class="img-responsive" alt="Fig. 6" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Fig. 6:</span> <span class=
            "figure-title">The method <tt>adopt_node</tt> removes
            the node that is to be adopted (proof in formalization
            document).</span>
          </div>
        </figure>
        <figure id="fig7">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-fig7.jpg"
          class="img-responsive" alt="Fig. 7" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Fig. 7:</span> <span class=
            "figure-title">After using <tt>adopt_node</tt>, all
            children lists remain distinct (proof in formalization
            document).</span>
          </div>
        </figure>
        <figure id="fig8">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-fig8.jpg"
          class="img-responsive" alt="Fig. 8" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Fig. 8:</span> <span class=
            "figure-title">After using <tt>insert_node</tt>, all
            children lists remain distinct if the child is not
            already in the children list into which it will be
            inserted (proof in formalization document).</span>
          </div>
        </figure>
        <figure id="fig9">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3185980/images/www18companion-41-fig9.jpg"
          class="img-responsive" alt="Fig. 9" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Fig. 9:</span> <span class=
            "figure-title">A formal proof that
            <tt>insert_before</tt> preserves the distinctness of
            the child nodes list.</span>
          </div>
        </figure>
        <p></p>
        <section id="sec-26">
          <p><em>5.2.1 Proof Structure.</em> Recall the definition
          of <tt>insert_before</tt> in Sect. 3.2, which consists of
          two heap-modifying functions: <tt>adopt_node</tt>, which
          removes the new child from its old parent and updates the
          owner document, and <tt>insert_node</tt>, which appends
          the new child to the actual children list. The proof is
          therefore structured as follows:</p>
          <p>First, we unroll the definition of
          <tt>insert_before</tt> to get a handle to the individual
          statements. Additionally, we obtain <tt>h'</tt>, which is
          the intermediate heap in between <tt>adopt_node</tt> and
          <tt>insert_node</tt>.</p>
          <p>Second, we prove that after <tt>adopt_node</tt>, in
          addition to all children lists still being distinct (we
          only remove one child from one list), the child will not
          be part of any of these (as it has been removed from the
          only children list that contained it). For this proof, we
          can use two properties of <tt>adopt_node</tt> that we
          proved earlier, <tt>adopt_node_removes_child</tt> (Fig.
          <a class="fig" href="#fig6">6</a>) and
          <tt>adopt_node_children_remain_distinct</tt> (Fig.
          <a class="fig" href="#fig7">7</a>).</p>
          <p>Third, since we know that before the use of
          <tt>insert_node</tt> all children lists are distinct and
          do not contain the node that is to be inserted, we can
          prove that all children list will remain distinct, as we
          only insert the given node and nothing else. Again, for
          this proof, we can use a property that we have already
          proven about <tt>insert_node</tt>,
          <tt>insert_node_children_remain_distinct</tt> (Fig.
          <a class="fig" href="#fig8">8</a>).</p>
        </section>
      </section>
    </section>
    <section id="sec-27">
      <header>
        <div class="title-info">
          <h2><span class="section-number">6</span> Related
          Work</h2>
        </div>
      </header>
      <p>To our knowledge, there are only very few formalizations
      of data structures for manipulating XML-like document
      structures available. Sternagel and Thiemann [<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0019">19</a>] present an “XML library”
      for Isabelle/HOL. The purpose of this library is to provide
      XML parsing and pretty printing facilities for Isabelle. As
      such, it is not a formalization of XML or XML-like data
      structures in Isabelle/HOL.</p>
      <p>Our DOM typed formalization shares several design decision
      with the type-safe DOM API of Thiemann [<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0020">20</a>]. The most closely related
      works are [<a class="bib" data-trigger="hover" data-toggle=
      "popover" data-placement="top" href="#BibPLXBIB0009">9</a>,
      <a class="bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0017">17</a>, <a class=
      "bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0018">18</a>] in which
      the authors present a non-executable, non-extensible, and
      non-mechanized operational semantics of a minimal DOM and
      show how this semantics can be used for Hoare-style reasoning
      for analyzing heaps of DOMs. The authors focus on providing a
      formal foundation for reasoning over client-side JavaScript
      programs that modify the DOM.</p>
      <p>A more informal model of the DOM that focuses on the needs
      of building a static analysis tool for client-side JavaScript
      programs is presented by Jensen et&nbsp;al. [<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0013">13</a>]. This model does not
      focus on the DOM as such, instead the authors focus on the
      representation of HTML documents on top of the DOM.</p>
      <p>Finally, there are several works, e.&nbsp;g., [<a class=
      "bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0002">2</a>, <a class=
      "bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0011">11</a>, <a class=
      "bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0012">12</a>] on
      formalizing parts of web browsers for analyzing their
      security. These works use high-level specifications of web
      browsers and do not contain a formalization of the DOM
      itself.</p>
    </section>
    <section id="sec-28">
      <header>
        <div class="title-info">
          <h2><span class="section-number">7</span> Conclusion and
          Future Work</h2>
        </div>
      </header>
      <p>We presented a typed formalization of the Document Object
      Model (DOM) in Isabelle/HOL. Technically, our formalization
      is an executable shallow embedding of the official
      specification of the WHATWG&nbsp;[<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0023">23</a>] and the W3C.</p>
      <p>We see several lines of future work. We consider
      tightening the link between the formal specification and the
      actual implementations used by various web browsers as the
      most important line of future work. One promising approach to
      achieve this goal is the systematic generation of test cases
      from the formal specification using test case generation
      techniques hat are integrated into
      Isabelle/HOL&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0006">6</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0007">7</a>]. The generated test cases can, as the
      already existing manually developed test cases, be used for
      validating the compliance of actual browser
      implementation.</p>
      <p>Furthermore, there are two promising areas w.r.t.
      extending the scope of our formalization: first, formalizing
      and analyzing the “DOM with Shadow Roots,” i.&nbsp;e., the
      new component model proposed as part of the DOM standard of
      the WHATWG&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0023">23</a>]. Second, using the extensibility of
      our formalization to add support for <tt>HTMLElement</tt>
      (and its sub-types such as <tt>HTMLIFrameElement</tt>). As
      the concept of iframes is fundamental for restricting
      information flow between parts of a website originating from
      different security domains, such a formalization would allow
      us to reason over web security properties in
      Isabelle/HOL.</p>
      <section id="sec-29">
        <section id="sec-30">
          <header>
            <div class="title-info">
              <h4><strong><em>Availability.</em></strong></h4>
            </div>
          </header>
          <p>The formalization is available under a 2-clause BSD
          license in the Archive of Formal Proofs&nbsp;[<a class=
          "bib" data-trigger="hover" data-toggle="popover"
          data-placement="top" href="#BibPLXBIB0004">4</a>]. A copy
          is also available at <a class="link-inline force-break"
          href=
          "https://git.logicalhacking.com/afp-mirror/Core_DOM">https://git.logicalhacking.com/afp-mirror/Core_DOM</a>.</p>
        </section>
      </section>
    </section>
  </section>
  <section class="back-matter">
    <section id="ref-001">
      <header>
        <div class="title-info">
          <h2 class="page-brake-head">REFERENCES</h2>
        </div>
      </header>
      <ul class="bibUl">
        <li id="BibPLXBIB0001" label="[1]">Peter&nbsp;B. Andrews.
        2002. <em><em>Introduction to Mathematical Logic and Type
        Theory: To Truth through Proof</em></em>. Kluwer Academic
        Publishers.</li>
        <li id="BibPLXBIB0002" label="[2]">Aaron Bohannon and
        Benjamin&nbsp;C. Pierce. 2010. Featherweight Firefox:
        Formalizing the Core of a Web Browser. In <em><em>Usenix
        Conference on Web Application Development
        (WebApps).</em></em></li>
        <li id="BibPLXBIB0003" label="[3]">Achim&nbsp;D. Brucker.
        2007. <em>An Interactive Proof Environment for
        Object-oriented Specifications</em>. Ph.D. Dissertation.
        ETH Zurich. ETH Dissertation No. 17097.</li>
        <li id="BibPLXBIB0004" label="[4]">Achim&nbsp;D. Brucker
        and Michael Herzberg. 2018. <em><em>Archive of Formal
        Proofs</em></em> (2018). <a class="link-inline force-break"
          href=
          "http://www.isa-afp.org/entries/Core_DOM.shtml">http://www.isa-afp.org/entries/Core_DOM.shtml</a>,
          Formal proof development. Submitted.
        </li>
        <li id="BibPLXBIB0005" label="[5]">Achim&nbsp;D. Brucker
        and Burkhart Wolff. 2008. An Extensible Encoding of
        Object-oriented Data Models in HOL. <em><em>Journal of
        Automated Reasoning</em></em> 41 (2008), 219–249. Issue 3.
        <a class="link-inline force-break" href=
        "https://doi.org/10.1007/s10817-008-9108-3" target=
        "_blank">https://doi.org/10.1007/s10817-008-9108-3</a>
        </li>
        <li id="BibPLXBIB0006" label="[6]">Achim&nbsp;D. Brucker
        and Burkhart Wolff. 2009. HOL-TestGen: An Interactive
        Test-case Generation Framework. In <em><em>Fundamental
        Approaches to Software Engineering,</em></em> Marsha
        Chechik and Martin Wirsing (Eds.). Number 5503 in
        <em>LNCS</em>. Springer-Verlag, 417–420. <a class=
        "link-inline force-break" href=
        "https://doi.org/10.1007/978-3-642-00593-0_28" target=
        "_blank">https://doi.org/10.1007/978-3-642-00593-0_28</a>
        </li>
        <li id="BibPLXBIB0007" label="[7]">Achim&nbsp;D. Brucker
        and Burkhart Wolff. 2013. On Theorem Prover-based Testing.
        <em><em>Formal Aspects of Computing (FAC)</em></em> 25, 5
        (2013), 683–721. <a class="link-inline force-break" href=
        "https://doi.org/10.1007/s00165-012-0222-y" target=
        "_blank">https://doi.org/10.1007/s00165-012-0222-y</a>
        </li>
        <li id="BibPLXBIB0008" label="[8]">Alonzo Church. 1940. A
        formulation of the simple theory of types. <em><em>Journal
        of Symbolic Logic</em></em> 5, 2 (June 1940), 56–68.</li>
        <li id="BibPLXBIB0009" label="[9]">Philippa Gardner, Gareth
        Smith, Mark&nbsp;J. Wheelhouse, and Uri Zarfaty. 2008. DOM:
        Towards a Formal Specification. In <em><em>Programming
        Language Technologies for XML.</em></em></li>
        <li id="BibPLXBIB0010" label="[10]">Mike J.&nbsp;C. Gordon
        and Tom&nbsp;F. Melham. 1993. <em><em>Introduction to HOL:
        a theorem proving environment for higher order
        logic.</em></em> Cambridge University Press.</li>
        <li id="BibPLXBIB0011" label="[11]">Arjun Guha, Matthew
        Fredrikson, Benjamin Livshits, and Nikhil Swam. 2011.
        Verified Security for Browser Extensions. In <em><em>IEEE
        Symposium on Security and Privacy.</em></em> 115–130.
        <a class="link-inline force-break" href=
        "https://doi.org/10.1109/SP.2011.36" target=
        "_blank">https://doi.org/10.1109/SP.2011.36</a>
        </li>
        <li id="BibPLXBIB0012" label="[12]">Dongseok Jang, Zachary
        Tatlock, and Sorin Lerner. 2012. Establishing Browser
        Security Guarantees through Formal Shim Verification. In
        <em><em>USENIX Security Symposium,</em></em> Tadayoshi
        Kohno (Ed.). USENIX Association, 113–128.</li>
        <li id="BibPLXBIB0013" label="[13]">Simon&nbsp;Holm Jensen,
        Magnus Madsen, and Anders Møller. 2011. Modeling the HTML
        DOM and Browser API in Static Analysis of JavaScript Web
        Applications. In <em><em>ACM SIGSOFT Symposium and European
        Conference on Foundations of Software Engineering
        (ESEC/FSE).</em></em> ACM, New York, NY, USA, 59–69.
        <a class="link-inline force-break" href=
        "https://doi.org/10.1145/2025113.2025125" target="_blank">
          https://doi.org/10.1145/2025113.2025125</a>
        </li>
        <li id="BibPLXBIB0014" label="[14]">Jeffrey&nbsp;J. Joyce
        and Carl-Johan&nbsp;H. Seger (Eds.). 1994. <em><em>Higher
        Order Logic Theorem Proving and Its Applications
        (HUG).</em></em> <em>LNCS</em>, Vol.&nbsp;780.
        Springer-Verlag, Heidelberg. <a class=
        "link-inline force-break" href=
        "https://doi.org/10.1007/3-540-57826-9" target=
        "_blank">https://doi.org/10.1007/3-540-57826-9</a>
        </li>
        <li id="BibPLXBIB0015" label="[15]">Gerwin Klein. 2009.
        Operating System Verification — An Overview.
        <em><em>Sādhanā</em></em> 34, 1 (Feb. 2009), 27–69.</li>
        <li id="BibPLXBIB0016" label="[16]">Tobias Nipkow,
        Lawrence&nbsp;C. Paulson, and Markus Wenzel. 2002. <em><em>
          Isabelle/HOL—A Proof Assistant for Higher-Order
          Logic.</em></em> <em>LNCS</em>, Vol.&nbsp;2283.
          Springer-Verlag, Heidelberg. <a class=
          "link-inline force-break" href=
          "https://doi.org/10.1007/3-540-45949-9" target=
          "_blank">https://doi.org/10.1007/3-540-45949-9</a>
        </li>
        <li id="BibPLXBIB0017" label="[17]">Azalea Raad,
        José&nbsp;Fragoso Santos, and Philippa Gardner. 2016. DOM:
        Specification and Client Reasoning. In <em><em>Programming
        Languages and Systems</em></em> (<em>LNCS</em>), Atsushi
        Igarashi (Ed.). Vol.&nbsp;10017. 401–422. <a class=
        "link-inline force-break" href=
        "https://doi.org/10.1007/978-3-319-47958-3_21" target=
        "_blank">https://doi.org/10.1007/978-3-319-47958-3_21</a>
        </li>
        <li id="BibPLXBIB0018" label="[18]">Gareth&nbsp;David
        Smith. 2011. <em>Local Reasoning about Web Programs</em>.
        Ph.D. Dissertation. Imperial College London, London,
        UK.</li>
        <li id="BibPLXBIB0019" label="[19]">Christian Sternagel and
        Renè Thiemann. 2014. XML. <em><em>Archive of Formal
        Proofs</em></em> (Oct. 2014). <a class=
        "link-inline force-break" href=
        "http://isa-afp.org/entries/XML.shtml">http://isa-afp.org/entries/XML.shtml</a>,
        Formal proof development.
        </li>
        <li id="BibPLXBIB0020" label="[20]">Peter Thiemann. 2005. A
        Type Safe DOM API. In <em><em>Database Programming
        Languages</em></em> (<em>LNCS</em>), Gavin&nbsp;M. Bierman
        and Christoph Koch (Eds.). Vol.&nbsp;3774. Springer,
        169–183. <a class="link-inline force-break" href=
        "https://doi.org/10.1007/11601524_11" target=
        "_blank">https://doi.org/10.1007/11601524_11</a>
        </li>
        <li id="BibPLXBIB0021" label="[21]">W3C. 2015. W3C DOM4.
        (19 Nov. 2015). <a class="link-inline force-break" href=
        "https://www.w3.org/TR/dom/" target=
        "_blank">https://www.w3.org/TR/dom/</a>
        </li>
        <li id="BibPLXBIB0022" label="[22]">Markus Wenzel and
        Lawrence&nbsp;C. Paulson. 2006. Isabelle/Isar. In <em><em>
          The Seventeen Provers of the World, Foreword by Dana S.
          Scott</em></em> (<em>LNCS</em>), Freek Wiedijk (Ed.).
          Vol.&nbsp;3600. Springer, 41–49. <a class=
          "link-inline force-break" href=
          "https://doi.org/10.1007/11542384_8" target=
          "_blank">https://doi.org/10.1007/11542384_8</a>
        </li>
        <li id="BibPLXBIB0023" label="[23]">WHATWG. 2017. DOM –
        Living Standard. (24 March 2017). <a class=
        "link-inline force-break" href=
        "https://dom.spec.whatwg.org/commit-snapshots/6253e53af2fbfaa6d25ad09fd54280d8083b2a97/"
          target=
          "_blank">https://dom.spec.whatwg.org/commit-snapshots/6253e53af2fbfaa6d25ad09fd54280d8083b2a97/</a>
          Last Updated 24 March 2017.
        </li>
      </ul>
    </section>
  </section>
  <section id="foot-001" class="footnote">
    <header>
      <div class="title-info">
        <h2>FOOTNOTE</h2>
      </div>
    </header>
    <p id="fn1"><a href="#foot-fn1"><sup>1</sup></a>This
    object-oriented form of extensibility allows us, e.g., to later
    extend the DOM model to a formal model of standards based on
    the DOM standard, such as HTML, without the need to re-prove
    properties over the DOM.</p>
    <div class="bibStrip">
      <p>This paper is published under the Creative Commons
      Attribution 4.0 International (CC-BY&nbsp;4.0) license.
      Authors reserve their rights to disseminate the work on their
      personal and corporate Web sites with the appropriate
      attribution.</p>
      <p><em>WWW '18 Companion, April 23-27, 2018, Lyon,
      France</em></p>
      <p>© 2018; IW3C2 (International World Wide Web Conference
      Committee), published under Creative Commons CC-BY&nbsp;4.0
      License.<br />
      ACM ISBN 978-1-4503-5640-4/18/04.<br />
      DOI: <a class="link-inline force-break" target="_blank" href=
      "https://doi.org/10.1145/3184558.3185980">https://doi.org/10.1145/3184558.3185980</a></p>
    </div>
  </section>
  <div class="pubHistory">
    <p></p>
  </div>
</body>
</html>
