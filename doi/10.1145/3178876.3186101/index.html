<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.7.16" />
  <title>SafeKeeper: Protecting Web Passwords using Trusted Execution Environments</title><!-- Copyright (c) 2010-2015 The MathJax Consortium -->
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width; initial-scale=1.0;" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="screen, print" rel="stylesheet" href="../../../data/dl.acm.org/pubs/lib/css/bootstrap.min.css" />
  <link media="screen, print" rel="stylesheet" href="../../../data/dl.acm.org/pubs/lib/css/bootstrap-theme.min.css" />
  <link media="screen, print" rel="stylesheet" href="../../../data/dl.acm.org/pubs/lib/css/main.css" />
  <script src="../../../data/dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>
  <script type="text/x-mathjax-config">
  <![CDATA[
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  ]]>
  </script>
</head>
<body id="main">
<div>
<p style='font-size: 75%; color #444'>
This is a web copy of <a href='https://doi.org/10.1145/3178876.3186101'>https://doi.org/10.1145/3178876.3186101</a> 
 Published in WWW2018 Proceedings © 2018 International World Wide Web Conference Committee, published under 
 <a rel='license' property='license' href='https://creativecommons.org/licenses/by/4.0/'>
 Creative Commons CC By 4.0 License</a>.
The <a href='https://github.com/usable-oa/thewebconf2018/tree/master/scripts'>modifications</a> 
from the original are solely to improve HTML aiming to make it Findable, Accessible, Interoperable and Reusable. 
augmenting HTML metadata and avoiding ACM trademark.
To reference this HTML version, use:
</p><p>
<strong>Permalink:</strong>
<a href='https://w3id.org/oa/10.1145/3178876.3186101'>https://w3id.org/oa/10.1145/3178876.3186101</a>
</p></div>
<hr>


  <section class="front-matter">
    <section>
      <header class="title-info">
        <div class="journal-title">
          <h1><span class="title">SafeKeeper: Protecting Web Passwords using Trusted Execution Environments</span><br />
          <span class="subTitle"></span></h1>
        </div>
      </header>
      <div class="authorGroup">
        <div class="author">
          <span class="givenName">Klaudia</span> <span class="surName">Krawiecka</span>, Aalto University, Finland, <a href="mailto:kkrawiecka@acm.org">kkrawiecka@acm.org</a>
        </div>
        <div class="author">
          <span class="givenName">Arseny</span> <span class="surName">Kurnikov</span>, Aalto University, Finland, <a href="mailto:arseny.kurnikov@aalto.fi">arseny.kurnikov@aalto.fi</a>
        </div>
        <div class="author">
          <span class="givenName">Andrew</span> <span class="surName">Paverd</span>, Aalto University, Finland, <a href="mailto:andrew.paverd@ieee.org">andrew.paverd@ieee.org</a>
        </div>
        <div class="author">
          <span class="givenName">Mohammad</span> <span class="surName">Mannan</span>, Concordia University, Canada, <a href="mailto:m.mannan@concordia.ca">m.mannan@concordia.ca</a>
        </div>
        <div class="author">
          <span class="givenName">N.</span> <span class="surName">Asokan</span>, Aalto University, Finland, <a href="mailto:asokan@acm.org">asokan@acm.org</a>
        </div>
      </div><br />
      <div class="pubInfo">
        <p>DOI: <a href="https://doi.org/10.1145/3178876.3186101" target="_blank">https://doi.org/10.1145/3178876.3186101</a><br />
        WWW '18: <a href="https://doi.org/10.1145/3178876" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p>
      </div>
      <div class="abstract">
        <p><small>Passwords are by far the most widely-used mechanism for authenticating users on the web, out-performing all competing solutions in terms of deployability (e.g. cost and compatibility). However, two critical security concerns are phishing and theft of password databases. These are exacerbated by users’ tendency to reuse passwords across different services. Current solutions typically address only one of the two concerns, and do not protect passwords against rogue servers. Furthermore, they do not provide any verifiable evidence of their (server-side) adoption to users, and they face deployability challenges in terms of ease-of-use for end users, and/or costs for service providers.</small></p>
        <p><small>We present SafeKeeper, a novel and comprehensive solution to ensure secrecy of passwords in web authentication systems. Unlike previous approaches, SafeKeeper protects users’ passwords against very strong adversaries, including external phishers as well as corrupted (rogue) servers. It is relatively inexpensive to deploy as it (i) uses widely available hardware-based trusted execution environments like Intel SGX, (ii) requires only minimal changes for integration into popular web platforms like WordPress, and (iii) imposes negligible performance overhead. We discuss several challenges in designing and implementing such a system, and how we overcome them. Via an 86-participant user study, systematic analysis and experiments, we show the usability, security and deployability of SafeKeeper, which is available as open-source.</small></p>
      </div>
      <div class="classifications">
        <div class="author">
          <span style="font-weight:bold;"><small>Keywords:</small></span> <span class="keyword"><small>Passwords</small>,</span> <span class="keyword"><small>Phishing</small>,</span> <span class="keyword"><small>Intel SGX</small>,</span> <span class="keyword"><small>Trusted Execution Environment</small></span>
        </div><br />
        <div class="AcmReferenceFormat">
          <p><small><span style="font-weight:bold;">ACM Reference Format:</span><br />
          Klaudia Krawiecka, Arseny Kurnikov, Andrew Paverd, Mohammad Mannan, and N. Asokan. 2018. SafeKeeper: Protecting Web Passwords using Trusted Execution Environments. In <em>WWW 2018: The 2018 Web Conference,</em> <em>April 23–27, 2018 (WWW 2018),</em> <em>Lyon, France. ACM, New York, NY, USA</em> 10 Pages. <a href="https://doi.org/10.1145/3178876.3186101" class="link-inline force-break" target="_blank">https://doi.org/10.1145/3178876.3186101</a></small></p>
        </div>
      </div>
    </section>
  </section>
  <section class="body">
    <section id="sec-6">
      <header>
        <div class="title-info">
          <h2><span class="section-number">1</span> Introduction</h2>
        </div>
      </header>
      <p>Passwords are by far the most widely used primary authentication mechanism on the web. Although many alternative schemes have been proposed, none has yet challenged the dominance of passwords. In the evaluation framework of authentication mechanisms by Bonneau et al.&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0008">8</a>], passwords have the best overall <em>usability</em>, since they are easy to understand, efficient to use, and don't require the user to carry additional devices/tokens. They also excel in terms of <em>deployability</em>, since they are compatible with virtually all servers and web browsers, incur minimal cost per user, and are accessible, mature, and non-proprietary. However, in terms of <em>security</em>, passwords are currently a comparatively poor choice. Two critical security concerns, leading to the compromise of a large number of passwords, are: (i) phishing of passwords from users, and (ii) password database breaches from servers.</p>
      <p>Phishing attacks are prevalent in the wild (cf. APWG&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0002">2</a>], PhishTank&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0033">33</a>]), and increasingly use TLS certificates from browser-trusted CAs (see e.g.&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0030">30</a>]). While advanced anti-phishing solutions exist&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0011">11</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0029">29</a>], and will improve over time, they alone cannot adequately address the password confidentiality problem, because users may unknowingly or inadvertently disclose passwords to malicious servers. Note that an estimated 43–51% of users reuse passwords across different services&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0013">13</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0017">17</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0022">22</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0039">39</a>].</p>
      <p>Password database breaches are increasingly frequent: hundreds of millions of passwords have been leaked in recent years (e.g.&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0014">14</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0034">34</a>]). Users are completely powerless against such breaches. Password breaches are commonly dealt with by asking users to quickly reset their passwords, which is not very effective&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0019">19</a>]. Widespread password reuse makes these breaches problematic beyond the sites where the actual leak occurred&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0022">22</a>]. Several recent solutions (e.g.&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0004">4</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0009">9</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0015">15</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0026">26</a>]) have been proposed to address password database breaches. Some of them (e.g.&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0004">4</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0009">9</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0026">26</a>]) make use of hardware-based trusted execution environments (TEEs) on the server side, but none can protect password confidentiality against <em>rogue</em> servers (i.e. compromised servers, or malicious server operators).</p>
      <p>Designing effective solutions to protect passwords against rogue servers poses multiple technical challenges in terms of security (How to hide passwords from the authenticating server itself? How to rate-limit password testing by the server?); usability (How to minimize the burden on users? How to support login from diverse user devices?); user-verifiability (How to notify users when the solution is active?); performance (How to realize this at scale?); and deployability (How to allow easy/inexpensive integration with popular website frameworks?).</p>
      <p>We present SafeKeeper, a comprehensive system for protecting the <em>confidentiality</em> of web passwords. Unlike all previous proposals, SafeKeeper defends against both phishing and password database theft, even in the case of rogue servers. SafeKeeper consists of a <em>server-side password protection service</em> that computes a cipher-based message authentication code (CMAC) on passwords before they are stored in the database, as mandated by NIST's digital identity guidelines (SP800-63B)&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0032">32</a>]. To protect the CMAC key, this computation is performed within a server-side TEE, isolating it from all other software on the server. SafeKeeper uses a novel rate-limiting mechanism to throttle online guessing attacks by rogue servers.</p>
      <p>SafeKeeper's client-side functionality, in the form of a web browser addon, enables end users to detect whether a web server is running the SafeKeeper password protection service within a server-side TEE, and to establish a secure channel from their browsers directly to it. This <em>assures</em> users that it is safe to enter their passwords as they will be accessible only to the SafeKeeper password protection service on the server. Unlike other client-side assurance approaches, SafeKeeper does not require users to correctly identify the server (e.g. checking URLs or TLS certificates). As long as users correctly recognize SafeKeeper's client-side signaling from the browser addon, and enter their passwords only to SafeKeeper-enabled web servers, confidentiality of their passwords is guaranteed, <em>even if users misjudge the identity of the server (phishing), or the server is malicious/compromised (rogue server)</em>. As such, SafeKeeper may present a significant shift in phishing avoidance and password protection.</p>
      <p>Our design considers <em>deployability</em> as a primary objective. We demonstrate this by developing a fully-functional implementation of SafeKeeper using Intel's recent Software Guard Extensions (SGX), and integrating this with minimal software changes into <tt>PHPass</tt>, the password hashing framework used in popular platforms like WordPress, Joomla, and Drupal, which account for over 34% of the Alexa top 10-million websites&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0037">37</a>]. SafeKeeper's client-end functionality does not depend on any additional device/hardware features, and can thus be implemented in most user devices/OSes, including smartphones. Our implementation is available as open-source software&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0025">25</a>]. Our contribution is SafeKeeper, including its:</p>
      <ul class="list-no-style">
        <li id="list1" label="•">
          <strong>Design</strong>: As a password-protection scheme featuring<br />
          <ul class="list-no-style">
            <li id="list2" label="•">a <strong>server-side password protection service</strong> using off-the-shelf trusted hardware to protect users’ passwords, <em>even against rogue servers</em> (Sections&nbsp;<a class="sec" href="#sec-15">4.1</a>–<a class="sec" href="#sec-17">4.3</a>), and<br />
            </li>
            <li id="list3" label="•">a novel <strong>client-side assurance mechanism</strong> allowing users to easily determine if it is safe to enter passwords on a web page (Section&nbsp;<a class="sec" href="#sec-18">4.4</a>). Our mechanism relies only on verifying whether the server runs SafeKeeper <em>without having to verify the server's identity or correct behavior</em>.<br />
            </li>
          </ul>
        </li>
        <li id="list4" label="•">
          <strong>Implementation and integration:</strong> A full open-source implementation of (i) server-side functionality using Intel SGX, and integration into <tt>PHPass</tt> to support several popular web platforms, and (ii) client-side functionality realized as a Google Chrome browser addon (Section&nbsp;<a class="sec" href="#sec-19">5</a>).<br />
        </li>
        <li id="list5" label="•">
          <strong>Analysis and evaluation:</strong> A comprehensive analysis of security guarantees (Section&nbsp;<a class="sec" href="#sec-28">6.1</a>), an experimental evaluation of performance (Section&nbsp;<a class="sec" href="#sec-36">6.3</a>), deployability in real-world platforms (Section&nbsp;<a class="sec" href="#sec-37">6.4</a>), and validation of effectiveness of the client-side assurance mechanism via an <em>86-participant user study</em> (Section&nbsp;<a class="sec" href="#sec-32">6.2</a>).<br />
        </li>
      </ul>
    </section>
    <section id="sec-7">
      <header>
        <div class="title-info">
          <h2><span class="section-number">2</span> Preliminaries</h2>
        </div>
      </header>
      <section id="sec-8">
        <header>
          <div class="title-info">
            <h3><span class="section-number">2.1</span> Storing Passwords</h3>
          </div>
        </header>
        <p>A widely-used approach for storing passwords is for the server to compute a <em>one-way</em> function (e.g. cryptographic hash) on the password, and store only the result in the database. When the user logs in, the same function is applied to the supplied password, and the result is compared to the value in the database. An adversary who obtains the database cannot reverse the one-way function, but can guess candidate passwords and apply the same one-way function to test his guesses. Since passwords are weak secrets (e.g. compared to cryptographic keys), a brute force guessing attack is often feasible. The adversary can speed up this attack using <em>rainbow tables</em> – pre-computed tables of hashed passwords. If multiple users choose the same password, the results of the one-way function will be the same. To defend against rainbow tables and avoid revealing duplicate passwords, it is customary to use a <em>salt</em> – a random number unique to each user that is concatenated with the password before being hashed. However, since salt values are stored in the database, an adversary who obtains this database can still mount brute-force guessing attacks against specific users. Recently (June 2017), NIST updated its digital identity guidelines in Special Publication 800-63B&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0032">32</a>]. One of the changes is to mandate the use of <em>keyed</em> one-way functions, such as CMAC, for protecting stored passwords.</p>
      </section>
      <section id="sec-9">
        <header>
          <div class="title-info">
            <h3><span class="section-number">2.2</span> Intel Software Guard Extensions</h3>
          </div>
        </header>
        <p>Intel's Software Guard Extensions (SGX) is a recent technology available in desktop and server CPUs&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0021">21</a>]. The new SGX CPU instructions allow a userspace application to establish a hardware-enforced TEE, called an <em>enclave</em>. The enclave runs in the application's virtual address space, but after it has been initialized, only the code inside the enclave is allowed to access enclave data. The application can call enclave functions (called <tt>ecalls</tt>) via well-defined entry points. Enclave data is stored in a special region of memory, called the Enclave Page Cache (EPC), which can only be accessed by the CPU. When any enclave data leaves the CPU (e.g. is written to DRAM), it is encrypted and integrity-protected, using a key accessible only to the CPU&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0016">16</a>]. The enclave's data is therefore protected against privileged software (including the OS/hypervisor), and hardware attacks (e.g. snooping on the memory bus). During enclave initialization, the CPU <em>measures</em> the enclave's code and configuration, which constitute the enclave's identity (i.e. its <tt>MRENCLAVE</tt> value). The enclave can <em>seal</em> data by encrypting it with a CPU-protected key that can only be accessed from enclaves running on the same CPU with precisely the same <tt>MRENCLAVE</tt> value. Remote attestation is the process through which one party, the <em>verifier</em>, can ascertain the precise hardware and software configuration of a remote party, the <em>prover</em>. The objective is to provide the verifier with sufficient information to make a trust decision about the prover. SGX supports remote attestation by providing verifiers with a signed <em>quote</em> from the enclave, which includes the enclave's precise identity (<tt>MRENCLAVE</tt> value) and the enclave's public key&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0001">1</a>]. The verifier can validate this quote using the <em>Intel Attestation Service</em> (IAS), and can then establish an end-to-end encrypted channel directly to the enclave. SGX remote attestation is explained in detail in our technical report&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0024">24</a>].</p>
      </section>
    </section>
    <section id="sec-10">
      <header>
        <div class="title-info">
          <h2><span class="section-number">3</span> System Model and Requirements</h2>
        </div>
      </header>
      <section id="sec-11">
        <header>
          <div class="title-info">
            <h3><span class="section-number">3.1</span> Overview</h3>
          </div>
        </header>
        <p>We use the term <em>password</em> to refer to any user-memorized authentication secret. Passwords are generally weak secrets&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0007">7</a>], which are often re-used across multiple services. Figure&nbsp;<a class="fig" href="#fig1">1</a> is a generalized model of a password-based authentication system. With the assistance of client-side software (e.g. a web browser), a user sends her user ID and password to a server over a secure channel (TLS), and based on this, the server makes an authentication decision. Although real systems are undoubtedly more complicated, they can all be logically represented as the model in Figure&nbsp;<a class="fig" href="#fig1">1</a>. Therefore, we use this model and terminology throughout this paper.</p>
        <figure id="fig1">
          <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186101/images/www2018-110-fig1.jpg" class="img-responsive" alt="Figure 1" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 1:</span> <span class="figure-title">Generalized model of a password-based authentication system.</span>
          </div>
        </figure>
        <p></p>
        <p>Confidentiality of user passwords may be compromised in multiple ways, including:</p>
        <ul class="list-no-style">
          <li id="list6" label="•">Users disclose a password directly to the adversary under the mistaken impression that the password is being sent to the intended service (e.g. phishing attacks).<br /></li>
          <li id="list7" label="•">Information about the password, or the password itself, is leaked from the server (e.g. stolen password database).<br /></li>
          <li id="list8" label="•">Server compromise (e.g. web server memory snooping).<br /></li>
        </ul>
        <p>Any comprehensive solution for protecting passwords must defend against <em>all</em> these different attack avenues.</p>
      </section>
      <section id="sec-12">
        <header>
          <div class="title-info">
            <h3><span class="section-number">3.2</span> Adversary Model</h3>
          </div>
        </header>
        <p>The goal of our adversary (<span class="inline-equation"><span class="tex">$\mathcal {A}dv$</span></span> ) is to learn users’ plaintext passwords. Our adversary model is stronger than that of previous solutions – we allow for the possibility that <span class="inline-equation"><span class="tex">$\mathcal {A}dv$</span></span> may have the capabilities of the <em>operator</em> (owner/administrator) of the web server itself. This covers both compromised web servers, as well as malicious server operators (for clarity, we use the term <em>rogue server</em> to refer to both of these). The widespread practice of reusing the same or similar passwords across services provides the incentive for <span class="inline-equation"><span class="tex">$\mathcal {A}dv$</span></span> to learn plaintext passwords, which they can then abuse in different ways, including (i) masquerading as the user on a <em>different</em> service, where the user may have used the same or similar password; (ii) accessing user data encrypted by a password-derived key (e.g. for encrypted cloud storage services, especially, if forced legally or illegally); and (iii) selling/leaking user passwords to other malicious entities. Concretely, we allow <span class="inline-equation"><span class="tex">$\mathcal {A}dv$</span></span> the following capabilities, covering rogue servers and weaker external adversaries:</p>
        <p><strong>Access password database:</strong> <span class="inline-equation"><span class="tex">$\mathcal {A}dv$</span></span> has unrestricted access to the password database. This models both rogue servers and weaker external adversaries who may steal the password database.</p>
        <p><strong>Modify web content:</strong> <span class="inline-equation"><span class="tex">$\mathcal {A}dv$</span></span> can arbitrarily modify the content sent to the user (including active content such as client-side scripts). This also models weaker external adversaries who can modify content using attacks such as cross-site scripting (XSS).</p>
        <p><strong>Access to server-client communication:</strong> <span class="inline-equation"><span class="tex">$\mathcal {A}dv$</span></span> can read all content sent to the web server, including content encrypted by a TLS session key. For a rogue server, such access is easily obtained.</p>
        <p><strong>Execute server-side code:</strong> <span class="inline-equation"><span class="tex">$\mathcal {A}dv$</span></span> has full knowledge of all software running on the server, and is able to execute arbitrary software on the server. This captures a powerful attacker who gains access and escalates privileges on the server, or a malicious server operator.</p>
        <p><strong>Launch phishing attacks:</strong> <span class="inline-equation"><span class="tex">$\mathcal {A}dv$</span></span> can launch state-of-the-art phishing attacks, including targeted attacks.</p>
        <p>We assume that <span class="inline-equation"><span class="tex">$\mathcal {A}dv$</span></span> <em>cannot</em> compromise the client-side software, including the user's OS and browser, but can send any content to the client. Although client-side security is important, it is an orthogonal problem and is addressed by other means (e.g. client-side platform security). We focus on how password-based authentication can be made resilient against strong server-side adversaries.</p>
        <p>We assume <span class="inline-equation"><span class="tex">$\mathcal {A}dv$</span></span> is computationally bounded, and thus cannot feasibly subvert correctly-implemented cryptographic primitives. We also assume <span class="inline-equation"><span class="tex">$\mathcal {A}dv$</span></span> does not have sufficient resources to subvert the security guarantees of hardware-based TEEs through direct physical attacks. Denial of service (DoS) attacks are out of scope because a rogue server can always mount a DoS attack by simply refusing to respond to requests.</p>
      </section>
      <section id="sec-13">
        <header>
          <div class="title-info">
            <h3><span class="section-number">3.3</span> Requirements and Objectives</h3>
          </div>
        </header>
        <p>Given our strong adversary model, a full server compromise could undoubtedly cause significant damage (e.g. theft, loss, or modification of user information). Our aim is to guarantee that even such a compromise will not leak users’ passwords. This is a valuable security guarantee because passwords are often re-used across multiple services, or used to derive cloud storage encryption keys.</p>
        <p>However, guaranteeing the confidentiality of stored passwords is not sufficient to defend against rogue servers or phishing attacks. Thus we also need to provide users with the means to easily and effectively determine when it is safe to enter their passwords. Therefore, we define the following two requirements for a comprehensive solution for protecting a password-based authentication system:</p>
        <ol class="list-no-style">
          <li id="list9" label="R1">
            <strong>Password protection:</strong> The server must protect users’ passwords by fulfilling all the following criteria:<br />
            <ol class="list-no-style">
              <li id="list10" label="(i)">The strong adversary defined above cannot obtain users’ passwords through any means other than guessing (e.g. he cannot observe passwords in transit or while they are being processed on the server).<br /></li>
              <li id="list11" label="(ii)"><em>Offline</em> password guessing must be computationally infeasible, irrespective of the strength of the password.<br /></li>
              <li id="list12" label="(iii)"><em>Online</em> password guessing must be throttled, irrespective of the adversary's computational capabilities.<br /></li>
            </ol>
          </li>
          <li id="list13" label="R2">
            <strong>User awareness:</strong> End users must be able to easily and accurately determine whether it is safe to enter their passwords when prompted by a given server (i.e. indirectly determine whether the server fulfils Requirement&nbsp;<a class="lst" href="#list9">R1</a>).<br />
          </li>
        </ol>
        <p>Note that Requirement&nbsp;<a class="lst" href="#list13">R2</a> <em>does not</em> mandate users to understand the precise technical security guarantees of Requirement&nbsp;<a class="lst" href="#list9">R1</a>, but rather that the solution should enable users to determine <em>which</em> servers meet this requirement, and will thus protect passwords.</p>
        <p>In order to be effective, any solution for protecting passwords must be deployable in real-world systems. Therefore, in addition to the above two security requirements, we also define the following deployability goals:</p>
        <p><strong>Minimal performance overhead:</strong> The solution should not noticeably degrade the performance of password-based authentication systems, either in terms of <em>latency</em> (the time required to complete a single authentication attempt), or <em>scalability</em> (the overall rate at which authentication attempts can be evaluated).</p>
        <p><strong>Minimal software changes:</strong> It should be possible to integrate the solution into a wide range of existing software systems without requiring significant effort.</p>
        <p><strong>Ease of upgrade:</strong> It should be possible to transparently upgrade existing password-based authentication systems (e.g. without requiring users to reset their passwords). Existing mechanisms for changing/resetting passwords should also remain unaffected.</p>
      </section>
    </section>
    <section id="sec-14">
      <header>
        <div class="title-info">
          <h2><span class="section-number">4</span> Design</h2>
        </div>
      </header>
      <p>As shown in Figure&nbsp;<a class="fig" href="#fig2">2</a>, SafeKeeper consists of a <em>server-side password protection service</em>, which computes a cipher-based message authentication code (CMAC) on passwords before they are stored in the database. An adversary must obtain the CMAC key in order to perform offline guessing attacks against a stolen password database. In SafeKeeper, this key is randomly generated and protected within a server-side Trusted Application (TA), executing within the TEE; see Section&nbsp;<a class="sec" href="#sec-15">4.1</a>.</p>
      <p>With direct access to the password protection service, a rogue server (i.e. a compromised server or malicious server operator) can also perform online password guessing attacks. In this case, the adversary supplies a guessed password, and the password protection service returns the processed result, which the adversary compares against the stored value. To defend against this attack, the password protection service must limit the rate at which it processes passwords. SafeKeeper achieves this by enforcing rate limiting in the TEE; see Section&nbsp;<a class="sec" href="#sec-16">4.2</a>.</p>
      <p>Furthermore, the rogue server may attempt to observe passwords <em>before</em> they are sent to the password protection service. A secure channel between the web browser addon and the server (e.g. a TLS connection) is insufficient as the server-end of such a connection is controlled by the server operator. Instead, SafeKeeper establishes an end-to-end secure channel between the browser and the TEE-protected password protection service; see Section&nbsp;<a class="sec" href="#sec-17">4.3</a>.</p>
      <p>Finally, the browser needs some way to determine which input data should be sent via this secure channel to the password protection service (e.g. passwords but not user IDs). To improve usability, the server operator defines which input fields will be protected, and then the SafeKeeper browser addon displays this information to the user. The user is thus only required to validate that the password field is protected; see Section&nbsp;<a class="sec" href="#sec-18">4.4</a>.</p>
      <section id="sec-15">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.1</span> Server-side Password Protection</h3>
          </div>
        </header>
        <p>The SafeKeeper password protection service (SafeKeeper TA) is designed to be a <em>drop-in replacement</em> for existing password hash algorithms. As such, it takes as input the concatenation of the password and the corresponding salt value and outputs a CMAC, which the server stores in its database. To protect the CMAC key, SafeKeeper computes the CMAC inside a server-side TEE. The TEE provides strong isolation (e.g. hardware-enforced) from all other software on the server (including the OS/hypervisor), and thus ensures that the CMAC key is available only to the TA code. Even if an adversary obtains the password database, he cannot perform an <em>offline</em> password guessing attack because he would need the CMAC key to test his guesses against the database. Since offline attacks are no longer possible, SafeKeeper can use any cryptographically secure one-way function, i.e. specifically-designed password hash functions (e.g.&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0005">5</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0006">6</a>]) are not essential (but can be used). The adversary is thus forced to try <em>online</em> guessing attacks, which are mitigated by SafeKeeper's rate-limiting mechanism.</p>
      </section>
      <section id="sec-16">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.2</span> Rate Limiting</h3>
          </div>
        </header>
        <p>Ideally, the password protection service should perform rate limiting on a per-account basis to: (i) protect each account password, and (ii) avoid rate-limiting a user due to the actions of other users. Note that, in order to serve as a drop-in replacement in existing authentication frameworks, the SafeKeeper TA only computes the CMAC, but does not make or learn the authentication decision. In other words, it cannot distinguish between the two scenarios: (i) when the user account is under guessing attack, and (ii) when a legitimate user is attempting to login multiple times within a short period of time (with or without a valid password). Also, as the CMAC does not take the user ID as input, we cannot implement user ID based rate limiting. Changing the function to include user IDs as input would require non-trivial changes to the server software, limiting SafeKeeper's use as a drop-in replacement. As a work-around, we rate limit each account using the unique per-account salt values, which are provided to the CMAC as part of regular operation. It is general security best-practice to use unique salt values for each account, but if a server operator chooses the same salt for multiple (or all) accounts, he only restricts his own guessing capability. Furthermore, since the salt is a fixed pre-determined length, the adversary cannot perform a type-substitution attack by providing a salt of a different length, e.g. concatenating the first few characters of a guessed password with the salt value.</p>
        <figure id="fig2">
          <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186101/images/www2018-110-fig2.jpg" class="img-responsive" alt="Figure 2" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 2:</span> <span class="figure-title">Overview of the SafeKeeper design.</span>
          </div>
        </figure>
        <p></p>
        <p>SafeKeeper limits password processing for each account (salt) based on a <em>quantized maximum rate</em>. Simply enforcing a <em>maximum rate</em> (e.g. waiting <em>W</em> minutes between password attempts) would negatively impact usability in cases where the user mistyped a password. Instead, the quantized maximum rate allows a fixed number of attempts within a pre-defined time interval, but doesn't mandate a delay between these attempts. For example, each user could be allowed <em>N</em> attempts that could be used at any time within each 24-hour period. After exhausting these attempts, the user has to wait until the following time period, when the count is reset. By calibrating <span class="inline-equation"><span class="tex">$N = \frac{24 \times 60}{W}$</span></span> , this achieves the same overall rate as waiting <em>W</em> minutes between attempts, but significantly improves usability when multiple attempts are required in quick succession.</p>
      </section>
      <section id="sec-17">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.3</span> Remote Attestation</h3>
          </div>
        </header>
        <p>To securely transmit a user password, the SafeKeeper browser addon must correctly authenticate the SafeKeeper password protection service (SafeKeeper TA) running inside a TEE, via remote attestation. In addition, the addon must establish a secure channel directly with the TA. SafeKeeper uses remote attestation to assure the addon of the precise TA running inside the server-side TEE. To verify that it is communicating with a genuine SafeKeeper TA, the addon verifies the quote, and then checks the binary measurement against a whitelist of known SafeKeeper TAs. Since the same TA can be used by many websites, and the functionality of the TA is unlikely to change, the whitelist of genuine SafeKeeper TAs will be short, and can be built into the SafeKeeper addon. The attestation protocol includes a key agreement step through which the browser and the TA establish a shared session key. Note that the attestation protocol provides only unilateral authentication of the SafeKeeper TA towards the client; i.e. the client software or the user is not authenticated during attestation. Thus, anyone, including an adversary can establish a connection and interact with the TA. However, since the key agreement step is cryptographically bound to the TA's remote attestation, the adversary cannot perform a man-in-the-middle attack when legitimate clients communicate with the TA. Using the shared session key, the addon encrypts the password before the page is submitted. The encrypted password is sent to the server in place of the original password, and may be wrapped in additional layers of encryption (e.g. TLS). On the server, the encrypted password is input to the TA, which decrypts it using the shared key and performs the CMAC.</p>
      </section>
      <section id="sec-18">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.4</span> Client-side Assurance Mechanism</h3>
          </div>
        </header>
        <p>SafeKeeper's client-side assurance mechanism can be added to existing web browsers e.g. by installing a browser addon. This addon executes the remote attestation protocol and establishes a secure channel with the TA. If the attestation succeeds, the addon changes its appearance (e.g. its icon) to signal this to the user.</p>
        <p>The server specifies in the web page which input fields should be encrypted and sent to the SafeKeeper password protection TA. The addon parses this information and encrypts any text entered into these fields. However, a rogue server may specify that some non-password fields should be protected, while the actual password field is left unprotected. To prevent this, the SafeKeeper addon signals to the user which input fields are protected by greying out the whole page, highlighting only the text input fields it will encrypt, and displaying an information tooltip.</p>
        <p>The adversary could attempt to spoof the highlighting performed by SafeKeeper (e.g. by highlighting fields that are not actually protected). To mitigate this, we use a similar principle to a <em>secure attention sequence</em> by requiring the user to click on the browser addon icon to activate the highlighting. This click cannot be detected or prevented by the adversary (as it is outside of the browser DOM). After the user has clicked, the SafeKeeper icon is again changed to indicate that it is in the <em>highlighting mode</em>. This provides a spoofing-resistant mechanism for signaling to the user which input fields will be protected. The user is thus assured that a password entered into such an input field will always be protected by SafeKeeper, regardless of the identity of the website or the behavior of the server.</p>
        <p>Unlike many other client-side approaches (e.g. password managers), the SafeKeeper browser addon is stateless and user-agnostic. This makes our client-side assurance mechanism a good candidate to be integrated directly into web browsers. We discuss other possible mechanisms in our accompanying technical report&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0024">24</a>].</p>
      </section>
    </section>
    <section id="sec-19">
      <header>
        <div class="title-info">
          <h2><span class="section-number">5</span> Implementation</h2>
        </div>
      </header>
      <p>We have implemented a fully-functional open-source prototype of SafeKeeper &nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0025">25</a>]. In this section, we describe the specific implementation challenges and our solutions.</p>
      <section id="sec-20">
        <header>
          <div class="title-info">
            <h3><span class="section-number">5.1</span> Server-side Password Protection</h3>
          </div>
        </header>
        <p>Our implementation of the password protection service uses Intel's recent Software Guard Extensions (SGX). However, SafeKeeper can use any equivalent TEE that provides isolated execution, sealed storage, and remote attestation. We use SGX for its performance and increasing prevalence on server platforms (e.g. Intel Xeon&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0020">20</a>]).</p>
        <p>The design of our SGX enclave is kept minimalistic, consisting of only four <tt>ecalls</tt>. When the enclave is started for the first time, the <tt>init()</tt> function uses Intel's hardware random number generator (<tt>RDRAND</tt> instruction) to generate a new strong CMAC key. When the enclave is later restarted, this function is used to pass previously-sealed data to the enclave. The <tt>process()</tt> function calculates the CMAC on a password and returns the result. We use the Rijndael-128 CMAC function, as this meets our security requirements and can be computed using AES-NI hardware extensions.</p>
        <p>We integrated SafeKeeper's password protection service into the <tt>PHPass</tt> library&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0031">31</a>], which is widely used for password hashing in popular web platforms including WordPress, Joomla, and Drupal. By default, <tt>PHPass</tt> uses a software implementation of MD5 with 256 iterations. We replaced this with a single call to our enclave, using the PHP-CPP framework&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0028">28</a>].</p>
        <section id="sec-21">
          <p><em>5.1.1 Rate limiting.</em> In addition to the web server's rate limiting (e.g. Captchas after failed attempts), we implement a rate-limiting mechanism within the TEE-protected password service (Section&nbsp;<a class="sec" href="#sec-16">4.2</a>). The SafeKeeper TA keeps an in-memory map associating each salt (<em>i</em>) with a number of remaining attempts (<em>attempts<sub>i</sub></em> ). To maximize flexibility, our implementation uses a 64-bit salt and a 32-bit integer for <em>attempts<sub>i</sub></em> , although this can be decreased to reduce memory consumption if needed. When <tt>process()</tt> is called for salt <em>i</em>, this function first checks the value of <em>attempts<sub>i</sub></em> ; if the value is zero, it returns only an error; otherwise <em>attempts<sub>i</sub></em> is decremented by one and the CMAC result is returned. The enclave stores <em>t<sub>reset</sub></em> , the time at which all <em>attempts</em> values are reset to a predefined value, <em>attempts<sub>max</sub></em> . The <tt>reset_attempts()</tt> function first obtains the current time; then, if <em>t<sub>reset</sub></em> has passed, sets all <em>attempts</em> values to <em>attempts<sub>max</sub></em> and increases <em>t<sub>reset</sub></em> by a predefined value. Although the effective rate is set by the enclave developer, it is verified by the user via the browser addon, so a malicious developer cannot set an arbitrarily high rate.</p>
          <p>To allow the enclave to be restarted (e.g. if the server is rebooted), the <tt>shutdown()</tt> function securely stores the state information outside the enclave. Specifically, the enclave seals the CMAC key, the map of salts and <em>attempts</em> values, and <em>t<sub>reset</sub></em> . This sealed data can be restored to the enclave via the <tt>init()</tt> function. The enclave uses hardware-backed monotonic counters to prevent rollback attacks in which the adversary attempts to restore old sealed data.</p>
          <p>A rogue server may attempt to reset the <em>attempts</em> values by abruptly killing the enclave without first sealing its state. However, the enclave will detect this because the counter value in the sealed data will not match the current value of the hardware monotonic counter. In this case, the enclave has no way of restoring the previous <em>attempts</em> values – the data has been irreversibly lost. Therefore, the only secure course of action is to set <em>t<sub>reset</sub></em> to some predetermined time in the future, and set all <em>attempts</em> to zero (i.e. to impose the maximum penalty). This captures the worst-case scenario in which the adversary had exhausted all guessing attempts against all accounts. Note that, during normal operations, enclave crashes should be rare, and with proper load balancing the effects of abnormal enclave crashes can be amortized.</p>
        </section>
        <section id="sec-22">
          <p><em>5.1.2 Remote attestation.</em> Remote attestation is used to assure the browser that it is communicating with a genuine SafeKeeper password protection service running inside an SGX enclave. It is achieved by obtaining a <em>quote</em> from the enclave and verifying it using the Intel Attestation Service (IAS). The quote includes an unforgeable representation of the code executing inside the enclave. As described in Section&nbsp;<a class="sec" href="#sec-7">2</a>, the remote attestation protocol provided with the SGX SDK involves four messages and two round-trips in order to achieve mutual authentication between the verifier and the enclave. In SafeKeeper there is no requirement for the browser addon to authenticate itself to the enclave. Any entity can request a quote from the enclave and then decide whether to establish a secure channel. We designed and implemented an optimized attestation protocol for SafeKeeper. Due to space limitations, we refer readers our technical report&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0024">24</a>] for full details of this protocol.</p>
        </section>
      </section>
      <section id="sec-23">
        <header>
          <div class="title-info">
            <h3><span class="section-number">5.2</span> Client-side Assurance Mechanism</h3>
          </div>
        </header>
        <p>We implement SafeKeeper's client-side assurance mechanism as an addon for the Google Chrome browser (similar implementations can also be developed for the other browsers). We assume that users can download and install this addon securely (e.g. using the Chrome Web Store), and receive software updates when available. Note that browser vendors are actively working to ensure the security of browser addons&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0027">27</a>].</p>
        <p>Our browser addon is written in JavaScript and consists of two parts: (i) a <em>background script</em> implementing the main functionality; and (ii) a <em>content script</em> injected into each web page in order to interact with the page content. The addon therefore requires permission to access tabs data, use the browser storage, and capture and modify certain web requests.</p>
        <section id="sec-24">
          <p><em>5.2.1 Detecting the password protection service.</em> Web servers using SafeKeeper send an SGX quote in the HTTP response header of web pages with protected fields (e.g. the login form). This quote is processed by the addon's background script, which verifies the integrity of the service and the validity of the quote. Specifically, the addon extracts from the quote the unique hash representing the enclave's loaded code (i.e. the <tt>MRENCLAVE</tt> value), and checks if this is included in its list of trusted values. This list can be updated in a similar manner to updating the browser. If the enclave's identity is trusted, the addon validates the quote using the Intel Attestation Service (IAS); see Section&nbsp;<a class="sec" href="#sec-22">5.1.2</a>. If the attestation process is successful, the background script generates a new DH key pair for the website, and establishes the shared key using the enclave's public key. Finally, the background script changes the addon's icon to indicate the website supports SafeKeeper; see Figure&nbsp;<a class="fig" href="#fig3">3</a>.</p>
          <figure id="fig3">
            <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186101/images/www2018-110-fig3.jpg" class="img-responsive" alt="Figure 3" longdesc="" />
            <div class="figure-caption">
              <span class="figure-number">Figure 3:</span> <span class="figure-title">SafeKeeper browser addon icons: (1) SafeKeeper is unavailable on the website, or the attestation protocol has failed; (2) SafeKeeper is supported and a secure channel has been established; (3) SafeKeeper is highlighting the protected input fields (see Section&nbsp;<a class="sec" href="#sec-25">5.2.2</a>).</span>
            </div>
          </figure>
          <p></p>
        </section>
        <section id="sec-25">
          <p><em>5.2.2 Highlighting protected input fields.</em> When a page is loaded, the injected content script checks for the SafeKeeper metatag. If present, this tag specifies which input fields must be encrypted by SafeKeeper. When the user clicks the browser addon icon, a popup window appears to provide information about the current web page. Clicking the addon icon also serves as the secure attention sequence described in Section&nbsp;<a class="sec" href="#sec-18">4.4</a>, as this cannot be manipulated by the adversary-controlled web page script. This action sends a message to the content script, which modifies the website's DOM elements to highlight the protected input fields and attach an information tooltip to inform the user why each field is highlighted. When the user clicks on the icon again, the content script restores the page's original appearance. When the web page is submitted, the content script encrypts all values from the protected input fields using the shared key agreed with the SafeKeeper password service.</p>
        </section>
        <section id="sec-26">
          <p><em>5.2.3 Defending against malicious client-side scripts.</em> As defined in our adversary model (Section&nbsp;<a class="sec" href="#sec-10">3</a>), a malicious server operator has the capability to modify the content of the web page, including adding client-side scripts. This poses several threats. First, a malicious script may attempt to read the password as it is typed by the user. Client-side scripts that exhibit this behaviour for other types of personal information have already been observed in the wild&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0018">18</a>]. With the exception of disabling the malicious script, there is no way to avoid this using current browser addon technologies since the script is executing in the same domain as the text input field. Second, malicious client-side scripts can attempt to spoof the highlighting of input fields performed by the SafeKeeper browser addon. Third, although the adversary cannot detect when the SafeKeeper highlighting has been activated, he can add a time delay to his malicious script in order to spoof the SafeKeeper UI <em>after</em> the user has clicked the SafeKeeper icon.</p>
          <p>Currently Google Chrome does not provide a direct option to disable client-side scripts for particular websites, so for SafeKeeper we have developed an alternative approach to achieve this using a <em>Content Security Policy</em> (CSP). Using the toggle switch on the SafeKeeper popup window, users can disable scripts for individual websites. SafeKeeper then reloads the page and injects our custom CSP metatag into the header, which still allows our injected content script to run, but blocks all other scripts on the page. A limitation of this approach is that there is a race condition between the time our CSP is injected, and the loading of other scripts. However, our experimental evaluation showed that only pages loaded directly from <tt>localhost</tt> were fast enough to evade our CSP. When scripts are disabled for a particular website, the addon stores this information in Chrome's local storage and continues to disable scripts on future visits to this website, until re-enabled by the user.</p>
          <p>However, disabling client-side scripts often negatively affects the usability of the web page. Therefore, by default SafeKeeper allows client-side scripts. Careful users can still turn-off all client-side scripts manually when needed. In the accompanying technical report&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0024">24</a>], we present alternative approaches that ensure the same level of security without disabling client-side scripts.</p>
        </section>
      </section>
    </section>
    <section id="sec-27">
      <header>
        <div class="title-info">
          <h2><span class="section-number">6</span> Evaluation</h2>
        </div>
      </header>
      <section id="sec-28">
        <header>
          <div class="title-info">
            <h3><span class="section-number">6.1</span> Security Analysis</h3>
          </div>
        </header>
        <p>As defined in Requirement&nbsp;<a class="lst" href="#list9">R1</a>, a comprehensive solution for protecting passwords must (i) prevent even the strongest adversary (i.e. rogue server) from observing passwords in transit or during processing on the server; (ii) prevent offline password guessing attacks; and (iii) throttle online password guessing, irrespective of <span class="inline-equation"><span class="tex">$\mathcal {A}dv$</span></span> ’s computational capabilities. In this section we analyse SafeKeeper's security guarantees against each of these classes of attacks. In our accompanying technical report&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0024">24</a>], we further discuss SafeKeeper's resilience against other types of attacks, including roll-back attacks, run-time attacks, and SGX side-channel attacks.</p>
        <section id="sec-29">
          <p><em>6.1.1 Passwords in transit and on the server.</em> The secure channel, based on the DH key agreement between the browser addon and the enclave, ensures the confidentiality of passwords while in transit over the network, and while they are being processed on the server, before they are input to the enclave. Since this channel is cryptographically bound to the enclave's remote attestation quote, the client-side software is assured that it is communicating with the correct enclave. Note that, this channel's security is independent of any other layer, such as TLS, established between the browser and web server. As such, password confidentiality remains unaffected even if there are flaws in TLS/HTTPS protocols (e.g.&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0003">3</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0036">36</a>]).</p>
        </section>
        <section id="sec-30">
          <p><em>6.1.2 Offline guessing.</em> In an offline attack, the adversary (<span class="inline-equation"><span class="tex">$\mathcal {A}dv$</span></span> ) would attempt to guess the password and test his guess directly against the leaked password database, bypassing any online guessing prevention by the web server. <span class="inline-equation"><span class="tex">$\mathcal {A}dv$</span></span> is therefore not subject to rate-limiting, and can perform guesses at the maximum rate supported by his available hardware. However, to test his guesses, <span class="inline-equation"><span class="tex">$\mathcal {A}dv$</span></span> must also guess the CMAC key, and thus making offline attacks infeasible even against very weak passwords.</p>
        </section>
        <section id="sec-31">
          <p><em>6.1.3 Online guessing.</em> To avoid having to guess the CMAC key, a malicious server operator could perform an <em>online</em> attack by submitting password guesses to the SafeKeeper password protection service, running in the SGX enclave. However, <span class="inline-equation"><span class="tex">$\mathcal {A}dv$</span></span> ’s rate of guessing is then constrained by SafeKeeper's rate-limiting mechanism described in Section&nbsp;<a class="sec" href="#sec-21">5.1.1</a>. This increases the difficulty of guessing the password by increasing the time required. For example, if an average strength password provides approximately 20&nbsp;bits of entropy&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0007">7</a>] and SafeKeeper's effective maximum rate were set to <em>N</em> = 144 authentication attempts per day, the average time required to guess this password (i.e. 2<sup>19</sup> guesses) would be nearly 10 years. Note that this still cannot protect very weak passwords (e.g. short passwords or those appearing in lists of frequently used passwords). This is a fundamental limitation of password-based authentication.</p>
          <p>Even though our rate limiting is based on the salt, which is under <span class="inline-equation"><span class="tex">$\mathcal {A}dv$</span></span> ’s control, <span class="inline-equation"><span class="tex">$\mathcal {A}dv$</span></span> cannot increase his guessing rate by manipulating the choice of salts. For example, if <span class="inline-equation"><span class="tex">$\mathcal {A}dv$</span></span> chooses the same salt for all accounts, he can test his guesses against all passwords in the database (e.g. <em>N</em> guesses per day, tested against all accounts). However, if he chooses unique salts he can test the same number of guesses against each individual account, and possibly vary guesses between accounts (e.g. <em>N</em> guesses per day against each account). Additionally, he may try to add fake accounts with guessed passwords to leverage the fact that the same passwords will result in the same CMAC values, if a global salt is used. However, as passwords of new accounts must also be processed by the SafeKeeper password protection service, the number of guessing attempts per day remains unaffected. An external adversary (i.e. without compromising the web server) will also be restricted by any online guessing prevention mechanisms (e.g. Captcha) implemented by an honest server operator.</p>
        </section>
      </section>
      <section id="sec-32">
        <header>
          <div class="title-info">
            <h3><span class="section-number">6.2</span> Usability Evaluation</h3>
          </div>
        </header>
        <p>To evaluate SafeKeeper against Requirement&nbsp;<a class="lst" href="#list13">R2</a>, we conducted a user study for the client-side browser addon. The objectives of this study were to: (i) quantify the ability of participants to use the addon correctly; (ii) assess the <em>memorability</em> of the addon usage after a period of disuse; and (iii) analyse the difficulty of using the addon. This user study was carried out in accordance with the standard practices of our institution. No data protection issues arose because participants were not asked to use/disclose any personal data.</p>
        <section id="sec-33">
          <p><em>6.2.1 Participants and methodology.</em> We recruited 86 participants using institutional mailing lists and social media. The participants were randomly split into two groups: main study group (64 participants), and control group (22 participants). We collected basic demographic information for the main study group: 70% of participants were male and 30% were female; ages between 18 to 39 years; participants’ educational qualification: 2% Ph.D., 34% Master's, 41% Bachelor's, 9% High school diploma (14% unspecified).</p>
          <p><strong>Main Group:</strong> Each participant in this group was initially shown the SafeKeeper information page, which contains the same information a normal user would see when installing our browser addon. Participants were then given a set of 25 websites. These websites were clones of popular websites, created using <em>HTTrack</em>&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0010">10</a>] and hosted on an internal institutional server. We slightly modified these sites for our experiment; see Table&nbsp;<a class="tbl" href="#tab1">1</a>. We did not warn the participants about spoofing. The websites were listed in the same order for all participants, but participants could access these in any sequence and had the option to return to previous websites.</p>
          <div class="table-responsive" id="tab1">
            <div class="table-caption">
              <span class="table-number">Table 1:</span> <span class="table-title">Test websites.</span>
            </div>
            <table class="table">
              <thead>
                <tr>
                  <th style="text-align:center;"><strong>SafeKeeper lock icon</strong></th>
                  <th style="text-align:left;"><strong>Password protected</strong></th>
                  <th style="text-align:center;"><strong>Spoofing types</strong></th>
                  <th style="text-align:center;"><strong># websites</strong></th>
                </tr>
              </thead>
              <tbody>
                <tr style="border-top: solid 2px">
                  <td style="text-align:center;">✓</td>
                  <td style="text-align:center;">✓</td>
                  <td style="text-align:center;">None</td>
                  <td style="text-align:center;">4</td>
                </tr>
                <tr>
                  <td style="text-align:center;">✓</td>
                  <td style="text-align:center;">✓</td>
                  <td style="text-align:center;">Other fields highlighted</td>
                  <td style="text-align:center;">5</td>
                </tr>
                <tr>
                  <td style="text-align:center;">✗</td>
                  <td style="text-align:center;">✗</td>
                  <td style="text-align:center;">None</td>
                  <td style="text-align:center;">6</td>
                </tr>
                <tr>
                  <td style="text-align:center;">✗</td>
                  <td style="text-align:center;">✗</td>
                  <td style="text-align:center;">Password field highlighted</td>
                  <td style="text-align:center;">3</td>
                </tr>
                <tr>
                  <td style="text-align:center;">✓</td>
                  <td style="text-align:center;">✗</td>
                  <td style="text-align:center;">Password field highlighted</td>
                  <td style="text-align:center;">4</td>
                </tr>
                <tr>
                  <td style="text-align:center;">✗</td>
                  <td style="text-align:center;">✗</td>
                  <td style="text-align:center;">Password field highlighted after delay</td>
                  <td style="text-align:center;">3</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>For each website, participants were asked: <em>“Does this website protect your password using SafeKeeper?”</em> Participants were instructed not to enter any password or other information on the website, but simply to record their answer on the provided paper form. The available options were: <em>Yes</em>, <em>No</em>, and the level of certainty of the answer. To assess the statistical significance of our results, we assumed a null hypothesis in which participants guess either <em>Yes</em> or <em>No</em> in a uniformly random manner. Under this null hypothesis, the effectiveness would therefore be 50%. We assumed the standard 5% threshold value for statistical significance (<em>α</em> = 0.05).</p>
          <p><strong>Follow-up Study:</strong> After two months, we invited 20 participants from the main group to participate in a follow-up study, with the objective of measuring how well they remembered how to use SafeKeeper after a relatively long period of disuse. The procedure was the same as for the initial study, except that participants were not shown the SafeKeeper information page, and were not reminded of the instructions for using SafeKeeper. They were shown the same set of websites in a different order and asked the same question.</p>
          <p><strong>Control Group:</strong> To obtain a baseline against which to assess the results of the follow-up study, we invited approximately the same number of participants (22) to use the tool without any instructions. This was the same procedure as the follow-up study, except that this control group had never previously used the addon. This control group is therefore the best approximation of the scenario in which users have completely forgotten how to use SafeKeeper.</p>
        </section>
        <section id="sec-34">
          <p><em>6.2.2 Results.</em> In the main group, participants correctly identified 86.81% of websites. Calculating the <em>p</em>-value for each participant (across all websites) showed that for 80% of participants, <em>p</em> &lt; 0.001. The <em>p</em>-value for each website (across all participants) does not exceed 0.001 for 88% of websites.</p>
          <p>In the follow-up study, the 20 recalled participants correctly identified 91% of websites on average (the average for these participants was 93% in the initial study). Calculating the <em>p</em>-value for each participant using McNemar's test shows that for 95% of participants, the <em>p</em>-value exceeds 0.2. This means that there was no statistically significant decrease in the effectiveness of SafeKeeper after two months of disuse. The <em>p</em>-value of only one participant shows a statistically significant decrease in effectiveness.</p>
          <p>Even with no instructions, the control group participants correctly identified 74% of websites on average. Using Fisher's exact test to compare the follow-up group to the control group resulted in <em>p</em> = 6.4 × 10<sup>− 14</sup> (far smaller than the threshold of 0.05), showing that the difference is statistically significant.</p>
        </section>
        <section id="sec-35">
          <p><em>6.2.3 Discussion.</em> Achieving almost 87% effectiveness, we have exceeded the percentage indicated in the null hypothesis, providing evidence of the addon's utility. Out of 64 participants in the main group, only for 5 was <em>p</em> &gt; 0.05. Among the 25 websites, only for one website was <em>p</em> &gt; 0.05 (the first phishing website participants encountered). The follow-up study indicates that SafeKeeper's effectiveness does not diminish, even after long periods of disuse (only one out of 20 participants showed a statistically significant drop in effectiveness). Surprisingly, the control group managed to use the browser addon without any instructions to correctly identify a relatively high number of websites. We suspect that these participants may have inferred the instructions to a certain extent based on the addon's behaviour and the text displayed in the popup window. Based on the background questionnaires, nearly 58% of participants do not usually check for a secure connection while browsing the web. 75% of participants were aware of phishing. When asked to assess the level of difficulty of using SafeKeeper, participants answers were: “very easy to use” (39%), “easy to use” (55%), “difficult to use” (6%), “very difficulty to use” (0%). Overall, 76% of participants said they would like to use SafeKeeper in their own browsers.</p>
        </section>
      </section>
      <section id="sec-36">
        <header>
          <div class="title-info">
            <h3><span class="section-number">6.3</span> Performance Evaluation</h3>
          </div>
        </header>
        <p>Using the implementation described in Section&nbsp;<a class="sec" href="#sec-19">5</a>, we evaluated the <em>memory consumption</em> and <em>scalability</em> of our server-side password protection service, as well as the <em>latency</em> of verifying a quote. All reported performance measurements are the average of 10&nbsp;trials, using a simulated password database of 1&nbsp;million active unique users (i.e. 1&nbsp;million unique salt values), performed on an Intel Core i5-6500 3.20&nbsp;GHz CPU with 8GB of RAM.</p>
        <p><strong>Memory consumption:</strong> Our enclave required at most 110&nbsp;MB of heap memory to store an in-memory rate-limiting map containing all 1&nbsp;million salt values. As discussed in Section&nbsp;<a class="sec" href="#sec-21">5.1.1</a>, memory consumption could be reduced by using more compact representations of the salt or counter values. Note that the enclave does not have to store the salts of every user in the database at the same time – it only stores salts it has processed in the current time window (e.g. users who authenticated in the past 24&nbsp;hours). The memory consumption can thus be further decreased by reducing this time window (e.g. setting the rate to 36 attempts per 6&nbsp;hours would only require storing salts for the past 6&nbsp;hours).</p>
        <p><strong>Scalability:</strong> To measure the performance of the server when multiple users attempt to authenticate concurrently, we instrumented <tt>PHPass</tt> to measure the maximum password processing rate. With the default hash function (software MD5, 256 iterations), the maximum rate is 446 (± 10) passwords/second. With the SafeKeeper password protection service, the rate <em>increases</em> to 1653 (± 70) passwords/second, since we do not require multiple iterations. We also measured the raw performance of the enclave without PHP (e.g. for websites running optimized software): the maximum rate is 101,337 (± 4186) passwords/second. Therefore, even for high-volume websites, this is unlikely to be a performance bottleneck.</p>
        <p><em>Latency:</em> The average latency of verifying a quote is 866&nbsp;ms (± 25&nbsp;ms). However, since this is done asynchronously while the web page loads, and since the time is comparable with the typical loading time of the web page, this should not have any noticeable impact on the user's browsing experience.</p>
      </section>
      <section id="sec-37">
        <header>
          <div class="title-info">
            <h3><span class="section-number">6.4</span> Deployability Evaluation</h3>
          </div>
        </header>
        <p><strong>Minimal software changes:</strong>SafeKeeper's server-side password protection service is designed to be a drop-in replacement for the one-way functions used in current password hashing frameworks (e.g. the <tt>PHPass</tt> library). Integrating SafeKeeper into <tt>PHPass</tt> required adding one line of code to initialize the enclave, and changing three lines of code in the password processing function.</p>
        <p>Existing servers can be migrated to SafeKeeper. Password hashes in an existing database can be input to a SafeKeeper enclave, which performs the CMAC as usual. This results in a so-called <em>onion hash</em>. When users log in, their passwords are sent directly to a special SafeKeeper enclave, which first performs the original hash, and then the CMAC. This allows the security of existing password databases to be upgraded without requiring users to provide their passwords.</p>
        <p>Due to space constraints, we discuss other deployability aspects in our technical report&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0024">24</a>], including backup of the CMAC key, and scaling SafeKeeper to multiple servers for load-balancing.</p>
      </section>
    </section>
    <section id="sec-38">
      <header>
        <div class="title-info">
          <h2><span class="section-number">7</span> Related Work</h2>
        </div>
      </header>
      <p>Password research has a rich history. Here we focus on proposals that improve password security against password database compromises, emphasizing solutions that leverage hardware-based security enhancements. However, no previous work has considered password confidentiality against rogue servers.</p>
      <p>To mitigate offline guessing attacks against hashed passwords, e.g. due to password database breaches, several proposals take advantage of SGX enclaves&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0004">4</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0009">9</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0026">26</a>]. These proposals either encrypt or calculate an HMAC of the password inside an enclave. However, they all assume a significantly weaker adversary model in which the server operator is trusted. Specifically, they do not consider the confidentiality of passwords on the server before they are input to the enclave, nor the possibility for a malicious server operator to perform a brute-force guessing attack using the enclave, nor the risk of phishing. SafeKeeper goes beyond these solutions by resisting rogue servers and phishing attacks.</p>
      <p>Various non-SGX server-side approaches have been proposed. Facebook uses a <em>remote password service</em>&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0015">15</a>] that computes a keyed one-way function on the password and returns the result. The secret key used in this function never leaves their service. Even if an adversary obtains the (keyed) password repository, he must guess the secret key, or connect to the Facebook remote password service (easy to detect and rate-limit). However, running such a service and protecting the key sever against attacks may be infeasible, especially with a limited budget. Also, the key service must be trusted (e.g. not to collude with an attacker), but the trustworthiness of the key server cannot be validated by users.</p>
      <p>Another server-side approach is to use specialized hardware to establish an isolated execution environment. Cvrcek et al.&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0012">12</a>] use a custom-built USB device to store a secret key and use this to calculate HMACs of passwords. Without the USB device, calculating the HMACs is not possible, and thus cracking passwords from leaked tags is also infeasible. Their prototype was capable of computing only 330 HMAC tags per minute, although scalability could be improved using multiple USB devices. However, plaintext passwords remain available to the server operator, and the trustworthiness of the USB device cannot be validated by users.</p>
      <p>As an alternative software-only server-side approach, PolyPasswordHasher&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0038">38</a>] uses a special set of <em>protector</em> account passwords to prevent offline dictionary attacks against the rest of the <em>shielded</em> account passwords. For protected accounts, it applies an XOR function to a <em>share</em> and the hash of a salted password. The share values are derived using a threshold cryptosystem, and stored only in memory (in plaintext). The result of the XOR operation is stored in a database on the web server. To guess shielded passwords, the adversary must crack a threshold of protector passwords (e.g. 3–5), and collect the corresponding shares. The shielded passwords are encrypted using a secret, not the shares, and then stored in the database. Therefore, the shielded accounts that use weaker passwords will not leak the information about the shares. The security of this solution relies on the passwords chosen by the protectors (e.g. admin accounts).</p>
      <p>Users often remain logged into multiple services at the same time. SAuth&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0023">23</a>] leverages this to detect password database compromise. A login attempt to a target site must be validated by a separate <em>vouching</em> site (e.g. to log into Gmail, the user must be logged into Facebook). Thus, an attacker who compromises passwords from one site will be unable to use them unless he can also compromise passwords from the vouching site (assumed to be unlikely).</p>
      <p>Several client-side techniques have also been proposed. For example, the PwdHash&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0035">35</a>] browser addon applies a pseudorandom function to the concatenation of a password and a salt, on the client side. The salt is generated based on a website domain, which binds the password to the specific website. However, an adversary who compromises the web server knows the domain name, and can therefore perform an offline brute-force guessing attack.</p>
      <p>Compared to existing work, SafeKeeper provides additional security features, including: protecting password confidentiality against a malicious server operator, strict password guess rate-limiting from within our enclave, enabling users to validate SGX protections of their passwords via browser UI, and relatively easy deployment options for server operators.</p>
    </section>
    <section id="sec-39">
      <header>
        <div class="title-info">
          <h2><span class="section-number">8</span> Conclusion and Future Work</h2>
        </div>
      </header>
      <p>Passwords are likely to remain the de facto approach for authenticating users on the web, despite their inherent security weaknesses. Therefore, it is critical to improve the security of such systems without decreasing performance, usability, or deployability. A comprehensive solution must address the dual threats of phishing and theft of password databases, even in the case of rogue servers. We have demonstrated that SafeKeeper is a significant step towards meeting these objectives. As future work, we plan to implement selected extensions and variations, such as using SafeKeeper to protect email addresses from misuse, and integrating SafeKeeper into client-side password managers, as described in our technical report&nbsp;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0024">24</a>].</p>
    </section>
  </section>
  <section class="back-matter">
    <section id="sec-40">
      <header>
        <div class="title-info">
          <h2>ACKNOWLEDGMENTS</h2>
        </div>
      </header>
      <p>This work was supported in part by the Intel Collaborative Research Institute for Secure Computing at Aalto University, and the Cloud Security Serivces (CloSer) project (3881/31/2016), funded by Tekes. M.&nbsp;Mannan is supported in part by an NSERC Discovery Grant and a NordSecMob Scholarship.</p>
    </section>
    <section id="ref-001">
      <header>
        <div class="title-info">
          <h2 class="page-brake-head">REFERENCES</h2>
        </div>
      </header>
      <ul class="bibUl">
        <li id="BibPLXBIB0001" label="[1]">Ittai Anati, Shay Gueron, Simon Johnson, and Vincent Scarlata. 2013. Innovative Technology for CPU Based Attestation and Sealing. In <em><em>International Workshop on Hardware and Architectural Support for Security and Privacy</em></em> . <a class="link-inline force-break" href="https://doi.org/10.1.1.405.8266" target="_blank">https://doi.org/10.1.1.405.8266</a>
        </li>
        <li id="BibPLXBIB0002" label="[2]">APWG.org. 2016. Phishing Activity Trends Report (4th Quarter). (2016). <a class="link-inline force-break" href="http://docs.apwg.org/reports/apwg_trends_report_q4_2016.pdf">http://docs.apwg.org/reports/apwg_trends_report_q4_2016.pdf</a>.
        </li>
        <li id="BibPLXBIB0003" label="[3]">Nimrod Aviram, Sebastian Schinzel, Juraj Somorovsky, Nadia Heninger, Maik Dankel, Jens Steube, Luke Valenta, David Adrian, J.&nbsp;Alex Halderman, Viktor Dukhovni, Emilia Käsper, Shaanan Cohney, Susanne Engels, Christof Paar, and Yuval Shavitt. 2016. DROWN: Breaking TLS Using SSLv2. In <em><em>USENIX Security Symposium</em></em> . <a href="https://drownattack.com/drown-attack-paper.pdf" target="_blank">https://drownattack.com/drown-attack-paper.pdf</a>
        </li>
        <li id="BibPLXBIB0004" label="[4]">Joseph Birr-Pixton. 2016. Using SGX to harden password hashing. (2016). <a class="link-inline force-break" href="https://jbp.io/2016/01/17/using-sgx-to-hash-passwords">https://jbp.io/2016/01/17/using-sgx-to-hash-passwords</a>.
        </li>
        <li id="BibPLXBIB0005" label="[5]">A. Biryukov, D. Dinu, and D. Khovratovich. 2016. Argon2: New Generation of Memory-Hard Functions for Password Hashing and Other Applications. In <em><em>IEEE European Symposium on Security and Privacy</em></em> . <a class="link-inline force-break" href="https://doi.org/10.1109/EuroSP.2016.31" target="_blank">https://doi.org/10.1109/EuroSP.2016.31</a>
        </li>
        <li id="BibPLXBIB0006" label="[6]">J. Blocki and A. Datta. 2016. CASH: A Cost Asymmetric Secure Hash Algorithm for Optimal Password Protection. In <em><em>IEEE Computer Security Foundations Symposium</em></em> . <a class="link-inline force-break" href="https://doi.org/10.1109/CSF.2016.33" target="_blank">https://doi.org/10.1109/CSF.2016.33</a>
        </li>
        <li id="BibPLXBIB0007" label="[7]">Joseph Bonneau. 2012. The Science of Guessing: Analyzing an Anonymized Corpus of 70 million Passwords. In <em><em>IEEE Symposium on Security and Privacy</em></em> . <a class="link-inline force-break" href="https://doi.org/10.1109/SP.2012.49" target="_blank">https://doi.org/10.1109/SP.2012.49</a>
        </li>
        <li id="BibPLXBIB0008" label="[8]">Joseph Bonneau, Cormac Herley, Paul&nbsp;C Van&nbsp;Oorschot, and Frank Stajano. 2012. The Quest to Replace Passwords: A Framework for Comparative Evaluation of Web Authentication Schemes. In <em><em>IEEE Symposium on Security and Privacy</em></em> . <a class="link-inline force-break" href="https://doi.org/10.1109/SP.2012.44" target="_blank">https://doi.org/10.1109/SP.2012.44</a>
        </li>
        <li id="BibPLXBIB0009" label="[9]">Helena Brekalo, Raoul Strackx, and Frank Piessens. 2016. Mitigating Password Database Breaches with Intel SGX. In <em><em>Workshop on System Software for Trusted Execution</em></em> . <a class="link-inline force-break" href="https://doi.org/10.1145/3007788.3007789" target="_blank">https://doi.org/10.1145/3007788.3007789</a>
        </li>
        <li id="BibPLXBIB0010" label="[10]">HTTrack Website Copier2017. (2017). <em>&nbsp;</em><a class="link-inline force-break" href="https://www.httrack.com/">https://www.httrack.com/</a>.
        </li>
        <li id="BibPLXBIB0011" label="[11]">Qian Cui, Guy-Vincent Jourdan, Gregor&nbsp;V. Bochmann, Russell Couturier, and Iosif-Viorel Onut2017. Tracking Phishing Attacks Over Time. In <em><em>Conference on World Wide Web</em></em> . <a class="link-inline force-break" href="https://doi.org/10.1145/3038912.3052654" target="_blank">https://doi.org/10.1145/3038912.3052654</a>
        </li>
        <li id="BibPLXBIB0012" label="[12]">Dan Cvrcek2014. Hardware Scrambling - No More Password Leaks. (2014). <a class="link-inline force-break" href="https://www.lightbluetouchpaper.org/2014/03/07/hardware-scrambling-no-more-password-leaks">https://www.lightbluetouchpaper.org/2014/03/07/hardware-scrambling-no-more-password-leaks</a>.
        </li>
        <li id="BibPLXBIB0013" label="[13]">Anupam Das, Joseph Bonneau, Matthew Caesar, Nikita Borisov, and XiaoFeng Wang2014. The Tangled Web of Password Reuse. In <em><em>Network and Distributed Systems Symposium</em></em> . <a class="link-inline force-break" href="https://doi.org/10.14722/ndss.2014.23357" target="_blank">https://doi.org/10.14722/ndss.2014.23357</a>
        </li>
        <li id="BibPLXBIB0014" label="[14]">The Breached Database Directory2017. (2017). <em>&nbsp;</em><a class="link-inline force-break" href="https://vigilante.pw">https://vigilante.pw</a>.
        </li>
        <li id="BibPLXBIB0015" label="[15]">Adam Everspaugh, Rahul Chatterjee, Samuel Scott, Ari Juels, and Thomas Ristenpart2015. The Pythia PRF Service. In <em><em>USENIX Security Symposium</em></em> . <a href="https://www.usenix.org/node/190917" target="_blank">https://www.usenix.org/node/190917</a>
        </li>
        <li id="BibPLXBIB0016" label="[16]">Shay Gueron2016. A Memory Encryption Engine Suitable for General Purpose Processors. (2016). <a class="link-inline force-break" href="https://eprint.iacr.org/2016/204">https://eprint.iacr.org/2016/204</a>.
        </li>
        <li id="BibPLXBIB0017" label="[17]">Weili Han, Zhigong Li, Minyue Ni, Guofei Gu, and Wenyuan Xu2016. Shadow Attacks based on Password Reuses: A Quantitative Empirical View. <em><em>IEEE Transactions on Dependable and Secure Computing</em></em> (2016). <a class="link-inline force-break" href="https://doi.org/10.1109/TDSC.2016.2568187" target="_blank">https://doi.org/10.1109/TDSC.2016.2568187</a>
        </li>
        <li id="BibPLXBIB0018" label="[18]">Kashmir Hill and Surya Mattu2017. Before You Hit ’Submit,’ This Company Has Already Logged Your Personal Data (Gizmodo). (2017). <a class="link-inline force-break" href="https://gizmodo.com/before-you-hit-submit-this-company-has-already-logge-1795906081">https://gizmodo.com/before-you-hit-submit-this-company-has-already-logge-1795906081</a>.
        </li>
        <li id="BibPLXBIB0019" label="[19]">Jun&nbsp;Ho Huh, Hyoungshick Kim, Swathi&nbsp;S.V.P. Rayala, Rakesh&nbsp;B. Bobba, and Konstantin Beznosov2017. I'm too Busy to Reset my LinkedIn Password: On the Effectiveness of Password Reset Emails. In <em><em>ACM SIGCHI Conference on Human Factors in Computing Systems</em></em> . <a class="link-inline force-break" href="https://doi.org/10.1145/3025453.3025788" target="_blank">https://doi.org/10.1145/3025453.3025788</a>
        </li>
        <li id="BibPLXBIB0020" label="[20]">Intel Corporation2017. 1U System Delivering Cryptographic Isolation Technology. (2017). <a class="link-inline force-break" href="https://www.intel.com/content/www/us/en/data-center-blocks/business/secure-enclaves-blocks.html">https://www.intel.com/content/www/us/en/data-center-blocks/business/secure-enclaves-blocks.html</a>.
        </li>
        <li id="BibPLXBIB0021" label="[21]">Intel Corporation2017. Software Guard Extensions (Intel SGX). (2017). <a class="link-inline force-break" href="https://software.intel.com/en-us/sgx">https://software.intel.com/en-us/sgx</a>.
        </li>
        <li id="BibPLXBIB0022" label="[22]">David Jaeger, Chris Pelchen, Hendrik Graupner, Feng Cheng, and Christoph Meinel2016. Analysis of Publicly Leaked Credentials and the Long Story of Password (Re-)use. In <em><em>Conference on Passwords</em></em> . <a href="http://www.passwordresearch.com/papers/paper686.html" target="_blank">http://www.passwordresearch.com/papers/paper686.html</a>
        </li>
        <li id="BibPLXBIB0023" label="[23]">Georgios Kontaxis, Elias Athanasopoulos, Georgios Portokalidis, and Angelos&nbsp;D. Keromytis2013. SAuth: Protecting User Accounts from Password Database Leaks. In <em><em>ACM Conference on Computer and Communications Security</em></em> . <a class="link-inline force-break" href="https://doi.org/10.1145/2508859.2516746" target="_blank">https://doi.org/10.1145/2508859.2516746</a>
        </li>
        <li id="BibPLXBIB0024" label="[24]">Klaudia Krawiecka, Arseny Kurnikov, Andrew Paverd, Mohammad Mannan, and N. Asokan2017. Protecting Web Passwords from Rogue Servers using Trusted Execution Environments. (2017). <a class="link-inline force-break" href="https://arxiv.org/abs/1709.01261">https://arxiv.org/abs/1709.01261</a>.
        </li>
        <li id="BibPLXBIB0025" label="[25]">Klaudia Krawiecka, Arseny Kurnikov, Andrew Paverd, Mohammad Mannan, and N. Asokan2018. SafeKeeper Project. (2018). <a class="link-inline force-break" href="https://github.com/safekeeper">https://github.com/safekeeper</a>.
        </li>
        <li id="BibPLXBIB0026" label="[26]">Klaudia Krawiecka, Andrew Paverd, and N. Asokan2016. Protecting Password Databases Using Trusted Hardware. In <em><em>Workshop on System Software for Trusted Execution</em></em> . <a class="link-inline force-break" href="https://doi.org/10.1145/3007788.3007798" target="_blank">https://doi.org/10.1145/3007788.3007798</a>
        </li>
        <li id="BibPLXBIB0027" label="[27]">Jake Leichtling2015. Continuing to protect Chrome users from malicious extensions. (2015). <a class="link-inline force-break" href="https://blog.chromium.org/2015/05/continuing-to-protect-chrome-users-from.html">https://blog.chromium.org/2015/05/continuing-to-protect-chrome-users-from.html</a>.
        </li>
        <li id="BibPLXBIB0028" label="[28]">PHP-CPP: A C++ library for developing PHP extensions2017. (2017). <em>&nbsp;</em><a class="link-inline force-break" href="http://www.php-cpp.com/">http://www.php-cpp.com/</a>.
        </li>
        <li id="BibPLXBIB0029" label="[29]">Samuel Marchal, Kalle Saari, Nidhi Singh, and N. Asokan2016. Know Your Phish: Novel Techniques for Detecting Phishing Sites and Their Targets. In <em><em>IEEE International Conference on Distributed Computing Systems</em></em> . <a class="link-inline force-break" href="https://doi.org/10.1109/ICDCS.2016.10" target="_blank">https://doi.org/10.1109/ICDCS.2016.10</a>
        </li>
        <li id="BibPLXBIB0030" label="[30]">Netcraft.com2017. Let's Encrypt and Comodo issue thousands of certificates for phishing. (2017). <a class="link-inline force-break" href="https://news.netcraft.com/archives/2017/04/12/lets-encrypt-and-comodo-issue-thousands-of-certificates-for-phishing.html">https://news.netcraft.com/archives/2017/04/12/lets-encrypt-and-comodo-issue-thousands-of-certificates-for-phishing.html</a>.
        </li>
        <li id="BibPLXBIB0031" label="[31]">PHPass: Portable PHP password hashing framework2017. (2017). <em>&nbsp;</em><a class="link-inline force-break" href="http://www.openwall.com/phpass/">http://www.openwall.com/phpass/</a>.
        </li>
        <li id="BibPLXBIB0032" label="[32]">Paul Grassi and others2017. NIST Special Publication 800-63B, Digital Identity Guidelines, Authentication and Lifecycle Management. (2017). <a class="link-inline force-break" href="https://doi.org/10.6028/NIST.SP.800-63b">https://doi.org/10.6028/NIST.SP.800-63b</a>.
        </li>
        <li id="BibPLXBIB0033" label="[33]">PhishTank.com2017. Statistics about phishing activity and PhishTank usage. (2017). <a class="link-inline force-break" href="https://www.phishtank.com/stats.php">https://www.phishtank.com/stats.php</a>.
        </li>
        <li id="BibPLXBIB0034" label="[34]">Have I Been Pwned2017. (2017). <em>&nbsp;</em><a class="link-inline force-break" href="https://haveibeenpwned.com/pwnedwebsites">https://haveibeenpwned.com/pwnedwebsites</a>.
        </li>
        <li id="BibPLXBIB0035" label="[35]">Blake Ross, Collin Jackson, Nick Miyake, Dan Boneh, and John&nbsp;C. Mitchell2005. Stronger Password Authentication Using Browser Extensions. In <em><em>USENIX Security Symposium</em></em> . <a href="http://usenix.org/publications/library/proceedings/sec05/tech/full_papers/ross/ross.pdf" target="_blank">http://usenix.org/publications/library/proceedings/sec05/tech/full_papers/ross/ross.pdf</a>
        </li>
        <li id="BibPLXBIB0036" label="[36]">Y. Sheffer, R. Holz, and P. Saint-Andre2015. RFC7457: Summarizing Known Attacks on Transport Layer Security (TLS) and Datagram TLS (DTLS). (2015). <a class="link-inline force-break" href="https://tools.ietf.org/html/rfc7457">https://tools.ietf.org/html/rfc7457</a>.
        </li>
        <li id="BibPLXBIB0037" label="[37]">W3Techs World Wide Web Technology Surveys2017. (2017). <em>&nbsp;</em><a class="link-inline force-break" href="https://w3techs.com/">https://w3techs.com/</a>.
        </li>
        <li id="BibPLXBIB0038" label="[38]">Santiago Torres and Justin Cappos2014. PolyPasswordHasher: Improving Password Storage Security. <em><em>;login: The USENIX Magazine</em></em> 39, 6 (Dec. 2014), 18–21. <a class="link-inline force-break" href="https://password-hashing.net/submissions/specs/PolyPassHash-v1.pdf">https://password-hashing.net/submissions/specs/PolyPassHash-v1.pdf</a>.
        </li>
        <li id="BibPLXBIB0039" label="[39]">Chun Wang, Steve&nbsp;T.K. Jan, Hang Hu, and Gang Wang2017. Empirical Analysis of Password Reuse and Modification across Online Service. (2017). <a class="link-inline force-break" href="https://arxiv.org/abs/1706.01939v2">https://arxiv.org/abs/1706.01939v2</a>.
        </li>
      </ul>
    </section>
  </section>
  <section id="foot-001" class="footnote">
    <header>
      <div class="title-info">
        <h2>FOOTNOTE</h2>
      </div>
    </header>
    <div class="bibStrip">
      <p>This paper is published under the Creative Commons Attribution 4.0 International (CC-BY&nbsp;4.0) license. Authors reserve their rights to disseminate the work on their personal and corporate Web sites with the appropriate attribution.</p>
      <p><em>WWW '18, April 23-27, 2018, Lyon, France</em></p>
      <p>© 2018; IW3C2 (International World Wide Web Conference Committee), published under Creative Commons CC-BY&nbsp;4.0 License. ACM ISBN 978-1-4503-5639-8/18/04.<br />
      DOI: <a class="link-inline force-break" target="_blank" href="https://doi.org/10.1145/3178876.3186101">https://doi.org/10.1145/3178876.3186101</a></p>
    </div>
  </section>
  <div class="pubHistory">
    <p></p>
  </div>
</body>
</html>
