<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">  <head>  <title>PixieDust: Declarative Incremental User Interface Rendering Through Static Dependency Tracking</title>  <!-- Copyright (c) 2010-2015 The MathJax Consortium --><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>  <meta name="viewport" content="width=device-width; initial-scale=1.0;"></meta>  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>  <link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/bootstrap.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/bootstrap-theme.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/main.css"/><script src="../../../data/dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script>  <script type="text/javascript"    src="../../../data/dl.acm.org/pubs/lib/js/MathJax.js?config=TeX-AMS_CHTML"></script>  <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>  </head>  <body id="main">  <section class="front-matter">   <section>    <header class="title-info">     <div class="journal-title">     <h1>      <span class="title">PixieDust: Declarative Incremental User Interface Rendering Through Static Dependency Tracking</span>      <br/>      <span class="subTitle"/>     </h1>     </div>    </header>    <div class="authorGroup">     <div class="author">     <span class="givenName">Nick ten</span>      <span class="surName">Veen</span>     Delft University of Technology, Delft, The Netherlands, <a href="mailto:n.tenveen@student.tudelft.nl">n.tenveen@student.tudelft.nl</a>     </div>     <div class="author">     <span class="givenName">Daco C.</span>      <span class="surName">Harkes</span>     Delft University of Technology, Delft, The Netherlands, <a href="mailto:d.c.harkes@tudelft.nl">d.c.harkes@tudelft.nl</a>     </div>     <div class="author">     <span class="givenName">Eelco</span>      <span class="surName">Visser</span>     Delft University of Technology, Delft, The Netherlands, <a href="mailto:e.visser@tudelft.nl">e.visser@tudelft.nl</a>     </div>                 </div>    <br/>    <div class="pubInfo">     <p>DOI: <a href="https://doi.org/10.1145/3184558.3185978" target="_blank">https://doi.org/10.1145/3184558.3185978</a>     <br/>WWW '18: <a href="https://doi.org/10.1145/3184558" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p>    </div>    <div class="abstract">     <p>     <small>Modern web applications are interactive. Reactive programming languages and libraries are the state-of-the-art approach for declaratively specifying these interactive applications. However, programs written with these approaches contain error-prone boilerplate code for efficiency reasons.</small>     </p>     <p>     <small>In this paper we present PixieDust, a declarative user-interface language for browser-based applications. PixieDust uses static dependency analysis to incrementally update a browser-DOM at runtime, without boilerplate code. We demonstrate that applications in PixieDust contain less boilerplate code than state-of-the-art approaches, while achieving on-par performance.</small>     </p>    </div>    <div class="classifications">     <div class="AcmReferenceFormat">     <p>      <small>       <span style="font-weight:bold;">ACM Reference Format:</span>       <br/>       Nick ten Veen, Daco C. Harkes, and Eelco Visser. 2018. PixieDust: Declarative Incremental User Interface Rendering Through Static Dependency Tracking. In <em>WWW '18 Companion: The 2018 Web Conference Companion,</em>       <em>April 23&#x2013;27, 2018 (WWW &#x2019;18 Companion),</em>       <em> Lyon, France. ACM, New York, NY, USA</em> 9 Pages. <a href="https://doi.org/10.1145/3184558.3185978" class="link-inline force-break"        target="_blank">https://doi.org/10.1145/3184558.3185978</a></small>     </p>     </div>    </div>   </section>  </section>  <section class="body">   <section id="sec-4">    <header>     <div class="title-info">     <h2>      <span class="section-number">1</span> Introduction</h2>     </div>    </header>    <p>Modern web applications are interactive. Data edits do not trigger page reloads, but in-place DOM updates. These DOM updates could be written by hand, but this is a tedious and error-prone exercise. A declarative, but naive, solution would be to rebuild the entire DOM from a declarative render function on each edit. However, DOM operations are slow, so this approach leads to unresponsive interfaces for large applications. Furthermore DOM elements would lose their local state (such as focus and event handlers). Current state-of-the art declarative solutions maintain a virtual DOM, and patch the browser DOM based on the diffs between virtual DOM renders. When data is edited, these solutions compare the view before and after the data edit and apply DOM updates to patch the difference. Since calculating the minimal difference between two trees is <em>O</em>(<em>n</em>     <sup>3</sup>)&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0005">5</a>], these solutions use <em>O</em>(<em>n</em>) non-minimal tree-diffing algorithms. Possible scalability issues with non-minimal tree diffing can be mitigated by identifying which sub-trees need to be updated on a change. However, the programmer is responsible for correctly identifying these sub-trees, which leads to boilerplate code.</p>    <p>In this paper we present PixieDust, a web programming language that enables concise declarative definition of user interfaces by automatic derivation of code to compute incremental view updates based on compile-time static dependency analysis. The contributions of this paper are:</p>    <ul class="list-no-style">     <li id="list1" label="&#x2022;">The design of the PixieDust language supporting concise and declarative definition of data model and view.<br/></li>     <li id="list2" label="&#x2022;">A static dependency analysis of the impact of model updates to views.<br/></li>     <li id="list3" label="&#x2022;">A mapping of PixieDust programs to an implementation in JavaScript of incremental view updates using the React framework as basis.<br/></li>     <li id="list4" label="&#x2022;">An evaluation showing that the performance of the approach is on-par with state-of-the-art approaches, with a factor 2 reduction in code size.<br/></li>    </ul>    <p>We proceed as follows. In the next section we analyze the state-of-the-art solutions, to see where error-prone boilerplate code is introduced. In Section&#x00A0;<a class="sec" href="#sec-6">3</a> we propose an approach for static dependency tracking to identify sub-trees for rerendering. In Section&#x00A0;<a class="sec" href="#sec-7">4</a> we present the PixieDust language for specifying data models and declarative views which incorporates this static dependency tracking. In Section&#x00A0;<a class="sec" href="#sec-8">5</a> we formally define the dependency analysis for PixieDust. In Section&#x00A0;<a class="sec" href="#sec-9">6</a> we formally define the operational semantics of PixieDust, detailing its interaction with the browser. In Section&#x00A0;<a class="sec" href="#sec-10">7</a> we evaluate our language design, and in Section&#x00A0;<a class="sec" href="#sec-11">8</a> we compare related work to PixieDust. <figure id="fig1">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-fig1.jpg" class="img-responsive" alt="Figure 1"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 1:</span>      <span class="figure-title">By default, the diffing algorithm of existing frameworks compare children in order. Adding a child node at the front causes all children to be completely rerendered. This issue can be fixed by manually adding identities to children.</span>     </div>     </figure>    </p>   </section>   <section id="sec-5">    <header>     <div class="title-info">     <h2>      <span class="section-number">2</span> Existing Approaches</h2>     </div>    </header>    <p>In this section we analyze techniques for efficient DOM updates used by state-of-the-art approaches and we identify problems with these techniques.</p>    <p>     <em>Linear Tree Diffing</em>.</p>    <p>All state-of-the-art approaches use linear tree diffing (for example React [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0002">2</a>]). Linear tree diffing algorithms compare old and new virtual DOM trees recursively per level. If the tag of a node is equal to the previous version, the browser DOM node remains intact. The attributes of intact nodes are compared, and any differences are patched in the DOM. The children of these nodes are traversed in the next level. If the tags are different, the entire node with its children are removed from the DOM and is rebuilt from scratch.</p>    <p>When children of a node are reordered, a linear diff algorithm cannot determine the new position of children. This means that instead of reordering the children, the children are replaced by each other. This can be very inefficient, for example when a child is added as first child (Figure&#x00A0;<a class="fig" href="#fig1">1</a>). Adding identities to children enables reordering in linear time (Figure&#x00A0;<a class="fig" href="#fig2">2</a>). However, it is the responsibility of the programmer to find suitable identities for the data structures that are being used and bind them to their sub-trees. <figure id="fig2">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-fig2.jpg" class="img-responsive" alt="Figure 2"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 2:</span>      <span class="figure-title">Identities (keys) on children increase performance, but add boilerplate code in MobX. This applies to all state-of-the-art solutions.</span>     </div>     </figure>     <figure id="fig3">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-fig3.jpg" class="img-responsive" alt="Figure 3"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 3:</span>      <span class="figure-title">Boilerplate code needed to dispatch a state update in Redux. The action is encoded as a plain javascript object which gets passed to a pure function by the runtime that processes all possible actions.</span>     </div>     </figure>    </p>    <p>     <em>Identifying which parts of the DOM-tree need updating</em>.</p>    <p>It is unnecessary to diff the entire tree structure when entire parts of the tree do not depend on the changes that were made. If a sub-tree is parameterized by the set of values it depends on, that information can be used to only diff when these values changed. There are multiple approaches to achieve this.</p>    <p>The first approach is to use immutable data. Elm [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0004">4</a>] and Redux [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0003">3</a>] use this approach. With immutable data structures and pure view functions, reference equality can be used to determine whether a sub-tree needs to be rerendered. When a value changes, only the node where that value is displayed, and the spine to the root of the tree are recalculated. Since immutable data structures cannot contain cycles, programmers need to use a tree structured data model. Since immutable data cannot be updated in place, solutions with immutable data use message passing to encode updates. These messages are dispatched to a pure function calculating the new state based on the previous state. This optimization does come with a lot of boilerplate: each action needs to be encoded in a data structure, and when these actions are decoded, the relevant part of the state needs to be looked up and modified (Figure&#x00A0;<a class="fig" href="#fig3">3</a>).</p>    <p>An alternative approach to localize DOM diffing is to construct a dependency graph for views. That way views can observe writes that are made to their dependencies to trigger a rerender. Hence, calls to setters on data are automatically reflected in the user interface. MobX [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>] is a framework that constructs the dependency graph dynamically while rendering. To achieve this at runtime, MobX relies on wrapping get and set operations of data. However, this can lead to subtle bugs where a child component is passed a value instead of the getter for that value.</p>    <p>     <em>Summary</em>. In conclusion, all state-of-the-art solutions induce error-prone boilerplate code. All solutions require identity annotations on lists. The immutable data solutions (Elm and Redux) require encoding of data modifications into action objects, and the mutable data solution (MobX) traps getters and setters (which can accidentally be circumvented in JavaScript).</p>   </section>   <section id="sec-6">    <header>     <div class="title-info">     <h2>      <span class="section-number">3</span> Static dependency tracking</h2>     </div>    </header>    <figure id="fig4">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-fig4.jpg" class="img-responsive" alt="Figure 4"      longdesc=""/>     <div class="figure-caption">     <span class="figure-number">Figure 4:</span>     <span class="figure-title">Miniature ToDo application data model and view</span>     </div>    </figure>    <p>The state-of-the-art client-side application frameworks induce error-prone boilerplate code and their assumptions can be accidentally violated leading to subtle bugs. We propose to use static dependency tracking as a solution to these issues. <em>Static</em> dependency tracking does not trap getters and setters at runtime (such as MobX), but instead (over)approximates the dependency structure at compile-time. View definitions reference parts of the data model. These references can be statically determined, and this can be used to decide which views should be rerendered after a data modification.</p>    <p>To illustrate how to statically derive dependencies, we consider a miniature ToDo application (Figure&#x00A0;<a class="fig" href="#fig4">4</a>). A <tt>TodoList</tt> holds zero or more <tt>Todo</tt>s. A <tt>Todo</tt> has a <tt>description</tt> and a <tt>finished</tt> flag. The view for a <tt>TodoList</tt> is a <tt>div</tt> containing a <tt>ul</tt> with a <tt>li</tt> for every item. Every <tt>Todo</tt> is rendered as a checkbox for the <tt>finished</tt> status and a <tt>span</tt> for the <tt>description</tt>.</p>    <p>By analyzing the body of the views, we can collect all referenced paths. The <tt>itemView</tt> references both fields of the <tt>Todo</tt>. The <tt>TodoList.view</tt> references the <tt>itemView</tt> of its <tt>todos</tt>. This means that this view needs to be updated both when a referenced <tt>itemView</tt> changes and when the <tt>todos</tt> list changes itself. Together, the application contains the following dependencies:</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-graphic5.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>These dependencies can be inverted to get the data flow of the application. To be able to invert dependencies that reference <tt>todos</tt>, we need an <em>inverse</em>. Figure&#x00A0;<a class="fig" href="#fig4">4</a> defines the inverse of <tt>todos</tt> as <tt>Todo.list</tt>. When we invert dependencies we obtain the following data flow:</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-graphic6.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>This data flow can be used to trigger rerendering of views on data modifications. Moreover, since views are parameterized by an entity, we can automatically assign keys to collections, without unnecessary boilerplate code.</p>    <p>We have designed and implemented PixieDust, a new language for declarative definition of user interfaces in the browser based on this dependency analysis. We will formalize this dependency analysis in Section&#x00A0;<a class="sec" href="#sec-8">5</a>, but first we will discuss the design of PixieDust.</p>   </section>   <section id="sec-7">    <header>     <div class="title-info">     <h2>      <span class="section-number">4</span> PixieDust</h2>     </div>    </header>    <p>PixieDust is a language for specifying data models and browser-based user interfaces that separates the concerns of model and view, literally by keywords (for example Figure&#x00A0;<a class="fig" href="#fig4">4</a>). Everything defined in the data model is visible in the view, but not vice versa. <figure id="fig5">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-fig5.jpg" class="img-responsive" alt="Figure 5"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 5:</span>      <span class="figure-title">TodoList views: the TodoList view has a header with an input field for adding new todos; a list of all todos; and a footer with the number of todos left, a filter for which todos to show, and a button for removing finished todos.</span>     </div>     </figure>     <figure id="fig6">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-fig6.jpg" class="img-responsive" alt="Figure 6"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 6:</span>      <span class="figure-title">TodoList view state: the view state contains a field to store the input for adding new items, a field for filtering visible items, and fields for computing visible items.</span>     </div>     </figure>    </p>    <p>     <em>Data Model</em>. For the data model we use the existing IceDust data modeling language&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0007">7</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0008">8</a>]. In IceDust, a data model consists of <em>entities</em> with <em>fields</em>. All fields have a type and a <em>multiplicity</em>. The multiplicities in IceDust are 1, ?, *, and + (similar to regular expressions and highlighted in red in examples). If multiplicities are omitted, they default to 1. Fields with an entity-type have an <em>inverse</em>. Whenever an object refers from such a field to another object, the other object refers back from its inverse field. Lastly, IceDust features <em>derived value</em> fields: fields for which the value is calculated. For example, we can extend the <tt>TodoList</tt> in Figure&#x00A0;<a class="fig" href="#fig4">4</a> with a field indicating whether all todos are finished and how many are left:</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-graphic9.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>     <em>View</em>.</p>    <p>In PixieDust we define views in the context of an entity (Figure&#x00A0;<a class="fig" href="#fig5">5</a>). The <tt>View</tt> type is a (virtual) DOM node. Inside a view, the fields of the context entity can be concisely accessed by referring to them. Other views of the same entity also can be referenced directly, and views of other entities can be referenced by member access. This makes for concise definitions of views in PixieDust.</p>    <p>The view of a model might contain state. In our example we have the state of the input field for adding new todos. To separate the concerns of data model and view, we do not add this state to the data model, but introduce view state. View state fields can be of any type and are scoped by a context entity (Figure&#x00A0;<a class="fig" href="#fig6">6</a>). View state supports the same kind of derived values as the data model. For example we derive the visible todos collection in Figure&#x00A0;<a class="fig" href="#fig6">6</a>.</p>    <p>User interfaces should support user interaction with the application. In PixieDust, actions declaratively describe data modification (Figure&#x00A0;<a class="fig" href="#fig7">7</a>). Actions are also scoped by an entity, this makes for concise definitions. Both the data model and view state can be accessed within actions. Moreover, new objects can be created (see <tt>addTodo</tt>) and old objects can be left for garbage collection (see <tt>deleteTodo</tt>). <figure id="fig7">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-fig7.jpg" class="img-responsive" alt="Figure 7"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 7:</span>      <span class="figure-title">ToDo application actions: items can be toggled, deleted and added; and for a list all items can be toggled, all finished items can be deleted, and the filter can be changed.</span>     </div>     </figure>    </p>    <p>Often an input element reads and writes to a specific field of an entity. One could program an action for each field, but that is tedious. For concise UI specifications, a language should support bidirectional mappings between user interface and data model. PixieDust provides built-in bidirectional mappings for primitive data types (<tt>BooleanInput</tt> and <tt>StringInput</tt> in Figure&#x00A0;<a class="fig" href="#fig5">5</a>). In future work we would like to explore user-defined bidirectional mappings.</p>    <p>     <em>Example</em>.</p>    <p>Figures&#x00A0;<a class="fig" href="#fig4">4</a>-<a class="fig" href="#fig7">7</a> contain an almost complete specification of a full ToDo application in PixieDust. The only thing missing is the definition of two functions (Figure&#x00A0;<a class="fig" href="#fig8">8</a>). Together, these figures form a concise specification of a complete ToDo application. Moreover, this application is incremental: derived values are only recalculated and views are only rerendered when needed. <figure id="fig8">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-fig8.jpg" class="img-responsive" alt="Figure 8"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 8:</span>      <span class="figure-title">Functions in ToDo application facilitate reuse</span>     </div>     </figure>    </p>   </section>   <section id="sec-8">    <header>     <div class="title-info">     <h2>      <span class="section-number">5</span> Dependency and Data-Flow Analysis</h2>     </div>    </header>    <p>In Section&#x00A0;<a class="sec" href="#sec-6">3</a> we introduced static dependency tracking as a way to get rid of error-prone dynamic dependency boilerplate code. In this section we formalize this static dependency analysis. The analysis is based on the dependency analysis of IceDust [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0007">7</a>]. In this paper we extend it with analysis for functions and views.</p>    <p>     <em>Dependencies between Fields in Data Model</em>. First, we recap the analysis of dependencies between fields from IceDust. To illustrate the analysis we extend Figure&#x00A0;<a class="fig" href="#fig4">4</a> with <tt>allFinished</tt> which is the <tt>conj</tt>unction of the finished fields:</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-graphic12.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>The dependencies of a field are all fields which are needed to compute the derived value of that field. The dependencies are reachable from the entity containing the field via a path. A dependency is denoted by (<em>Ent</em>.<em>Field</em> &#x2190; <em>&#x03C0;</em>), where <em>Ent</em>.<em>Field</em> is a field and <em>&#x03C0;</em> is the path to a field.</p>    <p>Computing the dependencies requires extracting paths from expressions defining field values. The <em>path-based abstract interpretation</em> relation (Figure&#x00A0;<a class="fig" href="#fig9">9</a>) defines the dependency paths of an expression. We use the notation (<em>Expr</em>&#x2198;{<em>&#x03C0;</em>}{<em>&#x03C1;</em>}), where <em>Expr</em> is the expression that is abstractly interpreted, and {<em>&#x03C0;</em>} and {<em>&#x03C1;</em>} are the sets of paths defined by the abstract interpretation. The paths in {<em>&#x03C0;</em>} are extended by surrounding expressions, while the paths in {<em>&#x03C1;</em>} are not. The <tt>if</tt> only extends paths in the second and third operand, so <em>&#x03A0;</em>     <sub>1</sub> is passed to {<em>&#x03C1;</em>}. All paths start with <tt>this</tt> [This] or with navigation [NavStart]. When navigating by means of <tt>e.m</tt> all dependency paths in {<em>&#x03C0;</em>} are extended with <tt>.m</tt> [Nav]. Operators just pass on all paths [UnOp, BinOp], and literals do not contain any paths [Literal]. Path-based abstract interpretation of the expression defining <tt>allFinished</tt> produces a set with a single path:</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-graphic13.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>The <em>dependencies</em> relation (Figure&#x00A0;<a class="fig" href="#fig9">9</a>) defines the dependencies of a field and a full program. We use the notation <em>Field</em>|<em>Prog</em>&#x2198;&#x2198;{(<em>Ent</em>.<em>Field</em> &#x2190; <em>&#x03C0;</em>)} where <em>Field</em>|<em>Prog</em> is a field or full program, and {(<em>Ent</em>.<em>Field</em> &#x2190; <em>&#x03C0;</em>)} is a set of dependencies. When a field depends on the value at the end of a path, it also depends on the relations en route. So the rule for fields [Field] takes the transitive prefix of the paths of its expression. As paths are concatenated later, the <tt>this</tt> is removed from paths. The paths for our example are:</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-graphic14.jpg" class="img-responsive" alt=""      longdesc=""/>     <figure id="fig9">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-fig9.jpg" class="img-responsive" alt="Figure 9"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 9:</span>      <span class="figure-title">Dependency relation by path extraction</span>     </div>     </figure>     <figure id="fig10">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-fig10.jpg" class="img-responsive" alt="Figure 10"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 10:</span>      <span class="figure-title">Data flow relation by inverting dependencies</span>     </div>     </figure> The data flow from a field is the set of all fields that depend on it to compute their value. The data flow relation is the inverse of the dependency relation. We use (<em>Ent</em>.<em>Field</em> &#x2192; <em>&#x03C0;</em>) to denote the data flow relation from the source, <em>Ent</em>.<em>Field</em>, to the target, the end of the path <em>&#x03C0;</em>.</p>    <p>The <em>dependency inversion</em> relation, (<em>Ent</em>.<em>Field</em> &#x2190; <em>&#x03C0;</em>)&#x2197;(<em>Ent</em> .<em>Field</em> &#x2192; <em>&#x03C0;</em>), in Figure&#x00A0;<a class="fig" href="#fig10">10</a> defines the inverse of a dependency. A dependency is inversed by swapping source and target, and inverting the path <em>&#x03C0;</em> to get the path from target to source. The function <tt>inv-path(<em>&#x03C0;</em>)</tt> inverts the names on the path, and inverts their order. Name inversion is selecting the name on the opposing side of a bidirectional relation. The resulting data flow in our example is:</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-graphic17.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>     <em>Dependencies with Filter, Find, and OrderBy</em>.</p>    <p>Note that IceDust&#x00A0;2&#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0008">8</a>] introduced <tt>filter</tt>, <tt>find</tt>, and <tt>orderBy</tt>, but did not document the dependency analysis for these. To illustrate the analysis of these, consider adding the following to <tt>TodoList</tt>:</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-graphic18.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>The rule [Col] (Figure&#x00A0;<a class="fig" href="#fig9">9</a>) covers these expressions containing a lambda. The occurrence of the parameter <tt>x</tt> in the paths of the body of the lambda are replaced with the paths of the argument. For our example replacing the <tt>x</tt> in <tt>x.finished</tt> with {<tt>todos</tt>} yields:</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-graphic19.jpg" class="img-responsive" alt=""      longdesc=""/>     <figure id="fig11">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-fig11.jpg" class="img-responsive" alt="Figure 11"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 11:</span>      <span class="figure-title">The PixieDust runtime has four stores. The entity store (<em>&#x03A3;</em>) maps object fields to user value, cached value, dirty flag, and subscribed components. The component store (C) maps components to object fields and a mounted flag. The queue (Q) is a global list of elements that need to be rerendered, and the frame (F) is a reference to a requested animation frame.</span>     </div>     </figure>    </p>    <p>     <em>Dependencies with Functions</em>.</p>    <p>In this paper we extend the dependency analysis with support for functions. As an example for functions we use our specification of <tt>todosLeft</tt> by using a function for counting the number of elements equal to <tt>false</tt>:</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-graphic21.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>Rule [Fun] in Figure&#x00A0;<a class="fig" href="#fig9">9</a> covers user-defined functions. The dependency paths of a function call are defined as the dependency paths of the function definition expression, with all occurrences of argument names replaced by the paths of the arguments at the call site. Note that these are all sets of paths, so functions <tt>replace-id*</tt> and <tt>replace-ids</tt> operate on sets. If we apply the analysis to our example, the paths of the function body are:</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-graphic22.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>The call from <tt>numLeft</tt> has the following <em>named</em> paths:</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-graphic23.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>Applying replacement yields the dependencies for <tt>numLeft</tt>:</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-graphic24.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>Note that this is identical to our original definition of <tt>numLeft</tt>.</p>    <p>PixieDust does not support direct recursive functions. In order to provide incremental behavior each recursive step should be cached. So recursion is supported through materializing the intermediate results in a field. For example,</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-graphic25.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>     <em>Dependencies between Views</em>.</p>    <p>In Section&#x00A0;<a class="sec" href="#sec-7">4</a> we introduced view state and <tt>View</tt>s as a new data type for fields in the view state. The dependency analysis treats view state fields equal to data model fields. However, views (fields of type <tt>View</tt>) that are related through containment, do not depend on each other. Views are updated <em>in place</em> inside the DOM, so &#x2019;parent&#x2019; views do not have to be notified of change. We will cover this in more detail in the next section.</p>   </section>   <section id="sec-9">    <header>     <div class="title-info">     <h2>      <span class="section-number">6</span> Operational Semantics</h2>     </div>    </header>    <p>In this section we describe the dynamic semantics of rendering PixieDust applications. Our compiler (PixieDust-to-JavaScript) uses the React rendering framework. Analogously, our semantics use semantic functions which correspond to the React and browser APIs calls and callbacks at runtime. Our semantics extend the IceDust&#x00A0;2 semantics for incremental calculation [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0008">8</a>]. (Semantic functions are typeset in bold, and IceDust&#x00A0;2 calls are typeset in italic.)</p>    <p>We specify the operational semantics of PixieDust using big-step semantics. The reduction rules modify four stores (Figure&#x00A0;<a class="fig" href="#fig11">11</a>). The first store (<em>&#x03A3;</em>) is the IceDust data store. We extend this store to include a list of components which should be notified of change per field: subscriptions. Note that we also store view state and rendered virtual DOMs in this store. The second store (C) contains meta data for React Components: which view-state field contains the rendered virtual DOM, and whether the component is currently mounted. The third store (Q) is a queue of views scheduled for rerendering, and the fourth store (F) refers to the next requested animation frame. In our rules we omit stores if they are not modified. When a store is omitted, it is implicitly threaded from left to right.</p>    <p>The evaluation rules are designed such that we only rerender views when needed, and only rerender them at most once per data modification. The rules in Figure&#x00A0;<a class="fig" href="#fig12">12</a> define what to do on data modifications. We override IceDust&#x0027;s [FlagDirty] rule to schedule renders on all subscriptions as soon as a field is marked as dirty. This does not rerender those views directly, but schedules them in the queue [Schedule]. Moreover, if this was the first view to be scheduled for rerender, we schedule a browser rerender with <strong>requestAnimationFrame</strong>. This method tells the browser that we want to perform an action before the next frame will be painted. In this way we can batch all effects of data modifications on the UI, avoiding double rerendering. <figure id="fig12">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-fig12.jpg" class="img-responsive" alt="Figure 12"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 12:</span>      <span class="figure-title">Evaluation rules for modifications to data</span>     </div>     </figure>     <figure id="fig13">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-fig13.jpg" class="img-responsive" alt="Figure 13"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 13:</span>      <span class="figure-title">Evaluation rules for render</span>     </div>     </figure>    </p>    <p>The rules in Figure&#x00A0;<a class="fig" href="#fig13">13</a> define what to do on a render. When the browser wants to display the next frame, it will call <strong>onAnimationFrame</strong>. On this call, the PixieDust runtime forces all mounted React components to be rerendered with <strong>forceUpdate</strong> [Render]. React then updates the browser DOM with the diffs from the virtual DOM, before the next frame is rendered. <figure id="fig14">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-fig14.jpg" class="img-responsive" alt="Figure 14"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 14:</span>      <span class="figure-title">Evaluation rules for component life cycle</span>     </div>     </figure>    </p>    <p>In this process, React will call various life cycle callbacks on components. Figure&#x00A0;<a class="fig" href="#fig14">14</a> defines what happens on various life cycle callbacks. The goal of these rules is to maintain a precise list of which data from the entity store is visible through views. First, rules [Mount, Unmt] keep track of whether components are currently mounted in the browser-DOM. Non-mounted components are not forced to update on a render [Render]. Second, the rules in Figure&#x00A0;<a class="fig" href="#fig14">14</a> maintain the <em>subs</em> fields in the entity store. The <em>subs</em> fields only contain components which depend on the field, and which are mounted. Note that we never have subscribers for view-typed fields [AddSub], since views are updated in place in the DOM (as discussed in Section&#x00A0;<a class="sec" href="#sec-8">5</a>). This way, only the minimal number of components is scheduled for rerendering when data is modified.</p>    <p>Finally, when React wants to update a view it calls <strong>render</strong>. This call is forwarded to IceDust&#x0027;s incremental evaluation for derived values which computes the virtual DOM for that view [Render].</p>    <p>Together, these evaluation rules minimize the amount of rerendering. In the next section we will evaluate the performance of our implementation. In this semantics we did not cover how actions work. However, the execution of actions is fairly straightforward, and we want to focus this paper on incremental rendering.</p>   </section>   <section id="sec-10">    <header>     <div class="title-info">     <h2>      <span class="section-number">7</span> evaluation</h2>     </div>    </header>    <p>We evaluate PixieDust with respect to two criteria: (1) reduction of error-prone boilerplate code, and (2) performance relative to state-of-the-art approaches. Our running example in this paper has been a ToDo application. More precisely, it is exactly the application from <a class="link-inline force-break" href="http://todomvc.com">todomvc.com</a>. TodoMVC compares frameworks through implementations of this ToDo application. We use this application to compare conciseness and performance.</p>    <div class="table-responsive" id="tab1">     <div class="table-caption">     <span class="table-number">Table 1:</span>     <span class="table-title">Lines of code for different todo list implementations. Implementations are stripped of features that are not shared between other implementations.</span>     </div>     <table class="table">     <tbody>      <tr>       <td style="text-align:left;"/>       <td style="text-align:right;">PixieDust</td>       <td style="text-align:right;">MobX/React</td>       <td style="text-align:right;">React</td>       <td style="text-align:right;">React/Redux</td>       <td style="text-align:right;">Elm</td>      </tr>      <tr>       <td style="text-align:left;">LOC</td>       <td style="text-align:right;">74</td>       <td style="text-align:right;">193</td>       <td style="text-align:right;">259</td>       <td style="text-align:right;">276</td>       <td style="text-align:right;">300</td>      </tr>     </tbody>     </table>    </div>    <p>     <em>Conciseness</em>. The goal of PixieDust is to remove error-prone boilerplate code. To asses this, we look at the number of lines of code of the todo application in different approaches. We have taken the reference implementations for TodoMVC of MobX and vanilla React from <a class="link-inline force-break" href="http://todomvc.com">todomvc.com</a>, the implementation for Redux from their repository<a class="fn" href="#fn1" id="foot-fn1"><sup>1</sup></a>, and the implementation for Elm from the author of Elm<a class="fn" href="#fn2" id="foot-fn2"><sup>2</sup></a>. Since not all implementations have the same features, we stripped off features that are not shared between all todo implementations. We used <tt>cloc</tt> for counting the lines of code, except for PixieDust which we had to count by hand.</p>    <p>The results are compiled in Table&#x00A0;<a class="tbl" href="#tab1">1</a>. Indeed, the PixieDust programs are more concise than the same programs in the state-of-the-art approaches. This is expected, as PixieDust is a domain-specific language with tailored syntax, while the state-of-the-art approaches are JavaScript libraries or general purpose languages.</p>    <p>     <em>Performance</em>. The <tt>todomvc performance benchmarks</tt> is an existing online benchmark suite for TodoMVC<a class="fn" href="#fn3" id="foot-fn3"><sup>3</sup></a>. This benchmark adds 50 tasks to a single todo list, marks all of them completed one by one and deletes them afterwards. We added an entry for a PixieDust implementation of the Todo application. The results of this benchmark can be seen in Figure&#x00A0;<a class="fig" href="#fig15">15</a>. PixieDust has on-par performance according to this benchmark. <figure id="fig15">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-fig15.jpg" class="img-responsive" alt="Figure 15"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 15:</span>      <span class="figure-title">TodoMVC online performance benchmark shows PixieDust performs comparable.</span>     </div>     </figure>    </p>    <p>Unfortunately, the TodoMVC benchmark does not benchmark all features. Moreover, the implementations of the various state-of-the-art systems have not been kept up to date (last commit November 2015). So, we created a new benchmark that considers more features<a class="fn" href="#fn4" id="foot-fn4"><sup>4</sup></a>. To make the benchmark more representative for larger applications we extended the ToDo application to support todo items which are lists themselves. A list is finished if all child lists and items are finished:</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-graphic30.jpg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>None of the TodoMVC entries featured nested todo lists. Since MobX is closest in conciseness and also based on mutable data structures, we&#x0027;ve extended its implementation with nested lists to compare against. Our test can be parameterized by several properties that influences the size and shape of the nested todo list:</p>    <ul class="list-no-style">     <li id="list5" label="&#x2022;"><strong>Depth</strong> defines the depth of nested todo lists from the root.<br/></li>     <li id="list6" label="&#x2022;"><strong>Children</strong> defines how many child lists are added per list.<br/></li>     <li id="list7" label="&#x2022;"><strong>Todos</strong> defines how many todos are added per list.<br/></li>    </ul>    <p>We run the benchmark on five data sets (Table&#x00A0;<a class="tbl" href="#tab2">2</a>). A test trace executes the following steps. The input field of the root list is selected. For each todo that needs to be added, three alphabetic characters are entered and the enter key is pressed to add it to the list. Next, the toggle all button is pressed twice to select and deselect all todos of the list and its children. After that, half of the todos of the list are finished one by one, and then one third of the todos are deleted individually. After this, all the filters are selected once, and the &#x201D;Clear finished todos&#x201D; button is pressed. Finally, if we have not yet reached the required depth, the specified amount of child lists is added to the list and this procedure is recursively repeated for each child.</p>    <p>To ensure that no renders are skipped, each action awaits the next animation frame before executing. The timings are recorded with the Chrome runtime performance recorder which reports scripting (executing JavaScript), rendering (the browser painting), and other (not categorized). During a test, the number of times a specific view component is rendered is counted. The todo list application has four components: <strong>Header</strong>, <strong>Footer</strong>, <strong>List</strong>, and <strong>Todo</strong>. The benchmarks were performed on a 2017 Macbook Pro laptop with Intel Core i7 2,6Ghz, 4 cores (8 threads), and 16 GB memory.</p>    <div class="table-responsive" id="tab2">     <div class="table-caption">     <span class="table-number">Table 2:</span>     <span class="table-title">Test properties for benchmarking (depth, degree, and number of leaves of nested ToDo tree) and total number of user interactions performed during execution trace.</span>     </div>     <table class="table">     <tbody>      <tr>       <td style="text-align:left;">Framework</td>       <td style="text-align:right;">Depth</td>       <td style="text-align:right;">Children</td>       <td style="text-align:right;">Todos</td>       <td style="text-align:right;">#Actions</td>       <td style="text-align:right;">&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;</td>      </tr>      <tr>       <td style="text-align:left;">Balanced</td>       <td style="text-align:right;">4</td>       <td style="text-align:right;">3</td>       <td style="text-align:right;">5</td>       <td style="text-align:right;">1120</td>       <td style="text-align:right;"/>      </tr>      <tr>       <td style="text-align:left;">Deep</td>       <td style="text-align:right;">10</td>       <td style="text-align:right;">1</td>       <td style="text-align:right;">5</td>       <td style="text-align:right;">280</td>       <td style="text-align:right;"/>      </tr>      <tr>       <td style="text-align:left;">Deeper</td>       <td style="text-align:right;">25</td>       <td style="text-align:right;">1</td>       <td style="text-align:right;">5</td>       <td style="text-align:right;">700</td>       <td style="text-align:right;"/>      </tr>      <tr>       <td style="text-align:left;">Wide</td>       <td style="text-align:right;">2</td>       <td style="text-align:right;">100</td>       <td style="text-align:right;">2</td>       <td style="text-align:right;">1414</td>       <td style="text-align:right;"/>      </tr>      <tr>       <td style="text-align:left;">Leaves</td>       <td style="text-align:right;">1</td>       <td style="text-align:right;">1</td>       <td style="text-align:right;">100</td>       <td style="text-align:right;">475</td>       <td style="text-align:right;"/>      </tr>     </tbody>     </table>    </div>    <figure id="fig16">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-fig16.jpg" class="img-responsive" alt="Figure 16"      longdesc=""/>     <div class="figure-caption">     <span class="figure-number">Figure 16:</span>     <span class="figure-title">Average time per action on tests from Table&#x00A0;<a class="tbl" href="#tab2">2</a>. Solid bars are PixieDust, striped bars are MobX/React.</span>     </div>    </figure>    <figure id="fig17">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3185978/images/www18companion-39-fig17.jpg" class="img-responsive" alt="Figure 17"      longdesc=""/>     <div class="figure-caption">     <span class="figure-number">Figure 17:</span>     <span class="figure-title">Total number of renders on tests from Table&#x00A0;<a class="tbl" href="#tab2">2</a>. Solid bars are PixieDust, striped bars are MobX/React.</span>     </div>    </figure>    <p>The results of the benchmark are compiled in Figures&#x00A0;<a class="fig" href="#fig16">16</a> and <a class="fig" href="#fig17">17</a>. In general, most tests have the same total execution time between frameworks, but the rerenders counts vary.</p>    <p>First, MobX renders the Todo view significantly more often than PixieDust. Whenever a new task is added to a list, all todo items are rendered again. This is caused by the fact that while rendering the list header, the derived value <span class="inline-equation"><span class="tex">$\inlinepix$</span>     </span>allFinished is calculated, which calls the getter on the finished field of each todo through the <span class="inline-equation"><span class="tex">$\inlinepix$</span>     </span>finishedTodos derived value. In the &#x2019;Leaves&#x2019; test, MobX also spends significantly more time processing JavaScript, presumably for this very reason.</p>    <p>Second, PixieDust renders the header component significantly more often when the depth is larger. This is caused by dirty flagging <tt>allFinished</tt> transitively along the spine of the tree whenever a modification is done in a todos list. Even when the value stays the same, a render is triggered. This is a limitation of lazy incrementality. In future work we might explore eager incremental evaluation which can detect if a dirty flagged value stays the same.</p>    <p>In conclusion, PixieDust outperforms MobX in some situations, and is outperformed by MobX in other situations. In general, PixieDust&#x0027;s performance is on-par with MobX while reducing lines of code.</p>   </section>   <section id="sec-11">    <header>     <div class="title-info">     <h2>      <span class="section-number">8</span> Related Work</h2>     </div>    </header>    <p>The related work is organized in two groups: reactive user-interface languages and incremental computing. The first group we divided in functional (immutable data) and declarative approaches.</p>    <p>     <em>Functional Reactive UIs</em>.</p>    <p>Elm is a functional reactive language for graphical user interfaces [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0004">4</a>]. Newer versions of Elm dropped the support for signals in favor of a simpler model. An application is split up in three parts: The model, the view and the update logic. The update logic takes events that might be triggered by the view or other sources and recompute the next state. While this model gives a clear separation of concerns, it does involve boilerplate code to achieve this.</p>    <p>Redux [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0003">3</a>] embraces the same pattern but integrates it in React and Javascript as a library. It has the same advantages and disadvantages as Elm. We covered the issues with these approaches in detail in Section&#x00A0;<a class="sec" href="#sec-5">2</a>.</p>    <p>Flapjax is a Javascript library for defining web applications using behaviors and event streams [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0010">10</a>]. In Flapjax data flow can be manually constructed by combining event sources and piping these to sinks. This model enables reactive programming, but hooking up reactive values to the DOM is still manual. Furthermore, the programmer is responsible for identifying where to hook up reactive values, which is error prone.</p>    <p>Reynders et.al. implemented a FRP library in Scala [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0011">11</a>]. They analyze different design trade-offs for FRP libraries that interact with the DOM. Based on these trade-offs, they implement a DOM UI library that uses push-pull FRP. Our approach also uses push-pull, push for marking things dirty, and pull for calculating by need. However, in our approach this behavior is hidden behind a declarative language.</p>    <p>UI.Next [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0006">6</a>] is a UI library in F#. It connects data sources to views by creating a dynamic data flow graph. The monoidal structure of its DOM elements enables composition of views. It requires higher-order functions to compose, which makes the code less declarative.</p>    <p>     <em>Declarative Reactive UIs</em>.</p>    <p>MobX [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>] is a state management library. By annotating the variables in a data structure which change over time, MobX can construct a dependency graph at runtime. In contrast, our approach does static runtime dependency tracking. We covered MobX extensively in Section&#x00A0;<a class="sec" href="#sec-5">2</a>.</p>    <p>Reactive variables [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0013">13</a>] aim to reduce the boilerplate in programming with signals by adding syntactic sugar for reactive variables. These reactive variables are similar to our approach in the sense that they hide the fact that these variables have a <tt>Signal<T></tt> type. Their approach is also compiled to JavaScript, but they do not detail how to interact with the DOM.</p>    <p>Mobl [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0009">9</a>] is a language to declaratively construct interactive mobile applications. The data model defines entities and bidirectional relations between entities, similar to the data model we use. Views can be parameterized by these entities which can be modified via input events. However, their interface language is geared toward phone screens, while ours is focused on browser-DOMs.</p>    <p>     <em>Incremental Computing</em>.</p>    <p>IceDust [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0007">7</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0008">8</a>] is a declarative data modeling language with derived values and bidirectional relations. It features incremental calculation for derived values. However, it does not have any support for views. In this paper we have extended their approach for incremental computing to cover views in the browser.</p>    <p>Functional Reactive programming can be used for incremental computing. In FRP implementations, like REScala [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0012">12</a>], signals propagate through their dependencies. That means that when a value changes, only relevant parts of the data flow are recalculated. However, this approach does not suffice for browser-based views. Because the DOM is a tree structure, composed views will propagate their signals up the spine of the tree, which triggers unnecessary rerenders.</p>   </section>   <section id="sec-12">    <header>     <div class="title-info">     <h2>      <span class="section-number">9</span> Conclusion</h2>     </div>    </header>    <p>In this paper we have presented PixieDust, a declarative user-interface language for browser-based applications. PixieDust uses static dependency analysis to incrementally update a browser-DOM at runtime. We have demonstrated that applications in PixieDust contain less boilerplate code than state-of-the-art approaches, while achieving on-par performance.</p>    <p>Our research also raises new research questions. First, can we refine our approach so it will perform better? Will eager incremental calculation of views, with the ability to short-circuit updates if values stay the same, perform better? And second, what would be a good language design for user-defined bidirectional mappings between data model and user interface?</p>   </section>   <section id="sec-13">    <header>     <div class="title-info">     <h2>ACKNOWLEDGMENTS</h2>     </div>    </header>    <p>This research was partially funded by the NWO VICI Language Designer&#x0027;s Workbench NWO VICI project (639.023.206 NWO).</p>    <section id="ref-001">     <header>     <div class="title-info">      <h2 class="page-brake-head">REFERENCES</h2>     </div>     </header>     <ul class="bibUl">     <li id="BibPLXBIB0001" label="[1]">2017. MobX. https://web.archive.org/web/20171008145333/https://mobx.js.org/. (2017). Accessed: 2017-11-04.</li>     <li id="BibPLXBIB0002" label="[2]">2017. React. https://web.archive.org/web/20171104234320/https://reactjs.org/. (2017). Accessed: 2017-11-04.</li>     <li id="BibPLXBIB0003" label="[3]">2017. Redux. http://web.archive.org/web/20171104000918/https://redux.js.org/. (2017). Accessed: 2017-11-04.</li>     <li id="BibPLXBIB0004" label="[4]">Evan Czaplicki and Stephen Chong. 2013. Asynchronous functional reactive programming for GUIs. In <em>       <em>PLDI</em>      </em>. 411&#x2013;422. <a class="link-inline force-break" href="https://doi.org/10.1145/2491956.2462161"       target="_blank">https://doi.org/10.1145/2491956.2462161</a></li>     <li id="BibPLXBIB0005" label="[5]">Erik&#x00A0;D. Demaine, Shay Mozes, Benjamin Rossman, and Oren Weimann. 2009. An optimal decomposition algorithm for tree edit distance. <em>       <em>TALG</em>      </em>6, 1 (2009). <a class="link-inline force-break" href="https://doi.org/10.1145/1644015.1644017"       target="_blank">https://doi.org/10.1145/1644015.1644017</a></li>     <li id="BibPLXBIB0006" label="[6]">Simon Fowler, Lo&#x00EF;c Denuzi&#x00E8;re, and Adam Granicz. 2015. Reactive Single-Page Applications with Dynamic Dataflow. In <em>       <em>PADL</em>      </em>. 58&#x2013;73. <a class="link-inline force-break"       href="https://doi.org/10.1007/978-3-319-19686-2_5"       target="_blank">https://doi.org/10.1007/978-3-319-19686-2_5</a></li>     <li id="BibPLXBIB0007" label="[7]">Daco Harkes, Danny&#x00A0;M. Groenewegen, and Eelco Visser. 2016. IceDust: Incremental and Eventual Computation of Derived Values in Persistent Object Graphs. In <em>       <em>ECOOP</em>      </em>. <a class="link-inline force-break"       href="https://doi.org/10.4230/LIPIcs.ECOOP.2016.11"       target="_blank">https://doi.org/10.4230/LIPIcs.ECOOP.2016.11</a></li>     <li id="BibPLXBIB0008" label="[8]">Daco Harkes and Eelco Visser. 2017. IceDust 2: Derived Bidirectional Relations and Calculation Strategy Composition. In <em>       <em>ECOOP</em>      </em>. <a class="link-inline force-break"       href="https://doi.org/10.4230/LIPIcs.ECOOP.2017.14"       target="_blank">https://doi.org/10.4230/LIPIcs.ECOOP.2017.14</a></li>     <li id="BibPLXBIB0009" label="[9]">Zef Hemel and Eelco Visser. 2011. Declaratively programming the mobile web with Mobl. In <em>       <em>OOPSLA</em>      </em>. 695&#x2013;712. <a class="link-inline force-break" href="https://doi.org/10.1145/2048066.2048121"       target="_blank">https://doi.org/10.1145/2048066.2048121</a></li>     <li id="BibPLXBIB0010" label="[10]">Leo&#x00A0;A. Meyerovich, Arjun Guha, Jacob&#x00A0;P. Baskin, Gregory&#x00A0;H. Cooper, Michael Greenberg, Aleks Bromfield, and Shriram Krishnamurthi. 2009. Flapjax: a programming language for Ajax applications. In <em>       <em>OOPSLA</em>      </em>. 1&#x2013;20. <a class="link-inline force-break" href="https://doi.org/10.1145/1640089.1640091"       target="_blank">https://doi.org/10.1145/1640089.1640091</a></li>     <li id="BibPLXBIB0011" label="[11]">Bob Reynders, Dominique Devriese, and Frank Piessens. 2017. Experience Report: Functional Reactive Programming and the DOM. In <em>       <em>Programming</em>      </em>. <a class="link-inline force-break" href="https://doi.org/10.1145/3079368.3079405"       target="_blank">https://doi.org/10.1145/3079368.3079405</a></li>     <li id="BibPLXBIB0012" label="[12]">Guido Salvaneschi, Gerold Hintz, and Mira Mezini. 2014. REScala: bridging between object-oriented and functional style in reactive applications. In <em>       <em>AOSD</em>      </em>. 25&#x2013;36. <a class="link-inline force-break" href="https://doi.org/10.1145/2577080.2577083"       target="_blank">https://doi.org/10.1145/2577080.2577083</a></li>     <li id="BibPLXBIB0013" label="[13]">Christopher Schuster and Cormac Flanagan. 2016. Reactive programming with reactive variables. In <em>       <em>AOSD</em>      </em>. 29&#x2013;33. <a class="link-inline force-break" href="https://doi.org/10.1145/2892664.2892666"       target="_blank">https://doi.org/10.1145/2892664.2892666</a></li>     </ul>    </section>   </section>  </section>  </body> </html> 
