<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta name="generator" content=
  "HTML Tidy for HTML5 for Linux version 5.7.16" />
  <title>Semantics and Complexity of GraphQL</title>
  <!-- Copyright (c) 2010-2015 The MathJax Consortium -->
  <meta http-equiv="Content-Type" content=
  "text/html; charset=utf-8" />
  <meta name="viewport" content=
  "width=device-width; initial-scale=1.0;" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="screen, print" rel="stylesheet" href=
  "../../../data/dl.acm.org/pubs/lib/css/bootstrap.min.css" />
  <link media="screen, print" rel="stylesheet" href=
  "../../../data/dl.acm.org/pubs/lib/css/bootstrap-theme.min.css" />
  <link media="screen, print" rel="stylesheet" href=
  "../../../data/dl.acm.org/pubs/lib/css/main.css" />
  <script src="../../../data/dl.acm.org/pubs/lib/js/jquery.min.js" type=
  "text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/bootstrap.min.js"
  type="text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/bibCit.js" type=
  "text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/divTab.js" type=
  "text/javascript"></script>
  <script type="text/javascript" src=
  "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>
  <script type="text/x-mathjax-config">
  <![CDATA[
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  ]]>
  </script>
</head>
<body id="main">
<div>
<p style='font-size: 75%; color #444'>
This is a web copy of <a href='https://doi.org/10.1145/3178876.3186014'>https://doi.org/10.1145/3178876.3186014</a> 
originally published by ACM Press, 
redistributed under the terms of 
<a href='https://creativecommons.org/licenses/by/4.0/'>Creative Commons Attribution 4.0 (CC BY 4.0)</a>.
The <a href='https://github.com/usable-oa/thewebconf2018/tree/master/scripts'>modifications</a> 
from the original are solely to improve HTML aiming to make it Findable, Accessible, Interoperable and Reusable. 
augmenting HTML metadata and avoiding ACM trademark.
To reference this HTML version, use:
</p><p>
<strong>Permalink:</strong>
<a href='https://w3id.org/oa/10.1145/3178876.3186014'>https://w3id.org/oa/10.1145/3178876.3186014</a>
</p></div>
<hr>


  <section class="front-matter">
    <section>
      <header class="title-info">
        <div class="journal-title">
          <h1><span class="title">Semantics and Complexity of
          GraphQL</span><br />
          <span class="subTitle"></span></h1>
        </div>
      </header>
      <div class="authorGroup">
        <div class="author">
          <span class="givenName">Olaf</span> <span class=
          "surName">Hartig</span>, Dept.&nbsp;of Computer and
          Information Science (IDA), Linköping University, <a href=
          "mailto:olaf.hartig@liu.se">olaf.hartig@liu.se</a>
        </div>
        <div class="author">
          <span class="givenName">Jorge</span> <span class=
          "surName">Pérez</span>, Department of Computer Science,
          Universidad de Chile Millenium Institute for Foundational
          Research on Data, <a href=
          "mailto:jperez@dcc.uchile.cl">jperez@dcc.uchile.cl</a>
        </div>
      </div><br />
      <div class="pubInfo">
        <p>DOI: <a href="https://doi.org/10.1145/3178876.3186014"
        target=
        "_blank">https://doi.org/10.1145/3178876.3186014</a><br />
        WWW '18: <a href="https://doi.org/10.1145/3178876" target=
        "_blank">Proceedings of The Web Conference 2018</a>, Lyon,
        France, April 2018</p>
      </div>
      <div class="abstract">
        <p><small>GraphQL is a recently proposed, and increasingly
        adopted, conceptual framework for providing a new type of
        data access interface on the Web. The framework includes a
        new graph query language whose semantics has been specified
        informally only. This has prevented the formal study of the
        main properties of the language.</small></p>
        <p><small>We embark on the formalization and study of
        GraphQL. To this end, we first formalize the semantics of
        GraphQL queries based on a labeled-graph data model.
        Thereafter, we analyze the language and show that it admits
        really efficient evaluation methods. In particular, we
        prove that the complexity of the GraphQL evaluation problem
        is NL-complete. Moreover, we show that the enumeration
        problem can be solved with constant delay. This implies
        that a server can answer a GraphQL query and send the
        response byte-by-byte while spending just a constant amount
        of time between every byte sent.</small></p>
        <p><small>Despite these positive results, we prove that the
        size of a GraphQL response might be prohibitively large for
        an internet scenario. We present experiments showing that
        current practical implementations suffer from this issue.
        We provide a solution to cope with this problem by showing
        that the total size of a GraphQL response can be computed
        in polynomial time. Our results on polynomial-time size
        computation plus the constant-delay enumeration can help
        developers to provide more robust GraphQL interfaces on the
        Web.</small></p>
      </div>
      <div class="classifications">
        <div class="AcmReferenceFormat">
          <p><small><span style="font-weight:bold;">ACM Reference
          Format:</span><br />
          Olaf Hartig and Jorge Pérez. 2018. Semantics and
          Complexity of GraphQL. In <em>WWW 2018: The 2018 Web
          Conference,</em> <em>April 23–27, 2018,</em> <em>Lyon,
          France. ACM, New York, NY, USA</em> 10 Pages. <a href=
          "https://doi.org/10.1145/3178876.3186014" class=
          "link-inline force-break" target=
          "_blank">https://doi.org/10.1145/3178876.3186014</a></small></p>
        </div>
      </div>
    </section>
  </section>
  <section class="body">
    <section id="sec-3">
      <header>
        <div class="title-info">
          <h2><span class="section-number">1</span>
          Introduction</h2>
        </div>
      </header>
      <p>After developing and using it internally for three years,
      in 2016, Facebook released a specification&nbsp;[<a class=
      "bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0005">5</a>] and a
      reference implementation of its GraphQL framework. This
      framework introduces a new type of Web-based data access
      interfaces that presents an alternative to the notion of
      REST-based interfaces&nbsp;[<a class="bib" data-trigger=
      "hover" data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0016">16</a>]. One of its main advantages is its
      ability to define precisely the data you want, replacing
      multiple REST requests with a single call&nbsp;[<a class=
      "bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0005">5</a>, <a class=
      "bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0006">6</a>]. Since its
      release, GraphQL has gained significant momentum and has been
      adopted by an increasing number of users &nbsp;including
      Coursera, Github, Neo4J, and Pinterest &nbsp;[<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0009">9</a>] . A core component of the
      GraphQL framework is a query language for expressing the data
      retrieval requests issued to GraphQL-aware Web servers. While
      there already exist a number of implementations of this
      language, a more fundamental understanding of the properties
      of the language is missing. The goal of this paper is to
      close this gap, which is a fundamental step to clarify
      intrinsic limitations and, more importantly, to identify
      optimization opportunities of possible implementations.</p>
      <p>To illustrate some of these limitations and optimization
      opportunities, consider the public GraphQL interface provided
      by Github&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0006">6</a>]. Figure&nbsp;<a class="fig" href=
      "#fig1">1</a>(a) shows a query over this interface and
      Figure&nbsp;<a class="fig" href="#fig1">1</a>(b) illustrates
      the corresponding query result. <a class="fn" href="#fn1" id=
      "foot-fn1"><sup>1</sup></a> This query retrieves the login
      names of the owners of the first two Github repositories that
      are listed for the user with login “danbri” (which happens to
      be “danbri” himself in both cases <a class="fn" href="#fn2"
      id="foot-fn2"><sup>2</sup></a>). As our experiments with this
      public GraphQL interface show, there is an intriguing issue
      with the size of a query result when we begin nesting
      queries. Assume that we extend our example into some kind of
      <em>path expressions</em> that discover repository owners by
      traversing the relationships between Github repositories and
      their owners in increasing levels of distance.
      Figure&nbsp;<a class="fig" href="#fig1">1</a>(a) represents
      the level-1 version of such a traversal. The level-2 version,
      illustrated in Figure&nbsp;<a class="fig" href=
      "#fig1">1</a>(c), retrieves the owners of the&nbsp;(first
      two) repositories that are listed for each repository owner
      in the result of the level-1 version, and so on.
      Figure&nbsp;<a class="fig" href="#fig1">1</a>(d) shows that
      there is an exponential increase of the result sizes for
      levels 1–7. We note that this issue is somehow acknowledged
      by the Github GraphQL interface and, as a safety measure to
      avoid queries that might turn out to be too
      resource-intensive, it introduces a few syntactic
      restrictions&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0007">7</a>]. As one such restriction, Github
      imposes a maximum level of nesting for queries that it
      accepts for execution.</p>
      <p>However, even with this restriction (and other syntactic
      restrictions imposed by the Github GraphQL
      interface&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0007">7</a>]), Github fails to avoid all queries
      that hit some resource limits when executed. For instance,
      when we replace <tt>first:2</tt> by <tt>first:5</tt> in the
      queries of our experiment, we observe not only exponential
      behavior of result size growth and query execution
      times&nbsp;(cf. Figure&nbsp;<a class="fig" href=
      "#fig1">1</a>(e)), but we also receive timeout errors for the
      level-6 and level-7 versions of the queries. The response
      messages with these timeout errors arrive from the server a
      bit more than 10 seconds after issuing the requests. Hence,
      Github's GraphQL processor clearly tries to execute these
      queries before their execution times exceed a threshold.
      Developers have already embarked trying to cope with this and
      similar issues&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0001">1</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0020">20</a>] defining ad hoc notions of
      “complexity” or “cost” of GraphQL queries. As we explain in
      this paper these approaches fall short on providing a robust
      solution for the problem as they can fail in both directions:
      discarding requests in which an efficient evaluation is
      possible, and allowing requests in which a complete
      evaluation is too resource intensive.</p>
      <figure id="fig1">
        <img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-fig1.jpg"
        class="img-responsive" alt="Figure 1" longdesc="" />
        <div class="figure-caption">
          <span class="figure-number">Figure 1:</span> <span class=
          "figure-title">GraphQL queries and responses over the
          Github GraphQL interface&nbsp;[<a class="bib"
          data-trigger="hover" data-toggle="popover"
          data-placement="top" href="#BibPLXBIB0006">6</a>].</span>
        </div>
      </figure>
      <p></p>
      <p>Instead of trying to tackle these and other issues by ad
      hoc solutions, we propose to study them from a formal point
      of view borrowing the long tradition and tools used by the
      database community to study the semantics and complexity of
      query languages. This paper is a first step in this
      direction. Our formalization and technical results allow us,
      among other things, to provide a robust solution for the
      above mentioned problems.</p>
      <p>The semantics of GraphQL queries—i.e., the definition of
      what the expected result of any given query is—is given in
      the GraphQL specification by means of a recursive program
      specified by pseudo code. This recursion is based on an
      operation to resolve any so-called “field” in a
      query&nbsp;(such as <tt>user</tt>, <tt>repositories</tt>, and
      <tt>owner</tt> in our example query). Surprisingly, this
      operation is not fully specified and, instead, simply assumes
      access to an <em>“internal function [...] for determining the
      [...] value of [the] field”</em>&nbsp;[<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0005">5</a>]. While the lack of a more
      precise definition of this internal function may be
      intentional&nbsp;(to allow for implementations of GraphQL on
      top of arbitrary database back-ends), it makes a systematic
      analysis of the GraphQL language unworkable. That is, without
      a complete formal definition it is impossible to determine
      properties such as the expressive power or the computational
      complexity of the language. Thus, our main conceptual
      contribution is a formalization of the semantics of GraphQL.
      We begin by defining a logical data model that formally
      captures the notion of a GraphQL graph, as well as the
      corresponding notion of a GraphQL schema
      (cf.&nbsp;Section&nbsp;<a class="sec" href="#sec-4">2</a>).
      Thereafter, based on our data model, we formalize the
      semantics of GraphQL queries by using a compositional
      approach (cf.&nbsp;Section&nbsp;<a class="sec" href=
      "#sec-7">3</a>) providing a normal form that we heavily use
      when study the properties of the language.</p>
      <p>As our first technical contribution we use our
      formalization to study the computational complexity of
      GraphQL (cf.&nbsp;Section&nbsp;<a class="sec" href=
      "#sec-11">4</a>). We study the classical decision evaluation
      problem and the enumeration problem, showing that both can be
      efficiently solved. In particular, we show that the
      evaluation problem is complete for the class of problems
      decided in Nondeterministic Logarithmic Space. Moreover, we
      prove that for queries that satisfy the above mentioned
      normal form, the enumeration problem can be solved with
      constant delay. This implies that a server can answer a
      GraphQL query and send the response byte-by-byte while
      spending just a constant amount of time between every byte
      sent.</p>
      <p>We also study the problem of computing the size of a
      GraphQL response (cf.&nbsp;Section&nbsp;<a class="sec" href=
      "#sec-12">5</a>), showing that it can be solved in polynomial
      time. That is, even though the size of a query result can be
      prohibitively large, one can efficiently compute the exact
      size without executing the query. Our results on
      polynomial-time size computation plus the constant-delay
      enumeration provide a robust way of tackling the issues
      presented by current GraphQL implementations.</p>
      <p>In Section&nbsp;<a class="sec" href="#sec-15">6</a> we
      review the related work, briefly comparing GraphQL with other
      more classical query languages. The conclusions of our work
      are presented in Section&nbsp;<a class="sec" href=
      "#sec-16">7</a>. We emphasize that this paper is a
      substantially extended version of a workshop
      paper&nbsp;[<a class="bib" data-trigger="hover" data-toggle=
      "popover" data-placement="top" href="#BibPLXBIB0010">10</a>]
      in which we initially presented a fragment of the
      formalization of the language but no result about normal
      forms, the complexity of the enumeration or the size
      computation problems.</p>
    </section>
    <section id="sec-4">
      <header>
        <div class="title-info">
          <h2><span class="section-number">2</span> Data Model</h2>
        </div>
      </header>
      <p>A dataset that is made available via a GraphQL interface
      can be queried in terms of a so-called <em>schema</em> based
      on which the dataset is represented implicitly as a directed,
      edge-labeled multigraph with typed nodes and node properties.
      The nodes in this graph correspond to JSON-style objects that
      may occur in the query results. The schema associated with a
      GraphQL interface introduces a notion of types for these
      objects. Such a type characterizes what fields an object of
      the given type may have and what values are allowed for each
      of these fields. The possible values can be restricted to a
      specific type of scalars or objects. To define the GraphQL
      query semantics formally we first need to make explicit this
      logical data model assumed by GraphQL. To this end, this
      section formalizes the notions of a GraphQL schema and a
      GraphQL graph. For each concept of the GraphQL specification
      that our definitions capture, we refer to section of the
      specification that introduces the concept.</p>
      <section id="sec-5">
        <header>
          <div class="title-info">
            <h3><span class="section-number">2.1</span> GraphQL
            Schema</h3>
          </div>
        </header>
        <p>We consider three infinite countable sets: <span class=
        "inline-equation"><span class="tex">${\tt
        Fields}$</span></span> &nbsp;(field names, <font style=
        "normal">$</font>&nbsp;[<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0005">5</a>]), <span class=
        "inline-equation"><span class="tex">${\tt
        Arguments}$</span></span> &nbsp;(argument names,
        <font style="normal">$</font>&nbsp;[<a class="bib"
        data-trigger="hover" data-toggle="popover" data-placement=
        "top" href="#BibPLXBIB0005">5</a>]), and <span class=
        "inline-equation"><span class="tex">${\tt
        Types}$</span></span> &nbsp;(type names, <font style=
        "normal">$</font>&nbsp;[<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0005">5</a>]). We assume that <span class=
        "inline-equation"><span class="tex">${\tt
        Fields}$</span></span> , <span class=
        "inline-equation"><span class="tex">${\tt
        Arguments}$</span></span> and <span class=
        "inline-equation"><span class="tex">${\tt
        Types}$</span></span> are disjoint and that there exists a
        finite set <span class="inline-equation"><span class=
        "tex">${\tt Scalars}$</span></span> &nbsp;(scalar type
        names, <font style="normal">$</font>&nbsp;[<a class="bib"
        data-trigger="hover" data-toggle="popover" data-placement=
        "top" href="#BibPLXBIB0005">5</a>]) which is a subset of
        <span class="inline-equation"><span class="tex">${\tt
        Types}$</span></span>. We also consider a set <span class=
        "inline-equation"><span class="tex">${\tt
        Vals}$</span></span> of scalar values, and a function
        <span class="inline-equation"><span class="tex">${\it
        values}:{\tt Scalars}\rightarrow 2^{{\tt
        Vals}}$</span></span> that assigns a set of values to every
        scalar type.</p>
        <p>GraphQL schemas and graphs are defined over finite
        subsets of the above sets. We assume three finite sets
        <span class="inline-equation"><span class="tex">${\tt
        F}\subset {\tt Fields}$</span></span> , <span class=
        "inline-equation"><span class="tex">${\tt A}\subset {\tt
        Arguments}$</span></span> , and <span class=
        "inline-equation"><span class="tex">${\tt T}\subset {\tt
        Types}$</span></span> , where <span class=
        "inline-equation"><span class="tex">${\tt T}$</span></span>
        is the disjoint union of <span class=
        "inline-equation"><span class="tex">${\tt O}_{\tt
        T}$</span></span> &nbsp;(object types, <font style=
        "normal">$</font>&nbsp;[<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0005">5</a>]), <span class=
        "inline-equation"><span class="tex">${\tt I}_{\tt
        T}$</span></span> &nbsp;(interface types, <font style=
        "normal">$</font>&nbsp;[<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0005">5</a>]), <span class=
        "inline-equation"><span class="tex">${\tt U}_{\tt
        T}$</span></span> &nbsp;(union types, <font style=
        "normal">$</font>&nbsp;[<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0005">5</a>]) and <span class=
        "inline-equation"><span class="tex">${\tt
        Scalars}$</span></span> , and we denote
        by&nbsp;<span class="inline-equation"><span class=
        "tex">${\tt L}_{\tt T}$</span></span> the set <span class=
        "inline-equation"><span class="tex">$\lbrace [\ {\tt t}\
        ]\mid {\tt t}\in {\tt T}\rbrace$</span></span> of list
        types constructed from <span class=
        "inline-equation"><span class="tex">${\tt T}$</span></span>
        &nbsp;(cf. <font style="normal">$</font>&nbsp;[<a class=
        "bib" data-trigger="hover" data-toggle="popover"
        data-placement="top" href="#BibPLXBIB0005">5</a>]). We now
        have everything necessary to define a GraphQL schema over
        <span class="inline-equation"><span class="tex">$({\tt
        F},{\tt A},{\tt T})$</span></span>.</p>
        <div class="definition" id="enc1">
          <label>Definition 2.1.</label>
          <p>A GraphQL schema <span class=
          "inline-equation"><span class="tex">${\mathcal
          {S}}$</span></span> over <span class=
          "inline-equation"><span class="tex">$({\tt F},{\tt
          A},{\tt T})$</span></span> is composed of the following
          five assignments:</p>
          <p></p>
          <ul class="list-no-style">
            <li id="list1" label="•"><span class=
            "inline-equation"><span class="tex">${\it
            fields}_{\mathcal {S}}:({\tt O}_{\tt T}\cup {\tt
            I}_{\tt T})\rightarrow 2^{{\tt F}}$</span></span> that
            assigns a set of fields to every object type and every
            interface type,<br /></li>
            <li id="list2" label="•"><span class=
            "inline-equation"><span class="tex">${\it
            args}_{\mathcal {S}}:{\tt F}\rightarrow 2^{{\tt
            A}}$</span></span> that assigns a set of arguments to
            every field,<br /></li>
            <li id="list3" label="•"><span class=
            "inline-equation"><span class="tex">${\it
            type}_{\mathcal {S}}:{\tt F}\cup {\tt A}\rightarrow
            {\tt T}\cup {\tt L}_{\tt T}$</span></span> that assigns
            a type or a list type to every field and argument,
            where<br />
            arguments are assigned scalar types; i.e., <span class=
            "inline-equation"><span class="tex">${\it
            type}_{\mathcal {S}}({\tt a})\in {\tt
            Scalars}$</span></span> for all <span class=
            "inline-equation"><span class="tex">${\tt a}\in {\tt
            A}$</span></span> ,<br /></li>
            <li id="list4" label="•"><span class=
            "inline-equation"><span class="tex">${\it
            union}_{\mathcal {S}}:{\tt U}_{\tt T}\rightarrow
            2^{{\tt O}_{\tt T}}$</span></span> that assigns a
            nonempty set of object types to every union
            type,<br /></li>
            <li id="list5" label="•"><span class=
            "inline-equation"><span class="tex">${\it
            implementation}_{\mathcal {S}}:{\tt I}_{\tt
            T}\rightarrow 2^{{\tt O}_{\tt T}}$</span></span> that
            assigns a set of object types to every
            interface.<br /></li>
          </ul>
          <p></p>
          <p>Additionally, <span class=
          "inline-equation"><span class="tex">${\mathcal
          {S}}$</span></span> contains a distinguished type
          <span class="inline-equation"><span class="tex">${\it
          root}_{\mathcal {S}}\in {\tt O}_{\tt T}$</span></span>
          called the (query) <em>root type</em>.</p>
        </div>
        <p>To avoid an overly complex formalization, our definition
        of a GraphQL schema does not capture the additional notions
        of <em>input types</em>&nbsp;(cf. <font style=
        "normal">$</font>&nbsp;[<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0005">5</a>]) and <em>non-null
        types</em>&nbsp;(cf. <font style=
        "normal">$</font>&nbsp;[<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0005">5</a>]). Moreover, since we are mostly
        interested in queries, we do not consider <em>mutation
        types</em>&nbsp;(<font style=
        "normal">$</font>&nbsp;[<a class="bib" data-trigger="hover"
        data-toggle="popover" data-placement="top" href=
        "#BibPLXBIB0005">5</a>]). A GraphQL schema is
        <em>consistent</em> if every object type that implements an
        interface type&nbsp;<span class=
        "inline-equation"><span class="tex">${\tt i}$</span></span>
        defines at least all the fields that <span class=
        "inline-equation"><span class="tex">${\tt i}$</span></span>
        defines. Formally, <span class=
        "inline-equation"><span class="tex">${\mathcal
        {S}}$</span></span> is consistent if <span class=
        "inline-equation"><span class="tex">${\it fields}_{\mathcal
        {S}}({\tt i})\subseteq {\it fields}_{\mathcal {S}}({\tt
        t})$</span></span> for every <span class=
        "inline-equation"><span class="tex">${\tt t}\in {\it
        implementation}_{\mathcal {S}}({\tt i})$</span></span>. We
        assume that all GraphQL schemas in this paper are
        consistent.</p>
        <figure id="fig2">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-fig2.jpg"
          class="img-responsive" alt="Figure 2" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 2:</span>
            <span class="figure-title">Example GraphQL schema in
            its original syntax.</span>
          </div>
        </figure>
        <p></p>
        <div class="example" id="enc2">
          <label>Example 2.2.</label>
          <p>Figure&nbsp;<a class="fig" href="#fig2">2</a>
          illustrates a GraphQL schema for data about Star Wars
          movies in the original syntax&nbsp;[<a class="bib"
          data-trigger="hover" data-toggle="popover"
          data-placement="top" href="#BibPLXBIB0005">5</a>]. This a
          simplified version of the schema used in one of the
          official learning resources for GraphQL (see <a class=
          "link-inline force-break" href=
          "http://graphql.org/learn/schema/">http://graphql.org/learn/schema/</a>).
          In terms of our formalization, we have a schema
          <span class="inline-equation"><span class=
          "tex">${\mathcal {S}}$</span></span> over <span class=
          "inline-equation"><span class="tex">$({\tt F},{\tt
          A},{\tt T})$</span></span> &nbsp;with</p>
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\begin{align*} {\tt F}&amp;=
              \lbrace {\tt id}, {\tt name}, {\tt length}, {\tt
              friends}, {\tt primaryFunction},{\tt starships},
              \\[-1mm] &amp;\phantom{= \lbrace \ } {\tt hero}, {\tt
              search} \rbrace , \\[0mm] {\tt A}&amp;= \lbrace {\tt
              episode}, {\tt text}\rbrace , \text{ \; and \; } \;
              {\tt T}= {\tt O}_{\tt T}\cup {\tt I}_{\tt T}\cup {\tt
              U}_{\tt T}\cup {\tt Scalars}\text{ \, such
              that}\end{align*}</span><br />
            </div>
          </div>
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\begin{align*} {\tt I}_{\tt
              T}&amp; = \lbrace {\tt Character}\rbrace , \; \; \;
              \; \; {\tt U}_{\tt T}= \lbrace {\tt
              SearchResult}\rbrace , \\ {\tt O}_{\tt T}&amp; =
              \lbrace {\tt Starship}, {\tt Droid}, {\tt Human},
              {\tt Query}\rbrace , \\ {\tt Scalars}&amp; = \lbrace
              {\tt ID},{\tt String},{\tt Float}, {\tt
              Episode}\rbrace .\end{align*}</span><br />
            </div>
          </div>As we can see in Figure&nbsp;<a class="fig" href=
          "#fig2">2</a>, in the original syntax, object types are
          defined using the keyword <span class=
          "inline-equation"><span class="tex">${\tt
          type}$</span></span> , and interface and union types with
          keywords <span class="inline-equation"><span class=
          "tex">${\tt interface}$</span></span> and <span class=
          "inline-equation"><span class="tex">${\tt
          union}$</span></span> , respectively. The values for the
          scalar types are implicit in their
          names&nbsp;(<span class="inline-equation"><span class=
          "tex">${\tt String}, {\tt Float}$</span></span> ) except
          for <span class="inline-equation"><span class="tex">${\tt
          ID}$</span></span> which is a special type used for
          unique identifiers&nbsp; (cf. <font style=
          "normal">$</font>&nbsp;[<a class="bib" data-trigger=
          "hover" data-toggle="popover" data-placement="top" href=
          "#BibPLXBIB0005">5</a>]), and <span class=
          "inline-equation"><span class="tex">${\tt
          Episodes}$</span></span> which is an <em>enum type</em>
          such that <span class="inline-equation"><span class=
          "tex">${\it values}({\tt Episodes})=\lbrace {\tt
          NEWHOPE}, {\tt EMPIRE}, {\tt JEDI}\rbrace$</span></span>.
          Regarding the functions that compose <span class=
          "inline-equation"><span class="tex">${\mathcal
          {S}}$</span></span> we have that <span class=
          "inline-equation"><span class="tex">${\it
          fields}_{\mathcal {S}}$</span></span> defines the
          assignments:
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\begin{align*} {\tt Starship}
              &amp;\rightarrow \lbrace {\tt id}, {\tt name}, {\tt
              length}\rbrace ,\\ {\tt Character} &amp;\rightarrow
              \lbrace {\tt id}, {\tt name}, {\tt friends}\rbrace ,
              \\ {\tt Droid} &amp;\rightarrow \lbrace {\tt id},
              {\tt name}, {\tt friends}, {\tt
              primaryFunction}\rbrace ,\\ {\tt Human}
              &amp;\rightarrow \lbrace {\tt id}, {\tt name}, {\tt
              friends}, {\tt starships}\rbrace ,\\ {\tt Query}
              &amp;\rightarrow \lbrace {\tt hero}, {\tt
              search}\rbrace ,\end{align*}</span><br />
            </div>
          </div>function <span class="inline-equation"><span class=
          "tex">${\it args}_{\mathcal {S}}$</span></span> defines
          the assignments:
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \begin{array}{rclcrcl}\tt
              hero &amp; \rightarrow &amp; \lbrace {\tt
              episode}\rbrace , &amp;&amp; {\tt search} &amp;
              \rightarrow &amp; \lbrace {\tt text}\rbrace ,\\
              \end{array} \]</span><br />
            </div>
          </div>and <span class="inline-equation"><span class=
          "tex">${\it type}_{\mathcal {S}}$</span></span> defines
          the assignments:
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \begin{array}{rclrcl}\tt
              id &amp; \rightarrow &amp; {\tt ID}, &amp; {\tt
              friends} &amp; \rightarrow &amp; [{\tt Character}],\\
              {\tt name} &amp; \rightarrow &amp; {\tt String},&amp;
              {\tt starships}&amp; \rightarrow &amp; {\tt
              [Starship]}, \\ {\tt length}&amp; \rightarrow &amp;
              {\tt Float},&amp; {\tt primaryFunction}&amp;
              \rightarrow &amp; {\tt String}\\ {\tt episode}&amp;
              \rightarrow &amp; {\tt Episode},&amp; {\tt hero}&amp;
              \rightarrow &amp; {\tt Character},\\ {\tt text}&amp;
              \rightarrow &amp; {\tt String},&amp; {\tt
              search}&amp; \rightarrow &amp; {\tt
              [SearchResult]}.\\ \end{array} \]</span><br />
            </div>
          </div>
          <p></p>
          <p>The interface and union types are given as
          follows:</p>
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\begin{align*} {\it
              implementation}_{\mathcal {S}}({\tt
              Character})&amp;=\lbrace {\tt Human}, {\tt
              Droid}\rbrace ,\\ {} [-1mm] {\it union}_{\mathcal
              {S}}({\tt SearchResult})&amp;=\lbrace {\tt Human},
              {\tt Droid}, {\tt Starship}\rbrace
              .\end{align*}</span><br />
            </div>
          </div>Finally the root type is defined as <span class=
          "inline-equation"><span class="tex">${\it root}_{\mathcal
          {S}}={\tt Query}$</span></span>. In Figure&nbsp;<a class=
          "fig" href="#fig2">2</a> this is defined as the type of
          the <span class="inline-equation"><span class="tex">${\tt
          query}$</span></span> field under a special <span class=
          "inline-equation"><span class="tex">${\tt
          schema}$</span></span> type.
          <p></p>
        </div>
      </section>
      <section id="sec-6">
        <header>
          <div class="title-info">
            <h3><span class="section-number">2.2</span> GraphQL
            Graphs</h3>
          </div>
        </header>
        <p>We now define the notion of a GraphQL graph by using the
        aforementioned domain&nbsp;<span class=
        "inline-equation"><span class="tex">$({\tt F},{\tt A},{\tt
        T})$</span></span>. Informally, a GraphQL graph is a
        directed, edge-labeled multigraph. Each node in the graph
        is associated with an object type from&nbsp;<span class=
        "inline-equation"><span class="tex">${\tt O}_{\tt
        T}$</span></span> and a set of properties&nbsp;(key-value
        pairs). The key names of these properties, as well as the
        edge labels, consist of a field name from&nbsp;<span class=
        "inline-equation"><span class="tex">${\tt F}$</span></span>
        and a (possibly empty) set of arguments, where such an
        argument is a pair consisting of an argument name from
        <span class="inline-equation"><span class="tex">${\tt
        A}$</span></span> and a corresponding value. The value of
        each node property is either a single scalar value or a
        sequence of scalars. Formally, we define the notion of a
        GraphQL graph as&nbsp;follows.</p>
        <div class="definition" id="enc3">
          <label>Definition 2.3.</label>
          <p>A <em>GraphQL graph</em>, or simply <em>graph</em>,
          over <span class="inline-equation"><span class=
          "tex">$({\tt F},{\tt A},{\tt T})$</span></span> is a
          tuple <em>G</em> = (<em>N</em>, <em>E</em>, <em>τ</em>,
          <em>λ</em>, <em>r</em>) with the following elements:</p>
          <p></p>
          <ul class="list-no-style">
            <li id="list6" label="•"><em>N</em> is a set of
            nodes,<br /></li>
            <li id="list7" label="•"><em>E</em> is a set of edges
            of the form <span class="inline-equation"><span class=
            "tex">$(u, {\tt f}[\alpha ], v)$</span></span> where
            <em>u</em>, <em>v</em> ∈ <em>N</em>, <span class=
            "inline-equation"><span class="tex">${\tt f}\in {\tt
            F}$</span></span> , and <em>α</em> is a partial mapping
            from <span class="inline-equation"><span class=
            "tex">${\tt A}$</span></span> to <span class=
            "inline-equation"><span class="tex">${\tt
            Vals}$</span></span> ,<br /></li>
            <li id="list8" label="•"><span class=
            "inline-equation"><span class="tex">$\tau :N\rightarrow
            {\tt O}_{\tt T}$</span></span> is a function that
            assigns a type to every node,<br /></li>
            <li id="list9" label="•"><em>λ</em> is a partial
            function that assigns a scalar value <span class=
            "inline-equation"><span class="tex">${\tt v} \in {\tt
            Vals}$</span></span> or a sequence <span class=
            "inline-equation"><span class="tex">${\tt [v}_1 \cdots
            {\tt v}_n{\tt ]}$</span></span> of scalar
            values&nbsp;(<span class="inline-equation"><span class=
            "tex">${\tt v}_i \in {\tt Vals}$</span></span> ) to
            some pairs of the form <span class=
            "inline-equation"><span class="tex">$(u, {\tt f}[\alpha
            ])$</span></span> where <em>u</em> ∈ <em>N</em>,
            <span class="inline-equation"><span class="tex">${\tt
            f}\in {\tt F}$</span></span> , and <em>α</em> is a
            partial mapping from <span class=
            "inline-equation"><span class="tex">${\tt
            A}$</span></span> to <span class=
            "inline-equation"><span class="tex">${\tt
            Vals}$</span></span> ,<br /></li>
            <li id="list10" label="•"><em>r</em> ∈ <em>N</em> is a
            distinguished node called the <em>root</em>
            node.<br /></li>
          </ul>
          <p></p>
        </div>
        <figure id="fig3">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-fig3.jpg"
          class="img-responsive" alt="Figure 3" longdesc="" />
          <div class="figure-caption">
            <span class="figure-number">Figure 3:</span>
            <span class="figure-title">Example GraphQL
            graph.</span>
          </div>
        </figure>
        <div class="example" id="enc4">
          <label>Example 2.4.</label>
          <p>Figure&nbsp;<a class="fig" href="#fig3">3</a>
          illustrates a graph <em>G</em> = (<em>N</em>, <em>E</em>,
          <em>τ</em>, <em>λ</em>, <em>r</em>) over the domain
          <span class="inline-equation"><span class="tex">$({\tt
          F}, {\tt A}, {\tt T})$</span></span> as given in
          Example&nbsp;<a class="enc" href="#enc2">2.2</a>.
          <em>G</em> is a simplified version of the graph used in
          one of the official learning resources for GraphQL (see
          <a class="link-inline force-break" href=
          "http://graphql.org/learn/schema/">http://graphql.org/learn/schema/</a>).
          In this case we have <em>N</em> = {<em>r</em>,
          <em>u</em>, <em>v</em>, <em>w</em>, <em>x</em>} and
          <em>E</em> contains several edges, including edges
          <span class="inline-equation"><span class="tex">$(r, {\tt
          hero[epsiode:EMPIRE]}, u)$</span></span> and <span class=
          "inline-equation"><span class="tex">$(u, {\tt friends},
          w)$</span></span>. The type assignment <em>τ</em> is
          depicted inside every node. For instance <span class=
          "inline-equation"><span class="tex">$\tau (v)={\tt
          Droid}$</span></span>. Function <em>λ</em> is shown as a
          box beside every node. For instance <span class=
          "inline-equation"><span class="tex">$\lambda (w,{\tt
          name})={\tt Han}$</span></span> , and <span class=
          "inline-equation"><span class="tex">$\lambda (x,{\tt
          length})={\tt 34.37}$</span></span>.</p>
        </div>
        <p>Observe that Definition&nbsp;<a class="enc" href=
        "#enc3">2.3</a> introduces the notion of a GraphQL graph
        independent of any particular GraphQL schema. However, for
        the purpose of defining queries over such a graph, the
        graph is assumed to conform to a given schema. Informally,
        the conditions of conformance to a schema <span class=
        "inline-equation"><span class="tex">${\mathcal
        {S}}$</span></span> imposes on a graph <em>G</em> are
        summarized as follows: For every edge <span class=
        "inline-equation"><span class="tex">$(u, {\tt f}[\alpha ],
        v)$</span></span> , field <span class=
        "inline-equation"><span class="tex">${\tt f}$</span></span>
        is among the field names for the type of <em>u</em>
        (<span class="inline-equation"><span class="tex">${\tt
        f}\in {\it fields}_{\mathcal {S}}(\tau (u))$</span></span>
        ). The type that <span class="inline-equation"><span class=
        "tex">${\mathcal {S}}$</span></span> associates with
        <span class="inline-equation"><span class="tex">${\tt
        f}$</span></span> must match the type of <em>v</em>
        (<span class="inline-equation"><span class="tex">${\it
        type}_{\mathcal {S}}({\tt f})=\tau (v)$</span></span> , or
        <span class="inline-equation"><span class="tex">$\tau
        (v)\in {\it implementation}_{\mathcal {S}}({\it
        type}_{\mathcal {S}}({\tt f}))$</span></span> , or
        <span class="inline-equation"><span class="tex">$\tau
        (v)\in {\it union}_{\mathcal {S}}({\it type}_{\mathcal
        {S}}({\tt f}))$</span></span> ), and if this type is not a
        list type, then <em>v</em> is the only node connected to
        <em>u</em> by an edge with label <span class=
        "inline-equation"><span class="tex">${\tt f}[\alpha
        ]$</span></span>. Moreover, for every argument map
        <span class="inline-equation"><span class="tex">${\tt
        a:v}$</span></span> in <em>α</em>, argument name
        <span class="inline-equation"><span class="tex">${\tt
        a}$</span></span> must be among the arguments that
        <span class="inline-equation"><span class="tex">${\mathcal
        {S}}$</span></span> associates with <span class=
        "inline-equation"><span class="tex">${\tt f}$</span></span>
        (<span class="inline-equation"><span class="tex">${\tt
        a}\in {\it args}_{\mathcal {S}}({\tt f})$</span></span> ),
        and value <span class="inline-equation"><span class=
        "tex">${\tt v}$</span></span> must be of the type
        associated with <span class="inline-equation"><span class=
        "tex">${\tt a}$</span></span> (<span class=
        "inline-equation"><span class="tex">${\tt v}\in {\it
        values}({\it type}_{\mathcal {S}}({\tt a}))$</span></span>.
        In addition to these conditions for the edges in
        <em>E</em>, there exist similar conditions for the node
        properties defined by function <em>λ</em>. Finally, the
        type of the root node should be the root type of
        <span class="inline-equation"><span class="tex">${\mathcal
        {S}}$</span></span> (<span class=
        "inline-equation"><span class="tex">$\tau (r)={\it
        root}_{\mathcal {S}}$</span></span> ). With these
        intuitions, one can see that the graph in
        Example&nbsp;<a class="enc" href="#enc4">2.4</a> conforms
        to the schema described in Example&nbsp;<a class="enc"
        href="#enc2">2.2</a>. Providing a detailed definition of
        these conditions is straightforward. Due to space
        limitations, we omit the definition in this paper. Finally,
        the size of graph <em>G</em>, denoted by |<em>G</em>|, is
        the total number of edges and node properties in
        <em>G</em>.</p>
        <p>We emphasize that our notion of a GraphQL graph is
        mostly a logical construct needed to base our work on a
        well-defined foundation. In practice, GraphQL interfaces
        typically provide access to an underlying database which
        may be stored using relational technology or in a NoSQL
        system. The actual data exposed via such an interface can
        be conceived of as graph-based view of the underlying
        database. GraphQL graphs are an abstraction of such views
        that allows us to formalize and study the GraphQL language
        independent of the technologies used to implement GraphQL
        interfaces.</p>
      </section>
    </section>
    <section id="sec-7">
      <header>
        <div class="title-info">
          <h2><span class="section-number">3</span> GraphQL
          Language</h2>
        </div>
      </header>
      <p>In this section we provide a formal definition of the
      GraphQL query language, defining its syntax and semantics
      over the data model that we introduced in the previous
      section. Before going into the formal definitions, we give
      some intuition of the expressions based on which GraphQL
      queries may be constructed and how these expressions are
      evaluated. The most basic construction are expressions of the
      form <span class="inline-equation"><span class="tex">${\tt f}
      {\tt [} \alpha {\tt ]}$</span></span> &nbsp;(cf. <font style=
      "normal">$</font>&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0005">5</a>]). Informally, when evaluated over a
      graph, such an expression can be used to match node
      properties whose name has the same form. Then, assuming the
      value of the property is a scalar value <span class=
      "inline-equation"><span class="tex">${\tt v}$</span></span> ,
      the result of the evaluation is a string of the form
      <span class="inline-equation"><span class="tex">${\tt f} {\tt
      :} {\tt v}$</span></span>. An alternative to the construction
      <span class="inline-equation"><span class="tex">${\tt f} {\tt
      [} \alpha {\tt ]}$</span></span> is <span class=
      "inline-equation"><span class="tex">$\ell {\tt :} {\tt f}
      {\tt [} \alpha {\tt ]}$</span></span> which captures the
      notion of <em>“field aliases”</em>&nbsp;(cf. <font style=
      "normal">$</font>&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0005">5</a>]). Such aliases can be used to rename
      the field names that appear in the query result. To match
      edges, expressions of the form <span class=
      "inline-equation"><span class="tex">${\tt f} {\tt [} \alpha
      {\tt ]{} \varphi {\tt }}$</span></span> can be used, where ϕ
      is a subquery to be evaluated in the context of the target
      nodes. Then, for the case of a single matching edge, the
      result is a string of the form <span class=
      "inline-equation"><span class="tex">${\tt f} {\tt :{} \rho
      {\tt }}$</span></span> with&nbsp;<em>ρ</em> being the string
      resulting from the evaluation of the subquery ϕ. On the other
      hand, if the number of matching edges may be greater than
      one&nbsp;(which may be the case if the type associated with
      field&nbsp;<span class="inline-equation"><span class=
      "tex">${\tt f}$</span></span> is a list type), then the
      result string is of the form <span class=
      "inline-equation"><span class="tex">${\tt f} {\tt :[{} \rho
      _1 {\tt }} \cdots {\tt {} \rho _n {\tt }]}$</span></span>.
      Expressions of the form <span class=
      "inline-equation"><span class="tex">${\tt f} {\tt [} \alpha
      {\tt ]{} \varphi {\tt }}$</span></span> can also be prefixed
      with a field alias: <span class=
      "inline-equation"><span class="tex">$\ell {\tt :} {\tt f}
      {\tt [} \alpha {\tt ]{} \varphi {\tt }}$</span></span>.</p>
      <p>Our query syntax introduces two more constructions:
      <span class="inline-equation"><span class="tex">${\tt on}\;
      {\tt t} {\tt {} \varphi {\tt }}$</span></span> and
      ϕ<sub>1</sub>⋅⋅⋅ϕ <sub><em>n</em></sub> . While the latter is
      simply an enumeration of multiple subexpressions whose
      results are meant to be concatenated, the former captures the
      notion of a <em>“type condition”</em> that is given by what
      the GraphQL specification refers to as an <em>“inline
      fragment”</em>&nbsp;(cf. <font style=
      "normal">$</font>&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0005">5</a>]). Hence, <span class=
      "inline-equation"><span class="tex">${\tt t}$</span></span>
      is either an object type, an interface type, or a union type,
      and ϕ is a subquery to be evaluated only for nodes whose
      associated type is compatible with <span class=
      "inline-equation"><span class="tex">${\tt
      t}$</span></span>.</p>
      <p>Readers who are familiar with the query syntax introduced
      in the GraphQL specification may notice that we do not
      capture a number of additional language features, namely,
      (non-inline) <em>“fragments”</em>&nbsp;(<font style=
      "normal">$</font>&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0005">5</a>]),
      <em>“variables”</em>&nbsp;(<font style=
      "normal">$</font>&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0005">5</a>]), and
      <em>“directives”</em>&nbsp;(<font style=
      "normal">$</font>&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0005">5</a>]). We emphasize that these features
      are merely syntactic sugar that a query parser may resolve by
      using the features captured in the presented&nbsp;syntax. The
      following definition formalizes our syntax of GraphQL
      queries.</p>
      <p></p>
      <div class="definition" id="enc5">
        <label>Definition 3.1.</label>
        <p>A <em>GraphQL query</em>, or simply <em>query</em>, over
        <span class="inline-equation"><span class="tex">$({\tt
        F},{\tt A},{\tt T})$</span></span> is an expression&nbsp;ϕ
        constructed from the following grammar where <span class=
        "inline-equation"><span class="tex">${\tt [, ]}$</span>,
        <span class="inline-equation"><span class="tex">${\tt \{,
        \}}$</span></span> , <span class=
        "inline-equation"><span class="tex">${\tt
        :}$</span></span>, and <span class=
        "inline-equation"><span class="tex">${\tt
        on}$</span></span> are terminal symbols, <span class=
        "inline-equation"><span class="tex">${\tt t}\in {\tt
        O}_{\tt T}\cup {\tt I}_{\tt T}\cup {\tt U}_{\tt
        T}$</span></span> , <span class=
        "inline-equation"><span class="tex">${\tt f}\in {\tt
        F}$</span></span> , <span class=
        "inline-equation"><span class="tex">$\ell \in {\tt
        Fields}$</span></span> , and <em>α</em> represents a
        partial mapping from <span class=
        "inline-equation"><span class="tex">${\tt A}$</span></span>
        to <span class="inline-equation"><span class="tex">${\tt
        Vals}$</span></span>.</span></p>
        <div class="table-responsive">
          <div class="display-equation">
            <span class="tex mytex">\[
            \begin{array}{rccccccccccccc}\varphi &amp; ::= \;\;
            &amp; {\tt f} {\tt [} \alpha {\tt ]} &amp;\;\; \mid
            \;\; &amp; \ell {\tt :} {\tt f} {\tt [} \alpha {\tt ]}
            &amp;\;\; \mid \;\; &amp; {\tt on}\; {\tt t} {\tt {}
            \varphi {\tt }} &amp; \;\; \mid \;\; &amp; \\ &amp;
            &amp; {\tt f} {\tt [} \alpha {\tt ]{} \varphi {\tt }}
            &amp; \;\; \mid \;\; &amp; \ell {\tt :} {\tt f} {\tt [}
            \alpha {\tt ]{} \varphi {\tt }} &amp; \;\; \mid \;\;
            &amp; \varphi \cdots \varphi &amp; \end{array}
            \]</span><br />
          </div>
        </div>
        <p></p>
      </div>
      <p></p>
      <p>For the sake of conciseness&nbsp;(and in correspondence
      with the original GraphQL syntax), for sub-expressions of the
      form <span class="inline-equation"><span class="tex">${\tt f}
      {\tt [} \alpha {\tt ]}$</span></span> with <em>α</em> the
      empty mapping, we just write&nbsp;<span class=
      "inline-equation"><span class="tex">${\tt f}$</span></span>.
      Figure&nbsp;<a class="fig" href="#fig4">4</a>&nbsp;(left)
      shows an example GraphQL query over the domain <span class=
      "inline-equation"><span class="tex">$({\tt F},{\tt A},{\tt
      T})$</span></span> in Example&nbsp;<a class="enc" href=
      "#enc2">2.2</a>.</p>
      <figure id="fig4">
        <img src=
        "../../../data/deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-fig4.jpg"
        class="img-responsive" alt="Figure 4" longdesc="" />
        <div class="figure-caption">
          <span class="figure-number">Figure 4:</span> <span class=
          "figure-title">GraphQL query (left) and response object
          (right).</span>
        </div>
      </figure>
      <p></p>
      <p>In the GraphQL specification&nbsp;[<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0005">5</a>], queries begin with the
      optional keyword <span class="inline-equation"><span class=
      "tex">$\mathtt {query}$</span></span> followed by an
      expression as the one introduced in Definition&nbsp;<a class=
      "enc" href="#enc5">3.1</a>. That is, the query in
      Figure&nbsp;<a class="fig" href="#fig4">4</a>&nbsp;(left) is
      written as <span class="inline-equation"><span class=
      "tex">$\mathtt {query}\mathtt {\lbrace } \mathtt
      {hero}\mathtt {[} \mathtt {episode}\texttt {:}\mathtt
      {EMPIRE}\mathtt {]}\mathtt {\lbrace }\cdots \mathtt { \rbrace
      }\mathtt { \rbrace }$</span></span> (see also
      Fig.&nbsp;<a class="fig" href="#fig1">1</a>). We dropped the
      <span class="inline-equation"><span class="tex">$\mathtt
      {query}$</span></span> keyword to have a simpler recursive
      syntax.</p>
      <p>A notion that we shall use heavily is the size of a query
      ϕ, denoted by |ϕ|, that we define as the number of field
      selections and types occurring in ϕ. This can be formally
      defined by recursion as follows:</p>
      <ul class="list-no-style">
        <li id="list11" label="•"><span class=
        "inline-equation"><span class="tex">$|{\tt f} {\tt [}
        \alpha {\tt ]}|=|\ell {\tt :} {\tt f} {\tt [} \alpha {\tt
        ]}|=1$</span></span><br /></li>
        <li id="list12" label="•"><span class=
        "inline-equation"><span class="tex">$|{\tt on}\; {\tt t}
        {\tt {} \varphi {\tt }}|=|{\tt f} {\tt [} \alpha {\tt ]{}
        \varphi {\tt }}| = |\ell {\tt :} {\tt f} {\tt [} \alpha
        {\tt ]{} \varphi {\tt }}| = 1 + |\varphi
        |$</span></span><br /></li>
        <li id="list13" label="•">|ϕ<sub>1</sub>ϕ<sub>2</sub>⋅⋅⋅ϕ
        <sub><em>k</em></sub> | = |ϕ<sub>1</sub>| + |ϕ<sub>2</sub>|
        + ⋅⋅⋅ + |ϕ <sub><em>k</em></sub> |<br /></li>
      </ul>
      <p>For instance, the query in Figure&nbsp;<a class="fig"
      href="#fig4">4</a>&nbsp;(left) has size 11.</p>
      <p>As for the case of GraphQL graphs, there is a notion of
      whether a query conforms to a schema <span class=
      "inline-equation"><span class="tex">${\mathcal
      {S}}$</span></span>. For instance, if a query begins with an
      expression of the form <span class=
      "inline-equation"><span class="tex">${\tt f}{\tt {}{\tt
      g}{\tt {} \varphi {\tt }}}$</span></span> , then <span class=
      "inline-equation"><span class="tex">${\tt f}$</span></span>
      must be a field of the root type in <span class=
      "inline-equation"><span class="tex">${\mathcal
      {S}}$</span></span> (<span class=
      "inline-equation"><span class="tex">${\tt f}\in {\it
      fields}_{\mathcal {S}}({\it root}_{\mathcal
      {S}})$</span></span> ), <span class=
      "inline-equation"><span class="tex">${\tt g}$</span></span>
      must be a field of the type assigned to <span class=
      "inline-equation"><span class="tex">${\tt f}$</span></span>
      (<span class="inline-equation"><span class="tex">${\tt g}\in
      {\it fields}_{\mathcal {S}}({\it type}_{\mathcal {S}}({\tt
      f}))$</span></span> ), and so on. Due to space limitations we
      do not include all the formal requirements here, but they are
      as straightforward to define as for the case of queries.</p>
      <p>As a last preliminary for formalizing the semantics of
      GraphQL queries we require a definition of the notion of a
      result that a GraphQL query may return.</p>
      <p></p>
      <div class="definition" id="enc6">
        <label>Definition 3.2.</label>
        <p>A <em>GraphQL response object</em> is an
        expression&nbsp;<em>ρ</em> constructed from the following
        grammar where <span class="inline-equation"><span class=
        "tex">${\tt \{, \}}$</span>, <span class=
        "inline-equation"><span class="tex">${\tt [, ]}$</span>,
        <span class="inline-equation"><span class="tex">${\tt
        :}$</span></span>, and <span class=
        "inline-equation"><span class="tex">$\mathtt
        {null}$</span></span> are terminal symbols, ɛ denotes the
        empty word, <span class="inline-equation"><span class=
        "tex">$\ell \in {\tt Fields}$</span></span> , and
        <span class="inline-equation"><span class="tex">${\tt v},
        {\tt v}_1, \,...\,, {\tt v}_n \in {\tt Vals}$</span></span>
        :</span></span></p>
        <div class="table-responsive">
          <div class="display-equation">
            <span class="tex mytex">\[
            \begin{array}{rcccccccccccccccccccc}\rho &amp; ::= \;
            &amp; \ell {\tt :} {\tt v} &amp; \; \mid \; &amp; \ell
            {\tt :[} {\tt v}_1 \cdots {\tt v}_n {\tt ]} &amp; \;
            \mid \; &amp; \ell {\tt :} {\tt null} &amp; \; \mid \;
            \\ &amp;&amp; \ell {\tt :{} \rho {\tt }} &amp; \; \mid
            \; &amp; \ell {\tt :[{} \rho {\tt }} \cdots {\tt {}
            \rho {\tt }]} &amp; \; \mid \; &amp; \rho \cdots \rho
            &amp; \; \mid \; &amp; \varepsilon \\ \end{array}
            \]</span><br />
          </div>
        </div>
        <p></p>
      </div>
      <p></p>
      <p>Figure&nbsp;<a class="fig" href="#fig4">4</a>&nbsp;(right)
      shows an example response object. Such objects are strings
      over alphabet <span class="inline-equation"><span class=
      "tex">$\Sigma ={\tt Fields}\cup {\tt Vals}\cup \lbrace {\tt
      {}, {\tt }}, {\tt [}, {\tt ]}, {\tt :}, \mathtt
      {null}\rbrace$</span></span> , and thus we can define the
      size of a response object <em>ρ</em>, denoted by
      |<em>ρ</em>|, simply as the number of symbols of <em>Σ</em>
      occurring in <em>ρ</em>. For instance, the size of the
      response object in Figure&nbsp;<a class="fig" href=
      "#fig4">4</a> is 36. Similarly as for the case of queries,
      response objects in the official specification begin with the
      keyword <span class="inline-equation"><span class=
      "tex">$\mathtt {data}$</span></span> (see Fig.&nbsp;<a class=
      "fig" href="#fig1">1</a>(b)). We have also dropped that
      keyword to have a simpler syntax.</p>
      <p>As a final note on the syntax of queries and response
      objects, notice that both have a <em>tree structure</em>.
      Thus, one can intuitively talk, for example, about
      <em>root</em> or <em>leaf</em> fields of a query or a
      response object, or even about <em>children</em> of a field
      in a query.</p>
      <section id="sec-8">
        <section id="sec-9">
          <p><em>Field collection.</em> Before going into the
          semantics we need the additional notion of <em>collecting
          fields</em> (cf. <font style=
          "normal">$</font>&nbsp;[<a class="bib" data-trigger=
          "hover" data-toggle="popover" data-placement="top" href=
          "#BibPLXBIB0005">5</a>]). The main idea is that repeated
          fields in a query/response should not be considered
          twice. For instance, a GraphQL query will never result in
          a response object of the following form:</p>
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \mathtt {droid}\mathtt
              {:}\mathtt {\lbrace }\ \mathtt {name}\mathtt {:}{\tt
              C3PO}\ \mathtt { \rbrace }\;\; \mathtt {ship}\mathtt
              {:}\mathtt {\lbrace }\ \mathtt {length}\mathtt
              {:}\mathtt {30.0}\ \mathtt { \rbrace }\;\; \mathtt
              {droid}\mathtt {:}\mathtt {\lbrace }\ \mathtt
              {pF}\mathtt {:}\mathtt {Protocol}\ \mathtt { \rbrace
              }. \]</span><br />
            </div>
          </div>Instead, if this is the data to be returned, the
          response object will&nbsp;be:
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \mathtt {droid}\mathtt
              {:}\mathtt {\lbrace }\ \mathtt {name}\mathtt {:}{\tt
              C3PO}\;\; \mathtt {pF}\mathtt {:}\mathtt {Protocol}
              \mathtt { \rbrace }\;\; \mathtt {ship}\mathtt
              {:}\mathtt {\lbrace }\ \mathtt {length}\mathtt
              {:}\mathtt {30.0}\ \mathtt { \rbrace }.
              \]</span><br />
            </div>
          </div>Notice how the two occurrences of the field
          <span class="inline-equation"><span class="tex">$\mathtt
          {droid}$</span></span> are merged collecting the
          subfields <span class="inline-equation"><span class=
          "tex">$\mathtt {name}$</span></span> and <span class=
          "inline-equation"><span class="tex">$\mathtt
          {pF}$</span></span> into a single group while maintaining
          their relative order. The example should clarify why this
          process is called field collection in the GraphQL
          specification. To formalize this we use a recursive
          function <span class="inline-equation"><span class=
          "tex">$\operatorname{collect}(\cdot)$</span></span> over
          response objects. For the sake of space we do not include
          the details of this function, but it can be easily
          implemented as a recursive procedure over a response
          object following the intuition in the example above.
          <p></p>
          <p>We are now ready to introduce the semantics of GraphQL
          queries. In what follows we always assume a fixed given
          schema <span class="inline-equation"><span class=
          "tex">${\mathcal {S}}$</span></span> .</p>
          <div class="definition" id="enc7">
            <label>Definition 3.3.</label>
            <p>Let <em>G</em> = (<em>N</em>, <em>E</em>,
            <em>τ</em>, <em>λ</em>, <em>r</em>) be a graph and ϕ a
            query, both conforming to a schema <span class=
            "inline-equation"><span class="tex">${\mathcal
            {S}}$</span></span> over <span class=
            "inline-equation"><span class="tex">$({\tt F},{\tt
            A},{\tt T})$</span></span> . The <em>evaluation
            of&nbsp;ϕ over&nbsp;</em>G from node&nbsp;<em>u</em> ∈
            <em>N</em> , denoted by <span class=
            "inline-equation"><span class="tex">$[[ \varphi ]]
            _G^u$</span></span> , is a GraphQL response object that
            is defined recursively as shown in
            Figure&nbsp;<a class="fig" href="#fig5">5</a>. The
            <em>evaluation of ϕ over <em>G</em></em> , denoted by
            <span class="inline-equation"><span class="tex">$[[
            \varphi ]] _G$</span></span> , is simply <span class=
            "inline-equation"><span class="tex">$[[ \varphi ]]
            _G^r.$</span></span></p>
            <figure id="fig5">
              <img src=
              "../../../data/deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-fig5.jpg"
              class="img-responsive" alt="Figure 5" longdesc="" />
              <div class="figure-caption">
                <span class="figure-number">Figure 5:</span>
                <span class="figure-title">Semantics of a GraphQL
                query.</span>
              </div>
            </figure>
            <p></p>
          </div>
          <div class="example" id="enc8">
            <label>Example 3.4.</label>
            <p>For the GraphQL graph <em>G</em> in
            Example&nbsp;<a class="enc" href="#enc4">2.4</a>, and
            the query ϕ and response object <em>ρ</em> in
            Figure&nbsp;<a class="fig" href="#fig4">4</a>, we have
            that <span class="inline-equation"><span class=
            "tex">$\rho =[[ \varphi ]] _G$</span></span> .</p>
          </div>
        </section>
      </section>
      <section id="sec-10">
        <header>
          <div class="title-info">
            <h3>Equivalences and normal forms</h3>
          </div>
        </header>
        <p>Let ϕ<sub>1</sub> and ϕ<sub>2</sub> be queries that
        conform to a schema <span class=
        "inline-equation"><span class="tex">${\mathcal
        {S}}$</span></span> . We say that ϕ<sub>1</sub> and
        ϕ<sub>2</sub> are equivalent, denoted by ϕ<sub>1</sub> ≡
        ϕ<sub>2</sub>, if for every graph <em>G</em> that conforms
        to <span class="inline-equation"><span class=
        "tex">${\mathcal {S}}$</span></span> it holds that
        <span class="inline-equation"><span class="tex">$[[ \varphi
        _1]] _G=[[ \varphi _2]] _G$</span></span> . We need two
        additional notions that shall be useful for algorithms and
        complexity analysis.</p>
        <div class="definition" id="enc9">
          <label>Definition 3.5.</label>
          <p>A GraphQL query ϕ is in <em>ground-typed normal
          form</em> if it satisfies the following grammar, where
          <span class="inline-equation"><span class="tex">$\mathtt
          {t}\in \mathtt {O_T}$</span></span> .</p>
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\[ \begin{array}{rcl}\varphi
              &amp; ::= \;\; &amp; \psi \cdots \psi \;\; \mid \;\;
              \chi \cdots \chi \\ \psi &amp; ::= \;\; &amp; {\tt
              on}\; {\tt t}\ {\tt {}\ \chi \cdots \chi \ {\tt }} \\
              \chi &amp; ::= \;\; &amp; {\tt f} {\tt [} \alpha {\tt
              ]} \;\; \mid \;\; \ell \mathtt {:} {\tt f} {\tt [}
              \alpha {\tt ]} \;\; \mid \;\; {\tt f} {\tt [} \alpha
              {\tt ]{}\ \varphi \ {\tt }} \;\; \mid \;\; \ell
              \mathtt {:} {\tt f} {\tt [} \alpha {\tt ]{}\ \varphi
              \ {\tt }} \end{array} \]</span><br />
            </div>
          </div>
          <p></p>
        </div>
        <p>That is, intuitively, ϕ is in <em>ground-typed normal
        form</em> if the following three conditions are satisfied:
        (1)&nbsp;for every expression of the form <span class=
        "inline-equation"><span class="tex">${\tt on}\, {\tt t}\
        {\tt {}\ \,...\,\ {\tt }}$</span></span> that occurs in ϕ,
        it holds that <span class="inline-equation"><span class=
        "tex">$\mathtt {t}\in \mathtt {O_T}$</span></span> ,
        (2)&nbsp;expressions of the form <span class=
        "inline-equation"><span class="tex">${\tt on}\, {\tt t}\
        {\tt {}\ \,...\,\ {\tt }}$</span></span> do not occur mixed
        with regular field selections, and (3)&nbsp;an expression
        <span class="inline-equation"><span class="tex">$\mathtt
        {on\, t^{\prime }}\ {\tt {}\ \,...\,\ {\tt
        }}$</span></span> does not occur immediately inside another
        <span class="inline-equation"><span class="tex">$\mathtt
        {on\, t}\ {\tt {}\ \,...\,\ {\tt }}$</span></span>
        expression. Finally, we introduce a notion that focuses on
        possible redundancy in GraphQL queries.</p>
        <div class="definition" id="enc10">
          <label>Definition 3.6.</label>
          <p>A GraphQL query ϕ is <em>non-redundant</em> if it
          satisfies the following condition. For every
          subexpression of ϕ of the form ϕ<sub>1</sub>⋅⋅⋅ϕ
          <sub><em>k</em></sub> there are no indexes <em>i</em>,
          <em>j</em> ∈ {1, ... , <em>k</em>} such that <em>i</em> ≠
          <em>j</em> and</p>
          <p></p>
          <ul class="list-no-style">
            <li id="list14" label="•"><span class=
            "inline-equation"><span class="tex">$\varphi _i=\varphi
            _j=\mathtt {f\mathtt {[}}\alpha \mathtt
            {]}$</span></span> , or<br /></li>
            <li id="list15" label="•"><span class=
            "inline-equation"><span class="tex">$\varphi _i=\varphi
            _j=\ell \texttt {:}\mathtt {f\mathtt {[}}\alpha \mathtt
            {]}$</span></span> , or<br /></li>
            <li id="list16" label="•"><span class=
            "inline-equation"><span class="tex">$\varphi _i=\mathtt
            {f\mathtt {[}}\alpha \mathtt {]}\mathtt {\lbrace }
            \beta \mathtt { \rbrace }$</span></span> and
            <span class="inline-equation"><span class=
            "tex">$\varphi _j=\mathtt {f\mathtt {[}}\alpha \mathtt
            {]}\mathtt {\lbrace } \gamma \mathtt { \rbrace
            }$</span></span> , or<br /></li>
            <li id="list17" label="•"><span class=
            "inline-equation"><span class="tex">$\varphi _i=\ell
            \texttt {:}\mathtt {f\mathtt {[}}\alpha \mathtt
            {]}\mathtt {\lbrace } \beta \mathtt { \rbrace
            }$</span></span> and <span class=
            "inline-equation"><span class="tex">$\varphi _j=\ell
            \texttt {:}\mathtt {f\mathtt {[}}\alpha \mathtt
            {]}\mathtt {\lbrace } \gamma \mathtt { \rbrace
            }$</span></span> , or<br /></li>
            <li id="list18" label="•"><span class=
            "inline-equation"><span class="tex">$\varphi _i=\mathtt
            {on\; t}\ \mathtt {\lbrace }\beta \mathtt { \rbrace
            }$</span></span> and <span class=
            "inline-equation"><span class="tex">$\varphi _j=\mathtt
            {on\; t}\ \mathtt {\lbrace }\gamma \mathtt { \rbrace
            }$</span></span> .<br /></li>
          </ul>
          <p></p>
        </div>
        <div class="example" id="enc11">
          <label>Example 3.7.</label>
          <p>The query in Figure&nbsp;<a class="fig" href=
          "#fig4">4</a> is a non-redundant query in ground-typed
          normal form.</p>
        </div>
        <div class="theorem" id="enc12">
          <label>Theorem 3.8.</label>
          <p>For every query ϕ that conforms to a schema
          <span class="inline-equation"><span class=
          "tex">${\mathcal {S}}$</span></span> there exists a
          non-redundant query ϕ′ in ground-typed normal form such
          that ϕ ≡ ϕ′.</p>
        </div>
        <p>Theorem&nbsp;<a class="enc" href="#enc12">3.8</a> can be
        obtained by rewriting queries using equivalence rules. Due
        to space constraints, we cannot include these rules in this
        paper; we will provide them in the full version of the
        paper.</p>
        <p>In the rest of the paper we assume that every GraphQL
        query is a non-redundant query in ground-typed normal form.
        One of the main properties of such queries is that they
        produce a unique response object without the need of the
        <span class="inline-equation"><span class=
        "tex">$\operatorname{collect}(\cdot)$</span></span>
        operator. More formally, let ⟨⟨ϕ⟩⟩ <sub><em>G</em></sub> be
        an evaluation function for queries defined in exactly the
        same way as <span class="inline-equation"><span class=
        "tex">$[[ \varphi ]] _G$</span></span> in
        Definition&nbsp;<a class="enc" href="#enc7">3.3</a> but
        replacing the last rule in Figure&nbsp;<a class="fig" href=
        "#fig5">5</a> by <span class="inline-equation"><span class=
        "tex">$\langle \langle {\varphi _1\cdots \varphi _k}\rangle
        \rangle _G^u = \langle \langle {\varphi _1}\rangle \rangle
        _G^u\cdots \langle \langle {\varphi _k}\rangle \rangle
        _G^u$</span></span> , that is, without using <span class=
        "inline-equation"><span class=
        "tex">$\operatorname{collect}(\cdot)$</span></span> . It is
        not difficult to prove that if ϕ is a non-redundant query
        in ground-typed normal form, then <span class=
        "inline-equation"><span class="tex">$[[ \varphi ]]
        _G=\langle \langle \varphi \rangle \rangle
        _G$</span></span> for every graph <em>G</em>. We shall
        exploit this property in the next sections.</p>
      </section>
    </section>
    <section id="sec-11">
      <header>
        <div class="title-info">
          <h2><span class="section-number">4</span> The Complexity
          of GraphQL</h2>
        </div>
      </header>
      <p>In this section we study the complexity of two classical
      decision problems in the context of GraphQL, namely, the
      evaluation problem and the enumeration problem, showing that
      both can be solved efficiently. For this analysis we make the
      following assumption: Let <em>G</em> be a GraphQL graph,
      <em>u</em> be a node, and <span class=
      "inline-equation"><span class="tex">${\tt f[}\alpha {\tt
      ]}$</span></span> be an edge label. We assume that one can
      access the list of <span class="inline-equation"><span class=
      "tex">${\tt f[}\alpha {\tt ]}$</span></span> -neighbors of
      <em>u</em> in time&nbsp;<em>O</em>(1), and one can access the
      <span class="inline-equation"><span class="tex">${\tt
      f[}\alpha {\tt ]}$</span></span> -property of a node in
      time&nbsp;<em>O</em>(1). Although this is a standard
      assumption for graph databases in a RAM computational model,
      we stress that a GraphQL graph is usually implemented as a
      <em>view</em> over another data source and, thus, the time
      required to access neighbors and data may depend on
      the&nbsp;underlying data storage. Our assumption allows us to
      study the two decision problems independent of
      implementation-specific peculiarities.</p>
      <p>Classical query languages, such as SQL or Relational
      Algebra, take as inputs a query and a database and produce a
      set of tuples as output. For these languages the standard way
      of defining a decision problem is the following: given a
      query <em>Q</em>, a database <em>D</em>, and a candidate
      tuple <em>t</em>, check if <em>t</em> is part of the
      evaluation of <em>Q</em> over <em>D</em>&nbsp;[<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0021">21</a>]. In contrast to classical
      languages, the result of a GraphQL query is not a set of
      tuples but a single response object. To define a similar
      decision problem for GraphQL, we consider the data values
      occurring in response objects. For example, in the object</p>
      <div class="table-responsive">
        <div class="display-equation">
          <span class="tex mytex">\[ \mathtt {droid}\mathtt
          {:}\mathtt {\lbrace }\ \mathtt {name}\mathtt {:}{\tt
          C3PO}\;\; \mathtt {pF}\mathtt {:}\mathtt {Protocol}
          \mathtt { \rbrace }\;\; \mathtt {ship}\mathtt {:}\mathtt
          {\lbrace }\ \mathtt {length}\mathtt {:}\mathtt {30.0}\
          \mathtt { \rbrace } \]</span><br />
        </div>
      </div>the values that occur are <span class=
      "inline-equation"><span class="tex">$\texttt
      {C3PO}$</span></span> , <span class=
      "inline-equation"><span class="tex">$\texttt
      {Protocol}$</span></span> and <span class=
      "inline-equation"><span class="tex">$\texttt
      {30.0}$</span></span>. Formally, we define the following
      decision problem.
      <p></p>
      <div class="table-responsive" id="inltbl1">
        <table class="table">
          <thead>
            <tr>
              <th style="text-align:right;">Problem:</th>
              <th style="text-align:left;"><font style=
              "font-variant: small-caps">GraphQL-Eval</font></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align:right;">Input:</td>
              <td style="text-align:left;">GraphQL query ϕ, graph
              <em>G</em>, and value <span class=
              "inline-equation"><span class="tex">$\texttt {v}\in
              {\tt Vals}$</span></span></td>
            </tr>
            <tr>
              <td style="text-align:right;">Ouput:</td>
              <td style="text-align:left;">Does <span class=
              "inline-equation"><span class="tex">$\texttt
              {v}$</span></span> occur in <span class=
              "inline-equation"><span class="tex">$[[ \varphi ]]
              _G$</span></span> ?</td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>We next show that <font style=
      "font-variant: small-caps">GraphQL-Eval</font> is complete
      for the class of problems that can be decided in
      nondeterministic logarithmic space.</p>
      <p></p>
      <div class="theorem" id="enc13">
        <label>Theorem 4.1.</label>
        <p><font style=
        "font-variant: small-caps">GraphQL-Eval</font> is
        NL-complete.</p>
      </div>
      <p></p>
      <div class="proof" id="proof1">
        <label>Proof.</label>
        <p>(Sketch) The proof of the membership in NL is based on
        characterizing the evaluation process as several
        reachability tests. Recall first that a GraphQL query can
        be seen as a tree. Moreover, one can traverse a query by
        following its tree structure, that is, going from one label
        up to its parent, down to one of its children, or
        left/right to its siblings, with a logspace machine by
        using standard techniques (see e.g.&nbsp;[<a class="bib"
        data-trigger="hover" data-toggle="popover" data-placement=
        "top" href="#BibPLXBIB0008">8</a>] Section 2.5). Thus, to
        show membership in NL we first guess a position, say
        <em>p</em>, in ϕ corresponding to an expression of the form
        <span class="inline-equation"><span class="tex">${\tt f}
        {\tt [} \alpha {\tt ]}$</span></span> or <span class=
        "inline-equation"><span class="tex">$\ell {\tt :} {\tt f}
        {\tt [} \alpha {\tt ]}$</span></span> . We also guess a
        node, say <em>u</em>, in <em>G</em>. Notice that to store
        <em>p</em> and <em>u</em> we only need logarithmic space.
        The intuition is that <em>p</em> represents the field in ϕ
        that when evaluated from <em>u</em> produces the value
        <span class="inline-equation"><span class="tex">$\texttt
        {v}$</span></span> . This last property holds if and only
        if either <span class="inline-equation"><span class=
        "tex">$\lambda (u,{\tt f}[\alpha ])=\texttt
        {v}$</span></span> or <span class=
        "inline-equation"><span class="tex">$\lambda (u,{\tt
        f}[\alpha ])$</span></span> is a list containing
        <span class="inline-equation"><span class="tex">$\texttt
        {v}$</span></span> . Both options can be checked by simply
        inspecting <em>G</em>. To complete the proof we consider
        the path <em>P</em> (sequence of field names and type
        restrictions) in the tree representation of ϕ that leads to
        position <em>p</em>. The last step in the proof is to check
        that node <em>u</em> can be reached from the root node in
        <em>G</em> by following path <em>P</em> which can be done
        in NL by a standard reachability test.</p>
        <p>NL-hardness follows from the reachability problem in
        directed graphs. Given a directed graph <em>G</em> with
        <em>k</em> nodes and two nodes <em>u</em> and <em>v</em>,
        we create a GraphQL graph <em>G</em>′ from <em>G</em> by
        setting <em>u</em> as the root node, and adding a field
        label <span class="inline-equation"><span class="tex">${\tt
        e}$</span></span> to every edge. Moreover, for every node
        in <em>G</em>′ we add a property <span class=
        "inline-equation"><span class="tex">${\tt a}$</span></span>
        with value <span class="inline-equation"><span class=
        "tex">${\tt 1}$</span></span> except for node <em>v</em> in
        which <span class="inline-equation"><span class="tex">${\tt
        a}$</span></span> is associated with value <span class=
        "inline-equation"><span class="tex">${\tt 2}$</span></span>
        . Then, we consider the sequence of queries constructed
        recursively as <span class="inline-equation"><span class=
        "tex">$\alpha _1 = {\tt a}$</span></span> and <span class=
        "inline-equation"><span class="tex">$\alpha_i = \verb|a
        e{|\alpha_{i-1}\verb|}|$</span></span> , and the query ϕ =
        <em>α<sub>k</sub></em> . That is, ϕ is the query
        <span class="inline-equation"><span class="tex">$\verb|a
        e{a e{a e{ |\cdots \verb| }}}|$</span></span> , where
        <span class="inline-equation"><span class="tex">${\tt
        a}$</span></span> is repeated <em>k</em> times and
        <span class="inline-equation"><span class="tex">${\tt
        e}$</span></span> repeated <em>k</em> − 1 times. It is not
        difficult to argue that <em>G</em>′ and ϕ can be
        constructed from <em>G</em> by using only logarithmic
        space. Moreover, value <span class=
        "inline-equation"><span class="tex">${\tt 2}$</span></span>
        occurs in <span class="inline-equation"><span class=
        "tex">$[[ \varphi ]] _{G^{\prime }}$</span></span> if and
        only if <em>v</em> is reachable from <em>u</em> in
        <em>G</em>.</p>
      </div>
      <p>Although it is theoretically interesting to pinpoint the
      exact complexity of the GraphQL evaluation problem, the
      previous result does not give a specific hint on how the
      whole evaluation of a query can be actually computed in
      practice. We next prove that for non-redundant queries in
      ground-typed normal form, the complete evaluation can be done
      in time linear with respect to the size of the output.
      Actually, in proving this result we show something even
      stronger: the complete evaluation of a GraphQL query can be
      constructed symbol-by-symbol with only constant-time delay
      between each symbol.</p>
      <p></p>
      <div class="theorem" id="enc14">
        <label>Theorem 4.2.</label>
        <p>Let <em>G</em> be a GraphQL graph and ϕ a non-redundant
        query in ground-typed normal form. Then, <span class=
        "inline-equation"><span class="tex">$\rho =[[ \varphi ]]
        _G$</span></span> can be computed such that <em>ρ</em> is
        produced symbol-by-symbol with constant-time delay between
        each symbol.</p>
      </div>
      <p></p>
      <div class="proof" id="proof2">
        <label>Proof.</label>
        <p>(Sketch) We consider a fixed GraphQL schema <span class=
        "inline-equation"><span class="tex">${\mathcal
        {S}}$</span></span> . Let ϕ be a non-redundant query in
        ground-typed normal form, and <em>G</em> be a graph, both
        conforming to <span class="inline-equation"><span class=
        "tex">${\mathcal {S}}$</span></span> . We describe a
        recursive algorithm <font style=
        "font-variant: small-caps">Enumerate</font> that receives a
        subquery of ϕ and a node <em>u</em>. The initial call is
        <font style="font-variant: small-caps">Enumerate</font>(ϕ,
        <em>r</em>) where <em>r</em> is the root node. For the
        recursive case we assume that ϕ follows the grammar in
        Definition&nbsp;<a class="enc" href="#enc9">3.5</a>. Thus,
        consider a call <font style=
        "font-variant: small-caps">Enumerate</font>(<em>χ</em>,
        <em>u</em>) with <em>χ</em> a subquery of ϕ given by the
        third rule in Definition&nbsp;<a class="enc" href=
        "#enc9">3.5</a>. Assume first that <em>χ</em> is of the
        form <span class="inline-equation"><span class=
        "tex">$\mathtt {f[}\alpha \mathtt {]}$</span></span> . If
        there is a value <span class="inline-equation"><span class=
        "tex">$\texttt {V}=\lambda (u,{\tt f}[\alpha
        ])$</span></span> in <em>G</em>, then <font style=
        "font-variant: small-caps">Enumerate</font> outputs
        <span class="inline-equation"><span class="tex">$\mathtt
        {f}\mathtt {:}\texttt {V}$</span></span> , otherwise it
        outputs <span class="inline-equation"><span class=
        "tex">$\mathtt {f}\mathtt {:}\texttt {null}$</span></span>
        , and returns. Assume now that <em>χ</em> is of the form
        <span class="inline-equation"><span class="tex">$\mathtt
        {f[}\alpha \mathtt {]}\mathtt {\lbrace }\varphi ^{\prime
        }\mathtt { \rbrace }$</span></span> . <font style=
        "font-variant: small-caps">Enumerate</font> first outputs
        expression <span class="inline-equation"><span class=
        "tex">$\mathtt {f}\mathtt {:}$</span></span> and then it
        proceeds depending on the following cases:</p>
        <p></p>
        <ol class="list-no-style">
          <li id="list19" label="(1)">If <span class=
          "inline-equation"><span class="tex">${\it type}_{\mathcal
          {S}}({\tt f})\in {\tt L}_{\tt T}$</span></span> , then
          <font style="font-variant: small-caps">Enumerate</font>
          outputs the symbol <span class=
          "inline-equation"><span class="tex">$\mathtt
          {[}$</span></span> . Next, for every <em>v</em> such that
          <span class="inline-equation"><span class=
          "tex">$(u,\mathtt {f[}\alpha \mathtt {]},v)\in
          E$</span></span> , it first outputs the symbol
          <span class="inline-equation"><span class="tex">$\mathtt
          {\lbrace }$</span></span> , then calls <font style=
          "font-variant: small-caps">Enumerate</font>(ϕ′,
          <em>v</em>), and then outputs the symbol <span class=
          "inline-equation"><span class="tex">$\mathtt { \rbrace
          }$</span></span> . Finally, it outputs the symbol
          <span class="inline-equation"><span class="tex">$\mathtt
          {]}$</span></span> and returns.<br /></li>
          <li id="list20" label="(2)">If <span class=
          "inline-equation"><span class="tex">${\it type}_{\mathcal
          {S}}({\tt f})\notin {\tt L}_{\tt T}$</span></span> , then
          we have two cases depending on whether there is a
          <em>v</em> such that <span class=
          "inline-equation"><span class="tex">$(u,\mathtt
          {f[}\alpha \mathtt {]},v)\in E$</span></span> or not. If
          there is no such <em>v</em>, then <font style=
          "font-variant: small-caps">Enumerate</font> simply
          outputs <tt>null</tt> and returns. Otherwise it first
          outputs the symbol <span class=
          "inline-equation"><span class="tex">$\mathtt {\lbrace
          }$</span></span> , then calls <font style=
          "font-variant: small-caps">Enumerate</font>(ϕ′,
          <em>v</em>), and then outputs the symbol <span class=
          "inline-equation"><span class="tex">$\mathtt { \rbrace
          }$</span></span> .<br /></li>
        </ol>
        <p></p>
        <p>The cases in which <em>χ</em> is of the form
        <span class="inline-equation"><span class="tex">$\ell
        \mathtt {:}\mathtt {f[}\alpha \mathtt {]}$</span></span> or
        <span class="inline-equation"><span class="tex">$\ell
        \mathtt {:}\mathtt {f[}\alpha \mathtt {]}\mathtt {\lbrace
        }\varphi ^{\prime }\mathtt { \rbrace }$</span></span> are
        similar but <font style=
        "font-variant: small-caps">Enumerate</font> outputs first
        <span class="inline-equation"><span class="tex">$\ell
        \mathtt {:}$</span></span> instead of <span class=
        "inline-equation"><span class="tex">$\mathtt {f}\mathtt
        {:}$</span></span>. Notice that in all these cases,
        <font style="font-variant: small-caps">Enumerate</font> is
        just following the semantics of GraphQL as defined in
        Definition&nbsp;<a class="enc" href="#enc7">3.3</a>. The
        really important cases are when we have expressions
        constructed from the first or second rule in
        Definition&nbsp;<a class="enc" href="#enc9">3.5</a>. Hence,
        consider a subquery of the form <em>χ</em> <sub>1</sub>
        <em>χ</em> <sub>2</sub>⋅⋅⋅<em>χ<sub>k</sub></em> where
        every <em>χ<sub>i</sub></em> is constructed from the third
        rule in Definition&nbsp;<a class="enc" href=
        "#enc9">3.5</a>. Given that ϕ is non-redundant and in
        ground-typed normal form, we do not need the <span class=
        "inline-equation"><span class=
        "tex">$\operatorname{collect}(\cdot)$</span></span>
        operator and, thus, <font style=
        "font-variant: small-caps">Enumerate</font>(<em>χ</em>
        <sub>1</sub> <em>χ</em>
        <sub>2</sub>⋅⋅⋅<em>χ<sub>k</sub></em> , <em>u</em>) can
        simply call <font style=
        "font-variant: small-caps">Enumerate</font>(<em>χ<sub>i</sub></em>
        , <em>u</em>) one by one for every <em>i</em> = 1, 2, ... ,
        <em>k</em> and produce the desired output. Finally,
        consider a subquery <em>ψ</em> <sub>1</sub> <em>ψ</em>
        <sub>2</sub>⋅⋅⋅<em>ψ<sub>k</sub></em> where every
        <em>ψ<sub>i</sub></em> is of the form <span class=
        "inline-equation"><span class="tex">${\tt on}\; {\tt t}_i\
        {\tt {} \varphi _i {\tt }}$</span></span> . Given that ϕ is
        non-redundant we know that <span class=
        "inline-equation"><span class="tex">${\tt t}_i\ne {\tt
        t}_j$</span></span> for <em>i</em> ≠ <em>j</em>. This
        implies that <em>k</em> is a constant value bounded by the
        number of types mentioned in <span class=
        "inline-equation"><span class="tex">${\mathcal
        {S}}$</span></span> . Moreover, since ϕ is ground typed, we
        have <span class="inline-equation"><span class="tex">${\tt
        t}_i\in {\tt O}_{\tt T}$</span></span> for every
        <em>i</em>. With these observations the call <font style=
        "font-variant: small-caps">Enumerate</font>(<em>ψ</em>
        <sub>1</sub> <em>ψ</em>
        <sub>2</sub>⋅⋅⋅<em>ψ<sub>k</sub></em> , <em>u</em>) can
        proceed as follows. Search for an index <em>i</em> such
        that <span class="inline-equation"><span class="tex">$\tau
        (u)={\tt t}_i$</span></span> . If such an index <em>i</em>
        exists, then call <font style=
        "font-variant: small-caps">Enumerate</font>(ϕ
        <sub><em>i</em></sub> , <em>u</em>). If the index does not
        exist, just return.</p>
        <p>To see that there is a constant-time delay between any
        two symbols produced by <font style=
        "font-variant: small-caps">Enumerate</font>, first notice
        that every call, except for the last case considered above,
        outputs at least one symbol as soon as it is called and at
        least one symbol just before it returns. Moreover, every
        recursive call to <font style=
        "font-variant: small-caps">Enumerate</font> is performed
        after a constant time upon its parent call. Finally, to
        consider the last case in the previous paragraph, given
        that ϕ is non-redundant and in ground-typed normal form we
        have that an expression of the form <span class=
        "inline-equation"><span class="tex">$\mathtt {on\,
        t^{\prime }}\ {\tt {}\ \,...\,\ {\tt }}$</span></span> does
        not occur immediately inside another <span class=
        "inline-equation"><span class="tex">$\mathtt {on\, t}\ {\tt
        {}\ \,...\,\ {\tt }}$</span></span> expression. This
        ensures that there are no two consecutive calls to
        <font style="font-variant: small-caps">Enumerate</font>
        that do not produce any output.</p>
      </div>
      <p>Computing all the components of the evaluation is usually
      called the <em>enumeration problem</em>&nbsp;[<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0003">3</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0013">13</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0017">17</a>]. Thus,
      Theorem&nbsp;<a class="enc" href="#enc14">4.2</a> shows that
      the enumeration problem for GraphQL can be solved with
      constant delay. As an immediate corollary we obtain the
      following.</p>
      <p></p>
      <div class="corollary" id="enc15">
        <label>Corollary 4.3.</label>
        <p>Let <em>G</em> be a GraphQL graph and ϕ a non-redundant
        query in ground-typed normal form. Then, <span class=
        "inline-equation"><span class="tex">$\rho =[[ \varphi ]]
        _G$</span></span> can be computed in time linear with
        respect to |<em>ρ</em>|.</p>
      </div>
      <p></p>
    </section>
    <section id="sec-12">
      <header>
        <div class="title-info">
          <h2><span class="section-number">5</span> The Size of a
          GraphQL Response</h2>
        </div>
      </header>
      <p>Based on our results in the previous section, we may
      conclude that one of the main sources of complexity in
      evaluating GraphQL queries is the size of a query response
      object. In this section we prove that even for very simple
      cases this object might be prohibitively large. We begin by
      stating an exponential upper bound.</p>
      <p></p>
      <div class="proposition" id="enc16">
        <label>Proposition 5.1.</label>
        <p>For every GraphQL query ϕ and GraphQL graph <em>G</em>
        it holds that <span class="inline-equation"><span class=
        "tex">$[[ \varphi ]] _G$</span></span> is of size
        <em>O</em>(|<em>G</em>|<sup>|ϕ|</sup>).</p>
      </div>
      <p></p>
      <p>The upper bound can be proven by a simple induction
      argument.</p>
      <p></p>
      <div class="proposition" id="enc17">
        <label>Proposition 5.2.</label>
        <p>For every <em>n</em> ≥ 0, there exists a graph
        <em>G</em> and a query ϕ such that <em>G</em> is of size 6
        and ϕ is of size 2(<em>n</em> + 1), but the size of
        <span class="inline-equation"><span class="tex">$[[ \varphi
        ]] _G$</span></span> is greater than 2
        <sup><em>n</em></sup> .</p>
      </div>
      <p></p>
      <div class="proof" id="proof3">
        <label>Proof.</label>
        <p>Let <em>G</em> be the following graph with root node
        <em>r</em>.</p>
        <figure id="fig6">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-fig6.jpg"
          class="img-responsive" alt="" longdesc="" />
        </figure>
        <p></p>
        <p>Consider now the queries given by the recurrence
        <span class="inline-equation"><span class="tex">$\alpha _0
        = \mathtt {name}$</span></span> , and <span class=
        "inline-equation"><span class="tex">$\alpha _i = \mathtt
        {knows}\ \mathtt {\lbrace }\ \mathtt {knows}\ \mathtt
        {\lbrace }\ \alpha _{i-1}\ \mathtt { \rbrace }\ \mathtt {
        \rbrace }$</span></span> for every <em>i</em> &gt; 0.
        Define ϕ as <span class="inline-equation"><span class=
        "tex">$\mathtt {start}\, \mathtt {\lbrace }\, \alpha _n\,
        \mathtt { \rbrace }$</span></span> . Then, the size of ϕ is
        2<em>n</em> + 2 but the evaluation of ϕ over <em>G</em> is
        of size exponential in <em>n</em>; more precisely, the name
        <span class="inline-equation"><span class="tex">${\tt
        Alice}$</span></span> occurs 2 <sup><em>n</em></sup> times
        in&nbsp;<span class="inline-equation"><span class="tex">$[[
        \varphi ]] _G$</span></span> .</p>
      </div>
      <p>One may think that the previous result is produced solely
      by the presence of directed cycles in the graph. As the next
      result shows, one can also obtain an exponential blow up even
      for acyclic graphs.</p>
      <p></p>
      <div class="proposition" id="enc18">
        <label>Proposition 5.3.</label>
        <p>For every <em>n</em> ≥ 0, there exists an acyclic graph
        <em>G</em> and a query ϕ such that <em>G</em> is of size
        4<em>n</em> + 2 and ϕ is of size 2<em>n</em> + 2, but the
        size of <span class="inline-equation"><span class="tex">$[[
        \varphi ]] _G$</span></span> is greater than 2
        <sup><em>n</em></sup> .</p>
      </div>
      <p></p>
      <div class="proof" id="proof4">
        <label>Proof.</label>
        <p>Let <em>G</em> be the following graph with root node
        <em>r</em>.</p>
        <figure id="fig7">
          <img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-fig7.jpg"
          class="img-responsive" alt="" longdesc="" />
        </figure>
        <p></p>
        <p>Furthermore, let ϕ be as defined in the proof of
        Proposition&nbsp;<a class="enc" href="#enc17">5.2</a>. Then
        <em>G</em> is of size 4<em>n</em> + 2, ϕ is of size
        2<em>n</em> + 2, but <span class=
        "inline-equation"><span class="tex">$[[ \varphi ]]
        _{G}$</span></span> is of size exponential in <em>n</em>;
        the name <span class="inline-equation"><span class=
        "tex">${\tt Alice}$</span></span> occurs 2
        <sup><em>n</em></sup> times in&nbsp;<span class=
        "inline-equation"><span class="tex">$[[ \varphi ]]
        _{G}$</span></span> .</p>
      </div>
      <p>A natural question at this point is how can we avoid
      obtaining a response object of exponential size. We prove
      next that we have at least two options: bound the number of
      different <em>walks</em> in the graph, or bound the
      <em>nesting depth</em> of queries. A walk in a graph is
      similar to a path but it is allowed to repeat edges. Notice
      that this implies that a graph with a cycle has an unbounded
      number of walks. The nesting depth of a query can be defined
      intuitively as the maximum number of nested curly braces in
      the query expression. For instance, the query in
      Figure&nbsp;<a class="fig" href="#fig4">4</a> has nesting
      depth 4.</p>
      <p></p>
      <div class="theorem" id="enc19">
        <label>Theorem 5.4.</label>
        <p>Let <em>G</em> be a graph with root node <em>r</em>, and
        ϕ a GraphQL query. Let <em>K</em> be a constant value not
        depending on the size of <em>G</em> or ϕ. Consider the
        following two properties.</p>
        <p></p>
        <ol class="list-no-style">
          <li id="list21" label="(1)">For every node <em>v</em> in
          <em>G</em> the number of different walks from <em>r</em>
          to <em>v</em> is bounded by <em>K</em>.<br /></li>
          <li id="list22" label="(2)">The nesting depth of ϕ is
          bounded by <em>K</em>.<br /></li>
        </ol>
        <p></p>
        <p>For <em>G</em> and ϕ satisfying either (1) or (2) we
        have that the evaluation <span class=
        "inline-equation"><span class="tex">$[[ \varphi ]]
        _{G}$</span></span> is of size <em>O</em>(|<em>G</em>|
        <sup><em>K</em></sup> · |ϕ|).</p>
      </div>
      <p></p>
      <div class="proof" id="proof5">
        <label>Proof.</label>
        <p>(Sketch) For case (1), let <span class=
        "inline-equation"><span class="tex">$\rho =[[ \varphi ]]
        _{G}$</span></span> . We know that every data value in
        <em>ρ</em> corresponds to a property of some node in
        <em>G</em> and, moreover, every path in <em>ρ</em>
        corresponds to a walk in <em>G</em> from the root node.
        Thus, the maximum number of data values appearing in
        <em>ρ</em> is bounded by |<em>G</em>| <sup><em>K</em></sup>
        . Furthermore, for every such value, the length of its path
        in <em>ρ</em> is bounded by |ϕ|, which gives us the
        <em>O</em>(|<em>G</em>| <sup><em>K</em></sup> · |ϕ|) bound.
        For case (2) the result follows from a simple induction
        argument.</p>
      </div>
      <p>Property&nbsp;(2) is exactly one of the restrictions that
      the GraphQL interface of Github imposes to ensure a
      reasonable output size&nbsp;(see Sec.&nbsp;<a class="sec"
      href="#sec-3">1</a>)&nbsp;[<a class="bib" data-trigger=
      "hover" data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0007">7</a>]; there also exists a software
      library&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0020">20</a>] that can be used to integrate the
      same type of restriction into any other
      GraphQL&nbsp;server.</p>
      <p>While property&nbsp;(1) or property&nbsp;(2) may be
      applied as a restriction to avoid exponential blow up of
      query results, we emphasize that both properties are more
      restrictive than necessary. That is, there are cases in which
      the properties are not satisfied but query results can still
      be of polynomial size only. For instance, we recall our
      initial Github experiment&nbsp;(cf. Sec.&nbsp;<a class="sec"
      href="#sec-3">1</a>) where the owner of some of the Github
      repositories listed for a Github user with login “danbri” was
      “danbri” himself. Hence, the data exposed via Github's
      GraphQL interface contains cycles and, thus, does not satisfy
      property&nbsp;(1). Now, for the sequence of queries in our
      experiment&nbsp;(with the level-1 and the level-2 versions
      illustrated in Figures&nbsp;<a class="fig" href=
      "#fig1">1</a>(a) and <a class="fig" href="#fig1">1</a>(c),
      respectively), consider a variation of the queries that uses
      <tt>first:1</tt>&nbsp;(instead of <tt>first:2</tt> or
      <tt>first:5</tt>). It is easy to see that the result size of
      the so-changed queries grows linearly with the level of the
      queries. Hence, for these queries we may permit an
      arbitrarily deep nesting without having to expect an
      exponential result size blow up. In this case, enforcing
      property&nbsp;(2) is too restrictive.</p>
      <p>In addition to restricting the nesting depth of queries,
      other approaches are used in practice to identify queries
      whose computation could be too resource intensive. For
      instance, Github combines the nesting-depth
      restriction&nbsp;(using a <em>K</em> of 25) with the
      following restriction. For every subquery of the form
      <span class="inline-equation"><span class="tex">${\tt f} {\tt
      [} \alpha {\tt ]{} \varphi {\tt }}$</span></span> or
      <span class="inline-equation"><span class="tex">$\ell {\tt :}
      {\tt f} {\tt [} \alpha {\tt ]{} \varphi {\tt
      }}$</span></span> for which the type of
      field&nbsp;<span class="inline-equation"><span class=
      "tex">${\tt f}$</span></span> is a list type&nbsp;(i.e.,
      <span class="inline-equation"><span class="tex">${\it
      type}_{\mathcal {S}}({\tt f})\in {\tt L}_{\tt
      T}$</span></span> ), the arguments&nbsp;<em>α</em> must
      contain either the argument named <tt>first</tt> or the
      argument named <tt>last</tt>, with a value that is an integer
      from 1 to 100. Moreover, based on these argument values, the
      Github GraphQL interface computes the maximum number of
      possible result nodes at each level of nesting depth of a
      given query. Queries for which this number is greater than
      500,000 at some level are rejected&nbsp;[<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0007">7</a>].</p>
      <p>Note that this restriction has not been sufficient to
      prevent the overly resource intensive attempt to execute the
      level-6 and the level-7 version of the test queries in our
      experiment in which we used <tt>first:5</tt>&nbsp;(i.e.,
      Figure&nbsp;<a class="fig" href="#fig1">1</a>(e)). On the
      other hand, the restriction may also be too restrictive in
      various cases. For instance, there may be a query for which
      the maximum number of <em>possible</em> result nodes at some
      level of nesting depth is greater than 500,000, but if the
      query would be executed, the actual number of result nodes
      may turn out to be significantly smaller and not cause any
      trouble at all.</p>
      <p>We found two more software libraries&nbsp;[<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0001">1</a>, <a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0014">14</a>] that aim to estimate some
      notion of “complexity” or “cost” of GraphQL queries. These
      estimation approaches take into account different cost
      factors that a user may associate with the various elements
      of the schema used. However, these approaches suffer from the
      same problem as the restrictions imposed by Github's GraphQL
      interface: They may easily overestimate the cost of a query
      by a large degree.</p>
      <section id="sec-13">
        <section id="sec-14">
          <p><em>Computing the exact size of a GraphQL
          response.</em> As shown in Theorem&nbsp;<a class="enc"
          href="#enc19">5.4</a>, in order to avoid returning
          response objects of exponential size, GraphQL service
          providers must impose severe restrictions on the
          structure of the queries or the data. Moreover, these
          restrictions can fail in both directions: discarding
          settings in which an efficient evaluation is possible and
          allowing settings in which a complete evaluation is too
          resource intensive. Fortunately, we can give a more
          elegant solution by showing that the exact size of the
          complete evaluation of a GraphQL query can be computed
          efficiently without the need of evaluating the whole
          query. We formalize this result in the following
          theorem.</p>
          <div class="theorem" id="enc20">
            <label>Theorem 5.5.</label>
            <p>Let <em>G</em> be a GraphQL graph and ϕ a
            non-redundant query in ground-typed normal form. The
            size of <span class="inline-equation"><span class=
            "tex">$[[ \varphi ]] _G$</span></span> can be computed
            in time <em>O</em>(|<em>G</em>| · |ϕ|).</p>
          </div>
          <p>To prove the theorem we present a dynamic programming
          strategy in Algorithms&nbsp;1 and&nbsp;2 . Let ϕ be a
          query and <em>G</em> a graph. The idea of procedure
          <span class="inline-equation"><span class="tex">$\mathtt
          {Label}$</span></span> in Algorithm&nbsp;2 is to label
          every node <em>u</em> with all subqueries <em>ψ</em> of ϕ
          for which we already know the size of <span class=
          "inline-equation"><span class="tex">$[[ \psi ]]
          _G^u$</span></span> . In that way we never visit a node
          twice for the same subquery. We maintain two structures:
          <span class="inline-equation"><span class="tex">$\mathtt
          {labels}[u]$</span></span> to store (pointers to) the
          subqueries, and <span class=
          "inline-equation"><span class="tex">$\mathtt
          {size}[u,\psi ]$</span></span> to store the size of
          <span class="inline-equation"><span class="tex">$[[ \psi
          ]] _G^u$</span></span> . To briefly illustrate how the
          algorithm works, consider the following graph</p>
          <figure id="fig8">
            <img src=
            "../../../data/deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-fig8.jpg"
            class="img-responsive" alt="" longdesc="" />
          </figure>
          <p></p>
          <p>and query ϕ given by
          <tt>e&nbsp;{&nbsp;g&nbsp;{&nbsp;a&nbsp;}&nbsp;}&nbsp;f&nbsp;{&nbsp;g&nbsp;{&nbsp;a&nbsp;}&nbsp;}</tt>.
          Assume that at some point during the execution of
          <span class="inline-equation"><span class="tex">$\mathtt
          {Label}$</span></span> we visit <em>w</em> with subquery
          <span class="inline-equation"><span class="tex">$\texttt
          {a}$</span></span> for the first time. Then, we store
          <span class="inline-equation"><span class="tex">$\texttt
          {a}$</span></span> in <span class=
          "inline-equation"><span class="tex">$\mathtt
          {labels}[w]$</span></span> (line&nbsp;2 in
          Algorithm&nbsp;2) and set <span class=
          "inline-equation"><span class="tex">$\mathtt
          {size}[w,\texttt {a}]$</span></span> to
          3&nbsp;(line&nbsp;4) because the evaluation is
          <span class="inline-equation"><span class="tex">$\texttt
          {a}\mathtt {:}\texttt {1}$</span></span> , which has
          three symbols. Assume now that we visit <em>v</em> with
          subquery <tt>g{a}</tt>. We first store this expression in
          <span class="inline-equation"><span class="tex">$\mathtt
          {labels}[v]$</span></span> and we recursively call
          <span class="inline-equation"><span class="tex">$\mathtt
          {Label}(G,w,\texttt {a})$</span></span> (line&nbsp;9)
          because <span class="inline-equation"><span class=
          "tex">$(v, {\tt g}, w)\in E$</span></span> . Given that
          <span class="inline-equation"><span class="tex">$\texttt
          {a}\in \mathtt {labels}[w]$</span></span> , the process
          immediately returns without any additional computation
          (line&nbsp;1). Next, we increment <span class=
          "inline-equation"><span class="tex">$\mathtt
          {size}[v,{\tt g{a}}]$</span></span> with <span class=
          "inline-equation"><span class="tex">$\mathtt
          {size}[w,{\tt a}]+2=5$</span></span> (line&nbsp;10), and
          finally add 2 (line&nbsp;12) to obtain <span class=
          "inline-equation"><span class="tex">$\mathtt
          {size}[v,{\tt g{a}}]=7$</span></span> , which is exactly
          the size of the evaluation <tt>g:{a:1}</tt> <span class=
          "inline-equation"><span class="tex">$=[[ {\tt g{a}}]]
          _G^v$</span></span> . With a similar analysis we obtain
          that the algorithm produces the value <span class=
          "inline-equation"><span class="tex">$\mathtt
          {size}[u,{\tt e{g{a}}}]=11$</span></span> , which is the
          number of symbols in <tt>e:{g:{a:1}}</tt>. What is more
          interesting is the call to <span class=
          "inline-equation"><span class="tex">$\mathtt
          {Label}$</span></span> with arguments <em>u</em> and
          <tt>f{g{a}}</tt>. Notice that this call produces a
          recursive call to <span class=
          "inline-equation"><span class="tex">$\mathtt
          {Label}(G,v,{\tt g{a}})$</span></span> , but since
          <tt>g{a}</tt> <span class="inline-equation"><span class=
          "tex">$\ \in \mathtt {labels}[v]$</span></span> , we
          already have the correct size in <span class=
          "inline-equation"><span class="tex">$\mathtt
          {size}[v,{\tt g{a}}]$</span></span> and we do not need to
          do any additional computation. Finally, the value
          <span class="inline-equation"><span class="tex">$\mathtt
          {size}[v,{\tt g{a}}]=7$</span></span> is used to set
          <span class="inline-equation"><span class="tex">$\mathtt
          {size}[u,{\tt f{g{a}}}]$</span></span> to value 11. All
          this computation can be used to obtain the size of
          <span class="inline-equation"><span class="tex">$[[
          \varphi ]] _G^u$</span></span> which is <span class=
          "inline-equation"><span class="tex">$\mathtt
          {size}[u,{\tt e{g{a}}}]+\mathtt {size}[u,{\tt
          f{g{a}}}]=22$</span></span> (line&nbsp;21) which is the
          number of symbols of <tt>e:{g:{a:1}}</tt>
          <tt>f:{g:{a:1}}</tt>. Algorithm&nbsp;1 initializes all
          the needed structures and makes the initial call with the
          whole query and the root node. To see that
          Algorithm&nbsp;1 works in time <em>O</em>(|<em>G</em>| ·
          |ϕ|) just notice that the number of subqueries is linear
          with respect to the query, and every node is visited at
          most once per subquery. Moreover, when visiting a node
          <em>u</em>, the number of steps is at most the number of
          outgoing edges from <em>u</em>.</p>
          <p><img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-img1.svg"
          class="img-responsive" alt="" longdesc="" /></p>
          <p><img src=
          "../../../data/deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-img2.svg"
          class="img-responsive" alt="" longdesc="" /></p>
        </section>
      </section>
    </section>
    <section id="sec-15">
      <header>
        <div class="title-info">
          <h2><span class="section-number">6</span> Related
          Work</h2>
        </div>
      </header>
      <p>A natural question is how our results compare with results
      for classical query languages. Given the tree-like structure
      of GraphQL queries, an immediate candidate to compare with is
      the language of acyclic conjunctive
      queries&nbsp;(ACQs)&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0008">8</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0022">22</a>]. Conjunctive queries (CQs)
      corresponds to the SELECT-FROM-WHERE fragment of SQL. The
      further acyclic restriction in ACQs ensures the existence of
      a <em>join tree</em> that allows one to efficiently evaluate
      the query&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0022">22</a>].</p>
      <p>In terms of expressiveness, it is not difficult to encode
      a GraphQL query into an ACQ, although some special care has
      to be put in the final construction of the GraphQL response
      object from the tuples of values produced by an ACQ. There is
      no formal work on proving properties of such an encoding, but
      practitioners have already started using these types of
      methods when evaluating GraphQL&nbsp;[<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0019">19</a>]. Despite the existence of
      an encoding, the classical ACQs complexity results do not
      directly entail the results in this paper. In terms of the
      evaluation problem, Gottlob et al.&nbsp;[<a class="bib"
      data-trigger="hover" data-toggle="popover" data-placement=
      "top" href="#BibPLXBIB0008">8</a>] have shown that for ACQs
      the problem is complete for LOGCFL, which is the class of
      problems that can be reduced in logarithmic space to a
      context-free language&nbsp;[<a class="bib" data-trigger=
      "hover" data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0011">11</a>]. <img src=
      "../../../data/deliveryimages.acm.org/10.1145/3190000/3186014/images/www2018-23-img3.svg"
      class="img-responsive" alt="" longdesc="" /> the membership
      of <font style="font-variant: small-caps">GraphQL-Eval</font>
      in NL shows an important difference in terms of complexity
      theory. In terms of the enumeration problem, there is a
      substantial amount of work on restrictions that allow a
      constant-delay evaluation for ACQs and related
      languages&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0002">2</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0004">4</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0012">12</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0017">17</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0018">18</a>]. As mentioned in&nbsp;[<a class=
      "bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0017">17</a>], “it is
      very unlikely that constant-delay enumeration can be achieved
      for all queries in ACQ” and, thus, constant-delay results
      impose restrictions over the structure of the
      queries&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0002">2</a>, <a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0017">17</a>] or of the queried
      data&nbsp;[<a class="bib" data-trigger="hover" data-toggle=
      "popover" data-placement="top" href="#BibPLXBIB0004">4</a>,
      <a class="bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0012">12</a>, <a class=
      "bib" data-trigger="hover" data-toggle="popover"
      data-placement="top" href="#BibPLXBIB0018">18</a>]. In
      contrast, Theorem&nbsp;<a class="enc" href="#enc14">4.2</a>
      proves the constant-delay result for GraphQL in general,
      requiring only a specific normal form for queries.</p>
      <p>Pichler and Skritek&nbsp;[<a class="bib" data-trigger=
      "hover" data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0015">15</a>] presented a fairly complete picture
      of the complexity of counting the number of tuples in the
      evaluation of an ACQ. This problem is closely related to the
      problem of computing the size of the evaluation of a GraphQL
      query. In&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0015">15</a>] the authors proved that for general
      ACQs the problem is intractable, and they presented a
      polynomial-time algorithm for the case of ACQs without
      existential variables. It is not clear that a GraphQL query
      can be encoded as a single ACQ without existential variables,
      but even if possible, applied to our scenario, the algorithm
      in&nbsp;[<a class="bib" data-trigger="hover" data-toggle=
      "popover" data-placement="top" href="#BibPLXBIB0015">15</a>]
      would work in time <em>O</em>(|<em>G</em>|<sup>2</sup> · |ϕ|)
      (see Theorem 1 in&nbsp;[<a class="bib" data-trigger="hover"
      data-toggle="popover" data-placement="top" href=
      "#BibPLXBIB0015">15</a>]), while our algorithm works in time
      linear with respect to |<em>G</em>|.</p>
    </section>
    <section id="sec-16">
      <header>
        <div class="title-info">
          <h2><span class="section-number">7</span>
          Conclusions</h2>
        </div>
      </header>
      <p>GraphQL is becoming increasingly popular as an alternative
      to REST-based interfaces which have dominated the Web-API
      scenario for more than 10 years. In the spirit of classical
      query languages, GraphQL uses a schema to describe the
      organization of the data and a declarative query language to
      allow clients to access this data.</p>
      <p>We have embarked on a systematic study of GraphQL
      providing a full formalization of the semantics of its query
      language based on a logical data model. Given this
      formalization, we have also studied the complexity of the
      language, in particular the evaluation, enumeration, and
      size-computation problems, showing that all of them can be
      efficiently solved. While our conceptual contributions can be
      used to further study the language form a theoretical point
      of view, our technical contributions can also help developers
      to implement more robust GraphQL interfaces on the Web.</p>
    </section>
  </section>
  <section class="back-matter">
    <section id="sec-17">
      <header>
        <div class="title-info">
          <h2>ACKNOWLEDGMENTS</h2>
        </div>
      </header>
      <p>Olaf Hartig's work has been funded by the CENIIT program
      at Linköping University&nbsp;(project number 17.05). Jorge
      Pérez is supported by the Millenium Institute for
      Foundational Research on Data, and ENLACE-Fondecyt
      VID-UChile.</p>
    </section>
    <section id="ref-001">
      <header>
        <div class="title-info">
          <h2 class="page-brake-head">REFERENCES</h2>
        </div>
      </header>
      <ul class="bibUl">
        <li id="BibPLXBIB0001" label="[1]">4Catalyzer Corporation.
        2017. GraphQL Validation Complexity. <a href=
        "https://github.com/4Catalyzer/graphql-validation-complexity/"
          target=
          "_blank">https://github.com/4Catalyzer/graphql-validation-complexity/</a>.
          (2017).
        </li>
        <li id="BibPLXBIB0002" label="[2]">Guillaume Bagan, Arnaud
        Durand, and Etienne Grandjean. 2007. On Acyclic Conjunctive
        Queries and Constant Delay Enumeration. In <em><em>Computer
        Science Logic, 21st International Workshop, CSL 2007, 16th
        Annual Conference of the EACSL, Lausanne, Switzerland,
        September 11-15, 2007, Proceedings</em></em> .
        208–222.</li>
        <li id="BibPLXBIB0003" label="[3]">Nadia Creignou, Markus
        Kröll, Reinhard Pichler, Sebastian Skritek, and Heribert
        Vollmer. 2017. On the Complexity of Hard Enumeration
        Problems. In <em><em>Language and Automata Theory and
        Applications - 11th International Conference, LATA 2017,
        Umeå, Sweden, March 6-9, 2017, Proceedings</em></em> .
        183–195.</li>
        <li id="BibPLXBIB0004" label="[4]">Arnaud Durand, Nicole
        Schweikardt, and Luc Segoufin. 2014. Enumerating answers to
        first-order queries over databases of low degree. In
        <em><em>Proceedings of the 33rd ACM SIGMOD-SIGACT-SIGART
        Symposium on Principles of Database Systems, PODS’14,
        Snowbird, UT, USA, June 22-27, 2014</em></em> .
        121–131.</li>
        <li id="BibPLXBIB0005" label="[5]">Facebook, Inc.2016.
        GraphQL. Working Draft, Oct.&nbsp;2016. Online at
          <a href="http://facebook.github.io/graphql" target=
          "_blank">http://facebook.github.io/graphql</a>, retrieved
          on Dec.&nbsp;12, 2016. (Oct. 2016).
        </li>
        <li id="BibPLXBIB0006" label="[6]">Github GraphQL API v4
        2017. <a href="https://developer.github.com/v4/" target=
        "_blank">https://developer.github.com/v4/</a>. (2017).
        </li>
        <li id="BibPLXBIB0007" label="[7]">Github GraphQL API v4,
        GraphQL resource limitations 2017. <a href=
        "https://developer.github.com/v4/guides/resource-limitations/"
          target=
          "_blank">https://developer.github.com/v4/guides/resource-limitations/</a>.
          (2017).
        </li>
        <li id="BibPLXBIB0008" label="[8]">Georg Gottlob, Nicola
        Leone, and Francesco Scarcello. 2001. The complexity of
        acyclic conjunctive queries. <em><em>J. ACM</em></em> 48, 3
        (2001), 431–498.</li>
        <li id="BibPLXBIB0009" label="[9]">GraphQL Users2017.
        <a href="http://graphql.org/users/" target=
        "_blank">http://graphql.org/users/</a>. (2017).
        </li>
        <li id="BibPLXBIB0010" label="[10]">Olaf Hartig and Jorge
        Pérez. 2017. An Initial Analysis of Facebook's GraphQL
        Language. In <em><em>Proceedings of the 11th Alberto
        Mendelzon International Workshop on Foundations of Data
        Management (AMW)</em></em> .</li>
        <li id="BibPLXBIB0011" label="[11]">D.&nbsp;S. Johnson.
        1990. A catalog of complexity classes. In <em><em>Handbook
        of Theoretical Computer Science</em></em> , J.&nbsp;van
        Leeuwen (Ed.). Vol.&nbsp;A. Elsevier, Chapter 2.</li>
        <li id="BibPLXBIB0012" label="[12]">Wojciech Kazana and Luc
        Segoufin. 2013. Enumeration of first-order queries on
        classes of structures with bounded expansion. In
        <em><em>Proceedings of the 32nd ACM SIGMOD-SIGACT-SIGART
        Symposium on Principles of Database Systems, PODS 2013, New
        York, NY, USA - June 22 - 27, 2013</em></em> .
        297–308.</li>
        <li id="BibPLXBIB0013" label="[13]">Markus Kröll, Reinhard
        Pichler, and Sebastian Skritek. 2016. On the Complexity of
        Enumerating the Answers to Well-designed Pattern Trees. In
        <em><em>19th International Conference on Database Theory,
        ICDT 2016, Bordeaux, France, March 15-18, 2016</em></em> .
        22:1–22:18.</li>
        <li id="BibPLXBIB0014" label="[14]">Ivo Meißner. 2017.
        GraphQL Query Complexity Analysis for graphql-js.
          <a href="https://github.com/ivome/graphql-query-complexity/"
          target=
          "_blank">https://github.com/ivome/graphql-query-complexity/</a>.
          (2017).
        </li>
        <li id="BibPLXBIB0015" label="[15]">Reinhard Pichler and
        Sebastian Skritek. 2013. Tractable counting of the answers
        to conjunctive queries. <em><em>J. Comput. Syst.
        Sci.</em></em> 79, 6 (2013), 984–1001.</li>
        <li id="BibPLXBIB0016" label="[16]">Leonard Richardson,
        Mike Amundsen, and Sam Ruby. 2013. <em><em>RESTful Web
        APIs</em></em> . O'Reilly Media, Inc.</li>
        <li id="BibPLXBIB0017" label="[17]">Luc Segoufin. 2013.
        Enumerating with constant delay the answers to a query. In
        <em><em>Joint 2013 EDBT/ICDT Conferences, ICDT ’13
        Proceedings, Genoa, Italy, March 18-22, 2013</em></em> .
        10–20.</li>
        <li id="BibPLXBIB0018" label="[18]">Luc Segoufin and
        Alexandre Vigny. 2017. Constant Delay Enumeration for FO
        Queries over Databases with Local Bounded Expansion. In
        <em><em>20th International Conference on Database Theory,
        ICDT 2017, March 21-24, 2017, Venice, Italy</em></em> .
        20:1–20:16.</li>
        <li id="BibPLXBIB0019" label="[19]">Stem Disintermedia,
        Inc.2016. Join Monster. <a href=
        "https://github.com/stems/join-monster" target=
        "_blank">https://github.com/stems/join-monster</a>. (2016).
        </li>
        <li id="BibPLXBIB0020" label="[20]">Stem Disintermedia,
        Inc.2017. GraphQL Depth Limit. <a href=
        "https://github.com/stems/graphql-depth-limit/" target=
        "_blank">https://github.com/stems/graphql-depth-limit/</a>.
        (2017).
        </li>
        <li id="BibPLXBIB0021" label="[21]">Moshe&nbsp;Y. Vardi.
        1982. The Complexity of Relational Query Languages
        (Extended Abstract). In <em><em>Proceedings of the 14th
        Annual ACM Symposium on Theory of Computing, May 5-7, 1982,
        San Francisco, California, USA</em></em> . 137–146.</li>
        <li id="BibPLXBIB0022" label="[22]">Mihalis Yannakakis.
        1981. Algorithms for Acyclic Database Schemes. In
        <em><em>Very Large Data Bases, 7th International
        Conference, September 9-11, 1981, Cannes, France,
        Proceedings</em></em> . 82–94.</li>
      </ul>
    </section>
  </section>
  <section id="foot-001" class="footnote">
    <header>
      <div class="title-info">
        <h2>FOOTNOTE</h2>
      </div>
    </header>
    <p id="fn1"><a href="#foot-fn1"><sup>1</sup></a>All the query
    executions on which we report have been performed on Oct. 3,
    2017.</p>
    <p id="fn2"><a href="#foot-fn2"><sup>2</sup></a>When increasing
    the number of repositories to be considered, by changing
    <tt>first:2</tt> to, say, <tt>first:10</tt>, we also find
    repositories with other owners.</p>
    <div class="bibStrip">
      <p>This paper is published under the Creative Commons
      Attribution 4.0 International (CC-BY&nbsp;4.0) license.
      Authors reserve their rights to disseminate the work on their
      personal and corporate Web sites with the appropriate
      attribution.</p>
      <p><em>WWW '18, April 23-27, 2018, Lyon, France</em></p>
      <p>© 2018; IW3C2 (International World Wide Web Conference
      Committee), published under Creative Commons CC-BY&nbsp;4.0
      License. ACM ISBN 978-1-4503-5639-8/18/04.<br />
      DOI: <a class="link-inline force-break" target="_blank" href=
      "https://doi.org/10.1145/3178876.3186014">https://doi.org/10.1145/3178876.3186014</a></p>
    </div>
  </section>
  <div class="pubHistory">
    <p></p>
  </div>
</body>
</html>
