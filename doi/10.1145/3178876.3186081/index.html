<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> <head> <title>StaQC: A Systematically Mined Question-Code Dataset from Stack Overflow</title> <!-- Copyright (c) 2010-2015 The MathJax Consortium --><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta> <meta name="viewport" content="width=device-width; initial-scale=1.0;"></meta> <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta> <link media="screen, print" rel="stylesheet" href="../../../data/dl.acm.org/pubs/lib/css/bootstrap.min.css"/><link media="screen, print" rel="stylesheet" href="../../../data/dl.acm.org/pubs/lib/css/bootstrap-theme.min.css"/><link media="screen, print" rel="stylesheet" href="../../../data/dl.acm.org/pubs/lib/css/main.css"/><script src="../../../data/dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script> <script src="../../../data/dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script> <script src="../../../data/dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script> <script src="../../../data/dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script> <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script> <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script> <link rel="cite-as" href="https://doi.org/10.1145/3178876.3186081"/></head> <body id="main">
<div>
<p style='font-size: 75%; color #444'>
This is a web copy of <a href='https://doi.org/10.1145/3178876.3186081'>https://doi.org/10.1145/3178876.3186081</a>.
 Published in WWW2018 Proceedings Â© 2018 International World Wide Web Conference Committee, published under 
 <a rel='license' property='license' href='https://creativecommons.org/licenses/by/4.0/'>
 Creative Commons CC By 4.0 License</a>.
The <a href='https://github.com/usable-oa/thewebconf2018/tree/master/scripts'>modifications</a> 
from the original are solely to improve HTML aiming to make it Findable, Accessible, Interoperable and Reusable. 
augmenting HTML metadata and avoiding ACM trademark.
To reference this HTML version, use:
</p><p>
<strong>Permalink:</strong>
<a href='https://w3id.org/oa/10.1145/3178876.3186081'>https://w3id.org/oa/10.1145/3178876.3186081</a>
</p></div>
<hr>

 <section class="front-matter"> <section> <header class="title-info"> <div class="journal-title">  <h1>  <span class="title">StaQC: A Systematically Mined Question-Code Dataset from Stack Overflow</span>  <br/>  <span class="subTitle"/>  </h1> </div> </header> <div class="authorGroup"> <div class="author">  <span class="givenName">Ziyu</span>  <span class="surName">Yao</span>,   The Ohio State University, <a href="mailto:yao.470@osu.edu">yao.470@osu.edu</a> </div> <div class="author">  <span class="givenName">Daniel S.</span>  <span class="surName">Weld</span>,   University of Washington, <a href="mailto:weld@cs.washington.edu">weld@cs.washington.edu</a> </div> <div class="author">  <span class="givenName">Wei-Peng</span>  <span class="surName">Chen</span>,   Fujitsu Labs of America, <a href="mailto:wei-peng.chen@us.fujitsu.com">wei-peng.chen@us.fujitsu.com</a> </div> <div class="author">  <span class="givenName">Huan</span>  <span class="surName">Sun</span>,   The Ohio State University, <a href="mailto:sun.397@osu.edu">sun.397@osu.edu</a>  </div>    </div> <br/> <div class="pubInfo"> <p>DOI: <a href="https://doi.org/10.1145/3178876.3186081" target="_blank">https://doi.org/10.1145/3178876.3186081</a>  <br/>WWW '18: <a href="https://doi.org/10.1145/3178876" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p> </div> <div class="abstract"> <p>  <small>Stack Overflow (SO) has been a great source of natural language questions and their code solutions (i.e., question-code pairs), which are critical for many tasks including code retrieval and annotation. In most existing research, question-code pairs were collected <em>heuristically</em> and tend to have low quality. In this paper, we investigate a new problem of <em>systematically mining</em> question-code pairs from Stack Overflow (in contrast to <em>heuristically collecting</em> them). It is formulated as predicting whether or not a code snippet is a standalone solution to a question. We propose a novel Bi-View Hierarchical Neural Network which can capture both the programming content and the textual context of a code snippet (i.e., two views) to make a prediction. On two manually annotated datasets in Python and SQL domain, our framework substantially outperforms heuristic methods with at least <strong>15%</strong> higher <em>F</em>  <sub>1</sub> and accuracy. Furthermore, we present StaQC (<span style="text-decoration: underline;">Sta</span>ck Overflow <span style="text-decoration: underline;">Q</span>uestion-<span style="text-decoration: underline;">C</span>ode pairs), the largest dataset to date of <strong>&#x223C; 148K</strong> Python and <strong>&#x223C; 120K</strong> SQL question-code pairs, automatically mined from SO using our framework. Under various case studies, we demonstrate that StaQC can greatly help develop data-hungry models for associating natural language with programming language<a class="fn" href="#fn1" id="foot-fn1"><sup>1</sup></a>.</small> </p> </div> <div class="CCSconcepts"> <p> <small> <span style="font-weight:bold;">CCS Concepts:</span> &#x2022;<strong> Information systems </strong>&#x2192; <strong>Web searching and information discovery;</strong> <strong>Question answering;</strong> <strong>Information extraction;</strong> &#x2022;<strong> Software and its engineering </strong>&#x2192; <em>Automatic programming;</em></small> </p> </div> <div class="classifications"> <div class="author">  <span style="font-weight:bold;">  <small>Keywords:</small>  </span>  <span class="keyword">  <small>Natural Language Question Answering; Question-Code Pairs; Deep Neural Networks; Stack Overflow</small>  </span> </div> <br/> <div class="AcmReferenceFormat">  <p>  <small>  <span style="font-weight:bold;">ACM Reference Format:</span>  <br/>  Ziyu Yao, Daniel S. Weld, Wei-Peng Chen, and Huan Sun. 2018. StaQC: A Systematically Mined Question-Code Dataset from Stack Overflow. In <em>WWW 2018: The 2018 Web Conference,</em>  <em>April 23&#x2013;27, 2018,</em>  <em> Lyon, France. ACM, New York, NY, USA</em> 11 Pages. <a href="https://doi.org/10.1145/3178876.3186081" class="link-inline force-break"  target="_blank">https://doi.org/10.1145/3178876.3186081</a></small>  </p> </div> </div> </section> </section> <section class="body"> <section id="sec-4"> <header> <div class="title-info">  <h2>  <span class="section-number">1</span> Introduction</h2> </div> </header> <p>Online forums such as Stack Overflow (SO) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0040">40</a>] have contributed a huge number of code snippets, understanding and reuse of which can greatly speed up software development. Towards this goal, a lot of research work have been developed recently, such as retrieving or generating code snippets based on a natural language query, and annotating code snippets using natural language [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0002">2</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0021">21</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0028">28</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0044">44</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0052">52</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0061">61</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0064">64</a>]. At the core of these work are machine learning models that map between natural language and programming language, which are typically data-hungry [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0019">19</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0024">24</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0046">46</a>] and require large-scale and high-quality < natural language question, code solution > pairs (i.e., question-code or QC pairs). <figure id="fig1">  <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186077/images/www2018-90-fig1.jpg" class="img-responsive" alt="Figure 1"  longdesc=""/>  <div class="figure-caption">  <span class="figure-number">Figure 1:</span>  <span class="figure-title">The accepted answer post to question <em>&#x201C;Elegant Python function to convert CamelCase to snake_case?&#x201D;</em> in SO. <em>S<sub>i</sub>  </em> (<em>i</em> = 1, 2, 3, 4) and <em>C<sub>j</sub>  </em> (<em>j</em> = 1, 2, 3, 4) denote sentence blocks and code blocks respectively, which can be trivially separated based on the HTML format.</span>  </div> </figure> </p> <p>In our work, <em>we define a code snippet as a code solution when the questioner can solve the problem solely based on it</em> (also named as &#x201C;standalone&#x201D; solution). Take Figure <a class="fig" href="#fig1">1</a> as an example, which shows the accepted answer post<a class="fn" href="#fn2" id="foot-fn2"><sup>1</sup></a> to question &#x201C;<em>Elegant Python function to convert CamelCase to snake_case</em>&#x201D;. Among the four code snippets {<em>C</em> <sub>1</sub>, <em>C</em> <sub>2</sub>, <em>C</em> <sub>3</sub>, <em>C</em> <sub>4</sub>}, only <em>C</em> <sub>1</sub> and <em>C</em> <sub>3</sub> are standalone code solutions to the question while the rest are not, because <em>C</em> <sub>2</sub> only gives an input-output demo of the &#x201C;convert&#x201D; function without its definition and <em>C</em> <sub>4</sub> is a reminder of an additional detail. Given an answer post with multiple code snippets (i.e., a multi-code answer post) like Figure <a class="fig" href="#fig1">1</a>, previous work usually collected question-code pairs in heuristic ways: Simply pair the question title with the first code snippet, or with each code snippet, or with the concatenation of all code snippets in the post [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0002">2</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0064">64</a>]. Iyer et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0021">21</a>] merely employed accepted answer posts that contain exactly one code snippet, and discarded all others with multiple code snippets. Such heuristic question-code collection methods suffer from at least one of the following weaknesses: (1) Low precision: Questions do not match with their paired code snippets, when the latter serve as background, explanation, or input-output demo rather than as a solution (e.g., <em>C</em> <sub>2</sub> in Figure <a class="fig" href="#fig1">1</a>); (2) Low recall: If one only selects the first code snippet to pair with a question, other code solutions in an answer post (e.g., <em>C</em> <sub>3</sub>) will be unemployed.</p> <p>In fact, multi-code answer posts are very common in SO, which makes the low-precision and low-recall issues even more prominent. In the Stack Exchange Data dump[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0051">51</a>], among all accepted answer posts for Python and SQL &#x201C;how-to-do-it&#x201D; questions (to be introduced in Section <a class="sec" href="#sec-5">2</a>), 44.66% and 34.35% contain more than one code snippets respectively. Note that an accepted answer post was verified only <em>as an entirety</em> by the questioner, and labels on whether each individual code snippet serves as a standalone solution or not are not readily available. Moreover, it is not feasible to obtain such labels by simply running each code snippet in a programming environment for two reasons: (1) A runnable code snippet is not necessarily a code solution (e.g., <em>C</em> <sub>4</sub> in Figure&#x00A0;<a class="fig" href="#fig1">1</a>); (2) It was reported that around 74% of Python and 88% of SQL code snippets in SO are not directly parsable or runnable [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0021">21</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0059">59</a>]. Nevertheless, many of them usually contain critical information to answer a question. Therefore, they can still be used in semantic analysis for downstream tasks [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0002">2</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0021">21</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0059">59</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0064">64</a>] once paired with natural language questions.</p> <p>To systematically mine question-code pairs with high precision and recall, we propose a novel task: <em>Given a question</em><a class="fn" href="#fn3" id="foot-fn3"><sup>2</sup></a>  <em>in SO and its accepted answer post with multiple code snippets, how to predict whether each code snippet is a standalone solution or not?</em> In this paper, we focus on &#x201C;how-to-do-it&#x201D;-type of questions which ask how to implement a certain task like in Figure&#x00A0;<a class="fig" href="#fig1">1</a>, since answers to such questions are most likely to be standalone code solutions. The definition and classification of different types of questions will be discussed in Section <a class="sec" href="#sec-5">2</a>. We identify two challenges in our task: (1) As shown in Figure&#x00A0;<a class="fig" href="#fig1">1</a>, code snippets in an answer post can play many non-solution roles such as serving as an input-output demo or reminder (e.g., <em>C</em> <sub>2</sub> and <em>C</em> <sub>4</sub>), which calls for a statistical learning model to make accurate predictions. (2) Both the textual context and the programming content of a code snippet can be predictive, but an effective model to jointly utilize them needs careful design. Intuitively, a text block with patterns like &#x201C;you can do ...&#x201D; and &#x201C;this is one thorough solution ...&#x201D; is more likely to be followed by a code solution. For example, given <em>S</em> <sub>1</sub> and <em>S</em> <sub>3</sub> in Figure <a class="fig" href="#fig1">1</a>, a code solution is likely to be introduced after them. On the other hand, by inspecting the code content, <em>C</em> <sub>2</sub> is probably not a code solution to the question, since it contains special Python console patterns like &#x201C; > > > ... > > > &#x201D; and no particular definition of &#x201C;convert&#x201D;.</p> <p>To tackle these challenges, we explore a series of models including traditional classifiers and deep learning models, and propose a novel model, named Bi-View Hierarchical Neural Network (BiV-HNN), to capture both the textual context and the programming content of each code snippet (which make the two views). In BiV-HNN, we design two different modules to learn features from text and code respectively, and combine them into a deep neural network architecture, which finally predicts whether a code snippet is a standalone solution or not. To summarize, our contributions lie in three folds:</p> <p> <em>First</em>, to the best of our knowledge, we are the first to investigate <em>systematically mining large-scale high-quality question-code pairs</em>, which are critical for developing learning-based models aiming to map between natural language and programming language.</p> <p> <em>Second</em>, we extensively explore various models including traditional classifiers and deep learning models to predict whether a code snippet is a solution or not, and propose a novel Bi-View Hierarchical Neural Network which considers both text- and code-based views. On two manually labeled datasets in Python and SQL domain, BiV-HNN outperforms both the widely adopted heuristic methods and traditional classifiers by a large margin in terms of <em>F</em> <sub>1</sub> and accuracy. Moreover, BiV-HNN does not rely on any prior knowledge and can be easily applied to other programming domains.</p> <p> <em>Last but not least</em>, we present StaQC, the largest dataset to date of <strong>&#x223C; 148K</strong> Python and <strong>&#x223C; 120K</strong> SQL question-code pairs, systematically mined by our framework. Using multiple case studies, we show that (1) StaQC is rich in surface variation: A question can be paired with multiple code solutions, and semantically the same code snippets can have different/paraphrased natural language descriptions. (2) Owing to such diversity as well as its large scale, StaQC is a much better data resource than existing ones for constructing models to map between natural language and programming language. In addition, we can continue to grow StaQC in both size and diversity, by regularly applying our framework to the fast-growing SO. Question-code pairs in other programming languages can also be mined similarly and included in StaQC.</p> </section> <section id="sec-5"> <header> <div class="title-info">  <h2>  <span class="section-number">2</span> Preliminaries</h2> </div> </header> <p>In this section, we first clarify our task definition, and then describe how we annotated datasets for model development.</p> <section id="sec-6"> <header>  <div class="title-info">  <h3>  <span class="section-number">2.1</span> Task Definition</h3>  </div> </header> <p>Given a question and its accepted answer post which contains multiple code snippets in Stack Overflow, we aim at predicting whether each code snippet in the answer post is a <em>standalone</em> solution to the question or not. As explained in Section <a class="sec" href="#sec-4">1</a>, we focus on &#x201C;accepted&#x201D; answer posts and &#x201C;standalone&#x201D; solutions.</p> <p>Users can ask different types of questions in SO such as &#x201C;how to implement X&#x201D; and &#x201C;what/why is Y&#x201D;. Following previous work [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0012">12</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0013">13</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0032">32</a>], we divide questions into five types: &#x201C;How-to-do-it&#x201D;, &#x201C;Debug/corrective&#x201D;, &#x201C;Conceptual&#x201D;, &#x201C;Seeking something, e.g., advice, tutorial&#x201D;, and their combinations. In particular, a question is of type &#x201C;how-to-do-it&#x201D; when the questioner provides a scenario and asks how to implement it like in Figure <a class="fig" href="#fig1">1</a>.</p> <p>For collecting question-code pairs, we target at &#x201C;how-to-do-it&#x201D; questions, because answers to other types of questions are not very likely to be standalone code solutions (e.g., answers to &#x201C;Conceptual&#x201D; questions are usually text descriptions). Next, we describe how to distinguish &#x201C;how-to-do-it&#x201D; questions from others.</p> </section> <section id="sec-7"> <header>  <div class="title-info">  <h3>  <span class="section-number">2.2</span> &#x201C;How-to-do-it&#x201D; Question Collection</h3>  </div> </header> <section id="sec-8">  <p><em>2.2.1 Question Type Classification.</em> &#x00A0;</p>  <p>At the high level, we combined the other four question types apart from &#x201C;how-to-do-it&#x201D; into one category named &#x201C;non-how-to&#x201D; and built a binary question type classifier.</p>  <p>We first collected Python and SQL questions from SO based on their tags, which are available for all question posts. Specifically, we considered questions whose tags contain the keyword &#x201C;python&#x201D; to be in Python domain and questions tagged by &#x201C;sql&#x201D;, &#x201C;database&#x201D; or &#x201C;oracle&#x201D; to be in SQL domain. For each domain, we randomly sampled and labeled 250 questions for training (150), validating (20) and testing (80) the classifier<a class="fn" href="#fn4" id="foot-fn4"><sup>3</sup></a>. Among the 250 questions, around 45% in Python and 57% in SQL are &#x201C;how-to-do-it&#x201D; questions. We built one Logistic Regression classifier respectively for each domain, based on simple features extracted from question and answer posts as in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0013">13</a>], such as keyword-occurrence features, the number of code blocks in question/answer posts, the maximum length of code blocks, etc. Hyperparameters in classifiers were tuned based on validation sets.</p>  <p>Finally, we obtained a question-type classification accuracy of 0.738 (precision: 0.653, recall: 0.889, and <em>F</em>  <sub>1</sub>: 0.753) for Python and an accuracy of 0.713 (precision: 0.625, recall: 0.946, and <em>F</em>  <sub>1</sub>: 0.753) for SQL. The classification of question types may be further improved with more advanced features and algorithms, which is not the focus of this paper.</p> </section> <section id="sec-9">  <p><em>2.2.2 &#x201C;How-to-do-it&#x201D; Question Set Collection.</em> &#x00A0;</p>  <p>Using the above classifiers, we classified all Python and SQL questions in SO whose accepted answer post contains code blocks and collected a large set of &#x201C;how-to-do-it&#x201D; questions in each domain. Among these &#x201C;how-to-do-it&#x201D; questions, around 44.66% (68,839) Python questions and 34.45% (39,752) SQL questions have an accepted answer post with more than one code snippets, from which we will systematically mine question-code pairs.</p> </section> </section> <section id="sec-10"> <header>  <div class="title-info">  <h3>  <span class="section-number">2.3</span> Annotating QC Pairs for Model Training</h3>  </div> </header> <p>To construct training/validation/testing datasets for our task, we hired four undergraduate students familiar with Python and SQL to annotate answer posts in these two domains. For each code snippet in an answer post, annotators can assign &#x201C;1&#x201D; to it if they think they can solve the problem based on the code snippet alone (i.e., it is a standalone code solution), and &#x201C;0&#x201D; otherwise. We ensured each code snippet is annotated by two annotators and adopted the label only when both annotators agreed on it. For each programming language, around 85% code snippets were labeled. The average Cohen&#x0027;s kappa agreement [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0009">9</a>] is around 0.658 for Python and 0.691 for SQL. The statistics of our manually annotated datasets are summarized in Table <a class="tbl" href="#tab1">1</a>, which will be used to develop our models.</p> </section> </section> <section id="sec-11"> <header> <div class="title-info">  <h2>  <span class="section-number">3</span> Bi-View Hierarchical NN</h2> </div> </header> <p>Without loss of generality, let us assume an answer post of a given question has a sequence of <em>blocks</em>  <span class="inline-equation"><span class="tex">$\lbrace S_{1}, C_{1}, S_2,..., S_i, C_i, S_{i+1}, ..., S_{L-1}, \\C_{L-1}, S_{L}\rbrace$</span> </span> with <em>L</em> text blocks (<em>S<sub>i</sub> </em>&#x2019;s) and <em>L</em> &#x2212; 1 code blocks (<em>C<sub>i</sub> </em>&#x2019;s) interleaving with each other. Our task is to automatically assign a binary label to each code snippet <em>C<sub>i</sub> </em>, where 1 means a standalone solution while 0 otherwise. In this work, we model each code snippet independently and predict the label of <em>C<sub>i</sub> </em> based on its textual context (i.e., <em>S<sub>i</sub> </em>, <em>S</em> <sub>  <em>i</em> + 1</sub>) and programming content. If either <em>S<sub>i</sub> </em> or <em>S</em> <sub>  <em>i</em> + 1</sub> is empty, we insert an empty dummy text block to make our model applicable. One can extend our formulation to a more complicated sequence labeling problem where a sequence of code snippets can be modeled simultaneously, which we leave for future work.</p> <div class="table-responsive" id="tab1"> <div class="table-caption">  <span class="table-number">Table 1:</span>  <span class="table-title">Statistics of manually annotated datasets.</span> </div> <table class="table"> 			 <thead>  <tr>  <th style="text-align:center;"/>  <th colspan="2" style="text-align:center;">  <strong>Python</strong>  <hr/>  </th>  <th colspan="2" style="text-align:center;">  <strong>SQL</strong>  <hr/>  </th>  </tr>  <tr>  <th style="text-align:center;"/>  <th style="text-align:center;"># of QC pairs</th>  <th style="text-align:center;">% of QC pairs with label &#x201C;1&#x201D;</th>  <th style="text-align:center;"># of QC pairs</th>  <th style="text-align:center;">% of QC pairs with label &#x201C;1&#x201D;</th>  </tr> 					 </thead>  <tbody>  <tr>  <td style="text-align:center;">Training</td>  <td style="text-align:center;">2,932</td>  <td style="text-align:center;">43.89%</td>  <td style="text-align:center;">2,183</td>  <td style="text-align:center;">56.12%</td>  </tr>  <tr>  <td style="text-align:center;">Validation</td>  <td style="text-align:center;">976</td>  <td style="text-align:center;">43.14%</td>  <td style="text-align:center;">727</td>  <td style="text-align:center;">55.98%</td>  </tr>  <tr>  <td style="text-align:center;">Testing</td>  <td style="text-align:center;">976</td>  <td style="text-align:center;">47.23%</td>  <td style="text-align:center;">727</td>  <td style="text-align:center;">58.32%</td>  </tr>  </tbody> </table> </div> <section id="sec-12"> <header>  <div class="title-info">  <h3>  <span class="section-number">3.1</span> Intuition</h3>  </div> </header> <p>We first analyze at the high level how each individual block contributes to elaborating the entire answer fluently. For example, in Figure <a class="fig" href="#fig1">1</a>, the first text block <em>S</em>  <sub>1</sub> suggests its followed code block <em>C</em>  <sub>1</sub> (which implements a function) is &#x201C;thorough&#x201D; and thus might be a solution. <em>S</em>  <sub>2</sub> subsequently connects <em>C</em>  <sub>1</sub> to examples it can work with in <em>C</em>  <sub>2</sub>. In contrast, <em>S</em>  <sub>3</sub> starts with the conjunction word &#x201C;Or&#x201D; and possibly will introduce an alternative solution (e.g., <em>C</em>  <sub>3</sub>). This observation inspires us to first model the meaning of each block separately using a <em>token-level sequence encoder</em>, then model the block sequence <em>S<sub>i</sub>  </em>-<em>C<sub>i</sub>  </em>-<em>S</em>  <sub>  <em>i</em> + 1</sub> using a <em>block-level encoder</em>, from which we finally obtain the semantic representation of <em>C<sub>i</sub>  </em>.</p> <p>Figure <a class="fig" href="#fig2">2</a> shows our model, named Bi-View Hierarchical Neural Network (BiV-HNN). It progressively learns the semantic representation of a code block from token level to block level, based on which we predict it to be a standalone solution or not. On the other hand, BiV-HNN naturally incorporates two views, i.e., textual context and code content, into the model structure. We detail each component as follows. <figure id="fig2">  <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186077/images/www2018-90-fig2.jpg" class="img-responsive" alt="Figure 2"  longdesc=""/>  <div class="figure-caption">  <span class="figure-number">Figure 2:</span>  <span class="figure-title">Our Bi-View Hierarchical Neural Network (BiV-HNN). Text block <em>S<sub>i</sub>  </em> and question <em>q</em> are encoded by a bidirectional GRU-based RNN (Bi-GRU) module and code block <em>C<sub>i</sub>  </em> is encoded by another Bi-GRU with different parameters.</span>  </div>  </figure> </p> </section> <section id="sec-13"> <header>  <div class="title-info">  <h3>  <span class="section-number">3.2</span> Token-level Sequence Encoder</h3>  </div> </header> <p>  <strong>Text block.</strong>Given a sentence block <em>S<sub>i</sub>  </em> with a sequence of words <em>w<sub>it</sub>  </em>, <em>t</em> &#x2208; [1, <em>T<sub>i</sub>  </em>], we first embed the words into vectors through a pretrained word embedding matrix <em>W<sub>e</sub>  </em>, i.e., <em>x<sub>it</sub>  </em> = <em>W<sub>e</sub>w<sub>it</sub>  </em>. We then use a bidirectional Gated Recurrent Unit (GRU) based Recurrent Neural Network (RNN) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0008">8</a>] to learn the word representation by summarizing the contextual information from both directions. The GRU tracks the state of sequences by controlling how much information is updated into the new hidden state from previous states. Specifically, given the input word vector <em>x<sub>t</sub>  </em> in the current step and the hidden state <em>h</em>  <sub>  <em>t</em> &#x2212; 1</sub> from the last step, the GRU first computes a <em>reset gate r</em> for resetting information from previous steps in order to learn a new hidden state <span class="inline-equation"><span class="tex">$\tilde{h}_t$</span>  </span>: <div class="table-responsive">  <div class="display-equation">  <span class="tex mytex">\begin{gather*} r = \sigma (W_r[x_t, h_{t-1}] + b_r),\\ \tilde{h}_t = \phi (W[x_t, r \odot h_{t-1}] + b),\end{gather*} </span>  <br/>  </div>  </div> where [<em>x<sub>t</sub>  </em>, <em>h</em>  <sub>  <em>t</em> &#x2212; 1</sub>] is the concatenation of <em>x<sub>t</sub>  </em> and <em>h</em>  <sub>  <em>t</em> &#x2212; 1</sub>, <em>&#x03C3;</em> and <em>&#x03D5;</em> are the <em>sigmoid</em> and <em>tanh</em> activation function respectively. <em>W<sub>r</sub>  </em>, <em>W</em> are two weight matrices in <span class="inline-equation"><span class="tex">$R^{d_h \times (d_x + d_h)}$</span>  </span> and <em>b<sub>r</sub>  </em>, <em>b</em> are the biases in <span class="inline-equation"><span class="tex">$R^{d_h}$</span>  </span>, where <em>d<sub>x</sub>  </em>, <em>d<sub>h</sub>  </em> is the dimension of <em>x<sub>t</sub>  </em> and the hidden state <em>h</em>  <sub>  <em>t</em> &#x2212; 1</sub> respectively. Intuitively, if <em>r</em> is close to 0, then the information in <em>h</em>  <sub>  <em>t</em> &#x2212; 1</sub> will not be passed into the current step when learning the new hidden state. The GRU also defines an <em>update gate u</em> for integrating hidden states <em>h</em>  <sub>  <em>t</em> &#x2212; 1</sub> and <span class="inline-equation"><span class="tex">$\tilde{h}_t$</span>  </span>: <div class="table-responsive">  <div class="display-equation">  <span class="tex mytex">\begin{gather*} u = \sigma (W_u[x_t, h_{t-1}] + b_u),\\ h_t = uh_{t-1} + (1-u)\tilde{h}_t.\end{gather*} </span>  <br/>  </div>  </div> When <em>u</em> is closer to 0, <em>h<sub>t</sub>  </em> contains more information about the current step <span class="inline-equation"><span class="tex">$\tilde{h}_t$</span>  </span>; otherwise, it memorizes more about previous steps. Onwards, we denote the above calculation by <em>h<sub>t</sub>  </em> = <em>GRU</em>(<em>x<sub>t</sub>  </em>, <em>h</em>  <sub>  <em>t</em> &#x2212; 1</sub>) for convenience.</p> <p>In our work, the bidirectional GRU (i.e., Bi-GRU) contains a forward GRU reading a text block <em>S<sub>i</sub>  </em> from <em>w</em>  <sub>  <em>i</em>1</sub> to <span class="inline-equation"><span class="tex">$w_{iT_i}$</span>  </span> and a backward GRU which reads from <span class="inline-equation"><span class="tex">$w_{iT_i}$</span>  </span> to <em>w</em>  <sub>  <em>i</em>1</sub>: <div class="table-responsive">  <div class="display-equation">  <span class="tex mytex">\begin{gather*} \overrightarrow{h}_{it} = {GRU}(x_{it}, \overrightarrow{h}_{i,t-1}), t \in [1, T_i], \\ \overleftarrow{h}_{it} = {GRU}(x_{it}, \overleftarrow{h}_{i,t+1}), t \in [T_i, 1],\\ {\overrightarrow{h}_{i0} = \overrightarrow{0}, \;\;\;\overleftarrow{h}_{i, T_i+1} = \overleftarrow{0},}\end{gather*} </span>  <br/>  </div>  </div> where the hidden states in both directions are initialized with zero vectors. Since the forward and backward GRU summarize the context information from different perspectives, we concatenate their last hidden states (i.e., <span class="inline-equation"><span class="tex">$\overrightarrow{h}_{iT_i}$</span>  </span>, <span class="inline-equation"><span class="tex">$\overleftarrow{h}_{i1}$</span>  </span>) to represent the meaning of the text block <em>S<sub>i</sub>  </em>: <div class="table-responsive">  <div class="display-equation">  <span class="tex mytex">\[ s_i = [\overrightarrow{h}_{iT_i}, \overleftarrow{h}_{i1}]. \] </span>  <br/>  </div>  </div>  <strong>Code block.</strong>Similarly, we employ another Bi-GRU RNN module to learn a vector representation <em>v<sub>c</sub>  </em> for code block <em>C<sub>i</sub>  </em> based on its code token sequence. One may directly take this code vector <em>v<sub>c</sub>  </em> as the token-level representation of a code block. However, since the goal of our model is to decide whether a code snippet answers a certain question, we associate <em>C<sub>i</sub>  </em> with the question title <em>q</em> to capture their semantic correspondences in the learnt vector representation <em>c<sub>i</sub>  </em>. Specifically, we first learn the <em>question vector v<sub>q</sub>  </em> by applying the token-level <em>text</em> encoder to the word sequence in <em>q</em>. The concatenation of <em>v<sub>q</sub>  </em> and <em>v<sub>c</sub>  </em> is then fed into a feedforward <em>tanh</em> layer (i.e., &#x201C;concat feedforward&#x201D; in Figure <a class="fig" href="#fig2">2</a>) for generating <em>c<sub>i</sub>  </em>: <div class="table-responsive">  <div class="display-equation">  <span class="tex mytex">\[ c_i = \phi (W_c[v_q, v_c] + b_c). \] </span>  <br/>  </div>  </div> We will verify the effect of incorporating <em>q</em> in our experiments.</p> <p>Unlike modeling a code block, we do not associate a text block with question <em>q</em> when learning its representation, because we observed no direct semantic matching between the two. For example, in Figure <a class="fig" href="#fig1">1</a>, a text block can hardly match the question by its content. However, as we discussed in Section <a class="sec" href="#sec-4">1</a>, a text block with patterns like &#x201C;you can do ...&#x201D; or &#x201C;This is one thorough solution ...&#x201D; can imply that a code solution will be introduced after it. Therefore, we model each text block per se, without incorporating question information.</p> </section> <section id="sec-14"> <header>  <div class="title-info">  <h3>  <span class="section-number">3.3</span> Block-level Sequence Encoder</h3>  </div> </header> <p>Given the sequence of token-level representations <em>s<sub>i</sub>  </em>-<em>c<sub>i</sub>  </em>-<em>s</em>  <sub>  <em>i</em> + 1</sub>, we use a bidirectional GRU-based RNN to build a block-level sequence encoder and finally obtain the code block representation: <div class="table-responsive">  <div class="display-equation">  <span class="tex mytex">\begin{gather*} \overrightarrow{h}_i = {GRU}(s_i, \overrightarrow{0}), \overleftarrow{h}_i = {GRU}(s_i, \overleftarrow{ch}_i),\\ \overrightarrow{ch}_i = {GRU}(c_i, \overrightarrow{h}_i), \overleftarrow{ch}_i = {GRU}(c_i, \overleftarrow{h}_{i+1}),\\ \overrightarrow{h}_{i+1} = {GRU}(s_{i+1}, \overrightarrow{ch}_{i}), \overleftarrow{h}_{i+1} = {GRU}(s_{i+1}, \overleftarrow{0}),\end{gather*} </span>  <br/>  </div>  </div> where the encoder is initialized with zero vectors (i.e., <span class="inline-equation"><span class="tex">$\overrightarrow{0}$</span>  </span> and <span class="inline-equation"><span class="tex">$\overleftarrow{0}$</span>  </span>) in both directions. We concatenate the forward state <span class="inline-equation"><span class="tex">$\overrightarrow{ch_i}$</span>  </span> and the backward state <span class="inline-equation"><span class="tex">$\overleftarrow{ch_i}$</span>  </span> of the code block as its semantic representation: <div class="table-responsive">  <div class="display-equation">  <span class="tex mytex">\[ z_i = [\overrightarrow{ch_i}, \overleftarrow{ch_i}]. \] </span>  <br/>  </div>  </div> </p> </section> <section id="sec-15"> <header>  <div class="title-info">  <h3>  <span class="section-number">3.4</span> Code Label Prediction</h3>  </div> </header> <p>The representation <em>z<sub>i</sub>  </em> of code block <em>C<sub>i</sub>  </em> is then used for prediction: <div class="table-responsive">  <div class="display-equation">  <span class="tex mytex">\[ y_i = \text{softmax}(W_yz_i+b_y), \] </span>  <br/>  </div>  </div> where <em>y<sub>i</sub>  </em> = [<em>y</em>  <sub>  <em>i</em>0</sub>, <em>y</em>  <sub>  <em>i</em>1</sub>] represents the probability of predicting <em>C<sub>i</sub>  </em> to have label 0 or 1 respectively.</p> <p>We define the loss function using cross entropy [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0019">19</a>], which is averaged over all the <em>N</em> code snippets during training: <div class="table-responsive">  <div class="display-equation">  <span class="tex mytex">\[ \mathcal {L} = - \frac{1}{N} \sum _{i=1}^{N} p_{i0}\log (y_{i0}) + p_{i1}\log (y_{i1}), \] </span>  <br/>  </div>  </div> where <em>p</em>  <sub>  <em>i</em>0</sub> = 0 and <em>p</em>  <sub>  <em>i</em>1</sub> = 1 if the i-th code snippet is manually annotated as a solution; otherwise, <em>p</em>  <sub>  <em>i</em>0</sub> = 1 and <em>p</em>  <sub>  <em>i</em>1</sub> = 0.</p> </section> </section> <section id="sec-16"> <header> <div class="title-info">  <h2>  <span class="section-number">4</span> Traditional Classifiers with Feature Engineering</h2> </div> </header> <p>In addition to neural network based models like BiV-HNN, we also explore traditional classifiers like Logistic Regression (LR) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0011">11</a>] and Support Vector Machine (SVM) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0010">10</a>] for our task. Features are manually crafted from both text- and code-based views:</p> <p> <strong>Textual Context.</strong> (1) <tt>Token</tt>: The unigrams and bigrams in the context. (2) <tt>FirstToken</tt>: If a sentence starts with phrases like &#x201C;try this&#x201D; or &#x201C;use it&#x201D;, then the following code snippet is very likely to be the solution. Inspired by this idea, we discriminate the first token from others in the context. (3) <tt>Conn</tt>: Boolean features indicating whether a connective word/phrase (e.g., &#x201C;alternatively&#x201D;) occurs in the context. We used the common connective words and phrases from Penn Discourse Tree Bank [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0043">43</a>].</p> <p> <strong>Code Content.</strong> (1) <tt>CodeToken</tt>: All code tokens in a code snippet. (2) <tt>CodeClass</tt>: To discriminate code snippets that function and can be considered for learning and pragmatic reuse (i.e., &#x201C;working code&#x201D; [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0022">22</a>]) from input-output demos, we introduce <tt>CodeClass</tt>, which is the probability of a code snippet being a working code. Specifically, from all the &#x201C;how-to-do-it&#x201D; Python questions in SO, we first collected totally 850 code snippets following text blocks such as &#x201C;output:&#x201D; and &#x201C;output is:&#x201D; as input-output code snippets. We further randomly selected 850 accepted answer posts containing exactly one code snippet and took their code snippets as the working code. We then extracted a set of features like the proportion of numbers and parenthesis and constructed a binary Logistic Regression classifier, which obtains 0.804 accuracy and 0.891 <em>F</em> <sub>1</sub> on a manually labeled testing set. Finally, the trained classifier outputs the probability for each code snippet in Python being a &#x201C;working code&#x201D; as the <tt>CodeClass</tt> feature. For SQL, a working code can usually be detected by keywords like &#x201C;SELECT&#x201D; and &#x201C;DELETE&#x201D;, which have been included in the <tt>CodeToken</tt> feature. Thus, we did not design the <tt>CodeClass</tt> feature for it.</p> <p>There could be other features to incorporate into traditional classifiers. However, coming up with useful features is anything but an easy task. In contrast, neural network models can automatically learn advanced features from raw data and have been broadly and successfully applied in different areas [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0008">8</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0024">24</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0030">30</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0050">50</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0053">53</a>]. Therefore, in our work, we choose to design the neural network based model BiV-HNN. We will compare different models in experiments.</p> </section> <section id="sec-17"> <header> <div class="title-info">  <h2>  <span class="section-number">5</span> Experiments</h2> </div> </header> <p>In this section, we conduct extensive experiments to compare various models and show the advantages of our proposed BiV-HNN.</p> <section id="sec-18"> <header>  <div class="title-info">  <h3>  <span class="section-number">5.1</span> Experimental Setup</h3>  </div> </header> <p>  <strong>Dataset Summarization.</strong>Section <a class="sec" href="#sec-5">2</a> discussed how we manually annotated question-code pairs for training, validation and testing. Statistics were summarized in Table <a class="tbl" href="#tab1">1</a>. To evaluate different models, we adopt precision, recall, <em>F</em>  <sub>1</sub>, and accuracy, which are defined in the same way as in a typical binary classification setting.</p> <p>  <strong>Data Preprocessing.</strong> We tokenized Python code snippets with best efforts: We first applied Python built-in tokenizer and for code lines that remain untokenized after that, we adopted the &#x201C;wordpunct_tokenizer&#x201D; in NLTK toolkit [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0027">27</a>] to separate tokens and symbols (e.g., &#x201C;.&#x201D; and &#x201C; = &#x201D;). In addition, we detected variables, numbers and strings in a code snippet by traversing its Abstract Syntax Tree (AST) parsed with Python built-in AST parser, and replaced them with special tokens &#x201C;VAR&#x201D;, &#x201C;NUMBER&#x201D; and &#x201C;STRING&#x201D; respectively, to alleviate data sparsity. For SQL, we followed [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0021">21</a>] to perform the tokenization, which replaced table/column names with placeholder tokens and numbered them to preserve their dependencies. Finally, we collected 4,557 (3,191) word tokens and 6,581 (1,200) code tokens from Python (SQL) training set.</p> <p>  <strong>Implementation Details.</strong>We used Tensorflow[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0055">55</a>] to implement our BiV-HNN and its variants to be introduced in Section <a class="sec" href="#sec-19">5.2</a>. The embedding size of word and code tokens was set at 150. The embedding vectors were pre-trained using GloVe [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0042">42</a>] on all Python or SQL posts in SO. Parameters were randomly initialized following [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0018">18</a>]. We started the learning rate at 0.001 and trained neural network models in mini batch of size 100 with the Adam optimizer [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0023">23</a>]. The size of the GRU units was chosen from {64, 128} for token-level encoders and from {128, 256} for block-level encoders. Following the convention [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0020">20</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0021">21</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0029">29</a>], we selected model parameters based on their performance on validation sets. The Logistic Regression and Support Vector Machine models were implemented with Python Scikit-learn library [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0041">41</a>].</p> </section> <section id="sec-19"> <header>  <div class="title-info">  <h3>  <span class="section-number">5.2</span> Baselines and Variants of BiV-HNN</h3>  </div> </header> <p>  <strong>Baselines.</strong> We compare our proposed model with two commonly used heuristics for collecting QC pairs: (1) <em>Select-First</em>: Only treat the first code snippet in an answer post as a solution; (2) <em>Select-All</em>: Treat every code snippet in an answer post as a solution and pair each of them with the question. In addition, we compare our model with traditional classifiers like LR and SVM based on hand-crafted features (Section <a class="sec" href="#sec-16">4</a>).</p> <p>  <strong>Variants of BiV-HNN.</strong>  <em>First</em>, to evaluate the effectiveness of combining two views (i.e., textual context and code content), we adapt BiV-HNN to consider only one single view: (1) <em>Text-HNN</em> (Figure 3a): In this model, we only utilize textual contexts of a code snippet. We mask all code blocks with a special token <SmallCap>CodeBlock</SmallCap> and represent them with a unified vector. (2) <em>Code-HNN</em> (Figure 3b): We only feed the output of the token-level code encoder (i.e., <em>c<sub>i</sub>  </em>) into the &#x201C;code label prediction&#x201D; layer in Section <a class="sec" href="#sec-11">3</a>, and do not model textual contexts. In addition, to evaluate the effect of question <em>q</em> when encoding a code block, we compare BiV-HNN with <em>BiV-HNN-nq</em>, which directly takes the code vector <em>v<sub>c</sub>  </em> as the code block representation <em>c<sub>i</sub>  </em>, without associating question <em>q</em>, for further learning. These three models are all input-level variants of BiV-HNN. <figure id="fig3">  <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186077/images/www2018-90-fig3.jpg" class="img-responsive" alt="Figure 3"  longdesc=""/>  <div class="figure-caption">  <span class="figure-number">Figure 3:</span>  <span class="figure-title">Single-view variants of BiV-HNN: (a) Text-HNN, without code content; (b) Code-HNN, without contextual text.</span>  </div>  </figure>  <figure id="fig4">  <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186077/images/www2018-90-fig4.jpg" class="img-responsive" alt="Figure 4"  longdesc=""/>  <div class="figure-caption">  <span class="figure-number">Figure 4:</span>  <span class="figure-title">&#x201C;Flat&#x201D;-structure variants of BiV-HNN, without differentiating token- and block-level: (a) Text-RNN; (b) BiV-RNN.</span>  </div>  </figure> </p> <p>  <em>Second</em>, to evaluate the hierarchical structure in BiV-HNN, we compare it with &#x201C;flat&#x201D; RNN models, which model word and code tokens as a single sequence. The comparison is conducted in both text-only and bi-view settings: (1) <em>Text-RNN</em> (Figure 4a): Compared with Text-HNN, we concatenate all words in context blocks <em>S<sub>i</sub>  </em> and <em>S</em>  <sub>  <em>i</em> + 1</sub> as well as the unified code vector <font style="font-variant: small-caps">CodeBlock</font> as a single sequence, i.e., <span class="inline-equation"><span class="tex">$\lbrace w_{i1},...,w_{i,T_i},$</span></span> <font style="font-variant: small-caps">CodeBlock</font>, <span class="inline-equation"><span class="tex">$w_{i+1,1},...,w_{i+1,T_{i+1}}\rbrace$</span></span>, using Bi-GRU RNN. The concatenation of the forward and backward hidden states of <font style="font-variant: small-caps">CodeBlock</font> is considered as its final semantic vector <em>z<sub>i</sub>  </em>, which is then fed into the code label prediction layer. (2) <em>BiV-RNN</em> (Figure 4b): In contrast to BiV-HNN, BiV-RNN models all word and code tokens in <em>S<sub>i</sub>  </em>-<em>C<sub>i</sub>  </em>-<em>S</em>  <sub>  <em>i</em> + 1</sub> as a single sequence, i.e., <span class="inline-equation"><span class="tex">$\lbrace w_{i1},...,w_{iT_{i}},co_{i1}, ...,co_{ij}, ...,co_{i,|C_i|},w_{i+1,1},...,w_{i+1,T_{i+1}}\rbrace$</span>  </span>, where <em>co<sub>ij</sub>  </em> denotes the <em>j</em>-th token in code <em>C<sub>i</sub>  </em> and |<em>C<sub>i</sub>  </em>| is the number of code tokens in <em>C<sub>i</sub>  </em>. BiV-RNN concatenates the last hidden states in two directions as the final semantic vector <em>z<sub>i</sub>  </em> for prediction. We also tried directly &#x201C;flattening&#x201D; BiV-HNN by concatenating tokens in <em>S<sub>i</sub>  </em>-<em>q</em>-<em>C<sub>i</sub>  </em>-<em>S</em>  <sub>  <em>i</em> + 1</sub>, but observed worse performance, perhaps because transitioning from <em>S<sub>i</sub>  </em> to question <em>q</em> is less natural.</p> <p>  <em>Finally</em>, at the block level, instead of using an RNN, one may apply a feedforward neural network [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0047">47</a>] to the concatenated token-level output [<em>s<sub>i</sub>  </em>, <em>c<sub>i</sub>  </em>, <em>s</em>  <sub>  <em>i</em> + 1</sub>]. Specifically, the block-level Bi-GRU in BiV-HNN can be replaced with a one-layer<a class="fn" href="#fn5" id="foot-fn5"><sup>4</sup></a> feedforward neural network, denoted as <em>BiV-HFF</em>. Intuitively, modeling the three blocks as a sequence is more consistent with the way humans read a post. We will verify this intuition in experiments.</p> <p>While there could be other variants of our model, the above ones are related to the most critical designs in BiV-HNN. We only show their performance due to space constraints.</p> </section> <section id="sec-20"> <header>  <div class="title-info">  <h3>  <span class="section-number">5.3</span> Results</h3>  </div> </header> <p>Our experimental results in Table <a class="tbl" href="#tab2">2</a> show the effectiveness of our BiV-HNN. On both datasets, BiV-HNN substantially outperforms heuristic baselines Select-First and Select-All by more than <strong>15%</strong> in <em>F</em>  <sub>1</sub> and accuracy. This demonstrates that our model can collect QC pairs with much higher quality than heuristic methods used in existing research. In addition, when compared with LR and SVM, BiV-HNN achieves 7% &#x223C; 9% higher <em>F</em>  <sub>1</sub> and accuracy on Python dataset, and 3% &#x223C; 5% better <em>F</em>  <sub>1</sub> and accuracy on SQL dataset. The gain on SQL data is relatively smaller, probably because interpreting SQL programs is a relatively easier task, implied by the observation that both simple classifiers and BiV-HNN can have around 85% F1.</p> <div class="table-responsive" id="tab2">  <div class="table-caption">  <span class="table-number">Table 2:</span>  <span class="table-title">Comparison of BiV-HNN and baseline methods.</span>  </div>  <table class="table"> 				 <thead>  <tr>  <th/>  <th/>  <th/>  <th/>  <th/>  <th/>  <th/>  <th/>  <th/>  </tr>  <tr>  <th style="text-align:center;"/>  <th colspan="4" style="text-align:center;">Python Testing Set<hr/>  </th>  <th colspan="4" style="text-align:center;">SQL Testing Set<hr/>  </th>  </tr>  <tr>  <th style="text-align:center;">Model</th>  <th style="text-align:center;">Precision</th>  <th style="text-align:center;">Recall</th>  <th style="text-align:center;">  <em>F</em>  <sub>1</sub>  </th>  <th style="text-align:center;">Accuracy</th>  <th style="text-align:center;">Precision</th>  <th style="text-align:center;">Recall</th>  <th style="text-align:center;">  <em>F</em>  <sub>1</sub>  </th>  <th style="text-align:center;">Accuracy</th>  </tr> 						</thead>  <tbody>  <tr>  <td colspan="9" style="text-align:center;">Heuristics Baselines<hr/>  </td>  </tr>  <tr>  <td style="text-align:center;">Select-First</td>  <td style="text-align:center;">0.676</td>  <td style="text-align:center;">0.551</td>  <td style="text-align:center;">0.607</td>  <td style="text-align:center;">0.663</td>  <td style="text-align:center;">0.755</td>  <td style="text-align:center;">0.517</td>  <td style="text-align:center;">0.613</td>  <td style="text-align:center;">0.620</td>  </tr>  <tr>  <td style="text-align:center;">Select-All</td>  <td style="text-align:center;">0.472</td>  <td style="text-align:center;">  <strong>1.000</strong>  </td>  <td style="text-align:center;">0.642</td>  <td style="text-align:center;">0.472</td>  <td style="text-align:center;">0.583</td>  <td style="text-align:center;">  <strong>1.000</strong>  </td>  <td style="text-align:center;">0.737</td>  <td style="text-align:center;">0.583</td>  </tr>  <tr>  <td colspan="9" style="text-align:center;">Classifiers based on simple features<hr/>  </td>  </tr>  <tr>  <td style="text-align:center;">Logistic Regression</td>  <td style="text-align:center;">0.801</td>  <td style="text-align:center;">0.733</td>  <td style="text-align:center;">0.766</td>  <td style="text-align:center;">0.788</td>  <td style="text-align:center;">0.843</td>  <td style="text-align:center;">0.849</td>  <td style="text-align:center;">0.846</td>  <td style="text-align:center;">0.820</td>  </tr>  <tr>  <td style="text-align:center;">Support Vector Machine</td>  <td style="text-align:center;">0.701</td>  <td style="text-align:center;">0.813</td>  <td style="text-align:center;">0.753</td>  <td style="text-align:center;">0.748</td>  <td style="text-align:center;">0.843</td>  <td style="text-align:center;">0.858</td>  <td style="text-align:center;">0.850</td>  <td style="text-align:center;">0.824</td>  </tr>  <tr>  <td style="text-align:center;">  <strong>BiV-HNN</strong>  </td>  <td style="text-align:center;">  <strong>0.808</strong>  </td>  <td style="text-align:center;">0.876</td>  <td style="text-align:center;">  <strong>0.841</strong>  </td>  <td style="text-align:center;">  <strong>0.843</strong>  </td>  <td style="text-align:center;">  <strong>0.872</strong>  </td>  <td style="text-align:center;">0.903</td>  <td style="text-align:center;">  <strong>0.888</strong>  </td>  <td style="text-align:center;">  <strong>0.867</strong>  </td>  </tr>  </tbody>  </table> </div> <p>Results in Table <a class="tbl" href="#tab3">3</a> show the effect of key components in BiV-HNN in comparison with alternatives. Due to space constraints, we do not show the accuracy of each model, which has roughly the same pattern as <em>F</em>  <sub>1</sub>. We have made the following observations: (1) <em>Single-view variants</em>. BiV-HNN outperforms Text-HNN and Code-HNN by a large margin on both datasets, showing that both views are critical for our task. In particular, by incorporating code content information, BiV-HNN is able to improve Text-HNN by 7% on Python dataset and around 5% on SQL dataset in <em>F</em>  <sub>1</sub>. (2) <em>No-query variant</em>. On Python dataset, the integration of the question information in BiV-HNN brings 3% <em>F</em>  <sub>1</sub> improvements over BiV-HNN-nq, which shows the effectiveness of associating the question with the code snippet for identifying code answers. For SQL dataset, adding the question gives no obvious benefit, possibly because the code content in each SQL program already carries critical information for making a prediction (e.g., a SQL program containing the command keyword &#x201C;SELECT&#x201D; is very likely to be a solution to the given question, regardless of the question content). (3) <em>&#x201C;Flat&#x201D;-structure variants</em>. On both datasets, the hierarchical structure leads to 1% &#x223C; 2% improvements against the &#x201C;flat&#x201D; structure in both bi-view (BiV-HNN vs. BiV-RNN) and single-view setting (Text-HNN vs. Text-RNN). (4) <em>Non-sequence variant</em>. On Python dataset, BiV-HNN outperforms BiV-HFF by around 2%, showing the block-level Bi-GRU is preferable over feedforward neural networks. The two models get roughly the same performance on SQL, probably because our task is easier in SQL domain than in Python domain as we mentioned earlier.</p> <p>In summary, our BiV-HNN is much more effective than widely-adopted heuristic baselines and traditional classifiers. The key components in BiV-HNN, such as bi-view inputs, hierarchical structure and block-level sequence encoding, are also empirically justified.</p> <p>  <strong>Error Analysis.</strong> There are a variety of non-solution roles that a code snippet can play, such as being only one step of a multi-step solution, an input-output example, etc. We observe that more than half of the wrong predictions were false positives (i.e., predicting a non-solution code snippet as a solution), correcting which usually requires integrating information from the entire answer post. For example, when a code snippet is the first step of a multi-step solution, BiV-HNN may mistakenly take it as a complete and standalone solution, since BiV-HNN does not simultaneously take into account follow-up code snippets and their context to make predictions. In addition, BiV-HNN may make mistakes when a correct prediction requires a close examination of the <em>content</em> of a question post (besides its title). Exploring these directions in the future may lead to further improved model performance on this task.</p> <div class="table-responsive" id="tab3">  <div class="table-caption">  <span class="table-number">Table 3:</span>  <span class="table-title">Comparison of BiV-HNN and its variants.</span>  </div>  <table class="table"> 				 <thead>  <tr>  <th/>  <th/>  <th/>  <th/>  <th/>  <th/>  <th/>  </tr>  <tr>  <th style="text-align:center;"/>  <th colspan="3" style="text-align:center;">Python Testing Set<hr/>  </th>  <th colspan="3" style="text-align:center;">SQL Testing Set<hr/>  </th>  </tr>  <tr>  <th style="text-align:center;">Model</th>  <th style="text-align:center;">Prec.</th>  <th style="text-align:center;">Rec.</th>  <th style="text-align:center;">  <em>F</em>  <sub>1</sub>  </th>  <th style="text-align:center;">Prec.</th>  <th style="text-align:center;">Rec.</th>  <th style="text-align:center;">  <em>F</em>  <sub>1</sub>  </th>  </tr> 						</thead>  <tbody>  <tr>  <td colspan="7" style="text-align:center;">Single-view Variants<hr/>  </td>  </tr>  <tr>  <td style="text-align:center;">Text-HNN</td>  <td style="text-align:center;">0.723</td>  <td style="text-align:center;">0.826</td>  <td style="text-align:center;">0.771</td>  <td style="text-align:center;">0.798</td>  <td style="text-align:center;">0.887</td>  <td style="text-align:center;">0.840</td>  </tr>  <tr>  <td style="text-align:center;">Code-HNN</td>  <td style="text-align:center;">0.770</td>  <td style="text-align:center;">0.859</td>  <td style="text-align:center;">0.812</td>  <td style="text-align:center;">0.848</td>  <td style="text-align:center;">0.854</td>  <td style="text-align:center;">0.851</td>  </tr>  <tr>  <td colspan="7" style="text-align:center;">No-query Variant<hr/>  </td>  </tr>  <tr>  <td style="text-align:center;">BiV-HNN-nq</td>  <td style="text-align:center;">0.802</td>  <td style="text-align:center;">0.818</td>  <td style="text-align:center;">0.810</td>  <td style="text-align:center;">  <strong>0.883</strong>  </td>  <td style="text-align:center;">0.892</td>  <td style="text-align:center;">0.887</td>  </tr>  <tr>  <td colspan="7" style="text-align:center;">&#x201C;Flat&#x201D;-structure Variants<hr/>  </td>  </tr>  <tr>  <td style="text-align:center;">Text-RNN</td>  <td style="text-align:center;">0.693</td>  <td style="text-align:center;">0.824</td>  <td style="text-align:center;">0.753</td>  <td style="text-align:center;">0.773</td>  <td style="text-align:center;">0.894</td>  <td style="text-align:center;">0.829</td>  </tr>  <tr>  <td style="text-align:center;">BiV-RNN</td>  <td style="text-align:center;">0.760</td>  <td style="text-align:center;">  <strong>0.887</strong>  </td>  <td style="text-align:center;">0.819</td>  <td style="text-align:center;">0.869</td>  <td style="text-align:center;">0.880</td>  <td style="text-align:center;">0.875</td>  </tr>  <tr>  <td colspan="7" style="text-align:center;">Non-sequence Variant<hr/>  </td>  </tr>  <tr>  <td style="text-align:center;">BiV-HFF</td>  <td style="text-align:center;">0.787</td>  <td style="text-align:center;">0.859</td>  <td style="text-align:center;">0.822</td>  <td style="text-align:center;">0.845</td>  <td style="text-align:center;">  <strong>0.939</strong>  </td>  <td style="text-align:center;">  <strong>0.889</strong>  </td>  </tr>  <tr>  <td style="text-align:center;">  <strong>BiV-HNN</strong>  </td>  <td style="text-align:center;">  <strong>0.808</strong>  </td>  <td style="text-align:center;">0.876</td>  <td style="text-align:center;">  <strong>0.841</strong>  </td>  <td style="text-align:center;">0.872</td>  <td style="text-align:center;">0.903</td>  <td style="text-align:center;">0.888</td>  </tr>  </tbody>  </table> </div> <p>  <strong>Model Combination.</strong>When experimenting with the single-view variants of BiV-HNN, i.e., Text-HNN and Code-HNN, we observed that the three models complement each other in making accurate predictions. For example, on Python validation set, around 70% mistakes made by Text-HNN or Code-HNN can be corrected by considering predictions from the other two models. Although BiV-HNN is built based on both text- and code-based views, 60% of its wrong predictions can be remedied by Text-HNN and Code-HNN. The same pattern was also observed on SQL dataset.</p> <p>Therefore, we further tested the effect of combining the three models via a simple heuristic: The label of a code snippet is predicted only when the three models agree on it. Using this heuristic, 69.2% code blocks on the annotated Python testing set are labeled with 0.916 <em>F</em>  <sub>1</sub> and 0.911 accuracy. Similarly, on SQL testing set, 78.7% code blocks are labeled with 0.943 <em>F</em>  <sub>1</sub> and 0.926 accuracy. The combined model further improves BiV-HNN by around 6% while still being able to label a large portion of the code snippets. Thus, we apply this combined model to those SO answer posts that are not manually annotated yet to obtain large-scale QC pairs, to be discussed next.</p> </section> </section> <section id="sec-21"> <header> <div class="title-info">  <h2>  <span class="section-number">6</span> StaQC: A Systematically Mined Dataset of Question-Code Pairs</h2> </div> </header> <p>In this section, we present StaQC (<span style="text-decoration: underline;">Sta</span>ck Overflow <span style="text-decoration: underline;">Q</span>uestion-<span style="text-decoration: underline;">C</span>ode pairs), a large-scale and diverse set of question-code pairs automatically mined using our framework. Under various case studies, we demonstrate that StaQC can greatly help tasks aiming to associate natural language with programming language.</p> <section id="sec-22"> <header>  <div class="title-info">  <h3>  <span class="section-number">6.1</span> Statistics of StaQC</h3>  </div> </header> <p>In Section <a class="sec" href="#sec-17">5</a>, we showed that a combination of BiV-HNN and its variants can reliably identify standalone code solutions with <span class="inline-equation"><span class="tex">${\gt}90\%$</span>  </span>  <em>F</em>  <sub>1</sub> and accuracy from a large portion of the testing set. Thus we applied this combined model to all unlabeled multi-code answer posts that correspond to &#x201C;how-to-do-it&#x201D; questions in Python and SQL domain, and finally collected <strong>60,083</strong> and <strong>41,826</strong> question-code pairs respectively. Additionally, there are 85,294 Python and 75,637 SQL &#x201C;how-to-do-it&#x201D; questions whose answer post contains exactly one code snippet. For them, as in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0021">21</a>], we paired the question title with the one code snippet as a question-code pair. Together with 2,169 and 2,056 manually annotated QC pairs with label &#x201C;1&#x201D; for each domain (Table <a class="tbl" href="#tab1">1</a>), we collected a dataset of <strong>147,546</strong> Python and <strong>119,519</strong> SQL QC pairs, named as StaQC. Table&#x00A0;<a class="tbl" href="#tab4">4</a> shows its statistics.</p> <p>  <em>Note that we can continue to expand StaQC with minimal efforts, since it is automatically mined by our framework, and more and more posts will be created in SO as time goes by. QC pairs in other programming languages can also be mined similarly to further enrich StaQC beyond Python and SQL domain</em>.</p> <div class="table-responsive" id="tab4">  <div class="table-caption">  <span class="table-number">Table 4:</span>  <span class="table-title">Statistics of StaQC.</span>  </div>  <table class="table"> 				 <thead>  <tr>  <th style="text-align:center;"/>  <th style="text-align:center;"># of QC pairs</th>  <th colspan="2" style="text-align:center;">Question<hr/>  </th>  <th colspan="2" style="text-align:center;">Code<hr/>  </th>  </tr>  <tr>  <th style="text-align:center;"/>  <th style="text-align:center;"/>  <th style="text-align:center;">Average length</th>  <th style="text-align:center;"># of tokens</th>  <th style="text-align:center;">Average length</th>  <th style="text-align:center;"># of tokens</th>  </tr> 						</thead>  <tbody>  <tr>  <td style="text-align:center;">Python</td>  <td style="text-align:center;">  <strong>147,546</strong>  </td>  <td style="text-align:center;">9</td>  <td style="text-align:center;">17,635</td>  <td style="text-align:center;">86</td>  <td style="text-align:center;">137,123</td>  </tr>  <tr>  <td style="text-align:center;">SQL</td>  <td style="text-align:center;">  <strong>119,519</strong>  </td>  <td style="text-align:center;">9</td>  <td style="text-align:center;">9,920</td>  <td style="text-align:center;">60</td>  <td style="text-align:center;">21,143</td>  </tr>  </tbody>  </table> </div> </section> <section id="sec-23"> <header>  <div class="title-info">  <h3>  <span class="section-number">6.2</span> Diversity of StaQC</h3>  </div> </header> <p>Besides the large scale, StaQC also enjoys great diversity in the sense that it contains multiple textual descriptions for semantically similar code snippets and multiple code solutions to a question. For example, considering question &#x201C;<em>How to limit a number to be within a specified range? (Python)</em>&#x201D; whose answer post contains five code snippets (Figure <a class="fig" href="#fig5">5</a>), our framework is able to correctly mine four alternative code answers. Heuristic methods may either miss some of them or mistakenly include a false solution (i.e., the 3rd code snippet). Therefore, our framework is able to obtain more alternative solutions for the same question more accurately. Moreover, Figure <a class="fig" href="#fig6">6</a> shows two question-code pairs included in StaQC, which we easily located by comparing code solutions of <em>relevant</em> questions in SO (i.e., questions manually linked by SO users). Note that the two code snippets have a very similar functionality but two different text descriptions. <figure id="fig5">  <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186077/images/www2018-90-fig5.jpg" class="img-responsive" alt="Figure 5"  longdesc=""/>  <div class="figure-caption">  <span class="figure-number">Figure 5:</span>  <span class="figure-title">StaQC contains four alternative code solutions to question &#x201C;<em>How to limit a number to be within a specified range? (Python)</em>&#x201D; [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0038">38</a>] whose answer post contains five code snippets. The number at the bottom right denotes the position of each code snippet in the answer post.</span>  </div>  </figure>  <figure id="fig6">  <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186077/images/www2018-90-fig6.jpg" class="img-responsive" alt="Figure 6"  longdesc=""/>  <div class="figure-caption">  <span class="figure-number">Figure 6:</span>  <span class="figure-title">StaQC has different text descriptions, e.g., &#x201C;<em>How to find a gap in range in SQL</em>&#x201D; [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0037">37</a>] and &#x201C;<em>How do I find a &#x201C;gap&#x201D; in running counter with SQL?</em>&#x201D; [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0036">36</a>], for two code snippets bearing a similar functionality.</span>  </div>  </figure> </p> <p>Figure <a class="fig" href="#fig5">5</a> and <a class="fig" href="#fig6">6</a> show that StaQC is highly diverse and rich in surface variation. Such a dataset is beneficial for model development. Intuitively, when certain data patterns are not observed in the training phase, a model is less capable to predict them during testing. StaQC can alleviate this issue by enabling a model to learn from alternative code solutions to the same question or from different text descriptions to similar code snippets. Next we demonstrate this benefit using an exemplar downstream task.</p> </section> <section id="sec-24"> <header>  <div class="title-info">  <h3>  <span class="section-number">6.3</span> Usage Demo of StaQC on Code Retrieval</h3>  </div> </header> <p>To further demonstrate the usage of StaQC, we employ it to train a deep learning model for the code retrieval task [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0002">2</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0021">21</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0022">22</a>]. <em>Given a natural language description and a set of code snippet candidates, the task is to retrieve code snippets that can match the description.</em> In particular, an effective model should rank matched code snippets as high as possible. Models are evaluated by Mean Reciprocal Rank (MRR) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0058">58</a>]. In [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0021">21</a>], the authors proposed a neural network based model, <em>CODE-NN</em>, which outputs a matching score between a natural language question and a code snippet. We choose CODE-NN as it is one of the state of the arts for code retrieval and improved previous work by a large margin. For training, the authors collected around 25,870 SQL QC pairs from answer posts containing exactly one code snippet (which is paired with the question title). They manually annotated two datasets DEV and EVAL for choosing the best model parameters and for final evaluation respectively, both containing around 100 QC pairs. The final evaluation is conducted in 20 runs. In each run, for every QC pair in DEV or EVAL, [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0021">21</a>] randomly selected 49 code snippets from SO as non-answer candidates, and ranked all 50 code snippets based on their scores output by CODE-NN. The averaged MRR is computed as the final result.</p> <p>  <strong>Improved Retrieval Performance.</strong>We first trained CODE-NN using the <em>original</em> training set in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0021">21</a>]. We denote this setting as <em>CODE-NN (original)</em>. Then we used StaQC to upgrade the training data in two most straightforward ways: (1) We directly took all the 119,519 SQL QC pairs in StaQC to train CODE-NN, denoted as <em>CODE-NN (StaQC)</em>. (2) To emphasize the effect of our framework, we just added the 41,826 QC pairs, automatically mined from SO multi-code answer posts, to the original training set and retrained the model, which is denoted as <em>CODE-NN (original + StaQC-multi)</em>. In both (1) and (2), questions and code snippets occurring in the DEV/EVAL set were removed from training.</p> <p>In all three settings, we used the same DEV/EVAL set and the same hyper-parameters as in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0021">21</a>] except the dropout rate, which was chosen from {0.5, 0.7} for each model to obtain better performance. Like [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0021">21</a>], we decayed the learning rate in each epoch and terminated the training when it was lower than 0.001. The best model was selected as the one achieving the highest average MRR on DEV set. When using this strategy, we observed better results on the EVAL set than those reported in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0021">21</a>] (around 0.44).</p> <p>Table <a class="tbl" href="#tab5">5</a> shows the average MRR score and standard deviation of each model on EVAL set. We can see that directly using StaQC for training leads to a substantial 6% improvement over using the original dataset in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0021">21</a>]. By adding QC pairs we mined from multi-code posts to the original training data, CODE-NN can be significantly improved by 3%. Note that the performance gains shown here are still conservative, since we adopted the same hyper-parameters and a small evaluation set, in order to see the direct impact of StaQC. Using more challenging evaluation sets and by conducting systematic hyper-parameter selection, we expect models trained on StaQC to be more advantageous. StaQC can also be used to train other code retrieval models besides CODE-NN, as well as models for other related tasks like code generation or annotation.</p> <div class="table-responsive" id="tab5">  <div class="table-caption">  <span class="table-number">Table 5:</span>  <span class="table-title">Performance of CODE-NN [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0021">21</a>] on code retrieval, with and without StaQC for training. <sup>*</sup>denotes statistically significant w.r.t. <em>CODE-NN (original)</em> under one-tailed Student&#x0027;s t-test (<em>p</em> < 0.05).</span>  </div>  <table class="table">  <tbody>  <tr>  <td style="text-align:center;">Model Setting</td>  <td style="text-align:center;">MRR</td>  </tr>  <tr>  <td style="text-align:center;">CODE-NN (original)</td>  <td style="text-align:center;">0.51 &#x00B1; 0.02</td>  </tr>  <tr>  <td style="text-align:center;">  <strong>CODE-NN (StaQC)</strong>  <sup>*</sup>  </td>  <td style="text-align:center;">  <strong>0.57</strong> &#x00B1; <strong>0.02</strong>  </td>  </tr>  <tr>  <td style="text-align:center;">CODE-NN (original + StaQC-multi)<sup>*</sup>  </td>  <td style="text-align:center;">0.54 &#x00B1; 0.02</td>  </tr>  </tbody>  </table> </div> </section> </section> <section id="sec-25"> <header> <div class="title-info">  <h2>  <span class="section-number">7</span> Discussion and Future Work</h2> </div> </header> <p>Besides boosting relevant tasks using StaQC, future work includes: (1) We currently only consider a code snippet to be a standalone solution or not. In many cases, code snippets in an answer post serve as multiple steps and should be merged to form a complete solution [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0039">39</a>]. This is a more challenging task and we leave it to the future. (2) In our experiments, we combined BiV-HNN and its two variants using a simple heuristic to achieve better performance. In the future, one can also use StaQC to retrain the three models, similar to self-training [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0034">34</a>], or jointly train the three models in a tri-training framework [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0063">63</a>]. (3) One may also employ Convolutional Neural Networks [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0001">1</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0024">24</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0049">49</a>], which have shown great power on representation learning, to encode text and code blocks. Moreover, we can consider encoders similar to [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0031">31</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0033">33</a>] for capturing the intrinsic structure of programming language.</p> </section> <section id="sec-26"> <header> <div class="title-info">  <h2>  <span class="section-number">8</span> Related Work</h2> </div> </header> <p> <em>Language</em> <strong>+</strong>  <em>Code</em> <strong>Tasks and Datasets</strong>. Tasks that map between natural language and programming language, referred to <em>Language</em> + <em>Code</em> tasks here, such as code annotation and code retrieval/generation, have been popularly studied in recent years [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0002">2</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0015">15</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0021">21</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0022">22</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0026">26</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0035">35</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0045">45</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0057">57</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0064">64</a>]. In order to train more advanced yet data-hungry models, researchers have collected data either automatically from online communities [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0002">2</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0005">5</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0021">21</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0022">22</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0026">26</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0045">45</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0057">57</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0064">64</a>] or with human intervention [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0016">16</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0035">35</a>]. Like our work, [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0002">2</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0021">21</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0057">57</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0064">64</a>] utilized SO to collect data. Particularly, [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0002">2</a>] merges code snippets in its answer post as the target source code and pair it with the question title. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0021">21</a>] only employs accepted answer posts containing exactly one code snippet. Other interesting datasets include &#x223C; 19K < English pseudo-code, Python code snippet > pairs manually annotated by [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0035">35</a>], and &#x223C; 114K pairs of Python functions and their documentation strings heuristically collected by [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0005">5</a>] from GitHub [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0017">17</a>]. Unlike their work, we systematically mine high-quality question-code pairs from SO using advanced machine learning models. Our mined dataset StaQC, the largest to date of around 148K Python and 120K SQL question-code pairs, has been shown to be a better resource. Moreover, StaQC is easily expandable in terms of both scale and programming language types.</p> <p> <strong>Recurrent Neural Networks for Sequential Data</strong>. Recurrent Neural Networks have shown great success in various natural language tasks [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0004">4</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0008">8</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0020">20</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0029">29</a>]. In an RNN, terms are modeled sequentially without discrimination. Recently, in order to handle information at different levels, [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0025">25</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0048">48</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0054">54</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0060">60</a>] stack multiple RNNs into a hierarchical structure. For example, [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0060">60</a>] incorporates the attention mechanism in a hierarchical RNN model to pick up important words and sentences. Their model finally aggregates all sentence vectors to learn the document representation. In comparison, we utilize the hierarchical structure to first learn the semantic meaning of each block individually, and then predict the label of a code snippet by combining two views: textual context and programming content.</p> <p> <strong>Mining Stack Overflow</strong>. Stack Overflow has been the focus of the Mining Software Repositories (MSR) challenge for years [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0003">3</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0062">62</a>]. A lot of work [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0012">12</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0013">13</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0014">14</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0032">32</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0056">56</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0059">59</a>] have been done on exploring the categories of questions, mining source codes, etc. We follow [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0012">12</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0013">13</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0032">32</a>] to categorize SO questions into 5 classes but only focus on the &#x201C;how-to-do-it&#x201D; type (Section <a class="sec" href="#sec-5">2</a>). [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0014">14</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0059">59</a>] analyzes the quality of code snippets (e.g., readability) or explores &#x201C;usable&#x201D; code snippets that could be parsed, compiled and run. Different from their work, we are interested in finding standalone code solutions, which are not necessarily directly parsable, compilable or runnable, but can be semantically paired with questions. To the best of our knowledge, we are the first to study the problem of systematically mining high-quality question-code pairs.</p> </section> <section id="sec-27"> <header> <div class="title-info">  <h2>  <span class="section-number">9</span> Conclusion</h2> </div> </header> <p>This paper explores systematically mining question-code pairs from Stack Overflow, in contrast to heuristically collecting them. We focus on the &#x201C;how-to-do-it&#x201D; questions since their answers are more likely to be code solutions. We present the largest-to-date dataset of diversified question-code pairs in Python and SQL domain (StaQC), systematically collected by our framework. StaQC can greatly help downstream tasks aiming to associate natural language with programming language. We will release it together with our source code for future research.</p> </section> <section id="sec-28"> <header> <div class="title-info">  <h2>Acknowledgments</h2> </div> </header> <p>This research was sponsored in part by the Army Research Office under cooperative agreements W911NF-17-1-0412, Fujitsu gift grant, DARPA contract FA8750-13-2-0019, the University of Washington WRF/Cable Professorship, Ohio Supercomputer Center [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"  href="#BibPLXBIB0007">7</a>], and NSF Grant CNS-1513120. The views and conclusions contained herein are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the Army Research Office or the U.S. Government. The U.S. Government is authorized to reproduce and distribute reprints for Government purposes notwithstanding any copyright notice herein.</p> </section> </section> <section class="back-matter"> <section id="ref-001"> <header> <div class="title-info">  <h2 class="page-brake-head">REFERENCES</h2> </div> </header> <ul class="bibUl"> <li id="BibPLXBIB0001" label="[1]">Miltiadis Allamanis, Hao Peng, and Charles Sutton. 2016. A convolutional attention network for extreme summarization of source code. In <em>  <em>ICML</em>  </em>. 2091&#x2013;2100.</li> <li id="BibPLXBIB0002" label="[2]">Miltos Allamanis, Daniel Tarlow, Andrew Gordon, and Yi Wei. 2015. Bimodal modelling of source code and natural language. In <em>  <em>ICML</em>  </em>. 2123&#x2013;2132.</li> <li id="BibPLXBIB0003" label="[3]">Alberto Bacchelli. 2013. Mining Challenge 2013: Stack Overflow. In <em>  <em>The 10th Working Conference on Mining Software Repositories</em>  </em>. to appear.</li> <li id="BibPLXBIB0004" label="[4]">Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. 2014. Neural Machine Translation by Jointly Learning to Align and Translate. <em>  <em>CoRR</em>  </em>abs/1409.0473(2014). arxiv:1409.0473<a class="link-inline force-break" href="http://arxiv.org/abs/1409.0473"  target="_blank">http://arxiv.org/abs/1409.0473</a></li> <li id="BibPLXBIB0005" label="[5]">Antonio Valerio&#x00A0;Miceli Barone and Rico Sennrich. 2017. A parallel corpus of Python functions and documentation strings for automated code documentation and code generation. <em>  <em>arXiv preprint arXiv:1707.02275</em>  </em>(2017).</li> <li id="BibPLXBIB0006" label="[6]">Brock&#x00A0;Angus Campbell and Christoph Treude. 2017. NLP2Code: Code Snippet Content Assist via Natural Language Tasks. <em>  <em>arXiv preprint arXiv:1701.05648</em>  </em>(2017).</li> <li id="BibPLXBIB0007" label="[7]">Ohio&#x00A0;Supercomputer Center. 1987. Ohio Supercomputer Center. <a class="link-inline force-break" href="http://osc.edu/ark:/19495/f5s1ph73."  target="_blank">http://osc.edu/ark:/19495/f5s1ph73.</a> (1987).</li> <li id="BibPLXBIB0008" label="[8]">Kyunghyun Cho, Bart van Merri&#x00EB;nboer, &#x00C7;a&#x011F;lar G&#x00FC;l&#x00E7;ehre, Dzmitry Bahdanau, Fethi Bougares, Holger Schwenk, and Yoshua Bengio. 2014. Learning Phrase Representations using RNN Encoder&#x2013;Decoder for Statistical Machine Translation. In <em>  <em>EMNLP</em>  </em>. Association for Computational Linguistics, Doha, Qatar, 1724&#x2013;1734.</li> <li id="BibPLXBIB0009" label="[9]">Jacob Cohen. 1960. A coefficient of agreement for nominal scales. <em>  <em>Educational and psychological measurement</em>  </em>20, 1 (1960), 37&#x2013;46.</li> <li id="BibPLXBIB0010" label="[10]">Corinna Cortes and Vladimir Vapnik. 1995. Support-vector networks. <em>  <em>Machine learning</em>  </em>20, 3 (1995), 273&#x2013;297.</li> <li id="BibPLXBIB0011" label="[11]">David&#x00A0;R Cox. 1958. The regression analysis of binary sequences. <em>  <em>Journal of the Royal Statistical Society. Series B (Methodological)</em>  </em> (1958), 215&#x2013;242.</li> <li id="BibPLXBIB0012" label="[12]">Lucas&#x00A0;BL de Souza, Eduardo&#x00A0;C Campos, and Marcelo de&#x00A0;A Maia. 2014. Ranking crowd knowledge to assist software development. In <em>  <em>Proceedings of the 22nd International Conference on Program Comprehension</em>  </em>. ACM, 72&#x2013;82.</li> <li id="BibPLXBIB0013" label="[13]">Fernanda&#x00A0;Madeiral Delfim, Kl&#x00E9;risson&#x00A0;VR Paix&#x00E3;o, Damien Cassou, and Marcelo de Almeida&#x00A0;Maia. 2016. Redocumenting APIs with crowd knowledge: a coverage analysis based on question types. <em>  <em>Journal of the Brazilian Computer Society</em>  </em>22, 1 (2016), 9.</li> <li id="BibPLXBIB0014" label="[14]">Maarten Duijn, Adam Ku&#x010D;era, and Alberto Bacchelli. 2015. Quality questions need quality code: classifying code fragments on stack overflow. In <em>  <em>Proceedings of the 12th Working Conference on Mining Software Repositories</em>  </em>. IEEE Press, 410&#x2013;413.</li> <li id="BibPLXBIB0015" label="[15]">Alessandra Giordani and Alessandro Moschitti. 2009. Semantic mapping between natural language questions and SQL queries via syntactic pairing. In <em>  <em>International Conference on Application of Natural Language to Information Systems</em>  </em>. Springer, 207&#x2013;221.</li> <li id="BibPLXBIB0016" label="[16]">Alessandra Giordani and Alessandro Moschitti. 2010. Corpora for Automatically Learning to Map Natural Language Questions into SQL Queries.. In <em>  <em>LREC</em>  </em>.</li> <li id="BibPLXBIB0017" label="[17]">GitHub. 2017. GitHub. (2017). <a class="link-inline force-break" href="https://github.com/" target="_blank">https://github.com/</a></li> <li id="BibPLXBIB0018" label="[18]">Xavier Glorot and Yoshua Bengio. 2010. Understanding the difficulty of training deep feedforward neural networks. In <em>  <em>Proceedings of the Thirteenth International Conference on Artificial Intelligence and Statistics</em>  </em>. 249&#x2013;256.</li> <li id="BibPLXBIB0019" label="[19]">Ian Goodfellow, Yoshua Bengio, and Aaron Courville. 2016. <em>  <em>Deep Learning</em>  </em>. MIT Press. <a class="link-inline force-break" href="http://www.deeplearningbook.org">http://www.deeplearningbook.org</a>.</li> <li id="BibPLXBIB0020" label="[20]">Karl&#x00A0;Moritz Hermann, Tomas Kocisky, Edward Grefenstette, Lasse Espeholt, Will Kay, Mustafa Suleyman, and Phil Blunsom. 2015. Teaching machines to read and comprehend. In <em>  <em>NIPS</em>  </em>. 1693&#x2013;1701.</li> <li id="BibPLXBIB0021" label="[21]">Srinivasan Iyer, Ioannis Konstas, Alvin Cheung, and Luke Zettlemoyer. 2016. Summarizing source code using a neural attention model. In <em>  <em>ACL</em>  </em>, Vol.&#x00A0;1. 2073&#x2013;2083.</li> <li id="BibPLXBIB0022" label="[22]">Iman Keivanloo, Juergen Rilling, and Ying Zou. 2014. Spotting working code examples. In <em>  <em>ICSE</em>  </em>. ACM, 664&#x2013;675.</li> <li id="BibPLXBIB0023" label="[23]">Diederik Kingma and Jimmy Ba. 2014. Adam: A method for stochastic optimization. <em>  <em>arXiv preprint arXiv:1412.6980</em>  </em>(2014).</li> <li id="BibPLXBIB0024" label="[24]">Alex Krizhevsky, Ilya Sutskever, and Geoffrey&#x00A0;E Hinton. 2012. ImageNet Classification with Deep Convolutional Neural Networks. In <em>  <em>NIPS</em>  </em>, F.&#x00A0;Pereira, C.&#x00A0;J.&#x00A0;C. Burges, L.&#x00A0;Bottou, and K.&#x00A0;Q. Weinberger (Eds.). Curran Associates, Inc., 1097&#x2013;1105.</li> <li id="BibPLXBIB0025" label="[25]">Jiwei Li, Minh-Thang Luong, and Dan Jurafsky. 2015. A hierarchical neural autoencoder for paragraphs and documents. <em>  <em>arXiv preprint arXiv:1506.01057</em>  </em>(2015).</li> <li id="BibPLXBIB0026" label="[26]">Wang Ling, Edward Grefenstette, Karl&#x00A0;Moritz Hermann, Tom&#x00E1;&#x0161; Ko&#x010D;isk&#x1EF3;, Andrew Senior, Fumin Wang, and Phil Blunsom. 2016. Latent predictor networks for code generation. <em>  <em>arXiv preprint arXiv:1603.06744</em>  </em>(2016).</li> <li id="BibPLXBIB0027" label="[27]">Edward Loper and Steven Bird. 2002. NLTK: The Natural Language Toolkit. In <em>  <em>Proceedings of the ACL-02 Workshop on Effective Tools and Methodologies for Teaching Natural Language Processing and Computational Linguistics - Volume 1</em>  </em>(ETMTNLP &#x2019;02). Association for Computational Linguistics, Stroudsburg, PA, USA, 63&#x2013;70. <a class="link-inline force-break" href="https://doi.org/10.3115/1118108.1118117"  target="_blank">https://doi.org/10.3115/1118108.1118117</a></li> <li id="BibPLXBIB0028" label="[28]">Pablo Loyola, Edison Marrese-Taylor, and Yutaka Matsuo. 2017. A Neural Architecture for Generating Natural Language Descriptions from Source Code Changes. <em>  <em>arXiv preprint arXiv:1704.04856</em>  </em>(2017).</li> <li id="BibPLXBIB0029" label="[29]">Minh-Thang Luong, Hieu Pham, and Christopher&#x00A0;D. Manning. 2015. Effective Approaches to Attention-based Neural Machine Translation. In <em>  <em>EMNLP</em>  </em>.</li> <li id="BibPLXBIB0030" label="[30]">Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg&#x00A0;S Corrado, and Jeff Dean. 2013. Distributed representations of words and phrases and their compositionality. In <em>  <em>NIPS</em>  </em>. 3111&#x2013;3119.</li> <li id="BibPLXBIB0031" label="[31]">Lili Mou, Ge Li, Lu Zhang, Tao Wang, and Zhi Jin. 2016. Convolutional neural networks over tree structures for programming language processing. In <em>  <em>AAAI</em>  </em>.</li> <li id="BibPLXBIB0032" label="[32]">Seyed&#x00A0;Mehdi Nasehi, Jonathan Sillito, Frank Maurer, and Chris Burns. 2012. What makes a good code example?: A study of programming Q&#x0026;A in StackOverflow. In <em>  <em>Software Maintenance (ICSM), 2012 28th IEEE International Conference on</em>  </em>. IEEE, 25&#x2013;34.</li> <li id="BibPLXBIB0033" label="[33]">Anh&#x00A0;Tuan Nguyen and Tien&#x00A0;N Nguyen. 2015. Graph-based statistical language model for code. In <em>  <em>Proceedings of the 37th International Conference on Software Engineering-Volume 1</em>  </em>. IEEE Press, 858&#x2013;868.</li> <li id="BibPLXBIB0034" label="[34]">Kamal Nigam and Rayid Ghani. 2000. Analyzing the effectiveness and applicability of co-training. In <em>  <em>CIKM</em>  </em>. ACM, 86&#x2013;93.</li> <li id="BibPLXBIB0035" label="[35]">Yusuke Oda, Hiroyuki Fudaba, Graham Neubig, Hideaki Hata, Sakriani Sakti, Tomoki Toda, and Satoshi Nakamura. 2015. Learning to generate pseudo-code from source code using statistical machine translation (t). In <em>  <em>Automated Software Engineering (ASE), 2015 30th IEEE/ACM International Conference on</em>  </em>. IEEE, 574&#x2013;584.</li> <li id="BibPLXBIB0036" label="[36]">Stack Overflow. 2017. How do I find a &#x201C;gap&#x201D; in running counter with SQL?(2017). <a class="link-inline force-break"  href="https://stackoverflow.com/a/1312137/4941215"  target="_blank">https://stackoverflow.com/a/1312137/4941215</a></li> <li id="BibPLXBIB0037" label="[37]">Stack Overflow. 2017. How to find a gap in range in SQL. (2017). <a class="link-inline force-break"  href="https://stackoverflow.com/a/17782635/4941215"  target="_blank">https://stackoverflow.com/a/17782635/4941215</a></li> <li id="BibPLXBIB0038" label="[38]">Stack Overflow. 2017. How to limit a number to be within a specified range? (Python). (2017). <a class="link-inline force-break"  href="https://stackoverflow.com/a/5996949/4941215"  target="_blank">https://stackoverflow.com/a/5996949/4941215</a></li> <li id="BibPLXBIB0039" label="[39]">Stack Overflow. 2017. Splitting a dataframe based on column values. (2017). <a class="link-inline force-break"  href="https://stackoverflow.com/a/33973304/4941215"  target="_blank">https://stackoverflow.com/a/33973304/4941215</a></li> <li id="BibPLXBIB0040" label="[40]">Stack Overflow. 2017. Stack Overflow. (2017). <a class="link-inline force-break" href="https://stackoverflow.com/"  target="_blank">https://stackoverflow.com/</a></li> <li id="BibPLXBIB0041" label="[41]">F. Pedregosa, G. Varoquaux, A. Gramfort, V. Michel, B. Thirion, O. Grisel, M. Blondel, P. Prettenhofer, R. Weiss, V. Dubourg, J. Vanderplas, A. Passos, D. Cournapeau, M. Brucher, M. Perrot, and E. Duchesnay. 2011. Scikit-learn: Machine Learning in Python. <em>  <em>Journal of Machine Learning Research</em>  </em>12 (2011), 2825&#x2013;2830.</li> <li id="BibPLXBIB0042" label="[42]">Jeffrey Pennington, Richard Socher, and Christopher&#x00A0;D Manning. 2014. Glove: Global Vectors for Word Representation.. In <em>  <em>EMNLP</em>  </em>, Vol.&#x00A0;14. 1532&#x2013;1543.</li> <li id="BibPLXBIB0043" label="[43]">Rashmi Prasad, Nikhil Dinesh, Alan Lee, Eleni Miltsakaki, Livio Robaldo, Aravind Joshi, and Bonnie Webber. 2008. The Penn Discourse TreeBank 2.0. In <em>  <em>In Proceedings of LREC</em>  </em>.</li> <li id="BibPLXBIB0044" label="[44]">Maxim Rabinovich, Mitchell Stern, and Dan Klein. 2017. Abstract Syntax Networks for Code Generation and Semantic Parsing. In <em>  <em>ACL</em>  </em>.</li> <li id="BibPLXBIB0045" label="[45]">Mukund Raghothaman, Yi Wei, and Youssef Hamadi. 2016. SWIM: synthesizing what I mean: code search and idiomatic snippet synthesis. In <em>  <em>ICSE</em>  </em>. ACM, 357&#x2013;367.</li> <li id="BibPLXBIB0046" label="[46]">Alexander&#x00A0;J Ratner, Christopher&#x00A0;M De&#x00A0;Sa, Sen Wu, Daniel Selsam, and Christopher R&#x00E9;. 2016. Data programming: Creating large training sets, quickly. In <em>  <em>NIPS</em>  </em>. 3567&#x2013;3575.</li> <li id="BibPLXBIB0047" label="[47]">David&#x00A0;E Rumelhart, Geoffrey&#x00A0;E Hinton, Ronald&#x00A0;J Williams, <em>et al.</em> 1988. Learning representations by back-propagating errors. <em>  <em>Cognitive modeling</em>  </em>5, 3 (1988), 1.</li> <li id="BibPLXBIB0048" label="[48]">Iulian&#x00A0;Vlad Serban, Alessandro Sordoni, Yoshua Bengio, Aaron&#x00A0;C Courville, and Joelle Pineau. 2016. Building End-To-End Dialogue Systems Using Generative Hierarchical Neural Network Models.. In <em>  <em>AAAI</em>  </em>. 3776&#x2013;3784.</li> <li id="BibPLXBIB0049" label="[49]">Yelong Shen, Xiaodong He, Jianfeng Gao, Li Deng, and Gr&#x00E9;goire Mesnil. 2014. A latent semantic model with convolutional-pooling structure for information retrieval. In <em>  <em>CIKM</em>  </em>. ACM, 101&#x2013;110.</li> <li id="BibPLXBIB0050" label="[50]">Karen Simonyan and Andrew Zisserman. 2014. Very deep convolutional networks for large-scale image recognition. <em>  <em>arXiv preprint arXiv:1409.1556</em>  </em>(2014).</li> <li id="BibPLXBIB0051" label="[51]">Inc Stack&#x00A0;Exchange. 2017. Stack Exchange Data Dump. (2017). <a class="link-inline force-break"  href="https://archive.org/details/stackexchange"  target="_blank">https://archive.org/details/stackexchange</a></li> <li id="BibPLXBIB0052" label="[52]">Yu Su, Ahmed Hassan&#x00A0;Awadallah, Madian Khabsa, Patrick Pantel, and Michael Gamon. 2017. Building Natural Language Interfaces to Web APIs, In <em>CIKM</em>.</li> <li id="BibPLXBIB0053" label="[53]">Christian Szegedy, Alexander Toshev, and Dumitru Erhan. 2013. Deep neural networks for object detection. In <em>  <em>NIPS</em>  </em>. 2553&#x2013;2561.</li> <li id="BibPLXBIB0054" label="[54]">Duyu Tang, Bing Qin, and Ting Liu. 2015. Document Modeling with Gated Recurrent Neural Network for Sentiment Classification.. In <em>  <em>EMNLP</em>  </em>. 1422&#x2013;1432.</li> <li id="BibPLXBIB0055" label="[55]">TensorFlow. 2017. TensorFlow. (2017). <a class="link-inline force-break" href="https://www.tensorflow.org/"  target="_blank">https://www.tensorflow.org/</a></li> <li id="BibPLXBIB0056" label="[56]">Christoph Treude, Ohad Barzilay, and Margaret-Anne Storey. 2011. How do programmers ask and answer questions on the web?: Nier track. In <em>  <em>ICSE</em>  </em>. IEEE, 804&#x2013;807.</li> <li id="BibPLXBIB0057" label="[57]">Venkatesh Vinayakarao, Anita Sarma, Rahul Purandare, Shuktika Jain, and Saumya Jain. 2017. Anne: Improving source code search using entity retrieval approach. In <em>  <em>Proceedings of the Tenth ACM International Conference on Web Search and Data Mining</em>  </em>. ACM, 211&#x2013;220.</li> <li id="BibPLXBIB0058" label="[58]">Ellen&#x00A0;M Voorhees <em>et al.</em> 1999. The TREC-8 Question Answering Track Report.. In <em>  <em>Trec</em>  </em>, Vol.&#x00A0;99. 77&#x2013;82.</li> <li id="BibPLXBIB0059" label="[59]">Di Yang, Aftab Hussain, and Cristina&#x00A0;Videira Lopes. 2016. From query to usable code: an analysis of stack overflow code snippets. In <em>  <em>Proceedings of the 13th International Workshop on Mining Software Repositories</em>  </em>. ACM, 391&#x2013;402.</li> <li id="BibPLXBIB0060" label="[60]">Zichao Yang, Diyi Yang, Chris Dyer, Xiaodong He, Alex Smola, and Eduard Hovy. 2016. Hierarchical attention networks for document classification. In <em>  <em>Proceedings of NAACL-HLT</em>  </em>. 1480&#x2013;1489.</li> <li id="BibPLXBIB0061" label="[61]">Pengcheng Yin and Graham Neubig. 2017. A Syntactic Neural Model for General-Purpose Code Generation. In <em>  <em>ACL</em>  </em>. Vancouver, Canada.</li> <li id="BibPLXBIB0062" label="[62]">Annie T.&#x00A0;T. Ying. 2015. Mining Challenge 2015: Comparing and combining different information sources on the Stack Overflow data set. In <em>  <em>The 12th Working Conference on Mining Software Repositories</em>  </em>. to appear.</li> <li id="BibPLXBIB0063" label="[63]">Zhi-Hua Zhou and Ming Li. 2005. Tri-training: Exploiting unlabeled data using three classifiers. <em>  <em>IEEE Transactions on knowledge and Data Engineering</em>  </em>17, 11(2005), 1529&#x2013;1541.</li> <li id="BibPLXBIB0064" label="[64]">Meital Zilberstein and Eran Yahav. 2016. Leveraging a corpus of natural language descriptions for program similarity. In <em>  <em>Proceedings of the 2016 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software</em>  </em>. ACM, 197&#x2013;211.</li> </ul> </section> </section> <section id="foot-001" class="footnote"> <header> <div class="title-info"> <h2>FOOTNOTE</h2> </div> </header> <p id="fn1"><a href="#foot-fn1"><sup>1</sup></a>Available at <a class="link-inline force-break" href="https://github.com/LittleYUYU/StackOverflow-Question-Code-Dataset">https://github.com/LittleYUYU/StackOverflow-Question-Code-Dataset</a>. </p> <p id="fn2"><a href="#foot-fn2"><sup>1</sup></a>In SO, an accepted answer post is marked with a green check by the questioner, if he/she thinks it solves the problem. Following previous work [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0021">21</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0059">59</a>], although there can be multiple answer posts to a question, <em>we only consider the accepted one because of its verified quality</em>, and use &#x201C;accepted answer post&#x201D; and &#x201C;answer post&#x201D; interchangeably.</p> <p id="fn3"><a href="#foot-fn3"><sup>2</sup></a>Following previous work [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0002">2</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0006">6</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0021">21</a>], we only use the title of a question post in this work, and leave incorporating the question post content for future work.</p> <p id="fn4"><a href="#foot-fn4"><sup>3</sup></a>Despite of the small amount of training data, no overfitting was observed in our experiments partly because the features are very simple.</p> <p id="fn5"><a href="#foot-fn5"><sup>4</sup></a>For fair comparison, we only use one layer since the Bi-GRU in BiV-HNN only has one hidden layer.</p> <div class="bibStrip"> <p>This paper is published under the Creative Commons Attribution 4.0 International (CC-BY&#x00A0;4.0) license. Authors reserve their rights to disseminate the work on their personal and corporate Web sites with the appropriate attribution.</p> <p> <em>WWW '18, April 23-27, 2018, Lyon, France</em> </p> <p>&#x00A9; 2018; IW3C2 (International World Wide Web Conference Committee), published under Creative Commons CC-BY&#x00A0;4.0 License. ACM ISBN 978-1-4503-5639-8/18/04.<br/>DOI: <a class="link-inline force-break" target="_blank"  href="https://doi.org/10.1145/3178876.3186081">doi.org/10.1145/3178876.3186081</a> </p> </div> </section> <div class="pubHistory"> <p/> </div> </body> </html> 
