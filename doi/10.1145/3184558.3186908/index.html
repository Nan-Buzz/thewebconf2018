<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">  <head>  <title>P3RPQ: Pregel-Based Parallel Provenance-Aware Regular Path Query Processing on Large RDF Graphs</title>  <!-- Copyright (c) 2010-2015 The MathJax Consortium --><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>  <meta name="viewport" content="width=device-width; initial-scale=1.0;"></meta>  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>  <link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/bootstrap.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/bootstrap-theme.min.css"/><link media="screen, print" rel="stylesheet"    href="../../../data/dl.acm.org/pubs/lib/css/main.css"/><script src="../../../data/dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script>  <script src="../../../data/dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script>  <script type="text/javascript"    src="../../../data/dl.acm.org/pubs/lib/js/MathJax.TeX-AMS_CHTML.js"></script>  <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>  </head>  <body id="main">  <section class="front-matter">   <section>    <header class="title-info">     <div class="journal-title">     <h1>      <span class="title">P3RPQ: Pregel-Based Parallel Provenance-Aware Regular Path Query Processing on Large RDF Graphs</span>      <br/>      <span class="subTitle"/>     </h1>     </div>    </header>    <div class="authorGroup">     <div class="author">     <span class="givenName">Yueqi</span>      <span class="surName">Xin</span>     School of Computer Science and Technology, Tianjin University, Tianjin, China     </div>     <div class="author">     <span class="givenName">Bingyi</span>      <span class="surName">Zhang</span>     School of Computer Science and Technology, Tianjin University, Tianjin, China     </div>     <div class="author">     <span class="givenName">Xin</span>      <span class="surName">Wang</span>     School of Computer Science and Technology, Tianjin University, Tianjin, China     </div>     <div class="author">     <span class="givenName">Qiang</span>      <span class="surName">Xu</span>     School of Computer Science and Technology, Tianjin University, Tianjin, China<a class="fn" href="#fn1" id="foot-fn1"><sup>&#x204E;</sup></a>, <a href="mailto:xinyueqi@tju.edu.cn, byzhang@tju.edu.cn, wangx@tju.edu.cn, xuqiang3@tju.edu.cn">xinyueqi@tju.edu.cn, byzhang@tju.edu.cn, wangx@tju.edu.cn, xuqiang3@tju.edu.cn</a>     </div>     <div class="author">     <span class="givenName">Zhiyong</span>      <span class="surName">Feng</span>     School of Computer Software, Tianjin University, Tianjin, China, <a href="mailto:zyfeng@tju.edu.cn">zyfeng@tju.edu.cn</a>     </div>         <Affiliation id="aff2">Tianjin Key Laboratory of Cognitive Computing and Application, Tianjin, China</Affiliation>         <Affiliation1 id="aff4">Tianjin Key Laboratory of Cognitive Computing and Application, Tianjin, China</Affiliation1>    </div>    <br/>    <div class="pubInfo">     <p>DOI: <a href="https://doi.org/10.1145/3184558.3186908" target="_blank">https://doi.org/10.1145/3184558.3186908</a>     <br/>WWW '18: <a href="https://doi.org/10.1145/3184558" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p>    </div>    <div class="abstract">     <p>     <small>This paper proposes a novel method for answering <span style="text-decoration: underline;">P</span>regel-based <span style="text-decoration: underline;">P</span>arallel <span style="text-decoration: underline;">P</span>rovenance-aware <span style="text-decoration: underline;">R</span>egular <span style="text-decoration: underline;">P</span>ath <span style="text-decoration: underline;">Q</span>ueries (<tt>P3RPQ</tt>) on large RDF graphs. Our method is developed using the Pregel framework, which utilizes Glushkov automata to keep track of the matching process of RPQs in parallel. Meanwhile, four optimization strategies are devised, which can reduce the response time of the basic algorithm dramatically and overcome the counting paths problem to some extent. The experiments are conducted to verify the performance of our algorithms on both synthetic and real-world datasets.</small>     </p>    </div>    <div class="classifications">     <div class="AcmReferenceFormat">     <p>      <small>       <span style="font-weight:bold;">ACM Reference Format:</span>       <br/>       Yueqi Xin, Bingyi Zhang, Xin Wang, Qiang Xu, and Zhiyong Feng. 2018. P3RPQ: Pregel-Based Parallel Provenance-Aware Regular Path Query Processing on Large RDF Graphs. In <em>WWW '18 Companion: The 2018 Web Conference Companion,</em>       <em>April 23&#x2013;27, 2018,</em>       <em> Lyon, France. ACM, New York, NY, USA</em> 3 Pages. <a href="https://doi.org/10.1145/3184558.3186908" class="link-inline force-break"        target="_blank">https://doi.org/10.1145/3184558.3186908</a></small>     </p>     </div>    </div>   </section>  </section>  <section class="body">   <section id="sec-5">    <header>     <div class="title-info">     <h2>      <span class="section-number">1</span> INTRODUCTION</h2>     </div>    </header>    <p>RDF is a flexible graph-like data model which can represent large-scale knowledge bases. <em>Regular path queries</em> (RPQs) are recognized as one of the fundamental operations for querying graph data, which can explore RDF graphs in a navigational manner. Answering an RPQ <em>Q</em> over an RDF graph <em>T</em> is to find a set of pairs of resources (<em>v</em>     <sub>0</sub>, <em>v<sub>n</sub>     </em>) such that the path between <em>v</em>     <sub>0</sub> and <em>v<sub>n</sub>     </em> satisfies <em>Q</em>. For example, an RPQ <span class="inline-equation"><span class="tex">$ Q_1 = (x, (\textsf {predecessor}|\textsf {father})^+, y)$</span>     </span> on an RDF graph <em>T</em>     <sub>1</sub> in Fig.&#x00A0;1(a) asks to find the set of (<em>v</em>     <sub>0</sub>, <em>v<sub>n</sub>     </em>) such that <em>v</em>     <sub>0</sub> can navigate to <em>v<sub>n</sub>     </em> via one or more predecessor or father edges. The answers are shown in Fig.&#x00A0;1(b), from which one cannot figure out how each resource is reached from another. In order to provide the <em>provenance</em> of each answer, we focus on the <em>provenance-aware</em> RPQs that return a <em>subgraph</em> of the RDF graph consisting of all the &#x201C;witness triples&#x201D;. For <em>Q</em>     <sub>1</sub>, the subgraph is exactly <em>T</em>     <sub>1</sub>, which effectively encode the conventional answers of <em>Q</em>     <sub>1</sub> shown in Fig.&#x00A0;1(b) . <figure id="fig1">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186908/images/www18companion-148-fig1.svg" class="img-responsive" alt="Figure 1"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 1:</span>      <span class="figure-title">       <strong>An RDF graph <em>T</em>        <sub>1</sub> and answers of RPQ <em>Q</em>        <sub>1</sub>       </strong>      </span>     </div>     </figure>    </p>    <p>Dey et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0001">1</a>] had done the first work to investigate provenance-aware RPQs by translating them into Datalog queries, which is hardly scalable for evaluating large graph data. Wang et al. [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0003">3</a>] employed product automata to solve this problem, which may result in excessive communication cost for large-scale RDF graphs.</p>    <p>Compared with the previous approaches, our main contributions include: (1) we propose a <em>Pregel-based</em> parallel method, which is the first work that answers provenance-aware RPQs using the Pregel graph parallel computing framework; (2) four optimization strategies are presented to reduce the overhead of the basic algorithm and partly address the <em>counting paths</em> problem; and (3) extensive experiments were conducted to verify the efficiency and scalability of our proposed method on both synthetic and real-world datasets.</p>   </section>   <section id="sec-6">    <header>     <div class="title-info">     <h2>      <span class="section-number">2</span> Problem and our approach</h2>     </div>    </header>    <p>An RDF graph <em>T</em> is a set of triples, each triple (<em>s</em>, <em>p</em>, <em>o</em>) representing a statement of a relationship (predicate) <em>p</em> between a subject <em>s</em> and an object <em>o</em>. An RDF graph can also be modeled as a directed labeled graph <em>T</em> = (<em>V</em>, <em>E</em>, <em>l</em>) with node set <em>V</em>, edge set <em>E</em>, and the function <em>l</em> that assigns a label to each edge. For each (<em>s</em>, <em>p</em>, <em>o</em>)&#x2286;<em>T</em>, there exists an edge <em>e</em> = (<em>s</em>, <em>o</em>) &#x2208; <em>E</em> and <em>l</em>(<em>e</em>) = <em>p</em>. Given an RPQ <em>Q</em> = (<em>x</em>, <em>r</em>, <em>y</em>) over <em>T</em>, <em>r</em> is a <em>regular expression</em> over the set <em>&#x03A3;</em> of edge labels. The regular expression is recursively defined as <em>r</em>: &#x2254;&#x025B;~|~<em>p</em>~|~<em>r</em>/<em>r</em>~|~<em>r</em>|<em>r</em>~|~<em>r</em>     <sup>*</sup>, where <em>p</em> &#x2208; <em>&#x03A3;</em> and /, |, and <sup>*</sup> are concatenation, alternation, and the Kleene closure, respectively. The shorthands <em>r</em>     <sup>+</sup> for <em>r</em>/<em>r</em>     <sup>*</sup> and <em>r</em>? for &#x025B;|<em>r</em> are allowed. <em>L</em>(<em>r</em>) denotes the language expressed by <em>r</em> and <em>&#x03BB;</em>(<em>&#x03C1;</em>) is the label of path <em>&#x03C1;</em>. The answer set to conventional semantics of an RPQ <em>Q</em> over an RDF graph <em>T</em> is defined as <span class="inline-equation"><span class="tex">$[[ Q ]] _{T} = \lbrace (v_0, v_n) \mid \exists$</span>     </span> a path <em>&#x03C1;</em> in <em>T</em> from <em>v</em>     <sub>0</sub> to <em>v<sub>n</sub>     </em> s.t. <em>&#x03BB;</em>(<em>&#x03C1;</em>) &#x2208; <em>L</em>(<em>r</em>)}, whereas the provenance-aware answer set of <em>Q</em> is defined as <span class="inline-equation"><span class="tex">$[[ Q ]] ^{\mathfrak {p}}_{T}=\lbrace (s, p, o) \mid \exists$</span>     </span> a path <em>&#x03C1;</em> in <em>T</em> s.t. (<em>s</em>, <em>p</em>, <em>o</em>) is an edge in <em>&#x03C1;</em> and <em>&#x03BB;</em>(<em>&#x03C1;</em>) &#x2208; <em>L</em>(<em>r</em>)}.</p>    <p>The computation in Pregel consists of a series of supersteps &#x00A0;[<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top"     href="#BibPLXBIB0002">2</a>], which is processed at each vertex <em>in parallel</em>. The Pregel-based evaluation for provenance-aware RPQs is shown in Algorithm&#x00A0;1, in which we construct a <em>Glushkov automaton A<sub>Q</sub>     </em> based on <em>r</em> in an RPQ <em>Q</em> = (<em>x</em>, <em>r</em>, <em>y</em>). Let <em>Pos</em>(<em>r</em>) = {1, &#x2026;, |<em>r</em>|} be the set of positions in <em>r</em>, where |<em>r</em>| is the length of <em>r</em>, and <em>i</em> &#x2208; <em>Pos</em>(<em>r</em>) is the index of <em>r</em>[<em>i</em>]. The function <span class="inline-equation"><span class="tex">$\texttt {first}(r)$</span>     </span> (resp. <span class="inline-equation"><span class="tex">$\texttt {last}(r))$</span>     </span> is the set of positions in <em>r</em> that can match the first (resp. last) symbol of a string in <em>L</em>(<em>r</em>). The function <span class="inline-equation"><span class="tex">$\texttt {follow}(r, i)$</span>     </span> is the set of positions in <em>r</em> that can follow position <em>i</em> when matching some string in <em>L</em>(<em>r</em>). Thus, <em>A<sub>Q</sub>     </em> is defined as a 5-tuple (<em>St</em>, <em>&#x03A3;</em>, <em>&#x03B4;</em>, <em>q</em>     <sub>0</sub>, <em>F</em>), where (1) <em>St</em> = {0}&#x222A;<em>Pos</em>(<em>r</em>), (2) <em>&#x03A3;</em> is the alphabet of <em>r</em>, (3) <span class="inline-equation"><span class="tex">$\delta (q_0,a)=\lbrace i \mid i \in \texttt {first}(r) \wedge r[i]=a\rbrace$</span>     </span> , <span class="inline-equation"><span class="tex">$\delta (q,a)=\lbrace i \mid i \in \texttt {follow}(r,q) \wedge r[i]=a\rbrace$</span>     </span>, for <em>a</em> &#x2208; <em>&#x03A3;</em> &#x2227; <em>q</em> &#x2208; <em>Pos</em>(<em>r</em>), (4) <em>q</em>     <sub>0</sub> = 0 is the initial state, and (5) <em>F</em> is the set of final states, if &#x025B; &#x2208; <em>L</em>(<em>r</em>), then <span class="inline-equation"><span class="tex">$F=\lbrace q_0\rbrace \cup \texttt {last}(r)$</span>     </span>, otherwise <span class="inline-equation"><span class="tex">$F=\texttt {last}(r)$</span>     </span>.</p>    <p>The matching process is mainly divided into the following phases: (1) in the first superstep, <em>v</em> &#x2208; <em>V</em> is considered to be matched with <span class="inline-equation"><span class="tex">$q \in \texttt {first}(r)$</span>     </span>; for the remaining supersteps, it is matched forward w.r.t. the receiving message set <em>M<sub>r</sub>     </em>; (2) <em>M<sub>s</sub>     </em> is generated and <span class="inline-equation"><span class="tex">$\texttt {sendMsg}(v,v^{\prime },M_s)$</span>     </span> is invoked at <em>v</em>, in which <em>M<sub>s</sub>     </em> is sent from <em>v</em> to <em>v</em>&#x2032;. It can be proved that the complexity of <tt>P3RPQ</tt> is bounded by <em>O</em>(|<em>r</em>|<sup>     <em>S</em> + 2</sup>), where <em>S</em> is the number of supersteps.</p>    <p>     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186908/images/www18companion-148-img1.svg" class="img-responsive" alt=""      longdesc=""/>    </p>    <p>The optimized algorithm <tt>P3RPQ<sub>      <em>opt</em>     </sub>     </tt> with <em>edge filtering</em> and <em>candidate state</em> only loads the edges that are relevant to <em>Q</em> and precomputes each state <em>q</em> &#x2208; <em>St</em> that <em>v</em> can match. Due to the <em>counting paths</em> problem, it may result in a large number of intermediate results when querying an RDF graph consisting of some vertices that can incur Cartesian products, just like <em>v</em>     <sub>2</sub> in <em>T</em>     <sub>1</sub> in Fig.1(a) . To this end, we propose another optimized algorithm <tt>P3RPQ<sub>      <em>cnt</em>     </sub>     </tt> with <em>message selection</em> and <em>message compression</em> to decrease the times of matching at vertices and compress the messages to be sent.</p>   </section>   <section id="sec-7">    <header>     <div class="title-info">     <h2>      <span class="section-number">3</span> EXPERIMENTS</h2>     </div>    </header>    <p>The proposed method was implemented in Scala using Spark GraphX deployed on a 10-site cluster. Each of the sites installs a 64-bit CentOS 7.3 operating system and has a 4-core CPU and 16GB memory. We use five experimental datasets LUBM100 (10.9M triples), LUBM200 (27.6M triples), DBpedia (18.2M triples), WatDiv1M (1.1M triples), and WatDiv10M (10.9M triples). An RPQ is complex if it has the closure operators <sup>*</sup> or <sup>+</sup>, otherwise it is simple. We designed 12 representative RPQs listed in Table.&#x00A0;<a class="tbl" href="#tab1">1</a>.</p>    <div class="table-responsive" id="tab1">     <div class="table-caption">     <span class="table-number">Table 1:</span>     <span class="table-title">Regular path queries</span>     </div>     <table class="table">     <tbody>      <tr>       <td colspan="2" style="text-align:center;">Simple RPQs<hr/>       </td>      </tr>      <tr>       <td style="text-align:left;">        <em>Q</em>        <sub>1</sub> = (<em>a</em>/<em>b</em>)|(<em>c</em>/<em>d</em>) &#x00A0;&#x00A0;&#x00A0;<em>Q</em>        <sub>2</sub> = <em>a</em>/<em>b</em>/<em>c</em>/<em>d</em>       </td>       <td style="text-align:left;">        <em>Q</em>        <sub>3</sub> = <em>a</em>/<em>b</em>/(<em>c</em>|<em>d</em>|<em>e</em>) &#x00A0;&#x00A0;&#x00A0;<em>Q</em>        <sub>4</sub> = (<em>a</em>|<em>b</em>)/(<em>a</em>|<em>c</em>)</td>      </tr>      <tr>       <td colspan="2" style="text-align:center;">Complex RPQs<hr/>       </td>      </tr>      <tr>       <td style="text-align:left;">        <em>Q</em>        <sub>5</sub> = (<em>a</em>/<em>a</em>)<sup>+</sup> &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0; <em>Q</em>        <sub>6</sub> = (<em>a</em>|<em>b</em>|<em>c</em>)<sup>+</sup>       </td>       <td style="text-align:left;">        <em>Q</em>        <sub>7</sub> = <em>a</em>        <sup>+</sup> &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0; <em>Q</em>        <sub>8</sub> = <em>a</em>/(<em>a</em>|<em>b</em>|<em>c</em>)<sup>*</sup>       </td>      </tr>      <tr>       <td style="text-align:left;">        <em>Q</em>        <sub>9</sub> = (<em>a</em>/<em>b</em>)<sup>+</sup>|(<em>c</em>/<em>d</em>)<sup>+</sup>       </td>       <td style="text-align:left;">        <em>Q</em>        <sub>10</sub> = (<em>a</em>/(<em>b</em>/<em>c</em>)<sup>*</sup>)<sup>+</sup>|(<em>d</em>/<em>e</em>)<sup>+</sup>       </td>      </tr>      <tr>       <td style="text-align:left;">        <em>Q</em>        <sub>11</sub> = ((<em>a</em>/<em>b</em>)/(<em>c</em>|<em>d</em>)<sup>*</sup>)<sup>+</sup>/(<em>e</em>|<em>f</em>)<sup>*</sup>       </td>       <td style="text-align:left;">        <em>Q</em>        <sub>12</sub> = (<em>a</em>|<em>b</em>)<sup>+</sup>/(<em>c</em>|<em>d</em>)<sup>+</sup>       </td>      </tr>     </tbody>     </table>    </div>    <p>Fig.&#x00A0;2(a) shows the average query response times of the above 12 queries over LUBM100, LUBM200, and DBpedia. It can be observed that <tt>P3RPQ<sub>      <em>opt</em>     </sub>     </tt> outperforms <tt>P3RPQ</tt> for all queries. We used LUBM100 and DBpedia as datasets, with 4 queries (<em>Q</em>     <sub>2</sub>, <em>Q</em>     <sub>4</sub>, <em>Q</em>     <sub>5</sub>, and <em>Q</em>     <sub>11</sub>) randomly selected from Table.&#x00A0;<a class="tbl" href="#tab1">1</a> to evaluate the scalability, as shown in Fig.&#x00A0;2(b) . Moreover, we generated RDF graphs w.r.t. the data model of WatDiv by constructing some vertices with <em>m</em> incoming and <em>n</em> outgoing edges, and designed the query <em>Q<sub>c</sub>     </em> = <em>a</em>     <sub>1</sub>/&#x2026;/<em>a</em>     <sub>10</sub>. In Fig.&#x00A0;2(c), we can observe that <tt>P3RPQ</tt> and <tt>P3RPQ<sub>      <em>opt</em>     </sub>     </tt> cannot finish within the time limit (10<sup>4</sup>s), whereas <tt>P3RPQ<sub>      <em>cnt</em>     </sub>     </tt> can return the answers in 78.39s and 377.56s, over the RDF graphs consisting of 1 million and 10 million triples, respectively. <figure id="fig2">     <img src="../../../data/deliveryimages.acm.org/10.1145/3190000/3186908/images/www18companion-148-fig2.jpg" class="img-responsive" alt="Figure 2"       longdesc=""/>     <div class="figure-caption">      <span class="figure-number">Figure 2:</span>      <span class="figure-title">       <strong>Experimental results</strong>      </span>     </div>     </figure>    </p>   </section>   <section id="sec-8">    <header>     <div class="title-info">     <h2>      <span class="section-number">4</span> CONCLUSION</h2>     </div>    </header>    <p>In this paper, we propose a novel method for answering RPQs with provenance-aware semantics over large RDF graphs using the Pregel parallel graph model. We devise four optimization techniques, which can reduce the query time dramatically and partly overcome the counting paths problem. Extensive experiments were conducted on both synthetic and real-world datasets, which have verified the effectiveness and efficiency of our proposed method.</p>   </section>  </section>  <section class="back-matter">   <section id="sec-9">    <header>     <div class="title-info">     <h2>ACKNOWLEDGMENTS</h2>     </div>    </header>    <p>This work is supported by the National Natural Science Foundation of China (61572353) and the Natural Science Foundation of Tianjin (17JCYBJC15400).</p>   </section>   <section id="ref-001">    <header>     <div class="title-info">     <h2 class="page-brake-head">REFERENCES</h2>     </div>    </header>    <ul class="bibUl">     <li id="BibPLXBIB0001" label="[1]">Saumen Dey, V&#x00ED;ctor Cuevas-Vicentt&#x00ED;n, Sven K&#x00F6;hler, Eric Gribkoff, and Michael Wang. 2013. On implementing provenance-aware regular path queries with relational query engines. In <em>      <em>Proceedings of EDBT/ICDT</em>     </em>. ACM, 214&#x2013;223.</li>     <li id="BibPLXBIB0002" label="[2]">Grzegorz Malewicz, Matthew&#x00A0;H Austern, Aart&#x00A0;JC Bik, James&#x00A0;C Dehnert, Ilan Horn, Naty Leiser, and Grzegorz Czajkowski. 2010. Pregel: a system for large-scale graph processing. In <em>      <em>Proceedings of SIGMOD</em>     </em>. ACM, 135&#x2013;146.</li>     <li id="BibPLXBIB0003" label="[3]">Xin Wang, Jun Ling, Junhu Wang, Kewen Wang, and Zhiyong Feng. 2014. Answering provenance-aware regular path queries on rdf graphs using an automata-based algorithm. In <em>      <em>Proceedings of WWW</em>     </em>. ACM, 395&#x2013;396.</li>    </ul>   </section>  </section>  <section id="foot-001" class="footnote">   <header>    <div class="title-info">     <h2>FOOTNOTE</h2>    </div>   </header>   <p id="fn1"><a href="#foot-fn1"><sup>&#x204E;</sup></a>Xin Wang is the corresponding author.</p>   <div class="bibStrip">    <p>This paper is published under the Creative Commons Attribution 4.0 International (CC-BY&#x00A0;4.0) license. Authors reserve their rights to disseminate the work on their personal and corporate Web sites with the appropriate attribution.</p>    <p>     <em>WWW '18, April 23-27, 2018, Lyon, France</em>    </p>    <p>&#x00A9; 2018; IW3C2 (International World Wide Web Conference Committee), published under Creative Commons CC-BY&#x00A0;4.0 License. ACM ISBN 978-1-4503-5640-4/18/04.<br/>DOI: <a class="link-inline force-break" target="_blank"     href="https://doi.org/10.1145/3184558.3186908">https://doi.org/10.1145/3184558.3186908</a>    </p>   </div>  </section>  <div class="pubHistory">   <p/>  </div>  </body> </html> 
