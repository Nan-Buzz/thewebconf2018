<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.7.16" />
  <title>GraphChain – A Distributed Database with Explicit Semantics and Chained RDF Graphs⁎⁎Operational Programme Smart Growth, project number 01.01.01-00-0982/16 funded by the National Centre for Research and Development</title><!-- Copyright (c) 2010-2015 The MathJax Consortium -->
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width; initial-scale=1.0;" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="screen, print" rel="stylesheet" href="../../../data/dl.acm.org/pubs/lib/css/bootstrap.min.css" />
  <link media="screen, print" rel="stylesheet" href="../../../data/dl.acm.org/pubs/lib/css/bootstrap-theme.min.css" />
  <link media="screen, print" rel="stylesheet" href="../../../data/dl.acm.org/pubs/lib/css/main.css" />
  <script src="../../../data/dl.acm.org/pubs/lib/js/jquery.min.js" type="text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/bootstrap.min.js" type="text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/bibCit.js" type="text/javascript"></script>
  <script src="../../../data/dl.acm.org/pubs/lib/js/divTab.js" type="text/javascript"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>
  <script type="text/x-mathjax-config">
  <![CDATA[
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  ]]>
  </script>
<link rel="cite-as" href="https://doi.org/10.1145/3184558.3191554"/></head>
<body id="main">
<div>
<p style='font-size: 75%; color #444'>
This is a web copy of <a href='https://doi.org/10.1145/3184558.3191554'>https://doi.org/10.1145/3184558.3191554</a>.
 Published in WWW2018 Proceedings © 2018 International World Wide Web Conference Committee, published under 
 <a rel='license' property='license' href='https://creativecommons.org/licenses/by/4.0/'>
 Creative Commons CC By 4.0 License</a>.
The <a href='https://github.com/usable-oa/thewebconf2018/tree/master/scripts'>modifications</a> 
from the original are solely to improve HTML aiming to make it Findable, Accessible, Interoperable and Reusable. 
augmenting HTML metadata and avoiding ACM trademark.
To reference this HTML version, use:
</p><p>
<strong>Permalink:</strong>
<a href='https://w3id.org/oa/10.1145/3184558.3191554'>https://w3id.org/oa/10.1145/3184558.3191554</a>
</p></div>
<hr>


  <section class="front-matter">
    <section>
      <header class="title-info">
        <div class="journal-title">
          <h1><span class="title">GraphChain – A Distributed Database with Explicit Semantics and Chained RDF Graphs<a class="fn" href="#fn1" id="foot-fn1"><sup>⁎</sup></a></span><br />
          <span class="subTitle"></span></h1>
        </div>
      </header>
      <div class="authorGroup">
        <div class="author">
          <span class="givenName">Mirek</span> <span class="surName">Sopek</span>, MakoLab S.A., ul. Demokratyczna 46 Łódź, Poland 93-430, <a href="mailto:sopek@makolab.com">sopek@makolab.com</a>
        </div>
        <div class="author">
          <span class="givenName">Przemysław</span> <span class="surName">Grądzki</span>, R&amp;D Team, DC Lublin MakoLab S.A., Lublin, Poland, <a href="mailto:przemyslaw.gradzki@makolab.com">przemyslaw.gradzki@makolab.com</a>
        </div>
        <div class="author">
          <span class="givenName">Witold</span> <span class="surName">Kosowski</span>, R&amp;D Team, MakoLab S.A., Łódź, Poland, <a href="mailto:witold.kosowski@makolab.com">witold.kosowski@makolab.com</a>
        </div>
        <div class="author">
          <span class="givenName">Dominik</span> <span class="surName">Kuziński</span>, R&amp;D Team, MakoLab S.A., Łódź, Poland, <a href="mailto:dominik.kuzinski@makolab.com">dominik.kuzinski@makolab.com</a>
        </div>
        <div class="author">
          <span class="givenName">Rafał</span> <span class="surName">Trójczak</span>, R&amp;D Team, DC Lublin MakoLab S.A., Lublin, Poland, <a href="mailto:rafal.trojczak@makolab.com">rafal.trojczak@makolab.com</a>
        </div>
        <div class="author">
          <span class="givenName">Robert</span> <span class="surName">Trypuz</span>, R&amp;D Team, DC Lublin MakoLab S.A., Faculty of Philosophy KUL, Lublin, Poland 20-950, <a href="mailto:robert.trypuz@makolab.com">robert.trypuz@makolab.com</a>
        </div>
      </div><br />
      <div class="pubInfo">
        <p>DOI: <a href="https://doi.org/10.1145/3184558.3191554" target="_blank">https://doi.org/10.1145/3184558.3191554</a><br />
        WWW '18: <a href="https://doi.org/10.1145/3184558" target="_blank">Proceedings of The Web Conference 2018</a>, Lyon, France, April 2018</p>
      </div>
      <div class="abstract">
        <p><small>In this paper we present a new idea of creating a Blockchain compliant distributed database which exposes its data with explicit semantics, is easily and natively accessible, and which applies Blockchain securitization mechanisms to the RDF graph data model directly, without additional packaging or specific serialisation. Essentially, the resulting database forms the linked chain of named RDF graphs and is given a name: GraphChain. Such graphs can then be published with the help of any standard mechanisms using triplestores or as linked data objects accessible via standard web mechanisms using the HTTP protocol to make them available on the web. They can also be easily queried using techniques like SPARQL or methods typical to available RDF graphs frameworks (like rdflib, Apache Jena, RDF4J, OWL API, RDF HDT, dotnetRDF and others). The GraphChain concept comes with its own, OWL-compliant ontology that defines all the structural, invariant elements of the GraphChain and defines their basic semantics. The paper describes also a few simple, prototypical GraphChain implementations with examples created using Java, .NET/C# and JavaScript/Node.js frameworks.</small></p>
      </div>
      <div class="CCSconcepts">
        <p><small><span style="font-weight:bold;">CCS Concepts:</span> • <strong>Computer systems organization</strong> → <strong>Distributed architectures;</strong> • <strong>Information systems</strong> → <strong>Resource Description Framework (RDF);</strong> <strong>Web Ontology Language (OWL);</strong></small></p>
      </div>
      <div class="classifications">
        <div class="author">
          <span style="font-weight:bold;"><small>Keywords:</small></span> <span class="keyword"><small>distributed database; semantic blockchain; GraphChain; linked data</small></span>
        </div><br />
        <div class="AcmReferenceFormat">
          <p><small><span style="font-weight:bold;">ACM Reference Format:</span><br />
          Mirek Sopek, Przemysław Grądzki, Witold Kosowski, Dominik Kuziński, Rafał Trójczak, and Robert Trypuz. 2018. GraphChain – A Distributed Database with Explicit Semantics and Chained RDF Graphs. In <em>WWW '18 Companion: The 2018 Web Conference Companion,</em> <em>April 23–27, 2018,</em> <em>Lyon, France. ACM, New York, NY, USA</em> 8 Pages. <a href="https://doi.org/10.1145/3184558.3191554" class="link-inline force-break" target="_blank">https://doi.org/10.1145/3184558.3191554</a></small></p>
        </div>
      </div>
    </section>
  </section>
  <section class="body">
    <section id="sec-7">
      <header>
        <div class="title-info">
          <h2><span class="section-number">1</span> Introduction</h2>
        </div>
      </header>
      <p>There is no doubt that the rise of the Blockchain technology changed the way in which modern distributed databases are designed and implemented. Blockchain offers several important benefits over traditional distributed database models. The most important are cryptographically guaranteed immutability and persistence of data stored on Blockchain accompanied by total decentralisation of the database management [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0025">25</a>]. However, almost all existing implementation of Blockchain have used simplified data structures on top of which cryptographic algorithms are implemented. In practice, developers who wanted to store structured data on the Blockchain were required to pack or embed their data into blocks. Depending on the specific implementation, the blocks were binary or could use serialised string data. In some other Blockchain implementations, the block data structure is quite complicated, yet it still cannot be efficiently used for structured data storage<a class="fn" href="#fn3" id="foot-fn3"><sup>1</sup></a>. For example, if a developer needed to store a tabular, tree-based or directed-graph data structure on Ethereum Blockchain he or she would typically serialise the structure into JSON object and embed it into Solidity scripts. While this is always possible, such strategy makes the embedded data hard to query: the objects need first to be extracted from blocks and then copied to a storage appropriate to their type. Only then the required query can be performed. Doing that across many, or sometimes all objects in a given domain, could require large scale extraction operation that would be very time consuming and inefficient.</p>
      <p>What is even more important, in many real-world applications, it is crucial to work directly with much more advanced data structures. For example, when Blockchain technology is to be used in digital identity applications, we need an efficient mechanism for rich representation of the identifiable object reference data to be present on the Blockchain <a class="fn" href="#fn4" id="foot-fn4"><sup>2</sup></a>. In another application, where Blockchain could be used for non-repudiatory storage of financial reports, it is desirable to store the reports right on the Blockchain. However, the limitations of the technology forced the early adopters of such processes to store on the Blockchain only the metadata about the reports, leaving the reports themselves outside the realm of the protected infrastructure<a class="fn" href="#fn5" id="foot-fn5"><sup>3</sup></a>.</p>
      <p>In the project initiated by the authors of this paper, we are building Blockchain based infrastructure for the Legal Entity Identifier (LEI) system. Initially, we built two Proof-of-Concepts using a private Ethereum Blockchain<a class="fn" href="#fn6" id="foot-fn6"><sup>4</sup></a>. While we proved the feasibility of the approach, we also discovered important shortcomings related to the use of such kind of blockchains for large set of structured data used today by systems like the global LEI system: the first one was related to the inability to query the ?blockchained? set efficiently, while the second was related to the complicated addressing scheme which made the retrieval of reference data difficult and inefficient.</p>
      <p>These findings led us to the idea of creating an entirely new solution where the fundamental underlying data model is the collection of linked named RDF Graphs. The Blockchain mechanisms such as data hashing, signatures, linking of graphs, distributed data replication (in analogy to blocks linking on the standard Blockchain) and achieving consensus are then implemented ?on top? of the stored graphs in multiple ?sites? forming the distributed database of chained RDF named graphs. The fundamental benefit of this approach is that on each site its users can work with the chained named graphs using methods that are fully developed and widely used today: SPARQL for quering, Linked Data mechanisms for accessing the nodes of the graphs, frameworks like Jena for arbitrary operations, reasoning using ontologies and so on.</p>
      <p>We named this solution GraphChain.</p>
      <p>For the current use case (the proposed infrastructure of the global LEI system<a class="fn" href="#fn7" id="foot-fn7"><sup>5</sup></a> the proposed solution will form a private, ”permissioned” system with Proof-of-Authority as the consensus mechanism, allowing, among other things, for unlimited querying over the entire the LEI system reference data set.</p>
      <p>However, as the focus of this paper is solely on the underlying data model of the system, we deliberately left the important considerations of the consensus mechanism for the future publications on the Graphchain.</p>
    </section>
    <section id="sec-8">
      <header>
        <div class="title-info">
          <h2><span class="section-number">2</span> The GraphChain definition</h2>
        </div>
      </header>
      <p>Let us start with introducing a few definitions related to the RDF graphs.</p>
      <p>An <em>RDF triple</em><a class="fn" href="#fn8" id="foot-fn8"><sup>6</sup></a> contains three components: <em>the subject</em>, which is an RDF URI reference or a blank node, <em>the predicate</em>, which is an RDF URI reference and <em>the object</em>, which is an RDF URI reference, a literal or a blank node. An <em>RDF graph</em> is an unordered set of RDF triples and a <em>named RDF graph</em> is an RDF graph which is assigned a name in the form of a URI [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0005">5</a>].</p>
      <p>The main idea behind GraphChain is to use Blockchain mechanisms on top of an abstract RDF graph data type. Following the general definition of the abstract data type (ADT) [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0006">6</a>], we define the abstract RDF graph data type by its behaviour in computer systems, the set of possible values and the operations permitted on these values. Such an approach allows us to create a Blockchain-compliant system on top of <em>any</em> concrete data structure used to represent and expose the graph. In general GraphChain does not assume any specific serialisation of the RDF graph (like RDF/XML, Turtle or JSON-LD) nor a mechanism for storage (triple store, files, memory) or exposing the graph (HTTP, file read etc). GraphChain is thus defined as:</p>
      <ol class="list-no-style">
        <li id="list1" label="(1)">A linked chain of named RDF graphs specified by the Graph-Chain ontology.<br /></li>
        <li id="list2" label="(2)">A set of general mechanisms for calculating a digest of the named RDF graph.<br /></li>
        <li id="list3" label="(3)">A set of network mechanisms that are responsible for the distribution of the named RDF graphs among the distributed peers.<br /></li>
      </ol>
      <p>The following two definitions make the idea of GraphChain more precise:</p>
      <p></p>
      <div class="definition" id="enc1">
        <label>Definition 2.1 (Linked chain of named RDF graphs).</label>
        <p>A linked chain of named RDF graphs is a linearly ordered collection (a chain) of cryptographically secured named RDF graphs. The collection is ordered by a functional relation pointing to the previous graph in the chain. With exception to the first graph in the chain, the relation is asymmetric and irreflexive.</p>
      </div>
      <p></p>
      <p></p>
      <div class="definition" id="enc2">
        <label>Definition 2.2 (GraphChain).</label>
        <p>A linked chain of named RDF graphs starting from the first graph called genesis unit<a class="fn" href="#fn9" id="foot-fn9"><sup>7</sup></a> is called the Graph-Chain. The GraphChain acts as a consistent named graphs history on which all nodes eventually agree<a class="fn" href="#fn10" id="foot-fn10"><sup>8</sup></a>.</p>
      </div>
      <p></p>
    </section>
    <section id="sec-9">
      <header>
        <div class="title-info">
          <h2><span class="section-number">3</span> The GraphChain architecture</h2>
        </div>
      </header>
      <p>A single node consists of several parts: a web interface for communication with clients (via the HTTP protocol), a web socket endpoint for communication with others nodes, a cryptography module for handling of digest calculation, a triple store repository manager for storing blocks as sets of triples and obtaining blocks from the repository, and services which bind all these parts together.</p>
      <p>In figure <a class="fig" href="#fig1">1</a> a diagram presenting nodes interaction is depicted. Clients can connect to a node via HTTP and to a triple store via SPARQL over HTTP. The interaction with the node itself enables a client to create new blocks (a process of block creation is explained below), add new peers, and retrieve block meta-information. Interaction with the triple store enables reading data from it with the usage of the SPARQL query language. Interaction among nodes is implemented by means of the web sockets protocol. Nodes can interact with their triple stores by various ways. These ways can be determined for example on the basis of required performance. For now we use SPARQL over HTTP.</p>
      <figure id="fig1">
        <img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191554/images/www18companion-293-fig1.jpg" class="img-responsive" alt="Figure 1" longdesc="" />
        <div class="figure-caption">
          <span class="figure-number">Figure 1:</span> <span class="figure-title">Nodes interaction.</span>
        </div>
      </figure>
      <p></p>
      <p>The block creation process begins with an HTTP request from the client. The HTTP request contains a serialised RDF graph (see figure <a class="fig" href="#fig2">2</a>). For now, we assume that this graph is serialised in the Turtle format, but it should be fairly easy to extend the application so that it would accept other types of serialisation formats. A sample HTTP request is presented in the listing 1 . For now we have not decided to limit the size of the input RDF graph, but we will do that in the future works.</p>
      <p><img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191554/images/www18companion-293-img1.svg" class="img-responsive" alt="" longdesc="" /></p>
      <p>After the application receives the graph, it is deserialised and its hash is calculated with one of the methods we will discuss in section <a class="sec" href="#sec-13">4.3</a>. Then a hash of a string being the concatenation of the following elements: a new block index, a previous block IRI, a previous hash, a current time stamp, a received graph IRI, and the aforementioned graph hash, is computed. The hash is considered to be the hash of the block.</p>
      <p>After the hash for the new block is calculated, a new block object is created. It consists of the counterpart Blockchain's header and content (see section <a class="sec" href="#sec-17">5</a>). The block is then serialised as two sets of triples: one for the header and one for the content. The first set of triples is stored in a <em>graph ledger</em> (which is a named graph in a repository) and the second one as a separate named graph. Finally, information about the change is broadcast to the other nodes.</p>
      <figure id="fig2">
        <img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191554/images/www18companion-293-fig2.jpg" class="img-responsive" alt="Figure 2" longdesc="" />
        <div class="figure-caption">
          <span class="figure-number">Figure 2:</span> <span class="figure-title">Block creation.</span>
        </div>
      </figure>
      <p></p>
    </section>
    <section id="sec-10">
      <header>
        <div class="title-info">
          <h2><span class="section-number">4</span> The GraphChain implementation challenges</h2>
        </div>
      </header>
      <p>The implementation of GraphChain as defined and presented in this paper brings a number of challenges that should be addressed before a fully functional, production-grade alternative to the existing Blockchain implementation is offered. These challenges are: 1) Performance of the programmatic access to RDF graphs; 2) Performance and quality of the RDF graphs serialisation used for broadcasting the named graphs to other nodes; 3) Computation of the RDF digests.</p>
      <section id="sec-11">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.1</span> Performance of the programmatic access to the RDF Graphs</h3>
          </div>
        </header>
        <p>While client access to the graphs forming the GraphChain can be realized efficiently using the existing access methods (in most cases using SPARQL), this method may be inefficient for the operations required by the Distributed Ledger Applications. Efficient serialisation mechanisms ? important for the broadcasting mechanisms, and fast computation of digests (both issues are addressed below) require as the first pre-requisite, an extremely fast access to ?atomic? elements of the graphs, i.e. to triples. While we are not yet presenting in this paper a detailed analysis and comparison between different access methods<a class="fn" href="#fn11" id="foot-fn11"><sup>9</sup></a>, we assume that in the production grade realisation, the memory-based representations of the RDF graphs shall be used allowing for direct addressing of the individual triples without the overhead of the SPARQL query engines. The detailed analysis of this aspect of the Graphchain implementation will be the subject of our near future studies.</p>
      </section>
      <section id="sec-12">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.2</span> Performance of RDF graphs serialisations</h3>
          </div>
        </header>
        <p>An efficient broadcasting mechanism needed for the functioning of the Graphchain requires the RDF graphs to be efficiently serialised, broadcasted to the other nodes and then de-serialised to form the internal representation of the graph at all network nodes. We are fully convinced that the best method to achieve high performance serialisation is offered by the HDT serialisation method<a class="fn" href="#fn12" id="foot-fn12"><sup>10</sup></a>. However, in the current initial implementations of the GraphChain presented in this paper, we used JSON-LD and Turtle serialisations. It will be replaced by the HDT method in the next steps of the project.</p>
      </section>
      <section id="sec-13">
        <header>
          <div class="title-info">
            <h3><span class="section-number">4.3</span> Computation of RDF digests</h3>
          </div>
        </header>
        <p>Computation of the RDF digest is absolutely essential to the implementation of distributed ledger technology on top of the RDF Graphs. The RDF data model is dramatically different from the block data models used by standard Blockchain implementations and what is needed is cryptographically safe and repeatable computation of the RDF digests.</p>
        <p>In [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0009">9</a>] the following issues important for computation of the RDF digests have been listed:</p>
        <ol class="list-no-style">
          <li id="list4" label="(1)">Blank nodes? identifiers are implementation dependent, i.e. they may change while transferring the same graph between different implementations, triple stores or other methods of their instantiation.<br /></li>
          <li id="list5" label="(2)">Every RDF graph is equivalent to an unordered set of triples; so the one and the same graph, even in the same syntax, can be serialised in many different ways.<br /></li>
          <li id="list6" label="(3)">RDF graph serialisation can be differently encoded; hashing functions are encoding sensitive.<br /></li>
        </ol>
        <p>Many attempts have been undertaken in order to find a complete and correct RDF graph hashing algorithm. The history of the attempts is described e.g. in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0009">9</a>, section 2] and recently in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0011">11</a>, section 7] where the following works are mentioned: [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0001">1</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0004">4</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0005">5</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0008">8</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0009">9</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0010">10</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0012">12</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0013">13</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0019">19</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0023">23</a>].</p>
        <p>For this work we have considered three algorithms suitable for the computation of the graph digest:</p>
        <ol class="list-no-style">
          <li id="list7" label="(1)">?Canonicalization? — calculation of the digest as the hash of the canonical graph serialisation<br /></li>
          <li id="list8" label="(2)">?DotHash? — calculation of the digest as the result of the combining operation on the hashes of the individual triples<br /></li>
          <li id="list9" label="(3)">?Interwoven DotHash? — calculation of the digest as as the result of the combining operation on the hashes of the individual triples and the triples linked by blank nodes.<br /></li>
        </ol>
        <p>These algorithms differ in the definition of the block of data submitted to the cryptographic hash function. As the hashing function we used SHA-256 in all of the algorithms.</p>
        <section id="sec-14">
          <p><em>4.3.1 Canonicalization.</em> This approach represents the most straightforward way in which the digest of the RDF graph can be computed. It is based on the normalised RDF serialisation proposed as the Draft Report of ”JSON for Linking Data” W3C Community Group in October 2017<a class="fn" href="#fn13" id="foot-fn13"><sup>11</sup></a>. The normalisation algorithm produces a representation of the RDF dataset (collection of the named RDF graphs) with well defined order and with blank nodes represented by canonical identifiers. The normalisation process is designed in such a way, that it should return exactly the same textual representation for the equivalent RDF graphs. In the exemplary implementations described in this paper we used JSON-LD for the normalised graph.</p>
        </section>
        <section id="sec-15">
          <p><em>4.3.2 DotHash.</em> The approach to the calculations of RDF Graph digest, named for the purpose of this paper ?DotHash? was first presented in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0018">18</a>]. The approach defines the digest of the graph as the result of the combining operation on the hashes of all triples of the graph:</p>
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\begin{equation*} \mathcal {D}(S) = \bigodot _{i=1}^{N}h(serialisation(t_i))\end{equation*}</span><br />
            </div>
          </div>
          <p></p>
          <p>The combining operation is associative and commutative and allows for the implementation of ?incremental cryptography?, where the computation of the digest of the graph created by addition of new triples can be done by combining the digest of original graph and the digest of the added triples. Following the analysis by the authors of the approach, the optimal (offering a good compromise between speed and security) approach is based on the ?AdHash? algorithm [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0003">3</a>] and defines the combining operation as a modulo operation with a suitably large value of the divisor.</p>
          <p>The incrementality of the calculations is extremely attractive for the GraphChain as it allows for very efficient implementation in situations permitting new triples to be added to existing graphs in the chain with very low computational overhead. In addition to that, the method allows for highly efficient parallelization even on commodity hardware. However, the method requires a very specific and non-generic approach when the graph contains blank nodes. The authors proposed a method where the blank nodes are labelled on the source side using statements like:</p>
          <div class="table-responsive">
            <div class="display-equation">
              <span class="tex mytex">\begin{equation*} \lbrace \_b \mbox{ hasLabel } L.\rbrace \end{equation*}</span><br />
            </div>
          </div>
          <p></p>
          <p>And these labels are then used on the destination side to rename the blank nodes so that they are identical as on the source side. Of course, then, the calculation of digests on both side will result in the same digests for both graphs. While this approach is practical, we did not find it generic enough and proposed the modified DotHash approach.</p>
        </section>
        <section id="sec-16">
          <p><em>4.3.3 Interwoven DotHash.</em> The principle feature of the ?Interwoven DotHash? method is its ability to compute the graph digest without canonicalization of the entire graph nor the use of additional triples with labels.</p>
          <p>The method we propose ignores the actual format of the blank nodes for the computation of digests while securing the essential effect of the blank nodes: their ability to weave multiple triples together.</p>
          <p>As before, we assume that the digest of the entire graph is computed as the combining operation that is associative, commutative and supporting incremental computations of the digest over the graph. Similarly, in the most optimal realisation, the combining operation can be implemented as a modulo (with a sufficiently large divisor) of the hashes of the triples. The hash of the triple can be computed over the entire serialised triple, or as a combination of hashes of the ?atomic? nodes of the triple, i.e. the subject, the predicate and the object. This later method allows, in principle, for the use of the alternative fast hash computations for the subject and predicate nodes, as they represent a specific sets of strings from a limited space of values (characteristic for URIs).</p>
          <p>Because the blank nodes are anonymous, their actual form and names do not matter. What does matter is the weaving of the triples together into specific constructs used in RDF files (lists, sequences etc).</p>
          <p>Exploring these features further we propose the following algorithm for the triple computation:</p>
          <ol class="list-no-style">
            <li id="list10" label="(1)">If the triple does not contain a blank node, compute it as a hash of its N3 serialised format.<br /></li>
            <li id="list11" label="(2)">If the triple contains a blank node as its Subject, then compute its hash as the sum of the hashes of the N3 serialised Predicate and Object and the hashes of non-blank nodes of all those triples where the blank node appears in the Object nodes.<br /></li>
            <li id="list12" label="(3)">If the triple contains a blank node as its Object, then compute its hash as the sum of the hashes of the N3 serialised Subject and Predicate and the hashes of non-blank nodes of all those triples where the blank node appears in the Subject nodes.<br /></li>
            <li id="list13" label="(4)">If the triple contains blank nodes in both Subject &amp; Object nodes, use the above rules twice, once for Subject, then for Objects.<br /></li>
          </ol>
          <p>Our algorithm has some similarity to the one proposed in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0010">10</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0011">11</a>]. The difference is in the way we compute the hashes on the level of the triple.</p>
          <p>The pseudo-code of the algorithm reads:</p>
          <p><img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191554/images/www18companion-293-img2.svg" class="img-responsive" alt="" longdesc="" /></p>
        </section>
      </section>
    </section>
    <section id="sec-17">
      <header>
        <div class="title-info">
          <h2><span class="section-number">5</span> GraphChain ontology</h2>
        </div>
      </header>
      <p>The GraphChain ontology<a class="fn" href="#fn14" id="foot-fn14"><sup>12</sup></a> is an (OWL) ontology of chained named RDF graphs resembling a sequentially ordered and cryptographically secured chain structure presented in the original paper [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0015">15</a>] by Nakamoto.</p>
      <p>From the ontological perspective GraphChain's block (unit) is a reified 7-ary relation (see [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0016">16</a>, Use Case 3]). In the reification pattern each <em>n</em>-ary relation between resources is represented as a separate OWL class and each instance of the relation—an <em>n</em>-tuple—is represented as an instance of the class plus <em>n</em> additional binary relations providing links to each argument of the <em>n</em>-tuple. The GraphChain's unit is composed of the elements that are listed in the lines 9-15 and 18-24 of listing 2 . Lines 8-15 and 17-24 present two instances of blocks <tt>gc:b0</tt> and <tt>gc:b1</tt> and seven triples the blocks are the subjects of. As one can observe GraphChain's unit has counterparts of the elements that normally constitute the Blockchain's block header. In our representation, for simplicity's sake, we have not made an explicit distinction between a block and its header.</p>
      <p>The GraphChain units are intended to “store” RDF triples. Strictly speaking, every block has a link to a named graph IRI and the hash of the graph.</p>
      <p>The genesis unit is hardcoded and contains the identifier of the GraphChain ontology and its hash. It means that the genesis unit of GraphChain contains information about its semantic structure.</p>
      <p><img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191554/images/www18companion-293-img3.svg" class="img-responsive" alt="" longdesc="" /></p>
      <p>GraphChain consists of 2 classes, 1 object property and 6 data properties. It has ALQ(D) expressivity and 11 restrictions on classes.</p>
    </section>
    <section id="sec-18">
      <header>
        <div class="title-info">
          <h2><span class="section-number">6</span> Exemplary implementations</h2>
        </div>
      </header>
      <p>We developed three implementations presenting the main features of the GraphChain idea.</p>
      <p>The C# implementation uses .NET Core platform for ease of deployment in multiple environments. The node itself is an ASP.NET Core web application with REST API for Client - Node communication and WebSocket layer for Peer to Peer transmission. It uses the DotHash algorithm for graph digests. Graph data itself is transferred through websockets in string form as Turtle serialisation encoded in Base64. Local data repository can be either in-memory-store or a dedicated triplestore (e.g. AllegroGraph). The library used as middleware for graph and triples operations is DotNetRdf.</p>
      <p>The Java implementation was created as a Spring-managed web application. It uses the RDF4J library for handling semantic-related operations. Currently, this implementation can store RDF graphs in both the RDF4J triple store and the AllegroGraph triple store, but adding a new storage method is possible. Similarly to the C# implementation, the Java implementation uses the DotHash algorithm for graph digests, but it can also use the Canonicalization method for that purpose.</p>
      <p>We have also developed a third, illustrative implementation of the node: a JavaScript implementation which is based on Naivechain<a class="fn" href="#fn15" id="foot-fn15"><sup>13</sup></a>. It offers HTTP API (<a class="link-inline force-break" href="https://github.com/lhartikk/naivechain#http-api">https://github.com/lhartikk/naivechain#http-api</a>) and P2P communication between nodes (<a class="link-inline force-break" href="https://github.com/lhartikk/naivechain#key-concepts-of-naivechain">https://github.com/lhartikk/naivechain#key-concepts-of-naivechain</a>). There are a few differences between our implementation and Naivechain. Our implementation: 1) has different structure of the block: it contains RDF URI referring to graph data and hash of graph data; 2) stores data in dedicated triple store (e.g RDF4J) instead of memory store; 3) includes transferring graph data (referred by IRI) in the process of replication between nodes.</p>
      <p>In all reported cases, we used LEI reference data represented as named RDF graphs to test the operations of the Graphchain. We were able, on all participating nodes, to use SPARQL queries on the entire chain of named graphs resulting in the same query results. Depending on the storage mechanism, we were also able to access the graphs with respective native access methods (e.g. iterating over graphs for in-memory storage models).</p>
      <p>In all these initial test implementations we intentionally set aside other important features of Blockchain, like the chain update strategy (e.g. LCR - the Longest Chain Rule) or consensus mechanism (e.g. Proof-of-Work or Proof-of-Authority). The motivation for that omission comes from the fact that the implementation of these features does not depend on the actual data model of the chain, because they form another layer of the Blockchain software stack. So implementing that in the initial work would complicate the implementation without benefits for the understanding of the role of the new graph-based data model for the technology.</p>
      <p>We have also created a very simple web interface for browsing the content of GraphChain using simple RESTful interface used in the aforementioned implementations<a class="fn" href="#fn16" id="foot-fn16"><sup>14</sup></a>. The web interface can be seen in figure <a class="fig" href="#fig3">3</a>.</p>
      <figure id="fig3">
        <img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191554/images/www18companion-293-fig3.jpg" class="img-responsive" alt="Figure 3" longdesc="" />
        <div class="figure-caption">
          <span class="figure-number">Figure 3:</span> <span class="figure-title">Web interface for browsing the content of GraphChain's graph ledger.</span>
        </div>
      </figure>
      <p></p>
      <p>It also allows for retrieving data from a graph ledger by means of SPARQL queries. Each node has its own SPARQL Endpoint. Below there are two exemplary queries<a class="fn" href="#fn17" id="foot-fn17"><sup>15</sup></a>:</p>
      <p><img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191554/images/www18companion-293-img4.svg" class="img-responsive" alt="" longdesc="" /></p>
      <p><img src="../../../data/deliveryimages.acm.org/10.1145/3200000/3191554/images/www18companion-293-img5.svg" class="img-responsive" alt="" longdesc="" /></p>
    </section>
    <section id="sec-19">
      <header>
        <div class="title-info">
          <h2><span class="section-number">7</span> Related Works</h2>
        </div>
      </header>
      <p>Many interesting ideas concerning how blockchain and Semantic Web technologies can be successively combined are discussed in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0007">7</a>]. In this section we shall focus on the main attempts that are aimed at creating a semantic Blockchain.</p>
      <p>BLONDiE is an ontology developed by Héctor Ugarte in the Semantic Blockchain project [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0024">24</a>]. The OWL ontology is available in GitHub repository: <a class="link-inline force-break" href="https://github.com/hedugaro/Blondie">https://github.com/hedugaro/Blondie</a>. It consists of 21 classes, 11 object properties, 50 data properties and 1 annotation property. It has ALCRIF(D) expressivity. We share the opinion expressed in [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0022">22</a>] that “BLONDiE is the most developed vocabulary for representing blockchain concepts, with the most potential to enable reusable modelling across different distributed ledgers in the future.” But BLONDiE as an ontology leaves much to be desired. It specifies the meaning of its classes and properties poorly. Except for disjointedness axioms it contains no other restrictions on classes (here we mean necessary and sufficient conditions). Object properties are characterised as functional, inverse functional, transitive, symmetric, asymmetric reflexive or irreflexive. Each object and data property has its domain and range. BLONDiE is missing some of the properties that are important and specific for our blockchain implementation, e.g. BLONDiE provides no references to the data graph IRI and the previous block IRI.</p>
      <p>EthOn is an ontology that is intended to be a semantical counterpart of the Ethereum Blockchain framework. It contains 46 classes, 48 object, 60 datatype properties and 3 annotation properties. Its documentation is here: <a class="link-inline force-break" href="http://ethon.consensys.net">http://ethon.consensys.net</a> and other resources are stored in GitHub: <a class="link-inline force-break" href="https://github.com/ConsenSys/EthOn">https://github.com/ConsenSys/EthOn</a>. EthOn supports multiple inheritance (e.g. <tt>Block</tt> is a child class of <tt>StateTransition</tt> and <tt>BlockConcept</tt>). EthOn has a few disjointedness axioms and 9 restrictions — 2 for <tt>Account</tt> class and 7 for subclasses of <tt>Msg</tt> class (involving 3 object properties: <tt>from</tt>, <tt>to</tt> and <tt>creates</tt>). Its potential has not been explored enough yet. For instance, more restrictions could be added to contribute more to the meaning of the EthOn classes, for instance, it could be made explicit (what is currently written only in the comments) that each <tt>AccountStorage</tt> is part of some <tt>AccountState</tt>, etc. EthOn taxonomy is not correct. It is common that the authors mix metalevel classes with the domain ones, e.g. <tt>Block</tt> is a subclass of <tt>BlockConcept</tt> meaning that each block is a block concept, and that is simply not true.</p>
      <p>Flex (Web) Ledger is a graph data model and a protocol for decentralized ledgers [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0014">14</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0020">20</a>, <a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0021">21</a>]. From the data model perspective, Flex Ledger assumes the use of generic JSON objects encapsulated in the ledger. But “The ledger data model and syntax make no assumption about which ontology is used.” [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0014">14</a>, p.1441]. So Flex Ledger does not have its own ontology and each concrete implementation of the ledger requires additional specification on the level of data structure and meaning. It is also worth mentioning that the Flex Ledger meta and the content data are stored together in the same graph whereas the GraphChain blocks’ content is store outside the block in a separate graph. For all the reasons stated above, GraphChain cannot be considered as an implementation of Flex Ledger.</p>
      <p>There is another very important related development that parallels GraphChain although from a different perspective than Semantic Web: MongoDB has recently announced the creation of Blockchain infrastructure combined with the existing MongoDB database. The similarity to our approach comes from the fact that Blockchain layer in the proposal does not change the native mechanisms to access data stored on MongoDB database, as is GraphChain not changing the access mechanisms native to RDF databases<a class="fn" href="#fn18" id="foot-fn18"><sup>16</sup></a>.</p>
    </section>
    <section id="sec-20">
      <header>
        <div class="title-info">
          <h2><span class="section-number">8</span> Concluding Remarks</h2>
        </div>
      </header>
      <p>In this paper, we have proposed a new approach to the architecture of a Blockchain compliant system, where the fundamental data structure is based on RDF graphs and where semantic technologies, including OWL ontologies and Linked Data principles form the foundations of its architecture. The emerging new Blockchain platform is called GraphChain.</p>
      <p>GraphChain is defined on the level of the abstract RDF data model. Such high level definition opens the possibility for its implementation as a software layer independent of the actual implementation of RDF data storage, querying mechanisms or serialisations. It also guarantees that all access methods characteristic for the given data storage remain unchanged, making the data fully available and open. We have demonstrated that the key elements of distributed ledger technology, as are usually implemented in Blockchain, can be implemented in GraphChain. In particular, serialisations required for broadcasting a graph into the network and computation of the graph digest can be implemented without compromising generality of the approach.</p>
      <p>The key element of the GraphChain is its ontology. It is in this part of the proposal where we define, also on the high level of abstraction, how the specific elements of Blockchain technology are to be implemented in the GraphChain Ledger. This ontological aspect of the emerging platform, combined with ontologies for data stored in the chain of named graphs, create a system that is fully compliant with semantic technologies and exhibits all the benefits of Distributed Ledger Technologies as implemented in a standard Blockchain.</p>
      <p>We are also reporting here three simple implementations of the GraphChain using Java, .NET and node.js technologies. The implementations were, by design, extremely simple and were only used for the verification of GraphChain's foundational features.</p>
      <p>The work is now in progress to use qualified open source Blockchain platform and create a production grade GraphChain implementation. Looking toward the production grade GraphChain, we are also exploring the possibilities for high-speed transactions on GraphChain. This is possible due to high level of parallelisation possible for the key elements of the future solutions.</p>
      <p>The production grade editions of the GraphChain will first be used for the creation of distributed ledger editions of the digital identity applications for Legal Entity Identifier (LEI) system related to the LEI.INFO initiative (<a class="link-inline force-break" href="http://lei.info">http://lei.info</a>), in its strife to create radically new foundations of the global LEI system.</p>
    </section>
  </section>
  <section class="back-matter">
    <section id="ref-001">
      <header>
        <div class="title-info">
          <h2 class="page-brake-head">REFERENCES</h2>
        </div>
      </header>
      <ul class="bibUl">
        <li id="BibPLXBIB0001" label="[1]">Jesús Arias-Fisteus, Norberto&nbsp;Fernández García, Luis&nbsp;Sánchez Fernández, and Carlos&nbsp;Delgado Kloos. 2010. Hashing and canonicalizing Notation 3 graphs. <em><em>J. Comput. Syst. Sci.</em></em> 76, 7 (2010), 663–685. <a class="link-inline force-break" href="https://doi.org/10.1016/j.jcss.2010.01.003" target="_blank">https://doi.org/10.1016/j.jcss.2010.01.003</a>
        </li>
        <li id="BibPLXBIB0002" label="[2]">Rick Barrett, Rick Cummings, Eugene Agichtein, and Evgeniy Gabrilovich (Eds.). 2017. <em><em>Proceedings of the 26th International Conference on World Wide Web Companion, Perth, Australia, April 3-7, 2017</em></em> . ACM. <a class="link-inline force-break" href="http://dl.acm.org/citation.cfm?id=3041021" target="_blank">http://dl.acm.org/citation.cfm?id=3041021</a>
        </li>
        <li id="BibPLXBIB0003" label="[3]">Mihir Bellare and Daniele Micciancio. 1997. A New Paradigm for Collision-Free Hashing: Incrementality at Reduced Cost. In <em><em>Advances in Cryptology - EUROCRYPT ’97, International Conference on the Theory and Application of Cryptographic Techniques, Konstanz, Germany, May 11-15, 1997, Proceeding</em></em> (<em>Lecture Notes in Computer Science</em>), Walter Fumy (Ed.). Vol.&nbsp; 1233. Springer, 163–192. <a class="link-inline force-break" href="https://doi.org/10.1007/3-540-69053-0_13" target="_blank">https://doi.org/10.1007/3-540-69053-0_13</a>
        </li>
        <li id="BibPLXBIB0004" label="[4]">Jeremy&nbsp;J. Carroll. 2003. <em><em>Signing RDF Graphs</em></em> . Technical Report HPL-2003-142. Hewlett-Packard Labs.</li>
        <li id="BibPLXBIB0005" label="[5]">Jeremy&nbsp;J. Carroll, Christian Bizer, Pat Hayes, and Patrick Stickler. 2005. Named graphs, provenance and trust. In <em><em>WWW ’05: Proceedings of the 14th international conference on World Wide Web</em></em> . ACM, New York, NY, USA, 613–622. <a class="link-inline force-break" href="https://doi.org/10.1145/1060745.1060835" target="_blank">https://doi.org/10.1145/1060745.1060835</a>
        </li>
        <li id="BibPLXBIB0006" label="[6]">Nell Dale and Henry&nbsp;M. Walker. 1996. <em><em>Abstract data types: specifications, implementations, and applications</em></em> . Jones &amp; Bartlett Learning.</li>
        <li id="BibPLXBIB0007" label="[7]">M. English, S. Auer, and S.Domingue. 2016. Blockchain technologies &amp; the Semantic Web: A framework for symbiotic development. In <em><em>CS Conference for University of Bonn Students</em></em> , J.&nbsp;Lehmann, H.&nbsp;Thakkar, L.&nbsp;Halilaj, and R.&nbsp;Asmat (Eds.). 47–61.</li>
        <li id="BibPLXBIB0008" label="[8]">Mark Giereth. 2005. On Partial Encryption of RDF-Graphs. In <em><em>The Semantic Web - ISWC 2005, 4th International Semantic Web Conference, ISWC 2005, Galway, Ireland, November 6-10, 2005, Proceedings</em></em> (<em>Lecture Notes in Computer Science</em>), Yolanda Gil, Enrico Motta, V.&nbsp;Richard Benjamins, and Mark&nbsp;A. Musen (Eds.). Vol. 3729. Springer, 308–322. <a class="link-inline force-break" href="https://doi.org/10.1007/11574620_24" target="_blank">https://doi.org/10.1007/11574620_24</a>
        </li>
        <li id="BibPLXBIB0009" label="[9]">Edzard Höfig and Ina Schieferdecker. 2014. Hashing of RDF Graphs and a Solution to the Blank Node Problem. In <em><em>Proceedings of the 10th International Workshop on Uncertainty Reasoning for the Semantic Web (URSW 2014) co-located with the 13th International Semantic Web Conference (ISWC 2014), Riva del Garda, Italy, October 19, 2014.</em></em> (<em>CEUR Workshop Proceedings</em>), Fernando Bobillo, Rommel&nbsp;N. Carvalho, Davide Ceolin, Paulo Cesar&nbsp;G. da&nbsp;Costa, Claudia d'Amato, Nicola Fanizzi, Kathryn&nbsp;B. Laskey, Kenneth&nbsp;J. Laskey, Thomas Lukasiewicz, Trevor&nbsp;P. Martin, Matthias Nickles, Michael Pool, Tom&nbsp;De Nies, Olaf Hartig, Paul&nbsp;T. Groth, and Stephen Marsh (Eds.). Vol. 1259. CEUR-WS.org, 55–66. <a class="link-inline force-break" href="http://ceur-ws.org/Vol-1259/method2014_submission_1.pdf" target="_blank">http://ceur-ws.org/Vol-1259/method2014_submission_1.pdf</a>
        </li>
        <li id="BibPLXBIB0010" label="[10]">Aidan Hogan. 2015. Skolemising Blank Nodes while Preserving Isomorphism. In <em><em>Proceedings of the 24th International Conference on World Wide Web, WWW 2015, Florence, Italy, May 18-22, 2015</em></em> , Aldo Gangemi, Stefano Leonardi, and Alessandro Panconesi (Eds.). ACM, 430–440. <a class="link-inline force-break" href="https://doi.org/10.1145/2736277.2741653" target="_blank">https://doi.org/10.1145/2736277.2741653</a>
        </li>
        <li id="BibPLXBIB0011" label="[11]">Aidan Hogan. 2017. Canonical Forms for Isomorphic and Equivalent RDF Graphs: Algorithms for Leaning and Labelling Blank Nodes. <em><em>ACM Trans. Web</em></em> 11, 4, Article 22 (July 2017), 62&nbsp;pages. <a class="link-inline force-break" href="https://doi.org/10.1145/3068333" target="_blank">https://doi.org/10.1145/3068333</a>
        </li>
        <li id="BibPLXBIB0012" label="[12]">Andreas Kasten, Ansgar Scherp, and Peter Schauß. 2014. A Framework for Iterative Signing of Graph Data on the Web, See [17], 146–160. <a class="link-inline force-break" href="https://doi.org/10.1007/978-3-319-07443-6_11" target="_blank">https://doi.org/10.1007/978-3-319-07443-6_11</a>
        </li>
        <li id="BibPLXBIB0013" label="[13]">Tobias Kuhn and Michel Dumontier. 2014. Trusty URIs: Verifiable, Immutable, and Permanent Digital Artifacts for Linked Data, See [17], 395–410. <a class="link-inline force-break" href="https://doi.org/10.1007/978-3-319-07443-6_27" target="_blank">https://doi.org/10.1007/978-3-319-07443-6_27</a>
        </li>
        <li id="BibPLXBIB0014" label="[14]">Victoria&nbsp;L. Lemieux and Manu Sporny. 2017. Preserving the Archival Bond in Distributed Ledgers: A Data Model and Syntax, See [2], 1437–1443. <a class="link-inline force-break" href="https://doi.org/10.1145/3041021.3053896" target="_blank">https://doi.org/10.1145/3041021.3053896</a>
        </li>
        <li id="BibPLXBIB0015" label="[15]">Satoshi Nakamoto. 2008. <em><em>Bitcoin: A Peer-to-Peer Electronic Cash System</em></em> . Technical Report. <a class="link-inline force-break" href="http://www.bitcoin.org/bitcoin.pdf" target="_blank">http://www.bitcoin.org/bitcoin.pdf</a>
        </li>
        <li id="BibPLXBIB0016" label="[16]">Natasha Noy and Alan Rector. 2006. <em><em>Defining N-ary Relations on the Semantic Web</em></em> . W3C Working Group Note. World Wide Web Consortium. <a class="link-inline force-break" href="http://www.w3.org/TR/swbp-n-aryRelations/" target="_blank">http://www.w3.org/TR/swbp-n-aryRelations/</a>
        </li>
        <li id="BibPLXBIB0017" label="[17]">Valentina Presutti, Claudia d'Amato, Fabien Gandon, Mathieu d'Aquin, Steffen Staab, and Anna Tordai (Eds.). 2014. <em><em>The Semantic Web: Trends and Challenges - 11th International Conference, ESWC 2014, Anissaras, Crete, Greece, May 25-29, 2014. Proceedings</em></em> . <em>Lecture Notes in Computer Science</em>, Vol. 8465. Springer. <a class="link-inline force-break" href="https://doi.org/10.1007/978-3-319-07443-6" target="_blank">https://doi.org/10.1007/978-3-319-07443-6</a>
        </li>
        <li id="BibPLXBIB0018" label="[18]">C. Sayers and A.&nbsp;H. Karp. 2003. <em><em>Computing the Digest of an RDF Graph</em></em> . Technical Report HPL-2003-235. Hewlett-Packard Labs.</li>
        <li id="BibPLXBIB0019" label="[19]">C. Sayers and A.&nbsp;H. Karp. 2004. <em><em>RDF Graph Digest Techniques and Potential Applications</em></em> . Technical Report HPL-2004-95. Hewlett-Packard Labs.</li>
        <li id="BibPLXBIB0020" label="[20]">Manu Sporny and Dave Longley. 2016. <em><em>Flex Ledger 1.0: A flexible format and protocol for decentralized ledgers on the Web</em></em> . Technical Report. Digital Bazaar, <a href="https://digitalbazaar.github.io/flex-ledger/" target="_blank">https://digitalbazaar.github.io/flex-ledger/</a>.
        </li>
        <li id="BibPLXBIB0021" label="[21]">Manu Sporny and Dave Longley. 2017. <em><em>The Web Ledger Protocol 1.0 A format and protocol for decentralized ledgers on the Web</em></em> . Technical Report. Digital Bazaar, <a href="https://w3c.github.io/web-ledger/" target="_blank">https://w3c.github.io/web-ledger/</a>.
        </li>
        <li id="BibPLXBIB0022" label="[22]">Allan Third and John Domingue. 2017. Linked Data Indexing of Distributed Ledgers, See [2], 1431–1436. <a class="link-inline force-break" href="http://dl.acm.org/citation.cfm?id=3041021" target="_blank">http://dl.acm.org/citation.cfm?id=3041021</a>
        </li>
        <li id="BibPLXBIB0023" label="[23]">Giovanni Tummarello, Christian Morbidoni, Paolo Puliti, and Francesco Piazza. 2005. Signing individual fragments of an RDF graph. In <em><em>Proceedings of the 14th international conference on World Wide Web, WWW 2005, Chiba, Japan, May 10-14, 2005 - Special interest tracks and posters</em></em> , Allan Ellis and Tatsuya Hagino (Eds.). ACM, 1020–1021. <a class="link-inline force-break" href="https://doi.org/10.1145/1062745.1062848" target="_blank">https://doi.org/10.1145/1062745.1062848</a>
        </li>
        <li id="BibPLXBIB0024" label="[24]">Hector Ugarte. 2017. <em><em>A more pragmatic Web 3.0: Linked Blockchain Data</em></em> . Technical Report. <a href="https://www.researchgate.net/publication/315619465_A%20_more_pragmatic_Web_30_Linked_Blockchain_Data" target="_blank">https://www.researchgate.net/publication/315619465_A _more_pragmatic_Web_30_Linked_Blockchain_Data</a>.
        </li>
        <li id="BibPLXBIB0025" label="[25]">Roger Wattenhofer. 2016. <em><em>The Science of the Blockchain</em>(1st ed.)</em>. CreateSpace Independent Publishing Platform, USA.</li>
      </ul>
    </section>
  </section>
  <section id="foot-001" class="footnote">
    <header>
      <div class="title-info">
        <h2>FOOTNOTE</h2>
      </div>
    </header>
    <p id="fn1"><a href="#foot-fn1"><sup>⁎</sup></a>Operational Programme Smart Growth, project number 01.01.01-00-0982/16 funded by the National Centre for Research and Development</p>
    <p id="fn3"><a href="#foot-fn3"><sup>1</sup></a><a class="link-inline force-break" href="https://ethereum.stackexchange.com/questions/268/ethereum-block-architecture">https://ethereum.stackexchange.com/questions/268/ethereum-block-architecture</a></p>
    <p id="fn4"><a href="#foot-fn4"><sup>2</sup></a>Mirek Sopek, “Using Blockchain for Digital Identifiers: Improving Data Security and Persistence for Digital Object Identifier (DOI) and Legal Entity Identifier (LEI)”. The E-Finance Lab and DZ BANK 2016 Fall Conference. Goethe University Frankfurt. September 1st, 2016.</p>
    <p id="fn5"><a href="#foot-fn5"><sup>3</sup></a>European Financial Transparency Gateway, SMART 2016, European Commission, DG FISMA, Tamás Szabó</p>
    <p id="fn6"><a href="#foot-fn6"><sup>4</sup></a>Mirek Sopek, ?How Can Blockchain amplify Digital Identifiers? Improving Data Persistence, Openness, and Trust in the modern world.? DataAmplified 2016 ? XBRL and the future of Business Reporting, Singapore, Nov. 8-10, 2016. <a class="link-inline force-break" href="https://www.dataamplified.org/sessions/blockchain-smart-contracts-and-efficiency/">https://www.dataamplified.org/sessions/blockchain-smart-contracts-and-efficiency/</a>.</p>
    <p id="fn7"><a href="#foot-fn7"><sup>5</sup></a>See for example: <a class="link-inline force-break" href="https://lei.info">https://lei.info</a>.</p>
    <p id="fn8"><a href="#foot-fn8"><sup>6</sup></a><a class="link-inline force-break" href="https://www.w3.org/TR/rdf11-concepts/#section-triples">https://www.w3.org/TR/rdf11-concepts/#section-triples</a></p>
    <p id="fn9"><a href="#foot-fn9"><sup>7</sup></a>Unit is a counterpart of a Blockchain's block. In section <a class="sec" href="#sec-17">5</a> we will define precisely how it is understood in our framework. Henceforward we shall use both terms “unit” and “block” as synonyms.</p>
    <p id="fn10"><a href="#foot-fn10"><sup>8</sup></a>Compare with [<a class="bib" data-trigger="hover" data-toggle="popover" data-placement="top" href="#BibPLXBIB0025">25</a>, Definition 7.20].</p>
    <p id="fn11"><a href="#foot-fn11"><sup>9</sup></a>There is an extensive literature on the efficiency of the triple stores themselves.</p>
    <p id="fn12"><a href="#foot-fn12"><sup>10</sup></a>See: <a class="link-inline force-break" href="http://www.rdfhdt.org/">http://www.rdfhdt.org/</a>.</p>
    <p id="fn13"><a href="#foot-fn13"><sup>11</sup></a>See <a href="https://json-ld.github.io/normalization/spec/" target="_blank">https://json-ld.github.io/normalization/spec/</a></p>
    <p id="fn14"><a href="#foot-fn14"><sup>12</sup></a><a class="link-inline force-break" href="http://ontologies.makolab.com/bc">http://ontologies.makolab.com/bc</a></p>
    <p id="fn15"><a href="#foot-fn15"><sup>13</sup></a>Naivechain's GitHub: <a class="link-inline force-break" href="https://github.com/lhartikk/naivechain">https://github.com/lhartikk/naivechain</a>.</p>
    <p id="fn16"><a href="#foot-fn16"><sup>14</sup></a><a class="link-inline force-break" href="http://binsem.makolab.pl/gcgui/">http://binsem.makolab.pl/gcgui/</a></p>
    <p id="fn17"><a href="#foot-fn17"><sup>15</sup></a>The queries can be used to retrieve data from the node <a class="link-inline force-break" href="http://binsem.makolab.pl/gcgui/8881">http://binsem.makolab.pl/gcgui/8881</a> by: • <a class="link-inline force-break" href="http://ml.ms/GraphChain_Query1">http://ml.ms/GraphChain_Query1</a> • <a class="link-inline force-break" href="http://ml.ms/GraphChain_Query2">http://ml.ms/GraphChain_Query2</a></p>
    <p id="fn18"><a href="#foot-fn18"><sup>16</sup></a><a class="link-inline force-break" href="https://www.mongodb.com/collateral/building-enterprise-grade-blockchain-databases-with-mongodb">https://www.mongodb.com/collateral/building-enterprise-grade-blockchain-databases-with-mongodb</a></p>
    <div class="bibStrip">
      <p>This paper is published under the Creative Commons Attribution 4.0 International (CC-BY&nbsp;4.0) license. Authors reserve their rights to disseminate the work on their personal and corporate Web sites with the appropriate attribution.</p>
      <p><em>WWW '18, April 23-27, 2018, Lyon, France</em></p>
      <p>© 2018; IW3C2 (International World Wide Web Conference Committee), published under Creative Commons CC-BY&nbsp;4.0 License. ACM ISBN 978-1-4503-5640-4/18/04.<br />
      DOI: <a class="link-inline force-break" target="_blank" href="https://doi.org/10.1145/3184558.3191554">https://doi.org/10.1145/3184558.3191554</a></p>
    </div>
  </section>
  <div class="pubHistory">
    <p></p>
  </div>
</body>
</html>
